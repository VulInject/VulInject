[
    {
        "index": 0,
        "code": "void *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n\n  // realloc only sets the errno (ENOMEM) when output pointer is null and a\n  // non-zero |size| is provided.\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8935"
    },
    {
        "index": 1,
        "code": "int __close_fd_get_file(unsigned int fd, struct file **res)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-21504"
    },
    {
        "index": 2,
        "code": "static void test_map_wrap(void)\n{\n    uc_engine *uc;\n\n    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n\n    uc_assert_err(UC_ERR_ARG,\n                  uc_mem_map(uc, 0xfffffffffffff000, 0x2000, UC_PROT_ALL));\n\n    OK(uc_close(uc));\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 3,
        "code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8939"
    },
    {
        "index": 4,
        "code": "static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tint alen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\n\t/*\n\t * The delay time (uSec) is optional.\n\t */\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\t/*\n\t * Run the loop...\n\t */\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34835"
    },
    {
        "index": 5,
        "code": "R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0173"
    },
    {
        "index": 7,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\t// IFDBG r_bin_java_print_constant_value_attr_summary(attr);\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1451"
    },
    {
        "index": 8,
        "code": "TfLiteStatus EvalShuffledQuantized(TfLiteContext* context, TfLiteNode* node,\n                                   TfLiteFullyConnectedParams* params,\n                                   OpData* data, const TfLiteTensor* input,\n                                   const TfLiteTensor* filter,\n                                   const TfLiteTensor* bias,\n                                   TfLiteTensor* output,\n                                   TfLiteTensor* shuffled_input_workspace) {\n  // TODO(b/110697972) decide more consistently if / how / where we want\n  // to perform this kind of runtime data type checks.\n  if (shuffled_input_workspace->type != kTfLiteUInt8) {\n    context->ReportError(context, \"Unexpected data type\");\n    return kTfLiteError;\n  }\n\n#define TF_LITE_SHUFFLED_FULLY_CONNECTED(type)                           \\\n  {                                                                      \\\n    type::ShuffledFullyConnected(                                        \\\n        op_params, GetTensorShape(input), GetTensorData<uint8_t>(input), \\\n        GetTensorShape(filter), GetTensorData<uint8_t>(filter),          \\\n        GetTensorShape(bias), GetTensorData<int32_t>(bias),              \\\n        GetTensorShape(output), GetTensorData<int16_t>(output),          \\\n        GetTensorData<uint8_t>(shuffled_input_workspace),                \\\n        CpuBackendContext::GetFromContext(context));                     \\\n  }\n  FullyConnectedParams op_params;\n  op_params.output_multiplier = data->output_multiplier;\n  op_params.output_shift = data->output_shift;\n  op_params.quantized_activation_min = data->output_activation_min;\n  op_params.quantized_activation_max = data->output_activation_max;\n  op_params.lhs_cacheable = IsConstantTensor(filter);\n  op_params.rhs_cacheable = IsConstantTensor(input);\n  if (kernel_type == kReference) {\n    reference_ops::ShuffledFullyConnected(\n        op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n        GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n        GetTensorShape(bias), GetTensorData<int32_t>(bias),\n        GetTensorShape(output), GetTensorData<int16_t>(output),\n        GetTensorData<uint8_t>(shuffled_input_workspace));\n  } else {\n    optimized_ops::ShuffledFullyConnected(\n        op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n        GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n        GetTensorShape(bias), GetTensorData<int32_t>(bias),\n        GetTensorShape(output), GetTensorData<int16_t>(output),\n        GetTensorData<uint8_t>(shuffled_input_workspace),\n        CpuBackendContext::GetFromContext(context));\n  }\n#undef TF_LITE_SHUFFLED_FULLY_CONNECTED\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23561"
    },
    {
        "index": 9,
        "code": "s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 10,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params =\n      reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* positions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputPositions, &positions));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (positions->type == kTfLiteInt32) {\n    switch (input->type) {\n      case kTfLiteFloat32:\n        return Gather<float, int32_t>(*params, input, positions, output);\n      case kTfLiteUInt8:\n        return Gather<uint8_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt8:\n        return Gather<int8_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt16:\n        return Gather<int16_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt32:\n        return Gather<int32_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt64:\n        return Gather<int64_t, int32_t>(*params, input, positions, output);\n      case kTfLiteBool:\n        return Gather<bool, int32_t>(*params, input, positions, output);\n      case kTfLiteString:\n        return GatherStrings<int32_t>(context, input, positions, output);\n      default:\n        context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                             TfLiteTypeGetName(input->type));\n        return kTfLiteError;\n    }\n  }\n  if (positions->type == kTfLiteInt64) {\n    switch (input->type) {\n      case kTfLiteFloat32:\n        return Gather<float, int64_t>(*params, input, positions, output);\n      case kTfLiteUInt8:\n        return Gather<uint8_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt8:\n        return Gather<int8_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt16:\n        return Gather<int16_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt32:\n        return Gather<int32_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt64:\n        return Gather<int64_t, int64_t>(*params, input, positions, output);\n      case kTfLiteBool:\n        return Gather<bool, int64_t>(*params, input, positions, output);\n      case kTfLiteString:\n        return GatherStrings<int64_t>(context, input, positions, output);\n      default:\n        context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                             TfLiteTypeGetName(input->type));\n        return kTfLiteError;\n    }\n  }\n  context->ReportError(context,\n                       \"Positions of type '%s' are not supported by gather.\",\n                       TfLiteTypeGetName(positions->type));\n  return kTfLiteError;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37687"
    },
    {
        "index": 11,
        "code": "eap_response(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tu_char typenum;\n\tu_char vallen;\n\tint secret_len;\n\tchar secret[MAXSECRETLEN];\n\tchar rhostname[256];\n\tMD5_CTX mdContext;\n\tu_char hash[MD5_SIGNATURE_SIZE];\n#ifdef USE_SRP\n\tstruct t_server *ts;\n\tstruct t_num A;\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n#endif /* USE_SRP */\n\n\tif (esp->es_server.ea_id != id) {\n\t\tdbglog(\"EAP: discarding Response %d; expected ID %d\", id,\n\t\t    esp->es_server.ea_id);\n\t\treturn;\n\t}\n\n\tesp->es_server.ea_responses++;\n\n\tif (len <= 0) {\n\t\terror(\"EAP: empty Response message discarded\");\n\t\treturn;\n\t}\n\n\tGETCHAR(typenum, inp);\n\tlen--;\n\n\tswitch (typenum) {\n\tcase EAPT_IDENTITY:\n\t\tif (esp->es_server.ea_state != eapIdentify) {\n\t\t\tdbglog(\"EAP discarding unwanted Identify \\\"%.q\\\"\", len,\n\t\t\t    inp);\n\t\t\tbreak;\n\t\t}\n\t\tinfo(\"EAP: unauthenticated peer name \\\"%.*q\\\"\", len, inp);\n\t\tif (esp->es_server.ea_peer != NULL &&\n\t\t    esp->es_server.ea_peer != remote_name)\n\t\t\tfree(esp->es_server.ea_peer);\n\t\tesp->es_server.ea_peer = malloc(len + 1);\n\t\tif (esp->es_server.ea_peer == NULL) {\n\t\t\tesp->es_server.ea_peerlen = 0;\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tBCOPY(inp, esp->es_server.ea_peer, len);\n\t\tesp->es_server.ea_peer[len] = '\\0';\n\t\tesp->es_server.ea_peerlen = len;\n\t\teap_figure_next_state(esp, 0);\n\t\tbreak;\n\n\tcase EAPT_NOTIFICATION:\n\t\tdbglog(\"EAP unexpected Notification; response discarded\");\n\t\tbreak;\n\n\tcase EAPT_NAK:\n\t\tif (len < 1) {\n\t\t\tinfo(\"EAP: Nak Response with no suggested protocol\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\n\t\tif (!explicit_remote && esp->es_server.ea_state == eapIdentify){\n\t\t\t/* Peer cannot Nak Identify Request */\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (vallen) {\n\t\tcase EAPT_SRP:\n\t\t\t/* Run through SRP validator selection again. */\n\t\t\tesp->es_server.ea_state = eapIdentify;\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdbglog(\"EAP: peer requesting unknown Type %d\", vallen);\n\t\t\tswitch (esp->es_server.ea_state) {\n\t\t\tcase eapSRP1:\n\t\t\tcase eapSRP2:\n\t\t\tcase eapSRP3:\n\t\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\t\tbreak;\n\t\t\tcase eapMD5Chall:\n\t\t\tcase eapSRP4:\n\t\t\t\tesp->es_server.ea_state = eapIdentify;\n\t\t\t\teap_figure_next_state(esp, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAPT_MD5CHAP:\n\t\tif (esp->es_server.ea_state != eapMD5Chall) {\n\t\t\terror(\"EAP: unexpected MD5-Response\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received MD5-Response with no data\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tif (vallen != 16 || vallen > len) {\n\t\t\terror(\"EAP: MD5-Response with bad length %d\", vallen);\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Not so likely to happen. */\n\t\tif (vallen >= len + sizeof (rhostname)) {\n\t\t\tdbglog(\"EAP: trimming really long peer name down\");\n\t\t\tBCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);\n\t\t\trhostname[sizeof (rhostname) - 1] = '\\0';\n\t\t} else {\n\t\t\tBCOPY(inp + vallen, rhostname, len - vallen);\n\t\t\trhostname[len - vallen] = '\\0';\n\t\t}\n\n\t\t/* In case the remote doesn't give us his name. */\n\t\tif (explicit_remote ||\n\t\t    (remote_name[0] != '\\0' && vallen == len))\n\t\t\tstrlcpy(rhostname, remote_name, sizeof (rhostname));\n\n\t\t/*\n\t\t * Get the secret for authenticating the specified\n\t\t * host.\n\t\t */\n\t\tif (!get_secret(esp->es_unit, rhostname,\n\t\t    esp->es_server.ea_name, secret, &secret_len, 1)) {\n\t\t\tdbglog(\"EAP: no MD5 secret for auth of %q\", rhostname);\n\t\t\teap_send_failure(esp);\n\t\t\tbreak;\n\t\t}\n\t\tMD5_Init(&mdContext);\n\t\tMD5_Update(&mdContext, &esp->es_server.ea_id, 1);\n\t\tMD5_Update(&mdContext, (u_char *)secret, secret_len);\n\t\tBZERO(secret, sizeof (secret));\n\t\tMD5_Update(&mdContext, esp->es_challenge, esp->es_challen);\n\t\tMD5_Final(hash, &mdContext);\n\t\tif (BCMP(hash, inp, MD5_SIGNATURE_SIZE) != 0) {\n\t\t\teap_send_failure(esp);\n\t\t\tbreak;\n\t\t}\n\t\tesp->es_server.ea_type = EAPT_MD5CHAP;\n\t\teap_send_success(esp);\n\t\teap_figure_next_state(esp, 0);\n\t\tif (esp->es_rechallenge != 0)\n\t\t\tTIMEOUT(eap_rechallenge, esp, esp->es_rechallenge);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase EAPT_SRP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: empty SRP Response\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(typenum, inp);\n\t\tlen--;\n\t\tswitch (typenum) {\n\t\tcase EAPSRP_CKEY:\n\t\t\tif (esp->es_server.ea_state != eapSRP1) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 1 Response\");\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tA.data = inp;\n\t\t\tA.len = len;\n\t\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\t\tassert(ts != NULL);\n\t\t\tesp->es_server.ea_skey = t_servergetkey(ts, &A);\n\t\t\tif (esp->es_server.ea_skey == NULL) {\n\t\t\t\t/* Client's A value is bogus; terminate now */\n\t\t\t\terror(\"EAP: bogus A value from client\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t} else {\n\t\t\t\teap_figure_next_state(esp, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPSRP_CVALIDATOR:\n\t\t\tif (esp->es_server.ea_state != eapSRP2) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 2 Response\");\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len < sizeof (u_int32_t) + SHA_DIGESTSIZE) {\n\t\t\t\terror(\"EAP: M1 length %d < %d\", len,\n\t\t\t\t    sizeof (u_int32_t) + SHA_DIGESTSIZE);\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETLONG(esp->es_server.ea_keyflags, inp);\n\t\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\t\tassert(ts != NULL);\n\t\t\tif (t_serververify(ts, inp)) {\n\t\t\t\tinfo(\"EAP: unable to validate client identity\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_ACK:\n\t\t\tif (esp->es_server.ea_state != eapSRP3) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 3 Response\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tesp->es_server.ea_type = EAPT_SRP;\n\t\t\teap_send_success(esp);\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tif (esp->es_rechallenge != 0)\n\t\t\t\tTIMEOUT(eap_rechallenge, esp,\n\t\t\t\t    esp->es_rechallenge);\n\t\t\tif (esp->es_lwrechallenge != 0)\n\t\t\t\tTIMEOUT(srp_lwrechallenge, esp,\n\t\t\t\t    esp->es_lwrechallenge);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\tif (esp->es_server.ea_state != eapSRP4) {\n\t\t\t\tinfo(\"EAP: unexpected SRP Subtype 4 Response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (len != SHA_DIGESTSIZE) {\n\t\t\t\terror(\"EAP: bad Lightweight rechallenge \"\n\t\t\t\t    \"response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSHA1Init(&ctxt);\n\t\t\tvallen = id;\n\t\t\tSHA1Update(&ctxt, &vallen, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, esp->es_challenge, esp->es_challen);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_peer,\n\t\t\t    esp->es_server.ea_peerlen);\n\t\t\tSHA1Final(dig, &ctxt);\n\t\t\tif (BCMP(dig, inp, SHA_DIGESTSIZE) != 0) {\n\t\t\t\terror(\"EAP: failed Lightweight rechallenge\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t\tif (esp->es_lwrechallenge != 0)\n\t\t\t\tTIMEOUT(srp_lwrechallenge, esp,\n\t\t\t\t    esp->es_lwrechallenge);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\t/* This can't happen. */\n\t\terror(\"EAP: unknown Response type %d; ignored\", typenum);\n\t\treturn;\n\t}\n\n\tif (esp->es_server.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_server_timeout, (void *)esp);\n\t}\n\n\tif (esp->es_server.ea_state != eapBadAuth &&\n\t    esp->es_server.ea_state != eapOpen) {\n\t\tesp->es_server.ea_id++;\n\t\teap_send_request(esp);\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8597"
    },
    {
        "index": 12,
        "code": "eap_request(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tu_char typenum;\n\tu_char vallen;\n\tint secret_len;\n\tchar secret[MAXWORDLEN];\n\tchar rhostname[256];\n\tMD5_CTX mdContext;\n\tu_char hash[MD5_SIGNATURE_SIZE];\n#ifdef USE_SRP\n\tstruct t_client *tc;\n\tstruct t_num sval, gval, Nval, *Ap, Bval;\n\tu_char vals[2];\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\tint fd;\n#endif /* USE_SRP */\n\n\t/*\n\t * Note: we update es_client.ea_id *only if* a Response\n\t * message is being generated.  Otherwise, we leave it the\n\t * same for duplicate detection purposes.\n\t */\n\n\tesp->es_client.ea_requests++;\n\tif (esp->es_client.ea_maxrequests != 0 &&\n\t    esp->es_client.ea_requests > esp->es_client.ea_maxrequests) {\n\t\tinfo(\"EAP: received too many Request messages\");\n\t\tif (esp->es_client.ea_timeout > 0) {\n\t\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t\t}\n\t\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n\t\treturn;\n\t}\n\n\tif (len <= 0) {\n\t\terror(\"EAP: empty Request message discarded\");\n\t\treturn;\n\t}\n\n\tGETCHAR(typenum, inp);\n\tlen--;\n\n\tswitch (typenum) {\n\tcase EAPT_IDENTITY:\n\t\tif (len > 0)\n\t\t\tinfo(\"EAP: Identity prompt \\\"%.*q\\\"\", len, inp);\n#ifdef USE_SRP\n\t\tif (esp->es_usepseudo &&\n\t\t    (esp->es_usedpseudo == 0 ||\n\t\t\t(esp->es_usedpseudo == 1 &&\n\t\t\t    id == esp->es_client.ea_id))) {\n\t\t\tesp->es_usedpseudo = 1;\n\t\t\t/* Try to get a pseudonym */\n\t\t\tif ((fd = open_pn_file(O_RDONLY)) >= 0) {\n\t\t\t\tstrcpy(rhostname, SRP_PSEUDO_ID);\n\t\t\t\tlen = read(fd, rhostname + SRP_PSEUDO_LEN,\n\t\t\t\t    sizeof (rhostname) - SRP_PSEUDO_LEN);\n\t\t\t\t/* XXX NAI unsupported */\n\t\t\t\tif (len > 0) {\n\t\t\t\t\teap_send_response(esp, id, typenum,\n\t\t\t\t\t    rhostname, len + SRP_PSEUDO_LEN);\n\t\t\t\t}\n\t\t\t\t(void) close(fd);\n\t\t\t\tif (len > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Stop using pseudonym now. */\n\t\tif (esp->es_usepseudo && esp->es_usedpseudo != 2) {\n\t\t\tremove_pn_file();\n\t\t\tesp->es_usedpseudo = 2;\n\t\t}\n#endif /* USE_SRP */\n\t\teap_send_response(esp, id, typenum, esp->es_client.ea_name,\n\t\t    esp->es_client.ea_namelen);\n\t\tbreak;\n\n\tcase EAPT_NOTIFICATION:\n\t\tif (len > 0)\n\t\t\tinfo(\"EAP: Notification \\\"%.*q\\\"\", len, inp);\n\t\teap_send_response(esp, id, typenum, NULL, 0);\n\t\tbreak;\n\n\tcase EAPT_NAK:\n\t\t/*\n\t\t * Avoid the temptation to send Response Nak in reply\n\t\t * to Request Nak here.  It can only lead to trouble.\n\t\t */\n\t\twarn(\"EAP: unexpected Nak in Request; ignored\");\n\t\t/* Return because we're waiting for something real. */\n\t\treturn;\n\n\tcase EAPT_MD5CHAP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received MD5-Challenge with no data\");\n\t\t\t/* Bogus request; wait for something real. */\n\t\t\treturn;\n\t\t}\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tif (vallen < 8 || vallen > len) {\n\t\t\terror(\"EAP: MD5-Challenge with bad length %d (8..%d)\",\n\t\t\t    vallen, len);\n\t\t\t/* Try something better. */\n\t\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Not so likely to happen. */\n\t\tif (vallen >= len + sizeof (rhostname)) {\n\t\t\tdbglog(\"EAP: trimming really long peer name down\");\n\t\t\tBCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);\n\t\t\trhostname[sizeof (rhostname) - 1] = '\\0';\n\t\t} else {\n\t\t\tBCOPY(inp + vallen, rhostname, len - vallen);\n\t\t\trhostname[len - vallen] = '\\0';\n\t\t}\n\n\t\t/* In case the remote doesn't give us his name. */\n\t\tif (explicit_remote ||\n\t\t    (remote_name[0] != '\\0' && vallen == len))\n\t\t\tstrlcpy(rhostname, remote_name, sizeof (rhostname));\n\n\t\t/*\n\t\t * Get the secret for authenticating ourselves with\n\t\t * the specified host.\n\t\t */\n\t\tif (!get_secret(esp->es_unit, esp->es_client.ea_name,\n\t\t    rhostname, secret, &secret_len, 0)) {\n\t\t\tdbglog(\"EAP: no MD5 secret for auth to %q\", rhostname);\n\t\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\t\tbreak;\n\t\t}\n\t\tMD5_Init(&mdContext);\n\t\ttypenum = id;\n\t\tMD5_Update(&mdContext, &typenum, 1);\n\t\tMD5_Update(&mdContext, (u_char *)secret, secret_len);\n\t\tBZERO(secret, sizeof (secret));\n\t\tMD5_Update(&mdContext, inp, vallen);\n\t\tMD5_Final(hash, &mdContext);\n\t\teap_chap_response(esp, id, hash, esp->es_client.ea_name,\n\t\t    esp->es_client.ea_namelen);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase EAPT_SRP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received empty SRP Request\");\n\t\t\t/* Bogus request; wait for something real. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Get subtype */\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tswitch (vallen) {\n\t\tcase EAPSRP_CHALLENGE:\n\t\t\ttc = NULL;\n\t\t\tif (esp->es_client.ea_session != NULL) {\n\t\t\t\ttc = (struct t_client *)esp->es_client.\n\t\t\t\t    ea_session;\n\t\t\t\t/*\n\t\t\t\t * If this is a new challenge, then start\n\t\t\t\t * over with a new client session context.\n\t\t\t\t * Otherwise, just resend last response.\n\t\t\t\t */\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\tt_clientclose(tc);\n\t\t\t\t\tesp->es_client.ea_session = NULL;\n\t\t\t\t\ttc = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* No session key just yet */\n\t\t\tesp->es_client.ea_skey = NULL;\n\t\t\tif (tc == NULL) {\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (name)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tBCOPY(inp, rhostname, vallen);\n\t\t\t\trhostname[vallen] = '\\0';\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\t/*\n\t\t\t\t * In case the remote doesn't give us his name,\n\t\t\t\t * use configured name.\n\t\t\t\t */\n\t\t\t\tif (explicit_remote ||\n\t\t\t\t    (remote_name[0] != '\\0' && vallen == 0)) {\n\t\t\t\t\tstrlcpy(rhostname, remote_name,\n\t\t\t\t\t    sizeof (rhostname));\n\t\t\t\t}\n\n\t\t\t\tif (esp->es_client.ea_peer != NULL)\n\t\t\t\t\tfree(esp->es_client.ea_peer);\n\t\t\t\tesp->es_client.ea_peer = strdup(rhostname);\n\t\t\t\tesp->es_client.ea_peerlen = strlen(rhostname);\n\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (s)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsval.data = inp;\n\t\t\t\tsval.len = vallen;\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen > len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (g)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* If no generator present, then use value 2 */\n\t\t\t\tif (vallen == 0) {\n\t\t\t\t\tgval.data = (u_char *)\"\\002\";\n\t\t\t\t\tgval.len = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgval.data = inp;\n\t\t\t\t\tgval.len = vallen;\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\t/*\n\t\t\t\t * If no modulus present, then use well-known\n\t\t\t\t * value.\n\t\t\t\t */\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tNval.data = (u_char *)wkmodulus;\n\t\t\t\t\tNval.len = sizeof (wkmodulus);\n\t\t\t\t} else {\n\t\t\t\t\tNval.data = inp;\n\t\t\t\t\tNval.len = len;\n\t\t\t\t}\n\t\t\t\ttc = t_clientopen(esp->es_client.ea_name,\n\t\t\t\t    &Nval, &gval, &sval);\n\t\t\t\tif (tc == NULL) {\n\t\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesp->es_client.ea_session = (void *)tc;\n\n\t\t\t\t/* Add Challenge ID & type to verifier */\n\t\t\t\tvals[0] = id;\n\t\t\t\tvals[1] = EAPT_SRP;\n\t\t\t\tt_clientaddexdata(tc, vals, 2);\n\t\t\t}\n\t\t\tAp = t_clientgenexp(tc);\n\t\t\teap_srp_response(esp, id, EAPSRP_CKEY, Ap->data,\n\t\t\t    Ap->len);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_SKEY:\n\t\t\ttc = (struct t_client *)esp->es_client.ea_session;\n\t\t\tif (tc == NULL) {\n\t\t\t\twarn(\"EAP: peer sent Subtype 2 without 1\");\n\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (esp->es_client.ea_skey != NULL) {\n\t\t\t\t/*\n\t\t\t\t * ID number should not change here.  Warn\n\t\t\t\t * if it does (but otherwise ignore).\n\t\t\t\t */\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\twarn(\"EAP: ID changed from %d to %d \"\n\t\t\t\t\t    \"in SRP Subtype 2 rexmit\",\n\t\t\t\t\t    esp->es_client.ea_id, id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (get_srp_secret(esp->es_unit,\n\t\t\t\t    esp->es_client.ea_name,\n\t\t\t\t    esp->es_client.ea_peer, secret, 0) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can't work with this peer because\n\t\t\t\t\t * the secret is missing.  Just give\n\t\t\t\t\t * up.\n\t\t\t\t\t */\n\t\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBval.data = inp;\n\t\t\t\tBval.len = len;\n\t\t\t\tt_clientpasswd(tc, secret);\n\t\t\t\tBZERO(secret, sizeof (secret));\n\t\t\t\tesp->es_client.ea_skey =\n\t\t\t\t    t_clientgetkey(tc, &Bval);\n\t\t\t\tif (esp->es_client.ea_skey == NULL) {\n\t\t\t\t\t/* Server is rogue; stop now */\n\t\t\t\t\terror(\"EAP: SRP server is rogue\");\n\t\t\t\t\tgoto client_failure;\n\t\t\t\t}\n\t\t\t}\n\t\t\teap_srpval_response(esp, id, SRPVAL_EBIT,\n\t\t\t    t_clientresponse(tc));\n\t\t\tbreak;\n\n\t\tcase EAPSRP_SVALIDATOR:\n\t\t\ttc = (struct t_client *)esp->es_client.ea_session;\n\t\t\tif (tc == NULL || esp->es_client.ea_skey == NULL) {\n\t\t\t\twarn(\"EAP: peer sent Subtype 3 without 1/2\");\n\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we're already open, then this ought to be a\n\t\t\t * duplicate.  Otherwise, check that the server is\n\t\t\t * who we think it is.\n\t\t\t */\n\t\t\tif (esp->es_client.ea_state == eapOpen) {\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\twarn(\"EAP: ID changed from %d to %d \"\n\t\t\t\t\t    \"in SRP Subtype 3 rexmit\",\n\t\t\t\t\t    esp->es_client.ea_id, id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen -= sizeof (u_int32_t) + SHA_DIGESTSIZE;\n\t\t\t\tif (len < 0 || t_clientverify(tc, inp +\n\t\t\t\t\tsizeof (u_int32_t)) != 0) {\n\t\t\t\t\terror(\"EAP: SRP server verification \"\n\t\t\t\t\t    \"failed\");\n\t\t\t\t\tgoto client_failure;\n\t\t\t\t}\n\t\t\t\tGETLONG(esp->es_client.ea_keyflags, inp);\n\t\t\t\t/* Save pseudonym if user wants it. */\n\t\t\t\tif (len > 0 && esp->es_usepseudo) {\n\t\t\t\t\tINCPTR(SHA_DIGESTSIZE, inp);\n\t\t\t\t\twrite_pseudonym(esp, inp, len, id);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * We've verified our peer.  We're now mostly done,\n\t\t\t * except for waiting on the regular EAP Success\n\t\t\t * message.\n\t\t\t */\n\t\t\teap_srp_response(esp, id, EAPSRP_ACK, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\tif (len < 4) {\n\t\t\t\twarn(\"EAP: malformed Lightweight rechallenge\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSHA1Init(&ctxt);\n\t\t\tvals[0] = id;\n\t\t\tSHA1Update(&ctxt, vals, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, inp, len);\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_name,\n\t\t\t    esp->es_client.ea_namelen);\n\t\t\tSHA1Final(dig, &ctxt);\n\t\t\teap_srp_response(esp, id, EAPSRP_LWRECHALLENGE, dig,\n\t\t\t    SHA_DIGESTSIZE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror(\"EAP: unknown SRP Subtype %d\", vallen);\n\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\tinfo(\"EAP: unknown authentication type %d; Naking\", typenum);\n\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\tbreak;\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t\tTIMEOUT(eap_client_timeout, (void *)esp,\n\t\t    esp->es_client.ea_timeout);\n\t}\n\treturn;\n\n#ifdef USE_SRP\nclient_failure:\n\tesp->es_client.ea_state = eapBadAuth;\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\tesp->es_client.ea_session = NULL;\n\tt_clientclose(tc);\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n#endif /* USE_SRP */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8597"
    },
    {
        "index": 13,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableTypeAttribute *lvattr;\n\tut64 offset = 6;\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, 0);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR;\n\tattr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_type_table_attr.local_variable_table = r_list_newf (r_bin_java_local_variable_type_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_type_table_attr.table_length; i++) {\n\t\tut64 curpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableTypeAttribute);\n\t\tif (!lvattr) {\n\t\t\tperror (\"calloc\");\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + 10 > sz) {\n\t\t\teprintf (\"oob\");\n\t\t\tfree (lvattr);\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->signature = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->signature_idx);\n\t\tif (!lvattr->signature) {\n\t\t\tlvattr->signature = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->signature_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_type_table_attr.local_variable_table, lvattr);\n\t}\n\t// IFDBG r_bin_java_print_local_variable_type_table_attr_summary(attr);\n\tattr->size = offset;\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 14,
        "code": "void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1341"
    },
    {
        "index": 15,
        "code": "static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = hextoul(argv[3], NULL);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34835"
    },
    {
        "index": 16,
        "code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0523"
    },
    {
        "index": 17,
        "code": "TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,\n                       TfLiteFullyConnectedParams* params, OpData* data,\n                       const TfLiteTensor* input, const TfLiteTensor* filter,\n                       const TfLiteTensor* bias, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  if (kernel_type == kReference) {\n    FullyConnectedParams op_params;\n    op_params.float_activation_min = output_activation_min;\n    op_params.float_activation_max = output_activation_max;\n    if (filter->sparsity != nullptr) {\n      const auto& sparsity = *filter->sparsity;\n      reference_ops::FullyConnectedSparseWeight(\n          sparsity, op_params, GetTensorShape(input),\n          GetTensorData<float>(input), GetTensorShape(filter),\n          GetTensorData<float>(filter), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorShape(output),\n          GetTensorData<float>(output));\n    } else {\n      reference_ops::FullyConnected(\n          op_params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), GetTensorData<float>(filter),\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output));\n    }\n  } else if (kernel_type == kLegacyPie) {\n    return EvalPie(context, node, params, data, input, filter, bias, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.float_activation_min = output_activation_min;\n    op_params.float_activation_max = output_activation_max;\n    if (filter->sparsity != nullptr) {\n      const auto& sparsity = *filter->sparsity;\n      if (!SupportedSparsityFormat(sparsity)) {\n        TF_LITE_KERNEL_LOG(context,\n                           \"Unsupported sparse fully-connected weight format.\");\n        return kTfLiteError;\n      }\n\n      if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {\n        // Random sparse.\n        optimized_ops::FullyConnectedSparseWeight(\n            sparsity, op_params, GetTensorShape(input),\n            GetTensorData<float>(input), GetTensorShape(filter),\n            GetTensorData<float>(filter), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorShape(output),\n            GetTensorData<float>(output));\n      } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&\n                 sparsity.dim_metadata[2].dense_size == 4) {\n        // Block sparse with block size of 1x4.\n        optimized_ops::FullyConnectedSparseWeight1x4(\n            sparsity, op_params, GetTensorShape(input),\n            GetTensorData<float>(input), GetTensorShape(filter),\n            GetTensorData<float>(filter), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorShape(output),\n            GetTensorData<float>(output),\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        TF_LITE_KERNEL_LOG(context,\n                           \"Unsupported sparse fully-connected weight format.\");\n        return kTfLiteError;\n      }\n\n    } else {\n      op_params.lhs_cacheable = IsConstantTensor(filter);\n      op_params.rhs_cacheable = IsConstantTensor(input);\n      optimized_ops::FullyConnected(\n          op_params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), GetTensorData<float>(filter),\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          CpuBackendContext::GetFromContext(context));\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23561"
    },
    {
        "index": 18,
        "code": "stop_insert(\n    pos_T\t*end_insert_pos,\n    int\t\tesc,\t\t\t// called by ins_esc()\n    int\t\tnomove)\t\t\t// <c-\\><c-o>, don't move cursor\n{\n    int\t\tcc;\n    char_u\t*ptr;\n\n    stop_redo_ins();\n    replace_flush();\t\t// abandon replace stack\n\n    /*\n     * Save the inserted text for later redo with ^@ and CTRL-A.\n     * Don't do it when \"restart_edit\" was set and nothing was inserted,\n     * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n     */\n    ptr = get_inserted();\n    if (did_restart_edit == 0 || (ptr != NULL\n\t\t\t\t       && (int)STRLEN(ptr) > new_insert_skip))\n    {\n\tvim_free(last_insert);\n\tlast_insert = ptr;\n\tlast_insert_skip = new_insert_skip;\n    }\n    else\n\tvim_free(ptr);\n\n    if (!arrow_used && end_insert_pos != NULL)\n    {\n\t// Auto-format now.  It may seem strange to do this when stopping an\n\t// insertion (or moving the cursor), but it's required when appending\n\t// a line and having it end in a space.  But only do it when something\n\t// was actually inserted, otherwise undo won't work.\n\tif (!ins_need_undo && has_format_option(FO_AUTO))\n\t{\n\t    pos_T   tpos = curwin->w_cursor;\n\n\t    // When the cursor is at the end of the line after a space the\n\t    // formatting will move it to the following word.  Avoid that by\n\t    // moving the cursor onto the space.\n\t    cc = 'x';\n\t    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)\n\t    {\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    curwin->w_cursor = tpos;\n\t    }\n\n\t    auto_format(TRUE, FALSE);\n\n\t    if (VIM_ISWHITE(cc))\n\t    {\n\t\tif (gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t\t// If the cursor is still at the same character, also keep\n\t\t// the \"coladd\".\n\t\tif (gchar_cursor() == NUL\n\t\t\t&& curwin->w_cursor.lnum == tpos.lnum\n\t\t\t&& curwin->w_cursor.col == tpos.col)\n\t\t    curwin->w_cursor.coladd = tpos.coladd;\n\t    }\n\t}\n\n\t// If a space was inserted for auto-formatting, remove it now.\n\tcheck_auto_format(TRUE);\n\n\t// If we just did an auto-indent, remove the white space from the end\n\t// of the line, and put the cursor back.\n\t// Do this when ESC was used or moving the cursor up/down.\n\t// Check for the old position still being valid, just in case the text\n\t// got changed unexpectedly.\n\tif (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n\t\t\t&& curwin->w_cursor.lnum != end_insert_pos->lnum))\n\t\t&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    pos_T\ttpos = curwin->w_cursor;\n\n\t    curwin->w_cursor = *end_insert_pos;\n\t    check_cursor_col();  // make sure it is not past the line\n\t    for (;;)\n\t    {\n\t\tif (gchar_cursor() == NUL && curwin->w_cursor.col > 0)\n\t\t    --curwin->w_cursor.col;\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    break;\n\t\tif (del_char(TRUE) == FAIL)\n\t\t    break;  // should not happen\n\t    }\n\t    if (curwin->w_cursor.lnum != tpos.lnum)\n\t\tcurwin->w_cursor = tpos;\n\t    else\n\t    {\n\t\t// reset tpos, could have been invalidated in the loop above\n\t\ttpos = curwin->w_cursor;\n\t\ttpos.col++;\n\t\tif (cc != NUL && gchar_pos(&tpos) == NUL)\n\t\t    ++curwin->w_cursor.col;\t// put cursor back on the NUL\n\t    }\n\n\t    // <C-S-Right> may have started Visual mode, adjust the position for\n\t    // deleted characters.\n\t    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tint len = (int)STRLEN(ml_get_curline());\n\n\t\tif (VIsual.col > len)\n\t\t{\n\t\t    VIsual.col = len;\n\t\t    VIsual.coladd = 0;\n\t\t}\n\t    }\n\t}\n    }\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n\n    // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n    // now in a different buffer.\n    if (end_insert_pos != NULL)\n    {\n\tcurbuf->b_op_start = Insstart;\n\tcurbuf->b_op_start_orig = Insstart_orig;\n\tcurbuf->b_op_end = *end_insert_pos;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1735"
    },
    {
        "index": 19,
        "code": "  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n\n    return Status::OK();\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29532"
    },
    {
        "index": 20,
        "code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    /* pop dummy callinfo */\n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0890"
    },
    {
        "index": 21,
        "code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; // enum RelocationInfoType\n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1240"
    },
    {
        "index": 22,
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; /* insert, delete */\n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; /* left, right */\n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1533"
    },
    {
        "index": 23,
        "code": "getSecretShares(const string &_polyName, const char *_encryptedPolyHex, const vector <string> &_publicKeys,\n                       int _t,\n                       int _n) {\n\n    CHECK_STATE(_encryptedPolyHex);\n\n    vector<char> hexEncrKey(BUF_LEN, 0);\n    vector<char> errMsg1(BUF_LEN, 0);\n    vector <uint8_t> encrDKGPoly(BUF_LEN, 0);\n    int errStatus = 0;\n    uint64_t encLen = 0;\n\n\n\n    if (!hex2carray(_encryptedPolyHex, &encLen, encrDKGPoly.data(), BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n    sgx_status_t status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), encLen);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    string result;\n\n    for (int i = 0; i < _n; i++) {\n        vector <uint8_t> encryptedSkey(BUF_LEN, 0);\n        uint32_t decLen;\n        vector<char> currentShare(193, 0);\n        vector<char> sShareG2(320, 0);\n\n        string pub_keyB = _publicKeys.at(i);\n        vector<char> pubKeyB(129, 0);\n\n        strncpy(pubKeyB.data(), pub_keyB.c_str(), 128);\n        pubKeyB.at(128) = 0;\n\n        spdlog::debug(\"pubKeyB is {}\", pub_keyB);\n\n        sgx_status_t status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,\n                                          currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n, i + 1);\n        HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n        spdlog::debug(\"cur_share is {}\", currentShare.data());\n\n        result += string(currentShare.data());\n\n        spdlog::debug(\"dec len is {}\", decLen);\n        carray2Hex(encryptedSkey.data(), decLen, hexEncrKey.data(), BUF_LEN);\n        string dhKeyName = \"DKG_DH_KEY_\" + _polyName + \"_\" + to_string(i) + \":\";\n\n        spdlog::debug(\"hexEncr DH Key: { }\", hexEncrKey.data());\n        spdlog::debug(\"name to write to db is {}\", dhKeyName);\n        SGXWalletServer::writeDataToDB(dhKeyName, hexEncrKey.data());\n\n        string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(i) + \":\";\n        spdlog::debug(\"name to write to db is {}\", shareG2_name);\n        spdlog::debug(\"s_shareG2: {}\", sShareG2.data());\n\n        SGXWalletServer::writeDataToDB(shareG2_name, sShareG2.data());\n\n\n    }\n\n    return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 24,
        "code": "UserTerminalRouter::UserTerminalRouter(\n    shared_ptr<PipeSocketHandler> _socketHandler,\n    const SocketEndpoint &_routerEndpoint)\n    : socketHandler(_socketHandler) {\n  serverFd = *(socketHandler->listen(_routerEndpoint).begin());\n  FATAL_FAIL(::chown(_routerEndpoint.name().c_str(), getuid(), getgid()));\n  FATAL_FAIL(::chmod(_routerEndpoint.name().c_str(),\n                     S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP |\n                         S_IROTH | S_IWOTH | S_IXOTH));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 25,
        "code": "static Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    int fval = 0;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if (op == 3) {\n            if (!fval) break;\n        } else if (fval)\n            break;\n    }\n    if (rc == JSI_OK) {\n        if (op == 1 && fval) // Find\n            Jsi_ValueCopy(interp, *ret, obj->arr[i]); \n        else if (op == 2 || op == 3) // Some/Every\n            Jsi_ValueMakeBool(interp, ret, fval);\n        else if (op == 4)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1));\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 26,
        "code": "TEST_F(QuantizedConv2DTest, SmallWithNoZero) {\n  const int stride = 1;\n  TF_ASSERT_OK(NodeDefBuilder(\"quantized_conv_op\", \"QuantizedConv2D\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"out_type\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"strides\", {1, stride, stride, 1})\n                   .Attr(\"padding\", \"SAME\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 3;\n  const int image_batch_count = 1;\n  // Here we're testing a slow implementation path, where zero is not\n  // representable in the image data and so simple border padding is not\n  // possible, so we have a min value greater than 0.\n  const float image_min = 1.0f;\n  const float image_max = 12.0f;\n  Tensor image_float(DT_FLOAT,\n                     {image_batch_count, image_height, image_width, depth});\n  test::FillValues<float>(&image_float,\n                          {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});\n  Tensor image_quantized =\n      FloatTensorToQuantized<quint8>(image_float, image_min, image_max);\n  const int filter_size = 3;\n  const int filter_count = 1;\n  const float filter_min = 1.0f;\n  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues<float>(&filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({1}), {image_min});\n  AddInputFromArray<float>(TensorShape({1}), {image_max});\n  AddInputFromArray<float>(TensorShape({1}), {filter_min});\n  AddInputFromArray<float>(TensorShape({1}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues<float>(&expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor& output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)->flat<float>()(0);\n  const float output_max = GetOutput(2)->flat<float>()(0);\n  Tensor output_float =\n      QuantizedTensorToFloat<qint32>(output_quantized, output_min, output_max);\n  test::ExpectTensorNear<float>(expected_float, output_float, 1.0);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29201"
    },
    {
        "index": 27,
        "code": "TEST(TF_CTStringTest, ResizeReserve) {\n  {\n    // Resize\n    TF_TString s60;\n\n    TF_TString_Init(&s60);\n\n    TF_TString_Resize(&s60, 2, 'a');\n\n    EXPECT_EQ(0, ::memcmp(\"aa\", TF_TString_GetDataPointer(&s60), 2));\n\n    TF_TString_Resize(&s60, 4, '\\0');\n\n    EXPECT_EQ(0, ::memcmp(\"aa\\0\\0\", TF_TString_GetDataPointer(&s60), 4));\n\n    TF_TString_Resize(&s60, 6, 'b');\n\n    EXPECT_EQ(0, ::memcmp(\"aa\\0\\0bb\", TF_TString_GetDataPointer(&s60), 6));\n\n    TF_TString_Resize(&s60, 2, 'c');\n\n    EXPECT_EQ(0, ::memcmp(\"aa\", TF_TString_GetDataPointer(&s60), 2));\n\n    TF_TString_Dealloc(&s60);\n  }\n  {\n    // Reserve\n    TF_TString s70;\n\n    TF_TString_Init(&s70);\n\n    TF_TString_Reserve(&s70, TF_TString_SmallCapacity - 1);\n\n    EXPECT_EQ(TF_TString_SmallCapacity, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(0, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TSTR_SMALL, TF_TString_GetType(&s70));\n\n    TF_TString_Reserve(&s70, TF_TString_SmallCapacity);\n\n    EXPECT_EQ(TF_TString_SmallCapacity, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(0, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TSTR_SMALL, TF_TString_GetType(&s70));\n\n    TF_TString_Copy(&s70, \"hello\", 5);\n\n    EXPECT_EQ(5, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TString_SmallCapacity, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(TF_TSTR_SMALL, TF_TString_GetType(&s70));\n\n    TF_TString_Reserve(&s70, 100);\n\n    // Test 16 byte alignment (7*16 - 1 = 111)\n    EXPECT_EQ(111, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(5, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TSTR_LARGE, TF_TString_GetType(&s70));\n\n    TF_TString_AssignView(&s70, kLongString, kLongStringLen);\n    TF_TString_Reserve(&s70, 10);\n\n    EXPECT_EQ(TF_TSTR_VIEW, TF_TString_GetType(&s70));\n    EXPECT_EQ(0, TF_TString_GetCapacity(&s70));\n\n    TF_TString_Reserve(&s70, 100);\n\n    // Converted to LARGE since it can no longer fit in SMALL.\n    EXPECT_EQ(TF_TSTR_LARGE, TF_TString_GetType(&s70));\n    EXPECT_EQ(111, TF_TString_GetCapacity(&s70));\n\n    TF_TString_Reserve(&s70, 200);\n\n    EXPECT_EQ(TF_TSTR_LARGE, TF_TString_GetType(&s70));\n    EXPECT_EQ(207, TF_TString_GetCapacity(&s70));\n\n    TF_TString_Dealloc(&s70);\n  }\n  {\n    // ReserveAmortized\n    TF_TString s70;\n\n    TF_TString_Init(&s70);\n\n    TF_TString_ReserveAmortized(&s70, TF_TString_SmallCapacity - 1);\n\n    EXPECT_EQ(TF_TString_SmallCapacity, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(0, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TSTR_SMALL, TF_TString_GetType(&s70));\n\n    TF_TString_ReserveAmortized(&s70, TF_TString_SmallCapacity);\n\n    EXPECT_EQ(TF_TString_SmallCapacity, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(0, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TSTR_SMALL, TF_TString_GetType(&s70));\n\n    TF_TString_Copy(&s70, \"hello\", 5);\n\n    EXPECT_EQ(5, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TString_SmallCapacity, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(TF_TSTR_SMALL, TF_TString_GetType(&s70));\n\n    TF_TString_ReserveAmortized(&s70, 100);\n\n    // Test 16 byte alignment (7*16 - 1 = 111)\n    EXPECT_EQ(111, TF_TString_GetCapacity(&s70));\n    EXPECT_EQ(5, TF_TString_GetSize(&s70));\n    EXPECT_EQ(TF_TSTR_LARGE, TF_TString_GetType(&s70));\n\n    TF_TString_AssignView(&s70, kLongString, kLongStringLen);\n    TF_TString_ReserveAmortized(&s70, 10);\n\n    EXPECT_EQ(TF_TSTR_VIEW, TF_TString_GetType(&s70));\n    EXPECT_EQ(0, TF_TString_GetCapacity(&s70));\n\n    TF_TString_ReserveAmortized(&s70, 100);\n\n    // Converted to LARGE since it can no longer fit in SMALL.\n    EXPECT_EQ(TF_TSTR_LARGE, TF_TString_GetType(&s70));\n    EXPECT_EQ(111, TF_TString_GetCapacity(&s70));\n\n    TF_TString_ReserveAmortized(&s70, 200);\n\n    EXPECT_EQ(TF_TSTR_LARGE, TF_TString_GetType(&s70));\n    // 223 = 2*previous_capacity+1\n    EXPECT_EQ(223, TF_TString_GetCapacity(&s70));\n\n    TF_TString_Dealloc(&s70);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41227"
    },
    {
        "index": 28,
        "code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-21736"
    },
    {
        "index": 29,
        "code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36148"
    },
    {
        "index": 30,
        "code": "static bool set_sockaddr(sockaddr_storage &sa_storage, req::ptr<Socket> sock,\n                         const String& addr, int port,\n                         struct sockaddr *&sa_ptr, size_t &sa_size) {\n  // Always zero it out:\n  // - fields are added over time; zeroing it out is future-proofing; for\n  //   example, sockaddr_in6 did not originally include sin6_scope_id or\n  //   sin6_flowinfo.\n  // - required for all on MacOS for correct behavior\n  // - on Linux, required for sockaddr_un to deal with buggy sun_path readers\n  //   (they should look at the length)\n  memset(&sa_storage, 0, sizeof(struct sockaddr_storage));\n  struct sockaddr *sock_type = (struct sockaddr*) &sa_storage;\n  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {\n        // Linux supports 3 kinds of unix sockets; behavior of this struct\n        // is in `man 7 unix`; relevant parts:\n        // - unnamed: 0-length path. As paths are not required to be\n        //   null-terminated, this needs to be undicated by the size.\n        //   These might be created by `socketpair()`, for eaxmple.\n        // - pathname (common): nothing strange. struct size technically\n        //   indicates length, but null terminators are usually set. This\n        //   does matter if addr.length() == size of the char array though\n        // - abstract: these have a meaningful name, but start with `\\0`\n        //\n        // Setting sa_size to indicate a 0-length path is required to\n        // distinguish between unnamed and abstract.\n        sa_size = offsetof(struct sockaddr_un, sun_path);\n      }\n#endif\n\n#endif // ifdef _MSC_VER\n    }\n    break;\n  case AF_INET:\n    {\n      struct sockaddr_in *sa = (struct sockaddr_in *)sock_type;\n      sa->sin_family = AF_INET;\n      sa->sin_port = htons((unsigned short) port);\n      if (!php_set_inet_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in);\n    }\n    break;\n  case AF_INET6:\n    {\n      struct sockaddr_in6 *sa = (struct sockaddr_in6 *)sock_type;\n      sa->sin6_family = AF_INET6;\n      sa->sin6_port = htons((unsigned short) port);\n      if (!php_set_inet6_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in6);\n    }\n    break;\n  default:\n    raise_warning(\"unsupported socket type '%d', must be \"\n                    \"AF_UNIX, AF_INET, or AF_INET6\", sock->getType());\n    return false;\n  }\n#ifdef __APPLE__\n  // This field is not in the relevant standards, not defined on Linux, but is\n  // technically required on MacOS (and other BSDs) according to the man pages:\n  // - `man 4 netintro` covers the base sa_len\n  // - `man 4 unix` and `man 4 inet6` cover AF_UNIX sun_len and AF_INET6\n  //    sin6_len\n  // - ... At least MacOS Catalina includes the wrong `man 4 inet`. Look at the\n  //   (Net|Free|Open)BSD `man 4 inet` instead.\n  //   The MacOS man page says it starts with `sin_family`, which would conflict\n  //   with the base sockaddr definition. `sin_len` is actually the first field\n  //   in the header file, matching `sa_len`.\n  sa_ptr->sa_len = sa_size;\n#endif\n  return true;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 31,
        "code": "hufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc < l && in < ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-20304"
    },
    {
        "index": 32,
        "code": "static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signalling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 33,
        "code": "  void Compute(OpKernelContext *ctx) override {\n    const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,\n        *b_values_t, *b_shape_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape_t));\n\n    // Validations.\n    OP_REQUIRES(\n        ctx,\n        TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&\n            TensorShapeUtils::IsMatrix(b_indices_t->shape()),\n        errors::InvalidArgument(\"Inputs a_indices and b_indices should be \"\n                                \"matrices but received shapes: \",\n                                a_indices_t->shape().DebugString(), \", \",\n                                b_indices_t->shape().DebugString()));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                    TensorShapeUtils::IsVector(b_values_t->shape()),\n                errors::InvalidArgument(\n                    \"Inputs a_values and b_values should be vectors \"\n                    \"but received shapes: \",\n                    a_values_t->shape().DebugString(), \" and \",\n                    b_values_t->shape().DebugString()));\n\n    const int64 a_nnz = a_indices_t->dim_size(0);\n    const int64 b_nnz = b_indices_t->dim_size(0);\n    const auto a_values = a_values_t->vec<T>();\n    const auto b_values = b_values_t->vec<T>();\n\n    OP_REQUIRES(\n        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n        errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                \" non-empty input values, got \",\n                                a_values.size(), \" and \", b_values.size()));\n\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_shape_t->shape()) &&\n                    TensorShapeUtils::IsVector(b_shape_t->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    a_shape_t->shape().DebugString(), \" and \",\n                    b_shape_t->shape().DebugString()));\n    OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),\n                errors::InvalidArgument(\n                    \"Operands do not have the same ranks; got shapes: \",\n                    a_shape_t->SummarizeValue(10), \" and \",\n                    b_shape_t->SummarizeValue(10)));\n    const auto a_shape = a_shape_t->flat<int64>();\n    const auto b_shape = b_shape_t->flat<int64>();\n    for (int i = 0; i < a_shape_t->NumElements(); ++i) {\n      OP_REQUIRES(ctx, a_shape(i) == b_shape(i),\n                  errors::InvalidArgument(\"Operands' shapes do not match: got \",\n                                          a_shape(i), \" and \", b_shape(i),\n                                          \" for dimension \", i));\n    }\n\n    const int num_dims = a_indices_t->dim_size(1);\n    const auto a_indices_mat = a_indices_t->matrix<int64>();\n    const auto b_indices_mat = b_indices_t->matrix<int64>();\n    std::vector<T> a_augmented_values, b_augmented_values;\n    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx\n    UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,\n                                b_values, b_nnz, num_dims, &a_augmented_values,\n                                &b_augmented_values, &entries_to_copy);\n\n    // Allocates and fills output tensors.\n    const int64 sum_nnz = a_augmented_values.size();\n    Tensor *output_indices_t, *output_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                        &output_indices_t));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));\n    auto output_indices_mat = output_indices_t->matrix<int64>();\n\n    for (int64 i = 0; i < sum_nnz; ++i) {\n      const bool from_a = entries_to_copy[i].first;\n      const int64 idx = entries_to_copy[i].second;\n      output_indices_mat.chip<0>(i) =\n          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n    }\n\n    // Performs the functor operation using Eigen.\n    //\n    // Note that the two stack-allocated std::vector's may not be aligned. Using\n    // allocate_temp() would've given us aligned storage, but we do not know\n    // their sizes in advance, so we couldn't use allocate_temp() anyway.\n    //\n    // TODO(zongheng): measure if it's worthwhile to somehow force alignment.\n    using UnalignedTensorMap =\n        Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                         Eigen::Unaligned>;\n    auto a_augmented_values_t =\n        UnalignedTensorMap(a_augmented_values.data(), sum_nnz);\n    auto b_augmented_values_t =\n        UnalignedTensorMap(b_augmented_values.data(), sum_nnz);\n    output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =\n        a_augmented_values_t.binaryExpr(b_augmented_values_t,\n                                        typename Functor::func());\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29612"
    },
    {
        "index": 34,
        "code": "static pyc_object *get_dict_object(RBuffer *buffer) {\n\tpyc_object *key = NULL,\n\t\t   *val = NULL;\n\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tkey = get_object (buffer);\n\t\tif (!key) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_list_append (ret->data, key)) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\tfree_object (key);\n\t\t\treturn NULL;\n\t\t}\n\t\tval = get_object (buffer);\n\t\tif (!val) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_list_append (ret->data, val)) {\n\t\t\tfree_object (val);\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tret->type = TYPE_DICT;\n\treturn ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0523"
    },
    {
        "index": 35,
        "code": "Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 36,
        "code": "skipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(arg, evalarg);\n    return p;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2889"
    },
    {
        "index": 37,
        "code": "R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\t// RBinJavaLocalVariableTypeAttribute *lvattr;\n\tRListIter *iter;\n\tut64 size = 0;\n\tif (attr) {\n\t\tRList *list = attr->info.local_variable_type_table_attr.local_variable_table;\n\t\tsize += 6;\n\t\t// attr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// r_list_foreach (list, iter, lvattr) {\n\t\tr_list_foreach_iter (list, iter) {\n\t\t\t// lvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t}\n\treturn size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 38,
        "code": "pixFewColorsOctcubeQuantMixed(PIX       *pixs,\n                              l_int32    level,\n                              l_int32    darkthresh,\n                              l_int32    lightthresh,\n                              l_int32    diffthresh,\n                              l_float32  minfract,\n                              l_int32    maxspan)\n{\nl_int32    i, j, w, h, wplc, wplm, wpld, ncolors, index;\nl_int32    rval, gval, bval, val, minval, maxval;\nl_int32   *lut;\nl_uint32  *datac, *datam, *datad, *linec, *linem, *lined;\nPIX       *pixc, *pixm, *pixg, *pixd;\nPIXCMAP   *cmap, *cmapd;\n\n    PROCNAME(\"pixFewColorsOctcubeQuantMixed\");\n\n    if (!pixs || pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 32 bpp\", procName, NULL);\n    if (level <= 0) level = 3;\n    if (level > 6)\n        return (PIX *)ERROR_PTR(\"invalid level\", procName, NULL);\n    if (darkthresh <= 0) darkthresh = 20;\n    if (lightthresh <= 0) lightthresh = 244;\n    if (diffthresh <= 0) diffthresh = 20;\n    if (minfract <= 0.0) minfract = 0.05;\n    if (maxspan <= 2) maxspan = 15;\n\n        /* Start with a simple fixed octcube quantizer. */\n    if ((pixc = pixFewColorsOctcubeQuant1(pixs, level)) == NULL)\n        return (PIX *)ERROR_PTR(\"too many colors\", procName, NULL);\n\n        /* Identify and save color entries in the colormap.  Set up a LUT\n         * that returns -1 for any gray pixel. */\n    cmap = pixGetColormap(pixc);\n    ncolors = pixcmapGetCount(cmap);\n    cmapd = pixcmapCreate(8);\n    lut = (l_int32 *)LEPT_CALLOC(256, sizeof(l_int32));\n    for (i = 0; i < 256; i++)\n        lut[i] = -1;\n    for (i = 0, index = 0; i < ncolors; i++) {\n        pixcmapGetColor(cmap, i, &rval, &gval, &bval);\n        minval = L_MIN(rval, gval);\n        minval = L_MIN(minval, bval);\n        if (minval > lightthresh)  /* near white */\n            continue;\n        maxval = L_MAX(rval, gval);\n        maxval = L_MAX(maxval, bval);\n        if (maxval < darkthresh)  /* near black */\n            continue;\n\n            /* Use the max diff between components to test for color */\n        if (maxval - minval >= diffthresh) {\n            pixcmapAddColor(cmapd, rval, gval, bval);\n            lut[i] = index;\n            index++;\n        }\n    }\n\n        /* Generate dest pix with just the color pixels set to their\n         * colormap indices.  At the same time, make a 1 bpp mask\n         * of the non-color pixels */\n    pixGetDimensions(pixs, &w, &h, NULL);\n    pixd = pixCreate(w, h, 8);\n    pixSetColormap(pixd, cmapd);\n    pixm = pixCreate(w, h, 1);\n    datac = pixGetData(pixc);\n    datam = pixGetData(pixm);\n    datad = pixGetData(pixd);\n    wplc = pixGetWpl(pixc);\n    wplm = pixGetWpl(pixm);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        linec = datac + i * wplc;\n        linem = datam + i * wplm;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(linec, j);\n            if (lut[val] == -1)\n                SET_DATA_BIT(linem, j);\n            else\n                SET_DATA_BYTE(lined, j, lut[val]);\n        }\n    }\n\n        /* Fill in the gray values.  Use a grayscale version of pixs\n         * as input, along with the mask over the actual gray pixels. */\n    pixg = pixConvertTo8(pixs, 0);\n    pixGrayQuantFromHisto(pixd, pixg, pixm, minfract, maxspan);\n\n    LEPT_FREE(lut);\n    pixDestroy(&pixc);\n    pixDestroy(&pixm);\n    pixDestroy(&pixg);\n    return pixd;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36281"
    },
    {
        "index": 39,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n\n    ValidateInputTensors(ctx, in0, in1);\n\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  // Band size.\n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29612"
    },
    {
        "index": 40,
        "code": "void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1052"
    },
    {
        "index": 41,
        "code": "static int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\n\t/* sh_size must be lower than UT32_MAX and not equal to zero, to avoid bugs on malloc() */\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 42,
        "code": "PJ_DEF(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t\t     const pj_str_t *method,\n\t\t\t\t\t     pjsip_digest_credential *auth)\n{\n    pj_str_t nonce_bin;\n    int aka_version;\n    const pj_str_t pjsip_AKAv1_MD5 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t pjsip_AKAv2_MD5 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac;\n    pj_uint8_t k[PJSIP_AKA_KLEN];\n    pj_uint8_t op[PJSIP_AKA_OPLEN];\n    pj_uint8_t amf[PJSIP_AKA_AMFLEN];\n    pj_uint8_t res[PJSIP_AKA_RESLEN];\n    pj_uint8_t ck[PJSIP_AKA_CKLEN];\n    pj_uint8_t ik[PJSIP_AKA_IKLEN];\n    pj_uint8_t ak[PJSIP_AKA_AKLEN];\n    pj_uint8_t sqn[PJSIP_AKA_SQNLEN];\n    pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n    pjsip_cred_info aka_cred;\n    int i, len;\n    pj_status_t status;\n\n    /* Check the algorithm is supported. */\n    if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n\t/*\n\t * A normal MD5 authentication is requested. Fallbackt to the usual\n\t * MD5 digest creation.\n\t */\n\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,\n\t\t\t\t &auth->realm, cred, method);\n\treturn PJ_SUCCESS;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n\t/*\n\t * AKA version 1 is requested.\n\t */\n\taka_version = 1;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) {\n\t/*\n\t * AKA version 2 is requested.\n\t */\n\taka_version = 2;\n\n    } else {\n\t/* Unsupported algorithm */\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Decode nonce */\n    nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen);\n    nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1);\n    status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len);\n    nonce_bin.slen = len;\n    if (status != PJ_SUCCESS)\n\treturn PJSIP_EAUTHINNONCE;\n\n    if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN)\n\treturn PJSIP_EAUTHINNONCE;\n\n    /* Get RAND, AUTN, and MAC */\n    chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0);\n    chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN);\n    chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN + \n\t\t\t      PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN);\n\n    /* Copy k. op, and amf */\n    pj_bzero(k, sizeof(k));\n    pj_bzero(op, sizeof(op));\n    pj_bzero(amf, sizeof(amf));\n\n    if (cred->ext.aka.k.slen)\n\tpj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen);\n    if (cred->ext.aka.op.slen)\n\tpj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen);\n    if (cred->ext.aka.amf.slen)\n\tpj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen);\n\n    /* Given key K and random challenge RAND, compute response RES,\n     * confidentiality key CK, integrity key IK and anonymity key AK.\n     */\n    f2345(k, chal_rand, res, ck, ik, ak, op);\n\n    /* Compute sequence number SQN */\n    for (i=0; i<PJSIP_AKA_SQNLEN; ++i)\n\tsqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]);\n\n    /* Verify MAC in the challenge */\n    /* Compute XMAC */\n    f1(k, chal_rand, sqn, amf, xmac, op);\n\n    if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) {\n\treturn PJSIP_EAUTHINNONCE;\n    }\n\n    /* Build a temporary credential info to create MD5 digest, using\n     * \"res\" as the password. \n     */\n    pj_memcpy(&aka_cred, cred, sizeof(aka_cred));\n    aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\n    /* Create a response */\n    if (aka_version == 1) {\n\t/*\n\t * For AKAv1, the password is RES\n\t */\n\taka_cred.data.ptr = (char*)res;\n\taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else if (aka_version == 2) {\n\n\t/*\n\t * For AKAv2, password is base64 encoded [1] parameters:\n\t *    PRF(RES||IK||CK,\"http-digest-akav2-password\")\n\t *\n\t * The pseudo-random function (PRF) is HMAC-MD5 in this case.\n\t */\n\n\tpj_str_t resikck;\n\tconst pj_str_t AKAv2_Passwd = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t hmac_digest[16];\n\tchar tmp_buf[48];\n\tint hmac64_len;\n\n\tresikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN;\n\tpj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf));\n\tresikck.ptr = tmp_buf;\n\tpj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN,\n\t          ck, PJSIP_AKA_CKLEN);\n\n\tpj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen,\n\t            (const pj_uint8_t*)resikck.ptr, resikck.slen,\n\t            hmac_digest);\n\n\taka_cred.data.slen = hmac64_len =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest));\n\tpj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf));\n\taka_cred.data.ptr = tmp_buf;\n\tpj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest),\n\t                 aka_cred.data.ptr, &len);\n\taka_cred.data.slen = hmac64_len;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn PJ_EBUG;\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24754"
    },
    {
        "index": 43,
        "code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-20298"
    },
    {
        "index": 44,
        "code": "bool CSteamNetworkConnectionBase::ProcessPlainTextDataChunk( int usecTimeSinceLast, RecvPacketContext_t &ctx )\n{\n\t#define DECODE_ERROR( ... ) do { \\\n\t\tConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Misc_InternalError, __VA_ARGS__ ); \\\n\t\treturn false; } while(false)\n\n\t#define EXPECT_BYTES(n,pszWhatFor) \\\n\t\tdo { \\\n\t\t\tif ( pDecode + (n) > pEnd ) \\\n\t\t\t\tDECODE_ERROR( \"SNP decode overrun, %d bytes for %s\", (n), pszWhatFor ); \\\n\t\t} while (false)\n\n\t#define READ_8BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(1,pszWhatFor); var = *(uint8 *)pDecode; pDecode += 1; } while(false)\n\n\t#define READ_16BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(2,pszWhatFor); var = LittleWord(*(uint16 *)pDecode); pDecode += 2; } while(false)\n\n\t#define READ_24BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(3,pszWhatFor); \\\n\t\t\tvar = *(uint8 *)pDecode; pDecode += 1; \\\n\t\t\tvar |= uint32( LittleWord(*(uint16 *)pDecode) ) << 8U; pDecode += 2; \\\n\t\t} while(false)\n\n\t#define READ_32BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(4,pszWhatFor); var = LittleDWord(*(uint32 *)pDecode); pDecode += 4; } while(false)\n\n\t#define READ_48BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(6,pszWhatFor); \\\n\t\t\tvar = LittleWord( *(uint16 *)pDecode ); pDecode += 2; \\\n\t\t\tvar |= uint64( LittleDWord(*(uint32 *)pDecode) ) << 16U; pDecode += 4; \\\n\t\t} while(false)\n\n\t#define READ_64BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(8,pszWhatFor); var = LittleQWord(*(uint64 *)pDecode); pDecode += 8; } while(false)\n\n\t#define READ_VARINT( var, pszWhatFor ) \\\n\t\tdo { pDecode = DeserializeVarInt( pDecode, pEnd, var ); if ( !pDecode ) { DECODE_ERROR( \"SNP data chunk decode overflow, varint for %s\", pszWhatFor ); } } while(false)\n\n\t#define READ_SEGMENT_DATA_SIZE( is_reliable ) \\\n\t\tint cbSegmentSize; \\\n\t\t{ \\\n\t\t\tint sizeFlags = nFrameType & 7; \\\n\t\t\tif ( sizeFlags <= 4 ) \\\n\t\t\t{ \\\n\t\t\t\tuint8 lowerSizeBits; \\\n\t\t\t\tREAD_8BITU( lowerSizeBits, #is_reliable \" size lower bits\" ); \\\n\t\t\t\tcbSegmentSize = (sizeFlags<<8) + lowerSizeBits; \\\n\t\t\t\tif ( pDecode + cbSegmentSize > pEnd ) \\\n\t\t\t\t{ \\\n\t\t\t\t\tDECODE_ERROR( \"SNP decode overrun %d bytes for %s segment data.\", cbSegmentSize, #is_reliable ); \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t\telse if ( sizeFlags == 7 ) \\\n\t\t\t{ \\\n\t\t\t\tcbSegmentSize = pEnd - pDecode; \\\n\t\t\t} \\\n\t\t\telse \\\n\t\t\t{ \\\n\t\t\t\tDECODE_ERROR( \"Invalid SNP frame lead byte 0x%02x. (size bits)\", nFrameType ); \\\n\t\t\t} \\\n\t\t} \\\n\t\tconst uint8 *pSegmentData = pDecode; \\\n\t\tpDecode += cbSegmentSize;\n\n\t// Make sure we have initialized the connection\n\tAssert( BStateIsActive() );\n\n\tconst SteamNetworkingMicroseconds usecNow = ctx.m_usecNow;\n\tconst int64 nPktNum = ctx.m_nPktNum;\n\tbool bInhibitMarkReceived = false;\n\n\tconst int nLogLevelPacketDecode = m_connectionConfig.m_LogLevel_PacketDecode.Get();\n\tSpewVerboseGroup( nLogLevelPacketDecode, \"[%s] decode pkt %lld\\n\", GetDescription(), (long long)nPktNum );\n\n\t// Decode frames until we get to the end of the payload\n\tconst byte *pDecode = (const byte *)ctx.m_pPlainText;\n\tconst byte *pEnd = pDecode + ctx.m_cbPlainText;\n\tint64 nCurMsgNum = 0;\n\tint64 nDecodeReliablePos = 0;\n\twhile ( pDecode < pEnd )\n\t{\n\n\t\tuint8 nFrameType = *pDecode;\n\t\t++pDecode;\n\t\tif ( ( nFrameType & 0xc0 ) == 0x00 )\n\t\t{\n\n\t\t\t//\n\t\t\t// Unreliable segment\n\t\t\t//\n\n\t\t\t// Decode message number\n\t\t\tif ( nCurMsgNum == 0 )\n\t\t\t{\n\t\t\t\t// First unreliable frame.  Message number is absolute, but only bottom N bits are sent\n\t\t\t\tstatic const char szUnreliableMsgNumOffset[] = \"unreliable msgnum\";\n\t\t\t\tint64 nLowerBits, nMask;\n\t\t\t\tif ( nFrameType & 0x10 )\n\t\t\t\t{\n\t\t\t\t\tREAD_32BITU( nLowerBits, szUnreliableMsgNumOffset );\n\t\t\t\t\tnMask = 0xffffffff;\n\t\t\t\t\tnCurMsgNum = NearestWithSameLowerBits( (int32)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREAD_16BITU( nLowerBits, szUnreliableMsgNumOffset );\n\t\t\t\t\tnMask = 0xffff;\n\t\t\t\t\tnCurMsgNum = NearestWithSameLowerBits( (int16)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\t\t\t\tAssert( ( nCurMsgNum & nMask ) == nLowerBits );\n\n\t\t\t\tif ( nCurMsgNum <= 0 )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode unreliable msgnum underflow.  %llx mod %llx, highest seen %llx\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\t\t\t\tif ( std::abs( nCurMsgNum - m_receiverState.m_nHighestSeenMsgNum ) > (nMask>>2) )\n\t\t\t\t{\n\t\t\t\t\t// We really should never get close to this boundary.\n\t\t\t\t\tSpewWarningRateLimited( usecNow, \"Sender sent abs unreliable message number using %llx mod %llx, highest seen %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( nFrameType & 0x10 )\n\t\t\t\t{\n\t\t\t\t\tuint64 nMsgNumOffset;\n\t\t\t\t\tREAD_VARINT( nMsgNumOffset, \"unreliable msgnum offset\" );\n\t\t\t\t\tnCurMsgNum += nMsgNumOffset;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++nCurMsgNum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( nCurMsgNum > m_receiverState.m_nHighestSeenMsgNum )\n\t\t\t\tm_receiverState.m_nHighestSeenMsgNum = nCurMsgNum;\n\n\t\t\t//\n\t\t\t// Decode segment offset in message\n\t\t\t//\n\t\t\tuint32 nOffset = 0;\n\t\t\tif ( nFrameType & 0x08 )\n\t\t\t\tREAD_VARINT( nOffset, \"unreliable data offset\" );\n\n\t\t\t//\n\t\t\t// Decode size, locate segment data\n\t\t\t//\n\t\t\tREAD_SEGMENT_DATA_SIZE( unreliable )\n\t\t\tAssert( cbSegmentSize > 0 ); // !TEST! Bogus assert, zero byte messages are OK.  Remove after testing\n\n\t\t\t// Receive the segment\n\t\t\tbool bLastSegmentInMessage = ( nFrameType & 0x20 ) != 0;\n\t\t\tSNP_ReceiveUnreliableSegment( nCurMsgNum, nOffset, pSegmentData, cbSegmentSize, bLastSegmentInMessage, usecNow );\n\t\t}\n\t\telse if ( ( nFrameType & 0xe0 ) == 0x40 )\n\t\t{\n\n\t\t\t//\n\t\t\t// Reliable segment\n\t\t\t//\n\n\t\t\t// First reliable segment?\n\t\t\tif ( nDecodeReliablePos == 0 )\n\t\t\t{\n\n\t\t\t\t// Stream position is absolute.  How many bits?\n\t\t\t\tstatic const char szFirstReliableStreamPos[] = \"first reliable streampos\";\n\t\t\t\tint64 nOffset, nMask;\n\t\t\t\tswitch ( nFrameType & (3<<3) )\n\t\t\t\t{\n\t\t\t\t\tcase 0<<3: READ_24BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<24)-1; break;\n\t\t\t\t\tcase 1<<3: READ_32BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<32)-1; break;\n\t\t\t\t\tcase 2<<3: READ_48BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<48)-1; break;\n\t\t\t\t\tdefault: DECODE_ERROR( \"Reserved reliable stream pos size\" );\n\t\t\t\t}\n\n\t\t\t\t// What do we expect to receive next?\n\t\t\t\tint64 nExpectNextStreamPos = m_receiverState.m_nReliableStreamPos + len( m_receiverState.m_bufReliableStream );\n\n\t\t\t\t// Find the stream offset closest to that\n\t\t\t\tnDecodeReliablePos = ( nExpectNextStreamPos & ~nMask ) + nOffset;\n\t\t\t\tif ( nDecodeReliablePos + (nMask>>1) < nExpectNextStreamPos )\n\t\t\t\t{\n\t\t\t\t\tnDecodeReliablePos += nMask+1;\n\t\t\t\t\tAssert( ( nDecodeReliablePos & nMask ) == nOffset );\n\t\t\t\t\tAssert( nExpectNextStreamPos < nDecodeReliablePos );\n\t\t\t\t\tAssert( nExpectNextStreamPos + (nMask>>1) >= nDecodeReliablePos );\n\t\t\t\t}\n\t\t\t\tif ( nDecodeReliablePos <= 0 )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode first reliable stream pos underflow.  %llx mod %llx, expected next %llx\",\n\t\t\t\t\t\t(unsigned long long)nOffset, (unsigned long long)( nMask+1 ), (unsigned long long)nExpectNextStreamPos );\n\t\t\t\t}\n\t\t\t\tif ( std::abs( nDecodeReliablePos - nExpectNextStreamPos ) > (nMask>>2) )\n\t\t\t\t{\n\t\t\t\t\t// We really should never get close to this boundary.\n\t\t\t\t\tSpewWarningRateLimited( usecNow, \"Sender sent reliable stream pos using %llx mod %llx, expected next %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)nOffset, (unsigned long long)( nMask+1 ), (unsigned long long)nExpectNextStreamPos );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Subsequent reliable message encode the position as an offset from previous.\n\t\t\t\tstatic const char szOtherReliableStreamPos[] = \"reliable streampos offset\";\n\t\t\t\tint64 nOffset;\n\t\t\t\tswitch ( nFrameType & (3<<3) )\n\t\t\t\t{\n\t\t\t\t\tcase 0<<3: nOffset = 0; break;\n\t\t\t\t\tcase 1<<3: READ_8BITU( nOffset, szOtherReliableStreamPos ); break;\n\t\t\t\t\tcase 2<<3: READ_16BITU( nOffset, szOtherReliableStreamPos ); break;\n\t\t\t\t\tdefault: READ_32BITU( nOffset, szOtherReliableStreamPos ); break;\n\t\t\t\t}\n\t\t\t\tnDecodeReliablePos += nOffset;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Decode size, locate segment data\n\t\t\t//\n\t\t\tREAD_SEGMENT_DATA_SIZE( reliable )\n\n\t\t\t// Ingest the segment.\n\t\t\tif ( !SNP_ReceiveReliableSegment( nPktNum, nDecodeReliablePos, pSegmentData, cbSegmentSize, usecNow ) )\n\t\t\t{\n\t\t\t\tif ( !BStateIsActive() )\n\t\t\t\t\treturn false; // we decided to nuke the connection - abort packet processing\n\n\t\t\t\t// We're not able to ingest this reliable segment at the moment,\n\t\t\t\t// but we didn't terminate the connection.  So do not ack this packet\n\t\t\t\t// to the peer.  We need them to retransmit\n\t\t\t\tbInhibitMarkReceived = true;\n\t\t\t}\n\n\t\t\t// Advance pointer for the next reliable segment, if any.\n\t\t\tnDecodeReliablePos += cbSegmentSize;\n\n\t\t\t// Decoding rules state that if we have established a message number,\n\t\t\t// (from an earlier unreliable message), then we advance it.\n\t\t\tif ( nCurMsgNum > 0 ) \n\t\t\t\t++nCurMsgNum;\n\t\t}\n\t\telse if ( ( nFrameType & 0xfc ) == 0x80 )\n\t\t{\n\t\t\t//\n\t\t\t// Stop waiting\n\t\t\t//\n\n\t\t\tint64 nOffset = 0;\n\t\t\tstatic const char szStopWaitingOffset[] = \"stop_waiting offset\";\n\t\t\tswitch ( nFrameType & 3 )\n\t\t\t{\n\t\t\t\tcase 0: READ_8BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t\tcase 1: READ_16BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t\tcase 2: READ_24BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t\tcase 3: READ_64BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t}\n\t\t\tif ( nOffset >= nPktNum )\n\t\t\t{\n\t\t\t\tDECODE_ERROR( \"stop_waiting pktNum %llu offset %llu\", nPktNum, nOffset );\n\t\t\t}\n\t\t\t++nOffset;\n\t\t\tint64 nMinPktNumToSendAcks = nPktNum-nOffset;\n\t\t\tif ( nMinPktNumToSendAcks == m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t\tcontinue;\n\t\t\tif ( nMinPktNumToSendAcks < m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t{\n\t\t\t\t// Sender must never reduce this number!  Check for bugs or bogus sender\n\t\t\t\tif ( nPktNum >= m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP stop waiting reduced %lld (pkt %lld) -> %lld (pkt %lld)\",\n\t\t\t\t\t\t(long long)m_receiverState.m_nMinPktNumToSendAcks,\n\t\t\t\t\t\t(long long)m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks,\n\t\t\t\t\t\t(long long)nMinPktNumToSendAcks,\n\t\t\t\t\t\t(long long)nPktNum\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld stop waiting: %lld (was %lld)\",\n\t\t\t\tGetDescription(),\n\t\t\t\t(long long)nPktNum,\n\t\t\t\t(long long)nMinPktNumToSendAcks, (long long)m_receiverState.m_nMinPktNumToSendAcks );\n\t\t\tm_receiverState.m_nMinPktNumToSendAcks = nMinPktNumToSendAcks;\n\t\t\tm_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks = nPktNum;\n\n\t\t\t// Trim from the front of the packet gap list,\n\t\t\t// we can stop reporting these losses to the sender\n\t\t\tauto h = m_receiverState.m_mapPacketGaps.begin();\n\t\t\twhile ( h->first <= m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t{\n\t\t\t\tif ( h->second.m_nEnd > m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t\t{\n\t\t\t\t\t// Ug.  You're not supposed to modify the key in a map.\n\t\t\t\t\t// I suppose that's legit, since you could violate the ordering.\n\t\t\t\t\t// but in this case I know that this change is OK.\n\t\t\t\t\tconst_cast<int64 &>( h->first ) = m_receiverState.m_nMinPktNumToSendAcks;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Were we pending an ack on this?\n\t\t\t\tif ( m_receiverState.m_itPendingAck == h )\n\t\t\t\t\t++m_receiverState.m_itPendingAck;\n\n\t\t\t\t// Were we pending a nack on this?\n\t\t\t\tif ( m_receiverState.m_itPendingNack == h )\n\t\t\t\t{\n\t\t\t\t\t// I am not sure this is even possible.\n\t\t\t\t\tAssertMsg( false, \"Expiring packet gap, which had pending NACK\" );\n\n\t\t\t\t\t// But just in case, this would be the proper action\n\t\t\t\t\t++m_receiverState.m_itPendingNack;\n\t\t\t\t}\n\n\t\t\t\t// Packet loss is in the past.  Forget about it and move on\n\t\t\t\th = m_receiverState.m_mapPacketGaps.erase(h);\n\t\t\t}\n\t\t}\n\t\telse if ( ( nFrameType & 0xf0 ) == 0x90 )\n\t\t{\n\n\t\t\t//\n\t\t\t// Ack\n\t\t\t//\n\n\t\t\t#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA > 0\n\t\t\t\tm_senderState.DebugCheckInFlightPacketMap();\n\t\t\t\t#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA == 1\n\t\t\t\tif ( ( nPktNum & 255 ) == 0 ) // only do it periodically\n\t\t\t\t#endif\n\t\t\t\t{\n\t\t\t\t\tm_senderState.DebugCheckInFlightPacketMap();\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t// Parse latest received sequence number\n\t\t\tint64 nLatestRecvSeqNum;\n\t\t\t{\n\t\t\t\tstatic const char szAckLatestPktNum[] = \"ack latest pktnum\";\n\t\t\t\tint64 nLowerBits, nMask;\n\t\t\t\tif ( nFrameType & 0x40 )\n\t\t\t\t{\n\t\t\t\t\tREAD_32BITU( nLowerBits, szAckLatestPktNum );\n\t\t\t\t\tnMask = 0xffffffff;\n\t\t\t\t\tnLatestRecvSeqNum = NearestWithSameLowerBits( (int32)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREAD_16BITU( nLowerBits, szAckLatestPktNum );\n\t\t\t\t\tnMask = 0xffff;\n\t\t\t\t\tnLatestRecvSeqNum = NearestWithSameLowerBits( (int16)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\tAssert( ( nLatestRecvSeqNum & nMask ) == nLowerBits );\n\n\t\t\t\t// Find the message number that is closes to \n\t\t\t\tif ( nLatestRecvSeqNum < 0 )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode ack latest pktnum underflow.  %llx mod %llx, next send %llx\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\tif ( std::abs( nLatestRecvSeqNum - m_statsEndToEnd.m_nNextSendSequenceNumber ) > (nMask>>2) )\n\t\t\t\t{\n\t\t\t\t\t// We really should never get close to this boundary.\n\t\t\t\t\tSpewWarningRateLimited( usecNow, \"Sender sent abs latest recv pkt number using %llx mod %llx, next send %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\tif ( nLatestRecvSeqNum >= m_statsEndToEnd.m_nNextSendSequenceNumber )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode ack latest pktnum %lld (%llx mod %llx), but next outoing packet is %lld (%llx).\",\n\t\t\t\t\t\t(long long)nLatestRecvSeqNum, (unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ),\n\t\t\t\t\t\t(long long)m_statsEndToEnd.m_nNextSendSequenceNumber, (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld latest recv %lld\\n\",\n\t\t\t\tGetDescription(),\n\t\t\t\t(long long)nPktNum, (long long)nLatestRecvSeqNum\n\t\t\t);\n\n\t\t\t// Locate our bookkeeping for this packet, or the latest one before it\n\t\t\t// Remember, we have a sentinel with a low, invalid packet number\n\t\t\tAssert( !m_senderState.m_mapInFlightPacketsByPktNum.empty() );\n\t\t\tauto inFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.upper_bound( nLatestRecvSeqNum );\n\t\t\t--inFlightPkt;\n\t\t\tAssert( inFlightPkt->first <= nLatestRecvSeqNum );\n\n\t\t\t// Parse out delay, and process the ping\n\t\t\t{\n\t\t\t\tuint16 nPackedDelay;\n\t\t\t\tREAD_16BITU( nPackedDelay, \"ack delay\" );\n\t\t\t\tif ( nPackedDelay != 0xffff && inFlightPkt->first == nLatestRecvSeqNum && inFlightPkt->second.m_pTransport == ctx.m_pTransport )\n\t\t\t\t{\n\t\t\t\t\tSteamNetworkingMicroseconds usecDelay = SteamNetworkingMicroseconds( nPackedDelay ) << k_nAckDelayPrecisionShift;\n\t\t\t\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - inFlightPkt->second.m_usecWhenSent;\n\t\t\t\t\tAssert( usecElapsed >= 0 );\n\n\t\t\t\t\t// Account for their reported delay, and calculate ping, in MS\n\t\t\t\t\tint msPing = ( usecElapsed - usecDelay ) / 1000;\n\n\t\t\t\t\t// Does this seem bogus?  (We allow a small amount of slop.)\n\t\t\t\t\t// NOTE: A malicious sender could lie about this delay, tricking us\n\t\t\t\t\t// into thinking that the real network latency is low, they are just\n\t\t\t\t\t// delaying their replies.  This actually matters, since the ping time\n\t\t\t\t\t// is an input into the rate calculation.  So we might need to\n\t\t\t\t\t// occasionally send pings that require an immediately reply, and\n\t\t\t\t\t// if those ping times seem way out of whack with the ones where they are\n\t\t\t\t\t// allowed to send a delay, take action against them.\n\t\t\t\t\tif ( msPing < -1 || msPing > 2000 )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Either they are lying or some weird timer stuff is happening.\n\t\t\t\t\t\t// Either way, discard it.\n\n\t\t\t\t\t\tSpewMsgGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %lluusec INVALID ping %lldusec\\n\",\n\t\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t\t(long long)nPktNum, (long long)nLatestRecvSeqNum,\n\t\t\t\t\t\t\t(unsigned long long)usecDelay,\n\t\t\t\t\t\t\t(long long)usecElapsed\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Clamp, if we have slop\n\t\t\t\t\t\tif ( msPing < 0 )\n\t\t\t\t\t\t\tmsPing = 0;\n\t\t\t\t\t\tProcessSNPPing( msPing, ctx );\n\n\t\t\t\t\t\t// Spew\n\t\t\t\t\t\tSpewVerboseGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %.1fms elapsed %.1fms ping %dms\\n\",\n\t\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t\t(long long)nPktNum, (long long)nLatestRecvSeqNum,\n\t\t\t\t\t\t\t(float)(usecDelay * 1e-3 ),\n\t\t\t\t\t\t\t(float)(usecElapsed * 1e-3 ),\n\t\t\t\t\t\t\tmsPing\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Parse number of blocks\n\t\t\tint nBlocks = nFrameType&7;\n\t\t\tif ( nBlocks == 7 )\n\t\t\t\tREAD_8BITU( nBlocks, \"ack num blocks\" );\n\n\t\t\t// If they actually sent us any blocks, that means they are fragmented.\n\t\t\t// We should make sure and tell them to stop sending us these nacks\n\t\t\t// and move forward.\n\t\t\tif ( nBlocks > 0 )\n\t\t\t{\n\t\t\t\t// Decrease flush delay the more blocks they send us.\n\t\t\t\t// FIXME - This is not an optimal way to do this.  Forcing us to\n\t\t\t\t// ack everything is not what we want to do.  Instead, we should\n\t\t\t\t// use a separate timer for when we need to flush out a stop_waiting\n\t\t\t\t// packet!\n\t\t\t\tSteamNetworkingMicroseconds usecDelay = 250*1000 / nBlocks;\n\t\t\t\tQueueFlushAllAcks( usecNow + usecDelay );\n\t\t\t}\n\n\t\t\t// Process ack blocks, working backwards from the latest received sequence number.\n\t\t\t// Note that we have to parse all this stuff out, even if it's old news (packets older\n\t\t\t// than the stop_aiting value we sent), because we need to do that to get to the rest\n\t\t\t// of the packet.\n\t\t\tbool bAckedReliableRange = false;\n\t\t\tint64 nPktNumAckEnd = nLatestRecvSeqNum+1;\n\t\t\twhile ( nBlocks >= 0 )\n\t\t\t{\n\n\t\t\t\t// Parse out number of acks/nacks.\n\t\t\t\t// Have we parsed all the real blocks?\n\t\t\t\tint64 nPktNumAckBegin, nPktNumNackBegin;\n\t\t\t\tif ( nBlocks == 0 )\n\t\t\t\t{\n\t\t\t\t\t// Implicit block.  Everything earlier between the last\n\t\t\t\t\t// NACK and the stop_waiting value is implicitly acked!\n\t\t\t\t\tif ( nPktNumAckEnd <= m_senderState.m_nMinPktWaitingOnAck )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tnPktNumAckBegin = m_senderState.m_nMinPktWaitingOnAck;\n\t\t\t\t\tnPktNumNackBegin = nPktNumAckBegin;\n\t\t\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld ack last block ack begin %lld\\n\",\n\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t(long long)nPktNum, (long long)nPktNumAckBegin );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuint8 nBlockHeader;\n\t\t\t\t\tREAD_8BITU( nBlockHeader, \"ack block header\" );\n\n\t\t\t\t\t// Ack count?\n\t\t\t\t\tint64 numAcks = ( nBlockHeader>> 4 ) & 7;\n\t\t\t\t\tif ( nBlockHeader & 0x80 )\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 nUpperBits;\n\t\t\t\t\t\tREAD_VARINT( nUpperBits, \"ack count upper bits\" );\n\t\t\t\t\t\tif ( nUpperBits > 100000 )\n\t\t\t\t\t\t\tDECODE_ERROR( \"Ack count of %llu<<3 is crazy\", (unsigned long long)nUpperBits );\n\t\t\t\t\t\tnumAcks |= nUpperBits<<3;\n\t\t\t\t\t}\n\t\t\t\t\tnPktNumAckBegin = nPktNumAckEnd - numAcks;\n\t\t\t\t\tif ( nPktNumAckBegin < 0 )\n\t\t\t\t\t\tDECODE_ERROR( \"Ack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckEnd, (long long)numAcks );\n\n\t\t\t\t\t// Extended nack count?\n\t\t\t\t\tint64 numNacks = nBlockHeader & 7;\n\t\t\t\t\tif ( nBlockHeader & 0x08)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 nUpperBits;\n\t\t\t\t\t\tREAD_VARINT( nUpperBits, \"nack count upper bits\" );\n\t\t\t\t\t\tif ( nUpperBits > 100000 )\n\t\t\t\t\t\t\tDECODE_ERROR( \"Nack count of %llu<<3 is crazy\", nUpperBits );\n\t\t\t\t\t\tnumNacks |= nUpperBits<<3;\n\t\t\t\t\t}\n\t\t\t\t\tnPktNumNackBegin = nPktNumAckBegin - numNacks;\n\t\t\t\t\tif ( nPktNumNackBegin < 0 )\n\t\t\t\t\t\tDECODE_ERROR( \"Nack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckBegin, (long long)numAcks );\n\n\t\t\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld nack [%lld,%lld) ack [%lld,%lld)\\n\",\n\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t(long long)nPktNum,\n\t\t\t\t\t\t(long long)nPktNumNackBegin, (long long)( nPktNumNackBegin + numNacks ),\n\t\t\t\t\t\t(long long)nPktNumAckBegin, (long long)( nPktNumAckBegin + numAcks )\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Process acks first.\n\t\t\t\tAssert( nPktNumAckBegin >= 0 );\n\t\t\t\twhile ( inFlightPkt->first >= nPktNumAckBegin )\n\t\t\t\t{\n\t\t\t\t\tAssert( inFlightPkt->first < nPktNumAckEnd );\n\n\t\t\t\t\t// Scan reliable segments, and see if any are marked for retry or are in flight\n\t\t\t\t\tfor ( const SNPRange_t &relRange: inFlightPkt->second.m_vecReliableSegments )\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// If range is present, it should be in only one of these two tables.\n\t\t\t\t\t\tif ( m_senderState.m_listInFlightReliableRange.erase( relRange ) == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( m_senderState.m_listReadyRetryReliableRange.erase( relRange ) > 0 )\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t// When we put stuff into the reliable retry list, we mark it as pending again.\n\t\t\t\t\t\t\t\t// But now it's acked, so it's no longer pending, even though we didn't send it.\n\t\t\t\t\t\t\t\tm_senderState.m_cbPendingReliable -= int( relRange.length() );\n\t\t\t\t\t\t\t\tAssert( m_senderState.m_cbPendingReliable >= 0 );\n\n\t\t\t\t\t\t\t\tbAckedReliableRange = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbAckedReliableRange = true;\n\t\t\t\t\t\t\tAssert( m_senderState.m_listReadyRetryReliableRange.count( relRange ) == 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if this was the next packet we were going to timeout, then advance\n\t\t\t\t\t// pointer.  This guy didn't timeout.\n\t\t\t\t\tif ( inFlightPkt == m_senderState.m_itNextInFlightPacketToTimeout )\n\t\t\t\t\t\t++m_senderState.m_itNextInFlightPacketToTimeout;\n\n\t\t\t\t\t// No need to track this anymore, remove from our table\n\t\t\t\t\tinFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.erase( inFlightPkt );\n\t\t\t\t\t--inFlightPkt;\n\t\t\t\t\tm_senderState.MaybeCheckInFlightPacketMap();\n\t\t\t\t}\n\n\t\t\t\t// Ack of in-flight end-to-end stats?\n\t\t\t\tif ( nPktNumAckBegin <= m_statsEndToEnd.m_pktNumInFlight && m_statsEndToEnd.m_pktNumInFlight < nPktNumAckEnd )\n\t\t\t\t\tm_statsEndToEnd.InFlightPktAck( usecNow );\n\n\t\t\t\t// Process nacks.\n\t\t\t\tAssert( nPktNumNackBegin >= 0 );\n\t\t\t\twhile ( inFlightPkt->first >= nPktNumNackBegin )\n\t\t\t\t{\n\t\t\t\t\tAssert( inFlightPkt->first < nPktNumAckEnd );\n\t\t\t\t\tSNP_SenderProcessPacketNack( inFlightPkt->first, inFlightPkt->second, \"NACK\" );\n\n\t\t\t\t\t// We'll keep the record on hand, though, in case an ACK comes in\n\t\t\t\t\t--inFlightPkt;\n\t\t\t\t}\n\n\t\t\t\t// Continue on to the the next older block\n\t\t\t\tnPktNumAckEnd = nPktNumNackBegin;\n\t\t\t\t--nBlocks;\n\t\t\t}\n\n\t\t\t// Should we check for discarding reliable messages we are keeping around in case\n\t\t\t// of retransmission, since we know now that they were delivered?\n\t\t\tif ( bAckedReliableRange )\n\t\t\t{\n\t\t\t\tm_senderState.RemoveAckedReliableMessageFromUnackedList();\n\n\t\t\t\t// Spew where we think the peer is decoding the reliable stream\n\t\t\t\tif ( nLogLevelPacketDecode >= k_ESteamNetworkingSocketsDebugOutputType_Debug )\n\t\t\t\t{\n\n\t\t\t\t\tint64 nPeerReliablePos = m_senderState.m_nReliableStreamPos;\n\t\t\t\t\tif ( !m_senderState.m_listInFlightReliableRange.empty() )\n\t\t\t\t\t\tnPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listInFlightReliableRange.begin()->first.m_nBegin );\n\t\t\t\t\tif ( !m_senderState.m_listReadyRetryReliableRange.empty() )\n\t\t\t\t\t\tnPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listReadyRetryReliableRange.begin()->first.m_nBegin );\n\n\t\t\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld peer reliable pos = %lld\\n\",\n\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t(long long)nPktNum, (long long)nPeerReliablePos );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if any of this was new info, then advance our stop_waiting value.\n\t\t\tif ( nLatestRecvSeqNum > m_senderState.m_nMinPktWaitingOnAck )\n\t\t\t{\n\t\t\t\tSpewVerboseGroup( nLogLevelPacketDecode, \"[%s]   updating min_waiting_on_ack %lld -> %lld\\n\",\n\t\t\t\t\tGetDescription(),\n\t\t\t\t\t(long long)m_senderState.m_nMinPktWaitingOnAck, (long long)nLatestRecvSeqNum );\n\t\t\t\tm_senderState.m_nMinPktWaitingOnAck = nLatestRecvSeqNum;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDECODE_ERROR( \"Invalid SNP frame lead byte 0x%02x\", nFrameType );\n\t\t}\n\t}\n\n\t// Should we record that we received it?\n\tif ( bInhibitMarkReceived )\n\t{\n\t\t// Something really odd.  High packet loss / fragmentation.\n\t\t// Potentially the peer is being abusive and we need\n\t\t// to protect ourselves.\n\t\t//\n\t\t// Act as if the packet was dropped.  This will cause the\n\t\t// peer's sender logic to interpret this as additional packet\n\t\t// loss and back off.  That's a feature, not a bug.\n\t}\n\telse\n\t{\n\n\t\t// Update structures needed to populate our ACKs.\n\t\t// If we received reliable data now, then schedule an ack\n\t\tbool bScheduleAck = nDecodeReliablePos > 0;\n\t\tSNP_RecordReceivedPktNum( nPktNum, usecNow, bScheduleAck );\n\t}\n\n\t// Track end-to-end flow.  Even if we decided to tell our peer that\n\t// we did not receive this, we want our own stats to reflect\n\t// that we did.  (And we want to be able to quickly reject a\n\t// packet with this same number.)\n\t//\n\t// Also, note that order of operations is important.  This call must\n\t// happen after the SNP_RecordReceivedPktNum call above\n\tm_statsEndToEnd.TrackProcessSequencedPacket( nPktNum, usecNow, usecTimeSinceLast );\n\n\t// Packet can be processed further\n\treturn true;\n\n\t// Make sure these don't get used beyond where we intended them to get used\n\t#undef DECODE_ERROR\n\t#undef EXPECT_BYTES\n\t#undef READ_8BITU\n\t#undef READ_16BITU\n\t#undef READ_24BITU\n\t#undef READ_32BITU\n\t#undef READ_64BITU\n\t#undef READ_VARINT\n\t#undef READ_SEGMENT_DATA_SIZE\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-6017"
    },
    {
        "index": 45,
        "code": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (bin->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (bin->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (bin->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (bin->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n\tsdb_set (bin->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);\n\tbin->ehdr.e_machine = READ16 (ehdr, i);\n\tbin->ehdr.e_version = READ32 (ehdr, i);\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i);\n\tbin->ehdr.e_phoff = READ64 (ehdr, i);\n\tbin->ehdr.e_shoff = READ64 (ehdr, i);\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i);\n\tbin->ehdr.e_phoff = READ32 (ehdr, i);\n\tbin->ehdr.e_shoff = READ32 (ehdr, i);\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i);\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_shnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i);\n\treturn true;\n\t// [Outdated] Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 46,
        "code": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2581"
    },
    {
        "index": 47,
        "code": "static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\n\tif (status)\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0204"
    },
    {
        "index": 48,
        "code": "static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0712"
    },
    {
        "index": 49,
        "code": "static int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle + 4 < to) {\n\t\t\tut32 n1 = r_read_le32 (buf + needle - from);\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1899"
    },
    {
        "index": 50,
        "code": "GF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber)\n{\n\tGF_StshEntry *ent;\n\tu32 i, count;\n\tcount = gf_list_count(stsh->entries);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StshEntry*)gf_list_get(stsh->entries, i);\n\t\tif (ent->shadowedSampleNumber == shadowNumber) {\n\t\t\tent->syncSampleNumber = sampleNumber;\n\t\t\treturn GF_OK;\n\t\t} else if (ent->shadowedSampleNumber > shadowNumber) break;\n\t}\n\tent = (GF_StshEntry*)gf_malloc(sizeof(GF_StshEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\tent->shadowedSampleNumber = shadowNumber;\n\tent->syncSampleNumber = sampleNumber;\n\tif (i == gf_list_count(stsh->entries)) {\n\t\treturn gf_list_add(stsh->entries, ent);\n\t} else {\n\t\treturn gf_list_insert(stsh->entries, ent, i ? i-1 : 0);\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 51,
        "code": "static void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %zu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase ROOTLESS_EUID_ATTR:\n\t\t\tconfig->is_rootless_euid = readint8(current);\t/* boolean */\n\t\t\tbreak;\n\t\tcase OOM_SCORE_ADJ_ATTR:\n\t\t\tconfig->oom_score_adj = current;\n\t\t\tconfig->oom_score_adj_len = payload_len;\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:\n\t\t\tconfig->namespaces = current;\n\t\t\tconfig->namespaces_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAPPATH_ATTR:\n\t\t\tconfig->uidmappath = current;\n\t\t\tconfig->uidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAPPATH_ATTR:\n\t\t\tconfig->gidmappath = current;\n\t\t\tconfig->gidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-43784"
    },
    {
        "index": 52,
        "code": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >= 32) {\n\t\treturn -1;\n\t}\n\tif (sps_id < 0) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 53,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t/* 'number' takes 13 bit */\n\tsli[i].number = ((p[1] & 0x07) << 10) +\n\t\t\t(p[2] << 2) +\n\t\t\t((p[3] & 0xC0) >> 6);\n\t/* 'pict_id' takes 6 bit */\n\tsli[i].pict_id = (p[3] & 0x3F);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 54,
        "code": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24793"
    },
    {
        "index": 55,
        "code": "static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = Jsi_ObjGetLength(interp, obj) - 1;\n\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    \n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 56,
        "code": "static int ScaKwdTab(GmfMshSct *msh)\n{\n   int      KwdCod, c;\n   int64_t  NexPos, EndPos, LstPos;\n   char     str[ GmfStrSiz ];\n\n   if(msh->typ & Asc)\n   {\n      // Scan each string in the file until the end\n      while(fscanf(msh->hdl, \"%s\", str) != EOF)\n      {\n         // Fast test in order to reject quickly the numeric values\n         if(isalpha(str[0]))\n         {\n            // Search which kwd code this string is associated with, then get its\n            // header and save the curent position in file (just before the data)\n            for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)\n               if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))\n               {\n                  ScaKwdHdr(msh, KwdCod);\n                  break;\n               }\n         }\n         else if(str[0] == '#')\n            while((c = fgetc(msh->hdl)) != '\\n' && c != EOF);\n      }\n   }\n   else\n   {\n      // Get file size\n      EndPos = GetFilSiz(msh);\n      LstPos = -1;\n\n      // Jump through kwd positions in the file\n      do\n      {\n         // Get the kwd code and the next kwd position\n         ScaWrd(msh, ( char *)&KwdCod);\n         NexPos = GetPos(msh);\n\n         // Make sure the flow does not move beyond the file size\n         if(NexPos > EndPos)\n            longjmp(msh->err, -24);\n\n         // And check that it does not move back\n         if(NexPos && (NexPos <= LstPos))\n            longjmp(msh->err, -30);\n\n         LstPos = NexPos;\n\n         // Check if this kwd belongs to this mesh version\n         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )\n            ScaKwdHdr(msh, KwdCod);\n\n         // Go to the next kwd\n         if(NexPos && !(SetFilPos(msh, NexPos)))\n            longjmp(msh->err, -25);\n\n      }while(NexPos && (KwdCod != GmfEnd));\n   }\n\n   return(1);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-46225"
    },
    {
        "index": 57,
        "code": "PJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;\n\tunsigned len;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end)\n\t    break;\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    /* Ignore unknown RTCP */\n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21722"
    },
    {
        "index": 58,
        "code": "testHuf (const std::string&)\n{\n    try\n    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n\tconst int N = 1000000;\n\tArray <unsigned short> raw (N);\n\n\tfill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill2 (raw, N, 1, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill3 (raw, N, 0);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX - 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, USHRT_MAX + 1);\n        compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\tcompressUncompress (raw, USHRT_MAX + 1);\n\tcompressUncompressSubset (raw, USHRT_MAX + 1);\n\tfill4 (raw, N);\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, 0);\n\tcompressUncompress (raw, 0);\t// test small input data sets\n\tfill4 (raw, 1);\n\tcompressUncompress (raw, 1);\n\tfill4 (raw, 2);\n\tcompressUncompress (raw, 2);\n\tfill4 (raw, 3);\n\tcompressUncompress (raw, 3);\n\n\tfill5 (raw, N);\t\t\t// test run-length coding of code table\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {\n\tcerr << \"ERROR -- caught exception: \" << e.what() << endl;\n\tassert (false);\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-20304"
    },
    {
        "index": 59,
        "code": "\n *\n\n */\n\n#include <stdlib.h>\n\n\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\n\n * all the API functions to use the MPU wrappers.  That should only be done when\n\n * task.h is included from an application file. */\n\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n\n\n#include \"FreeRTOS.h\"\n\n#include \"task.h\"\n\n\n\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n\n\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\n\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\n\n#endif\n\n\n\n/* Block sizes must not get too small. */\n\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize << 1 ) )\n\n\n\n/* Assumes 8bit bytes! */\n\n#define heapBITS_PER_BYTE         ( ( size_t ) 8 )\n\n\n\n/* Define the linked list structure.  This is used to link free blocks in order\n\n * of their memory address. */\n\ntypedef struct A_BLOCK_LINK\n\n{\n\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\n\n    size_t xBlockSize;                     /*<< The size of the free block. */\n\n} BlockLink_t;\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\n/*\n\n * Inserts a block of memory that is being freed into the correct position in\n\n * the list of free memory blocks.  The block being freed will be merged with\n\n * the block in front it and/or the block behind it if the memory blocks are\n\n * adjacent to each other.\n\n */\n\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert );\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\n/* The size of the structure placed at the beginning of each allocated memory\n\n * block must by correctly byte aligned. */\n\nstatic const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\n\n\n\n/* Create a couple of list links to mark the start and end of the list. */\n\nstatic BlockLink_t xStart, * pxEnd = NULL;\n\n\n\n/* Keeps track of the number of calls to allocate and free memory as well as the\n\n * number of free bytes remaining, but says nothing about fragmentation. */\n\nstatic size_t xFreeBytesRemaining = 0U;\n\nstatic size_t xMinimumEverFreeBytesRemaining = 0U;\n\nstatic size_t xNumberOfSuccessfulAllocations = 0;\n\nstatic size_t xNumberOfSuccessfulFrees = 0;\n\n\n\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\n\n * member of an BlockLink_t structure is set then the block belongs to the\n\n * application.  When the bit is free the block is still part of the free heap\n\n * space. */\n\nstatic size_t xBlockAllocatedBit = 0;\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\nvoid * pvPortMalloc( size_t xWantedSize )\n\n{\n\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n\n    void * pvReturn = NULL;\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32020"
    },
    {
        "index": 60,
        "code": "\n\n/* Allocate the memory for the heap. */\n\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\n\n\n\n/* The application writer has already defined the array used for the RTOS\n\n* heap - probably so it can be placed in a special segment or address. */\n\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\n\n#else\n\n    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\n\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\n\n\n\n\n\n/* Define the linked list structure.  This is used to link free blocks in order\n\n * of their size. */\n\ntypedef struct A_BLOCK_LINK\n\n{\n\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\n\n    size_t xBlockSize;                     /*<< The size of the free block. */\n\n} BlockLink_t;\n\n\n\n\n\nstatic const uint16_t heapSTRUCT_SIZE = ( ( sizeof( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );\n\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )\n\n\n\n/* Create a couple of list links to mark the start and end of the list. */\n\nstatic BlockLink_t xStart, xEnd;\n\n\n\n/* Keeps track of the number of free bytes remaining, but says nothing about\n\n * fragmentation. */\n\nstatic size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;\n\n\n\n/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */\n\n\n\n/*\n\n * Insert a block into the list of free blocks - which is ordered by size of\n\n * the block.  Small blocks at the start of the list and large blocks at the end\n\n * of the list.\n\n */\n\n#define prvInsertBlockIntoFreeList( pxBlockToInsert )                                                                               \\\n\n    {                                                                                                                               \\\n\n        BlockLink_t * pxIterator;                                                                                                   \\\n\n        size_t xBlockSize;                                                                                                          \\\n\n                                                                                                                                    \\\n\n        xBlockSize = pxBlockToInsert->xBlockSize;                                                                                   \\\n\n                                                                                                                                    \\\n\n        /* Iterate through the list until a block is found that has a larger size */                                                \\\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32020"
    },
    {
        "index": 62,
        "code": "bool createBLSShare(const string &blsKeyName, const char *s_shares, const char *encryptedKeyHex) {\n\n    CHECK_STATE(s_shares);\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg(BUF_LEN,0);\n    int errStatus = 0;\n\n    uint64_t decKeyLen;\n    SAFE_UINT8_BUF(encr_bls_key,BUF_LEN);\n    SAFE_UINT8_BUF(encr_key,BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encr_key, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    uint32_t enc_bls_len = 0;\n\n    sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,\n                                                 &enc_bls_len);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(hexBLSKey,2 * BUF_LEN)\n\n    carray2Hex(encr_bls_key, enc_bls_len, hexBLSKey, 2 * BUF_LEN);\n\n    SGXWalletServer::writeDataToDB(blsKeyName, hexBLSKey);\n\n    return true;\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 63,
        "code": "R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);\n\tif (!element_value) {\n\t\treturn NULL;\n\t}\n\tRBinJavaElementValuePair *evps = NULL;\n\telement_value->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!element_value->metas) {\n\t\tR_FREE (element_value);\n\t\treturn NULL;\n\t}\n\telement_value->file_offset = buf_offset;\n\telement_value->tag = buffer[offset];\n\telement_value->size += 1;\n\toffset += 1;\n\telement_value->metas->type_info = (void *) r_bin_java_get_ev_meta_from_tag (element_value->tag);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// look up value in bin->cp_list\n\t\t// (ut16) read and set const_value.const_value_idx\n\t\telement_value->value.const_value.const_value_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\t// look-up, deep copy, and set const_value.const_value_cp_obj\n\t\telement_value->value.const_value.const_value_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.const_value.const_value_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// (ut16) read and set enum_const_value.type_name_idx\n\t\telement_value->value.enum_const_value.type_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// (ut16) read and set enum_const_value.const_name_idx\n\t\telement_value->value.enum_const_value.const_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set enum_const_value.const_name_cp_obj\n\t\telement_value->value.enum_const_value.const_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.const_name_idx);\n\t\t// look-up, deep copy, and set enum_const_value.type_name_cp_obj\n\t\telement_value->value.enum_const_value.type_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.type_name_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// (ut16) read and set class_value.class_info_idx\n\t\telement_value->value.class_value.class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set class_value.class_info_cp_obj\n\t\telement_value->value.class_value.class_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.class_value.class_info_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// (ut16) read and set array_value.num_values\n\t\telement_value->value.array_value.num_values = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\telement_value->value.array_value.values = r_list_new ();\n\t\tfor (i = 0; i < element_value->value.array_value.num_values; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaElementValue *ev_element = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (ev_element) {\n\t\t\t\telement_value->size += ev_element->size;\n\t\t\t\toffset += ev_element->size;\n\t\t\t\t// read array_value.num_values, and append to array_value.values\n\t\t\t\tr_list_append (element_value->value.array_value.values, (void *) ev_element);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// annotation new is not used here.\n\t\t// (ut16) read and set annotation_value.type_idx;\n\t\tif (offset + 8 < sz) {\n\t\t\telement_value->value.annotation_value.type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\telement_value->size += 2;\n\t\t\toffset += 2;\n\t\t\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\t\t\telement_value->value.annotation_value.num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\telement_value->size += 2;\n\t\t\toffset += 2;\n\t\t}\n\t\telement_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\t// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs\n\t\tfor (i = 0; i < element_value->value.annotation_value.num_element_value_pairs; i++) {\n\t\t\tif (offset > sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (evps) {\n\t\t\t\telement_value->size += evps->size;\n\t\t\t\toffset += evps->size;\n\t\t\t}\n\t\t\tif (evps == NULL) {\n\t\t\t\t// TODO: eprintf error when reading element pair\n\t\t\t}\n\t\t\tr_list_append (element_value->value.annotation_value.element_value_pairs, (void *) evps);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n\treturn element_value;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 64,
        "code": "size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    /* FIXME: this function could be replaced by mobi_find_attrvalue()? */\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    /* FIXME: search may start inside tag, so it is a safer option */\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            /* found match */\n            size_t offset = size - length;\n            if (last_border == '>') {\n                /* We are in tag contents */\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            /* previous character should be white space or opening tag */\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            /* now go forward */\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            /* return offset to the beginning of the attribute value string */\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1908"
    },
    {
        "index": 65,
        "code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\t/*\n\t * The id is already defined in this DTD.\n\t */\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23308"
    },
    {
        "index": 66,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned bitlen, padlen, len;\n\n    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);\n\n    bitlen = (unsigned)rpsi->rpsi_bit_len + 16;\n    padlen = (32 - (bitlen % 32)) % 32;\n    len = (3 + (bitlen+padlen)/32) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB RPSI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 3; /* FMT = 3 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB RPSI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    /* PB (number of padding bits) */\n    *p++ = (pj_uint8_t)padlen;\n    /* Payload type */\n    *p++ = rpsi->pt & 0x7F;\n    /* RPSI bit string */\n    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);\n    p += rpsi->rpsi_bit_len/8;\n    if (rpsi->rpsi_bit_len % 8) {\n\t*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);\n    }\n    /* Zero padding */\n    if (padlen >= 8)\n\tpj_bzero(p, padlen/8);\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 67,
        "code": "static Jsi_RC jsi_ArrayMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, nsiz, i, maa = 0;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis;\n    Jsi_Func *fptr = NULL;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrCnt;\n    if (nsiz<=0) nsiz = 1;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        Jsi_LogError(\"index too large: %d\", nsiz);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_Value *vobjs[3];\n\n    fptr = func->d.obj->d.fobj->func;\n    maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < curlen; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        nobj->arr[i] = Jsi_ValueNew1(interp);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, nobj->arr+i, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if( JSI_OK!=rc ) {\n            goto bail;\n        }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 69,
        "code": "op_insert(oparg_T *oap, long count1)\n{\n    long\t\tins_len, pre_textlen = 0;\n    char_u\t\t*firstline, *ins_text;\n    colnr_T\t\tind_pre_col = 0, ind_post_col;\n    int\t\t\tind_pre_vcol = 0, ind_post_vcol = 0;\n    struct block_def\tbd;\n    int\t\t\ti;\n    pos_T\t\tt1;\n    pos_T\t\tstart_insert;\n\t\t\t// offset when cursor was moved in insert mode\n    int\t\t\toffset = 0;\n\n    // edit() changes this - record it for OP_APPEND\n    bd.is_MAX = (curwin->w_curswant == MAXCOL);\n\n    // vis block is still marked. Get rid of it now.\n    curwin->w_cursor.lnum = oap->start.lnum;\n    update_screen(INVERTED);\n\n    if (oap->block_mode)\n    {\n\t// When 'virtualedit' is used, need to insert the extra spaces before\n\t// doing block_prep().  When only \"block\" is used, virtual edit is\n\t// already disabled, but still need it when calling\n\t// coladvance_force().\n\t// coladvance_force() uses get_ve_flags() to get the 'virtualedit'\n\t// state for the current window.  To override that state, we need to\n\t// set the window-local value of ve_flags rather than the global value.\n\tif (curwin->w_cursor.coladd > 0)\n\t{\n\t    int\t\told_ve_flags = curwin->w_ve_flags;\n\n\t    if (u_save_cursor() == FAIL)\n\t\treturn;\n\n\t    curwin->w_ve_flags = VE_ALL;\n\t    coladvance_force(oap->op_type == OP_APPEND\n\t\t\t\t\t   ? oap->end_vcol + 1 : getviscol());\n\t    if (oap->op_type == OP_APPEND)\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_ve_flags = old_ve_flags;\n\t}\n\t// Get the info about the block before entering the text\n\tblock_prep(oap, &bd, oap->start.lnum, TRUE);\n\t// Get indent information\n\tind_pre_col = (colnr_T)getwhitecols_curline();\n\tind_pre_vcol = get_indent();\n\tfirstline = ml_get(oap->start.lnum) + bd.textcol;\n\n\tif (oap->op_type == OP_APPEND)\n\t    firstline += bd.textlen;\n\tpre_textlen = (long)STRLEN(firstline);\n    }\n\n    if (oap->op_type == OP_APPEND)\n    {\n\tif (oap->block_mode && curwin->w_cursor.coladd == 0)\n\t{\n\t    // Move the cursor to the character right of the block.\n\t    curwin->w_set_curswant = TRUE;\n\t    while (*ml_get_cursor() != NUL\n\t\t    && (curwin->w_cursor.col < bd.textcol + bd.textlen))\n\t\t++curwin->w_cursor.col;\n\t    if (bd.is_short && !bd.is_MAX)\n\t    {\n\t\t// First line was too short, make it longer and adjust the\n\t\t// values in \"bd\".\n\t\tif (u_save_cursor() == FAIL)\n\t\t    return;\n\t\tfor (i = 0; i < bd.endspaces; ++i)\n\t\t    ins_char(' ');\n\t\tbd.textlen += bd.endspaces;\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = oap->end;\n\t    check_cursor_col();\n\n\t    // Works just like an 'i'nsert on the next character.\n\t    if (!LINEEMPTY(curwin->w_cursor.lnum)\n\t\t    && oap->start_vcol != oap->end_vcol)\n\t\tinc_cursor();\n\t}\n    }\n\n    t1 = oap->start;\n    start_insert = curwin->w_cursor;\n    (void)edit(NUL, FALSE, (linenr_T)count1);\n\n    // When a tab was inserted, and the characters in front of the tab\n    // have been converted to a tab as well, the column of the cursor\n    // might have actually been reduced, so need to adjust here.\n    if (t1.lnum == curbuf->b_op_start_orig.lnum\n\t    && LT_POS(curbuf->b_op_start_orig, t1))\n\toap->start = curbuf->b_op_start_orig;\n\n    // If user has moved off this line, we don't know what to do, so do\n    // nothing.\n    // Also don't repeat the insert when Insert mode ended with CTRL-C.\n    if (curwin->w_cursor.lnum != oap->start.lnum || got_int)\n\treturn;\n\n    if (oap->block_mode)\n    {\n\tstruct block_def\tbd2;\n\tint\t\t\tdid_indent = FALSE;\n\tsize_t\t\t\tlen;\n\tint\t\t\tadd;\n\n\t// If indent kicked in, the firstline might have changed\n\t// but only do that, if the indent actually increased.\n\tind_post_col = (colnr_T)getwhitecols_curline();\n\tif (curbuf->b_op_start.col > ind_pre_col && ind_post_col > ind_pre_col)\n\t{\n\t    bd.textcol += ind_post_col - ind_pre_col;\n\t    ind_post_vcol = get_indent();\n\t    bd.start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    did_indent = TRUE;\n\t}\n\n\t// The user may have moved the cursor before inserting something, try\n\t// to adjust the block for that.  But only do it, if the difference\n\t// does not come from indent kicking in.\n\tif (oap->start.lnum == curbuf->b_op_start_orig.lnum\n\t\t\t\t\t\t  && !bd.is_MAX && !did_indent)\n\t{\n\t    int t = getviscol2(curbuf->b_op_start_orig.col,\n\t\t\t\t\t       curbuf->b_op_start_orig.coladd);\n\n\t    if (!bd.is_MAX)\n\t    {\n\t\tif (oap->op_type == OP_INSERT\n\t\t\t&& oap->start.col + oap->start.coladd\n\t\t\t\t!= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t\t{\n\t\t    oap->start.col = curbuf->b_op_start_orig.col;\n\t\t    pre_textlen -= t - oap->start_vcol;\n\t\t    oap->start_vcol = t;\n\t\t}\n\t\telse if (oap->op_type == OP_APPEND\n\t\t\t&& oap->end.col + oap->end.coladd\n\t\t\t\t>= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t\t{\n\t\t    oap->start.col = curbuf->b_op_start_orig.col;\n\t\t    // reset pre_textlen to the value of OP_INSERT\n\t\t    pre_textlen += bd.textlen;\n\t\t    pre_textlen -= t - oap->start_vcol;\n\t\t    oap->start_vcol = t;\n\t\t    oap->op_type = OP_INSERT;\n\t\t}\n\t    }\n\t    else if (bd.is_MAX && oap->op_type == OP_APPEND)\n\t    {\n\t\t// reset pre_textlen to the value of OP_INSERT\n\t\tpre_textlen += bd.textlen;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t    }\n\t}\n\n\t// Spaces and tabs in the indent may have changed to other spaces and\n\t// tabs.  Get the starting column again and correct the length.\n\t// Don't do this when \"$\" used, end-of-line will have changed.\n\t//\n\t// if indent was added and the inserted text was after the indent,\n\t// correct the selection for the new indent.\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    oap->start.col += ind_post_col - ind_pre_col;\n\t    oap->start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col += ind_post_col - ind_pre_col;\n\t    oap->end_vcol += ind_post_vcol - ind_pre_vcol;\n\t}\n\tblock_prep(oap, &bd2, oap->start.lnum, TRUE);\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    // undo for where \"oap\" is used below\n\t    oap->start.col -= ind_post_col - ind_pre_col;\n\t    oap->start_vcol -= ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col -= ind_post_col - ind_pre_col;\n\t    oap->end_vcol -= ind_post_vcol - ind_pre_vcol;\n\t}\n\tif (!bd.is_MAX || bd2.textlen < bd.textlen)\n\t{\n\t    if (oap->op_type == OP_APPEND)\n\t    {\n\t\tpre_textlen += bd2.textlen - bd.textlen;\n\t\tif (bd2.endspaces)\n\t\t    --bd2.textlen;\n\t    }\n\t    bd.textcol = bd2.textcol;\n\t    bd.textlen = bd2.textlen;\n\t}\n\n\t/*\n\t * Subsequent calls to ml_get() flush the firstline data - take a\n\t * copy of the required string.\n\t */\n\tfirstline = ml_get(oap->start.lnum);\n\tlen = STRLEN(firstline);\n\tadd = bd.textcol;\n\tif (oap->op_type == OP_APPEND)\n\t{\n\t    add += bd.textlen;\n\t    // account for pressing cursor in insert mode when '$' was used\n\t    if (bd.is_MAX\n\t\t&& (start_insert.lnum == Insstart.lnum\n\t\t\t\t\t   && start_insert.col > Insstart.col))\n\t    {\n\t\toffset = (start_insert.col - Insstart.col);\n\t\tadd -= offset;\n\t\tif (oap->end_vcol > offset)\n\t\t    oap->end_vcol -= (offset + 1);\n\t\telse\n\t\t    // moved outside of the visual block, what to do?\n\t\t    return;\n\t    }\n\t}\n\tif ((size_t)add > len)\n\t    firstline += len;  // short line, point to the NUL\n\telse\n\t    firstline += add;\n\tif (pre_textlen >= 0 && (ins_len =\n\t\t\t   (long)STRLEN(firstline) - pre_textlen - offset) > 0)\n\t{\n\t    ins_text = vim_strnsave(firstline, ins_len);\n\t    if (ins_text != NULL)\n\t    {\n\t\t// block handled here\n\t\tif (u_save(oap->start.lnum,\n\t\t\t\t\t (linenr_T)(oap->end.lnum + 1)) == OK)\n\t\t    block_insert(oap, ins_text, (oap->op_type == OP_INSERT),\n\t\t\t\t\t\t\t\t\t &bd);\n\n\t\tcurwin->w_cursor.col = oap->start.col;\n\t\tcheck_cursor();\n\t\tvim_free(ins_text);\n\t    }\n\t}\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0261"
    },
    {
        "index": 70,
        "code": "void print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32136"
    },
    {
        "index": 71,
        "code": "main(argc, argv)\nint argc;\nchar *argv[];\n{\n    register int fd;\n#ifdef CHDIR\n    register char *dir;\n#endif\n    boolean exact_username;\n    boolean resuming = FALSE; /* assume new game */\n    boolean plsel_once = FALSE;\n\n    sys_early_init();\n\n#if defined(__APPLE__)\n    {\n/* special hack to change working directory to a resource fork when\n   running from finder --sam */\n#define MAC_PATH_VALUE \".app/Contents/MacOS/\"\n        char mac_cwd[1024], *mac_exe = argv[0], *mac_tmp;\n        int arg0_len = strlen(mac_exe), mac_tmp_len, mac_lhs_len = 0;\n        getcwd(mac_cwd, 1024);\n        if (mac_exe[0] == '/' && !strcmp(mac_cwd, \"/\")) {\n            if ((mac_exe = strrchr(mac_exe, '/')))\n                mac_exe++;\n            else\n                mac_exe = argv[0];\n            mac_tmp_len = (strlen(mac_exe) * 2) + strlen(MAC_PATH_VALUE);\n            if (mac_tmp_len <= arg0_len) {\n                mac_tmp = malloc(mac_tmp_len + 1);\n                sprintf(mac_tmp, \"%s%s%s\", mac_exe, MAC_PATH_VALUE, mac_exe);\n                if (!strcmp(argv[0] + (arg0_len - mac_tmp_len), mac_tmp)) {\n                    mac_lhs_len =\n                        (arg0_len - mac_tmp_len) + strlen(mac_exe) + 5;\n                    if (mac_lhs_len > mac_tmp_len - 1)\n                        mac_tmp = realloc(mac_tmp, mac_lhs_len);\n                    strncpy(mac_tmp, argv[0], mac_lhs_len);\n                    mac_tmp[mac_lhs_len] = '\\0';\n                    chdir(mac_tmp);\n                }\n                free(mac_tmp);\n            }\n        }\n    }\n#endif\n\n    hname = argv[0];\n    hackpid = getpid();\n    (void) umask(0777 & ~FCMASK);\n\n    choose_windows(DEFAULT_WINDOW_SYS);\n\n#ifdef CHDIR /* otherwise no chdir() */\n    /*\n     * See if we must change directory to the playground.\n     * (Perhaps hack runs suid and playground is inaccessible\n     *  for the player.)\n     * The environment variable HACKDIR is overridden by a\n     *  -d command line option (must be the first option given).\n     */\n    dir = nh_getenv(\"NETHACKDIR\");\n    if (!dir)\n        dir = nh_getenv(\"HACKDIR\");\n\n    if (argc > 1) {\n        if (argcheck(argc, argv, ARG_VERSION) == 2)\n            exit(EXIT_SUCCESS);\n\n        if (argcheck(argc, argv, ARG_SHOWPATHS) == 2) {\n#ifdef CHDIR\n            chdirx((char *) 0, 0);\n#endif\n            iflags.initoptions_noterminate = TRUE;\n            initoptions();\n            iflags.initoptions_noterminate = FALSE;\n            reveal_paths();\n            exit(EXIT_SUCCESS);\n        }\n        if (argcheck(argc, argv, ARG_DEBUG) == 1) {\n            argc--;\n            argv++;\n        }\n        if (argc > 1 && !strncmp(argv[1], \"-d\", 2) && argv[1][2] != 'e') {\n            /* avoid matching \"-dec\" for DECgraphics; since the man page\n             * says -d directory, hope nobody's using -desomething_else\n             */\n            argc--;\n            argv++;\n            dir = argv[0] + 2;\n            if (*dir == '=' || *dir == ':')\n                dir++;\n            if (!*dir && argc > 1) {\n                argc--;\n                argv++;\n                dir = argv[0];\n            }\n            if (!*dir)\n                error(\"Flag -d must be followed by a directory name.\");\n        }\n    }\n#endif /* CHDIR */\n\n    if (argc > 1) {\n        /*\n         * Now we know the directory containing 'record' and\n         * may do a prscore().  Exclude `-style' - it's a Qt option.\n         */\n        if (!strncmp(argv[1], \"-s\", 2) && strncmp(argv[1], \"-style\", 6)) {\n#ifdef CHDIR\n            chdirx(dir, 0);\n#endif\n#ifdef SYSCF\n            initoptions();\n#endif\n#ifdef PANICTRACE\n            ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n            panictrace_setsignals(TRUE);\n#endif\n#endif\n            prscore(argc, argv);\n            /* FIXME: shouldn't this be using nh_terminate() to free\n               up any memory allocated by initoptions() */\n            exit(EXIT_SUCCESS);\n        }\n    } /* argc > 1 */\n\n/*\n * Change directories before we initialize the window system so\n * we can find the tile file.\n */\n#ifdef CHDIR\n    chdirx(dir, 1);\n#endif\n\n#ifdef _M_UNIX\n    check_sco_console();\n#endif\n#ifdef __linux__\n    check_linux_console();\n#endif\n    initoptions();\n#ifdef PANICTRACE\n    ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n    panictrace_setsignals(TRUE);\n#endif\n#endif\n    exact_username = whoami();\n\n    /*\n     * It seems you really want to play.\n     */\n    u.uhp = 1; /* prevent RIP on early quits */\n    program_state.preserve_locks = 1;\n#ifndef NO_SIGNAL\n    sethanguphandler((SIG_RET_TYPE) hangup);\n#endif\n\n    process_options(argc, argv); /* command line options */\n#ifdef WINCHAIN\n    commit_windowchain();\n#endif\n    init_nhwindows(&argc, argv); /* now we can set up window system */\n#ifdef _M_UNIX\n    init_sco_cons();\n#endif\n#ifdef __linux__\n    init_linux_cons();\n#endif\n\n#ifdef DEF_PAGER\n    if (!(catmore = nh_getenv(\"HACKPAGER\"))\n        && !(catmore = nh_getenv(\"PAGER\")))\n        catmore = DEF_PAGER;\n#endif\n#ifdef MAIL\n    getmailstatus();\n#endif\n\n    /* wizard mode access is deferred until here */\n    set_playmode(); /* sets plname to \"wizard\" for wizard mode */\n    if (exact_username) {\n        /*\n         * FIXME: this no longer works, ever since 3.3.0\n         * when plnamesuffix() was changed to find\n         * Name-Role-Race-Gender-Alignment.  It removes\n         * all dashes rather than just the last one,\n         * regardless of whether whatever follows each\n         * dash matches role, race, gender, or alignment.\n         */\n        /* guard against user names with hyphens in them */\n        int len = (int) strlen(plname);\n        /* append the current role, if any, so that last dash is ours */\n        if (++len < (int) sizeof plname)\n            (void) strncat(strcat(plname, \"-\"), pl_character,\n                           sizeof plname - len - 1);\n    }\n    /* strip role,race,&c suffix; calls askname() if plname[] is empty\n       or holds a generic user name like \"player\" or \"games\" */\n    plnamesuffix();\n\n    if (wizard) {\n        /* use character name rather than lock letter for file names */\n        locknum = 0;\n    } else {\n        /* suppress interrupts while processing lock file */\n        (void) signal(SIGQUIT, SIG_IGN);\n        (void) signal(SIGINT, SIG_IGN);\n    }\n\n    dlb_init(); /* must be before newgame() */\n\n    /*\n     * Initialize the vision system.  This must be before mklev() on a\n     * new game or before a level restore on a saved game.\n     */\n    vision_init();\n\n    display_gamewindows();\n\n    /*\n     * First, try to find and restore a save file for specified character.\n     * We'll return here if new game player_selection() renames the hero.\n     */\n attempt_restore:\n\n    /*\n     * getlock() complains and quits if there is already a game\n     * in progress for current character name (when locknum == 0)\n     * or if there are too many active games (when locknum > 0).\n     * When proceeding, it creates an empty <lockname>.0 file to\n     * designate the current game.\n     * getlock() constructs <lockname> based on the character\n     * name (for !locknum) or on first available of alock, block,\n     * clock, &c not currently in use in the playground directory\n     * (for locknum > 0).\n     */\n    if (*plname) {\n        getlock();\n        program_state.preserve_locks = 0; /* after getlock() */\n    }\n\n    if (*plname && (fd = restore_saved_game()) >= 0) {\n        const char *fq_save = fqname(SAVEF, SAVEPREFIX, 1);\n\n        (void) chmod(fq_save, 0); /* disallow parallel restores */\n#ifndef NO_SIGNAL\n        (void) signal(SIGINT, (SIG_RET_TYPE) done1);\n#endif\n#ifdef NEWS\n        if (iflags.news) {\n            display_file(NEWS, FALSE);\n            iflags.news = FALSE; /* in case dorecover() fails */\n        }\n#endif\n        pline(\"Restoring save file...\");\n        mark_synch(); /* flush output */\n        if (dorecover(fd)) {\n            resuming = TRUE; /* not starting new game */\n            wd_message();\n            if (discover || wizard) {\n                /* this seems like a candidate for paranoid_confirmation... */\n                if (yn(\"Do you want to keep the save file?\") == 'n') {\n                    (void) delete_savefile();\n                } else {\n                    (void) chmod(fq_save, FCMASK); /* back to readable */\n                    nh_compress(fq_save);\n                }\n            }\n        }\n    }\n\n    if (!resuming) {\n        boolean neednewlock = (!*plname);\n        /* new game:  start by choosing role, race, etc;\n           player might change the hero's name while doing that,\n           in which case we try to restore under the new name\n           and skip selection this time if that didn't succeed */\n        if (!iflags.renameinprogress || iflags.defer_plname || neednewlock) {\n            if (!plsel_once)\n                player_selection();\n            plsel_once = TRUE;\n            if (neednewlock && *plname)\n                goto attempt_restore;\n            if (iflags.renameinprogress) {\n                /* player has renamed the hero while selecting role;\n                   if locking alphabetically, the existing lock file\n                   can still be used; otherwise, discard current one\n                   and create another for the new character name */\n                if (!locknum) {\n                    delete_levelfile(0); /* remove empty lock file */\n                    getlock();\n                }\n                goto attempt_restore;\n            }\n        }\n        newgame();\n        wd_message();\n    }\n\n    /* moveloop() never returns but isn't flagged NORETURN */\n    moveloop(resuming);\n\n    exit(EXIT_SUCCESS);\n    /*NOTREACHED*/\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5209"
    },
    {
        "index": 72,
        "code": "uc_list(char_u *name, size_t name_len)\n{\n    int\t\ti, j;\n    int\t\tfound = FALSE;\n    ucmd_T\t*cmd;\n    int\t\tlen;\n    int\t\tover;\n    long\ta;\n    garray_T\t*gap;\n\n    // In cmdwin, the alternative buffer should be used.\n    gap =\n#ifdef FEAT_CMDWIN\n\t    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t    &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    a = (long)cmd->uc_argt;\n\n\t    // Skip commands which don't match the requested prefix and\n\t    // commands filtered out.\n\t    if (STRNCMP(name, cmd->uc_name, name_len) != 0\n\t\t    || message_filtered(cmd->uc_name))\n\t\tcontinue;\n\n\t    // Put out the title first time\n\t    if (!found)\n\t\tmsg_puts_title(_(\"\\n    Name              Args Address Complete    Definition\"));\n\t    found = TRUE;\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\n\t    // Special cases\n\t    len = 4;\n\t    if (a & EX_BANG)\n\t    {\n\t\tmsg_putchar('!');\n\t\t--len;\n\t    }\n\t    if (a & EX_REGSTR)\n\t    {\n\t\tmsg_putchar('\"');\n\t\t--len;\n\t    }\n\t    if (gap != &ucmds)\n\t    {\n\t\tmsg_putchar('b');\n\t\t--len;\n\t    }\n\t    if (a & EX_TRLBAR)\n\t    {\n\t\tmsg_putchar('|');\n\t\t--len;\n\t    }\n\t    while (len-- > 0)\n\t\tmsg_putchar(' ');\n\n\t    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n\t    len = (int)STRLEN(cmd->uc_name) + 4;\n\n\t    do {\n\t\tmsg_putchar(' ');\n\t\t++len;\n\t    } while (len < 22);\n\n\t    // \"over\" is how much longer the name is than the column width for\n\t    // the name, we'll try to align what comes after.\n\t    over = len - 22;\n\t    len = 0;\n\n\t    // Arguments\n\t    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))\n\t    {\n\t\tcase 0:\t\t\t\tIObuff[len++] = '0'; break;\n\t\tcase (EX_EXTRA):\t\tIObuff[len++] = '*'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC):\tIObuff[len++] = '?'; break;\n\t\tcase (EX_EXTRA|EX_NEEDARG):\tIObuff[len++] = '+'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 5 - over);\n\n\t    // Address / Range\n\t    if (a & (EX_RANGE|EX_COUNT))\n\t    {\n\t\tif (a & EX_COUNT)\n\t\t{\n\t\t    // -count=N\n\t\t    sprintf((char *)IObuff + len, \"%ldc\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse if (a & EX_DFLALL)\n\t\t    IObuff[len++] = '%';\n\t\telse if (cmd->uc_def >= 0)\n\t\t{\n\t\t    // -range=N\n\t\t    sprintf((char *)IObuff + len, \"%ld\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse\n\t\t    IObuff[len++] = '.';\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 8 - over);\n\n\t    // Address Type\n\t    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)\n\t\tif (addr_type_complete[j].expand != ADDR_LINES\n\t\t\t&& addr_type_complete[j].expand == cmd->uc_addr_type)\n\t\t{\n\t\t    STRCPY(IObuff + len, addr_type_complete[j].shortname);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 13 - over);\n\n\t    // Completion\n\t    for (j = 0; command_complete[j].expand != 0; ++j)\n\t\tif (command_complete[j].expand == cmd->uc_compl)\n\t\t{\n\t\t    STRCPY(IObuff + len, command_complete[j].name);\n\t\t    len += (int)STRLEN(IObuff + len);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0 && cmd->uc_compl_arg != NULL\n\t\t\t\t\t    && STRLEN(cmd->uc_compl_arg) < 200)\n\t\t    {\n\t\t\tIObuff[len] = ',';\n\t\t\tSTRCPY(IObuff + len + 1, cmd->uc_compl_arg);\n\t\t\tlen += (int)STRLEN(IObuff + len);\n\t\t    }\n#endif\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 25 - over);\n\n\t    IObuff[len] = '\\0';\n\t    msg_outtrans(IObuff);\n\n\t    msg_outtrans_special(cmd->uc_rep, FALSE,\n\t\t\t\t\t     name_len == 0 ? Columns - 47 : 0);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(cmd->uc_script_ctx);\n#endif\n\t    out_flush();\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || i < gap->ga_len)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (!found)\n\tmsg(_(\"No user-defined commands found\"));\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 73,
        "code": "int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.boolif = NULL;\n\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36087"
    },
    {
        "index": 75,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64 depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    const int64 batch_size = images.dim_size(0);\n    const int64 height = images.dim_size(1);\n    const int64 width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64 i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(4);\n          for (int64 j = 0; j < 4; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64 b = 0; b < batch_size; ++b) {\n      const int64 num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<T, 3>();\n      for (int64 bb = 0; bb < num_boxes; ++bb) {\n        int64 color_index = bb % color_table.size();\n        const int64 min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0});\n        const int64 max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64 max_box_row_clamp =\n            std::min<int64>(max_box_row, height - 1);\n        const int64 min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0});\n        const int64 max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29571"
    },
    {
        "index": 76,
        "code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23560"
    },
    {
        "index": 77,
        "code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n\n  // Pointer to input buffer\n  unsigned char *input = (unsigned char*) in.data;\n\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n\n  // Pointer to output buffer\n  unsigned char *output;\n\n  // Create new buffer if size is larger than input size\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n\n  // Calculate our scale\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n\n      // Indexes in the current pyramid resolution and resampled spaces\n      // Make sure to limit our input index to the image surface\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n\n  // Delete original buffer\n  if( new_buffer ) delete[] (unsigned char*) input;\n\n  // Correctly set our Rawtile info\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 78,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45938"
    },
    {
        "index": 79,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  int k = 0;\n  int embedding_size = 1;\n  int lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const int dim = dense_shape->data.i32[i];\n    lookup_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const int dim = SizeOfDimension(value, i);\n    embedding_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const int output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-29605"
    },
    {
        "index": 80,
        "code": "goto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 81,
        "code": "static int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tint i;\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t/* geometry */\n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t/* parameters coming from user space */\n\tconst void *outparam;\t/* parameters passed back to user space */\n\n\t/* convert compatibility eject ioctls into floppy eject ioctl.\n\t * We do this in order to provide a means to eject floppy disks before\n\t * installing the new fdutils package */\n\tif (cmd == CDROMEJECT ||\t/* CD-ROM eject */\n\t    cmd == 0x6470) {\t\t/* SunOS floppy eject */\n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t/* convert the old style command into a new style command */\n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* permission checks */\n\tif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t/* copyin */\n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\t/* somebody else has this drive open */\n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t/* do the actual eject. Fails on\n\t\t * non-Sparc architectures */\n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tdrive_state[drive].keep_data = 0;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tdrive_params[drive].flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tdrive_params[drive].flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = drive_state[drive].flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETEMSGTRESH:\n\t\tdrive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &drive_params[drive].max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tdrive_params[drive].max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\tif (!valid_floppy_drive_params(inparam.dp.autodetect,\n\t\t\t\tinparam.dp.native_format))\n\t\t\treturn -EINVAL;\n\t\tdrive_params[drive] = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = &drive_params[drive];\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\tfallthrough;\n\tcase FDGETDRVSTAT:\n\t\toutparam = &drive_state[drive];\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = &fdc_state[FDC(drive)];\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = &write_errors[drive];\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\tif (type)\n\t\t\treturn -EINVAL;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tset_floppy(drive);\n\t\ti = raw_cmd_ioctl(cmd, (void __user *)param);\n\t\tif (i == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\treturn i;\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle(current_fdc, current_drive);\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-33981"
    },
    {
        "index": 82,
        "code": "static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tgf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tgf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 83,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableAttribute *lvattr;\n\tut64 curpos = 0, offset = 6;\n\tRBinJavaAttrInfo *attr;\n\tut32 i = 0;\n\tif (!buffer || sz < 1) {\n\t\treturn NULL;\n\t}\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR;\n\tattr->info.local_variable_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_table_attr.local_variable_table =\\\n\t\tr_list_newf (r_bin_java_local_variable_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_table_attr.table_length; i++) {\n\t\tif (offset + 10 > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tcurpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableAttribute);\n\t\tif (!lvattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->descriptor_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->descriptor = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->descriptor_idx);\n\t\tif (!lvattr->descriptor) {\n\t\t\tlvattr->descriptor = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->descriptor_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_table_attr.local_variable_table, lvattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_local_variable_table_attr_summary(attr);\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 84,
        "code": "static void copy_recurse_data(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  int type, int stackptr, int stacktop, BOOL has_quit)\n{\ndelayed_mem_copy_status status;\nPCRE2_SPTR alternative;\nsljit_sw private_srcw[2];\nsljit_sw shared_srcw[3];\nsljit_sw kept_shared_srcw[2];\nint private_count, shared_count, kept_shared_count;\nint from_sp, base_reg, offset, i;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\nswitch (type)\n  {\n  case recurse_copy_from_global:\n  from_sp = TRUE;\n  base_reg = STACK_TOP;\n  break;\n\n  case recurse_copy_private_to_global:\n  case recurse_copy_shared_to_global:\n  case recurse_copy_kept_shared_to_global:\n  from_sp = FALSE;\n  base_reg = STACK_TOP;\n  break;\n\n  default:\n  SLJIT_ASSERT(type == recurse_swap_global);\n  from_sp = FALSE;\n  base_reg = TMP2;\n  break;\n  }\n\nstackptr = STACK(stackptr);\nstacktop = STACK(stacktop);\n\nstatus.tmp_regs[0] = TMP1;\nstatus.saved_tmp_regs[0] = TMP1;\n\nif (base_reg != TMP2)\n  {\n  status.tmp_regs[1] = TMP2;\n  status.saved_tmp_regs[1] = TMP2;\n  }\nelse\n  {\n  status.saved_tmp_regs[1] = RETURN_ADDR;\n  if (HAS_VIRTUAL_REGISTERS)\n    status.tmp_regs[1] = STR_PTR;\n  else\n    status.tmp_regs[1] = RETURN_ADDR;\n  }\n\nstatus.saved_tmp_regs[2] = TMP3;\nif (HAS_VIRTUAL_REGISTERS)\n  status.tmp_regs[2] = STR_END;\nelse\n  status.tmp_regs[2] = TMP3;\n\ndelayed_mem_copy_init(&status, common);\n\nif (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n  {\n  SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->recursive_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->recursive_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nif (type != recurse_copy_shared_to_global)\n  {\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->control_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->control_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n#endif\n\nwhile (cc < ccend)\n  {\n  private_count = 0;\n  shared_count = 0;\n  kept_shared_count = 0;\n\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (has_quit && !setsom_found)\n      {\n      kept_shared_srcw[0] = OVECTOR(0);\n      kept_shared_count = 1;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (has_quit)\n      {\n      if (common->has_set_som && !setsom_found)\n        {\n        kept_shared_srcw[0] = OVECTOR(0);\n        kept_shared_count = 1;\n        setsom_found = TRUE;\n        }\n      if (common->mark_ptr != 0 && !setmark_found)\n        {\n        kept_shared_srcw[kept_shared_count] = common->mark_ptr;\n        kept_shared_count++;\n        setmark_found = TRUE;\n        }\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[0] = common->capture_last_ptr;\n      shared_count = 1;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    private_count = 1;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      {\n      private_count = 1;\n      private_srcw[0] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n      }\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    private_count = 2;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    private_srcw[1] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    i = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    i = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      switch(get_class_iterator_size(cc + i))\n        {\n        case 1:\n        private_count = 1;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        break;\n\n        case 2:\n        private_count = 2;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n        break;\n\n        default:\n        SLJIT_UNREACHABLE();\n        break;\n        }\n    cc += i;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (has_quit && !setmark_found)\n      {\n      kept_shared_srcw[0] = common->mark_ptr;\n      kept_shared_count = 1;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0 && !control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    if (!control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  if (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < private_count; i++)\n      {\n      SLJIT_ASSERT(private_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, private_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, private_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * private_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < shared_count; i++)\n      {\n      SLJIT_ASSERT(shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * shared_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_swap_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_copy_kept_shared_to_global);\n\n    for (i = 0; i < kept_shared_count; i++)\n      {\n      SLJIT_ASSERT(kept_shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, kept_shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, kept_shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * kept_shared_count;\n  }\n\nSLJIT_ASSERT(cc == ccend && stackptr == stacktop);\n\ndelayed_mem_copy_finish(&status);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1587"
    },
    {
        "index": 85,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tif (sz < 10) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t// Current spec does not call for variable sizes.\n\tattr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new: Processing stack map, summary is:\\n\");\n\tIFDBG r_bin_java_print_stack_map_table_attr_summary(attr);\n\tfor (i = 0; i < attr->info.stack_map_table_attr.number_of_entries; i++) {\n\t\t// read next stack frame\n\t\tIFDBG eprintf (\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\tif (stack_frame == NULL && R_BIN_JAVA_GLOBAL_BIN && R_BIN_JAVA_GLOBAL_BIN->current_code_attr) {\n\t\t\tIFDBG eprintf (\"Setting an implicit frame at #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\t\tstack_frame = R_BIN_JAVA_GLOBAL_BIN->current_code_attr->info.code_attr.implicit_frame;\n\t\t}\n\t\tIFDBG eprintf (\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \", current stack_frame: %p\\n\", i, buf_offset + offset, stack_frame);\n\t\tif (offset >= sz) {\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_stack_frame = r_bin_java_stack_map_frame_new (buffer + offset, sz - offset, stack_frame, buf_offset + offset);\n\t\tif (new_stack_frame) {\n\t\t\toffset += new_stack_frame->size;\n\t\t\t// append stack frame to the list\n\t\t\tr_list_append (attr->info.stack_map_table_attr.stack_map_frame_entries, (void *) new_stack_frame);\n\t\t\tstack_frame = new_stack_frame;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_table_attr_new: Unable to parse the stack frame for the stack map table.\\n\");\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\tattr = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr) {\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 86,
        "code": "host_name_lookup_byaddr(void)\n{\nstruct hostent * hosts;\nstruct in_addr addr;\nunsigned long time_msec = 0;\t/* init to quieten dumb static analysis */\n\nif (slow_lookup_log) time_msec = get_time_in_ms();\n\n/* Lookup on IPv6 system */\n\n#if HAVE_IPV6\nif (Ustrchr(sender_host_address, ':') != NULL)\n  {\n  struct in6_addr addr6;\n  if (inet_pton(AF_INET6, CS sender_host_address, &addr6) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv6 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr6, sizeof(addr6), AF_INET6, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr6, sizeof(addr6), AF_INET6);\n  #endif\n  }\nelse\n  {\n  if (inet_pton(AF_INET, CS sender_host_address, &addr) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv4 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr, sizeof(addr), AF_INET, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr, sizeof(addr), AF_INET);\n  #endif\n  }\n\n/* Do lookup on IPv4 system */\n\n#else\naddr.s_addr = (S_ADDR_TYPE)inet_addr(CS sender_host_address);\nhosts = gethostbyaddr(CS(&addr), sizeof(addr), AF_INET);\n#endif\n\nif (  slow_lookup_log\n   && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log\n   )\n  log_long_lookup(US\"gethostbyaddr\", sender_host_address, time_msec);\n\n/* Failed to look up the host. */\n\nif (!hosts)\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup failed: h_errno=%d\\n\",\n    h_errno);\n  return (h_errno == TRY_AGAIN || h_errno == NO_RECOVERY) ? DEFER : FAIL;\n  }\n\n/* It seems there are some records in the DNS that yield an empty name. We\ntreat this as non-existent. In some operating systems, this is returned as an\nempty string; in others as a single dot. */\n\nif (!hosts->h_name || !hosts->h_name[0] || hosts->h_name[0] == '.')\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an empty name: \"\n    \"treated as non-existent host name\\n\");\n  return FAIL;\n  }\n\n/* Copy and lowercase the name, which is in static storage in many systems.\nPut it in permanent memory. */\n\n  {\n  int old_pool = store_pool;\n  store_pool = POOL_TAINT_PERM;\t\t/* names are tainted */\n\n  sender_host_name = string_copylc(US hosts->h_name);\n\n  /* If the host has aliases, build a copy of the alias list */\n\n  if (hosts->h_aliases)\n    {\n    int count = 1;\n    uschar **ptr;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++) count++;\n    store_pool = POOL_PERM;\n    ptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n    store_pool = POOL_TAINT_PERM;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++)\n      *ptr++ = string_copylc(*aliases);\n    *ptr = NULL;\n    }\n  store_pool = old_pool;\n  }\n\nreturn OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-37452"
    },
    {
        "index": 87,
        "code": "mp_sint32 LoaderXM::load(XMFileBase& f, XModule* module)\n{\n\tmp_ubyte insData[230];\t\t\n\tmp_sint32 smpReloc[MP_MAXINSSAMPS];\n\tmp_ubyte nbu[MP_MAXINSSAMPS];\n\tmp_uint32 fileSize = 0;\n\t\t\t\n\tmodule->cleanUp();\n\n\t// this will make code much easier to read\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\n\t// we're already out of memory here\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tfileSize = f.sizeWithBaseOffset();\n\t\n\tf.read(&header->sig,1,17);\n\tf.read(&header->name,1,20);\n\tf.read(&header->whythis1a,1,1);\n\theader->whythis1a=0;\n\tf.read(&header->tracker,1,20);\n\tf.readWords(&header->ver,1);\n\t\n\tif (header->ver != 0x102 && \n\t\theader->ver != 0x103 && // untested\n\t\theader->ver != 0x104)\n\t\treturn MP_LOADER_FAILED;\n\t\n\tf.readDwords(&header->hdrsize,1);\n\t\n\theader->hdrsize-=4;\n\t\n\tmp_uint32 hdrSize = 0x110;\n\tif (header->hdrsize > hdrSize)\n\t\thdrSize = header->hdrsize;\n\t\t\t\t\n\tmp_ubyte* hdrBuff = new mp_ubyte[hdrSize];\n\tmemset(hdrBuff, 0, hdrSize);\n\t\n\tf.read(hdrBuff, 1, header->hdrsize);\n\t\n\theader->ordnum = LittleEndian::GET_WORD(hdrBuff);\n\theader->restart = LittleEndian::GET_WORD(hdrBuff+2);\n\theader->channum = LittleEndian::GET_WORD(hdrBuff+4);\n\theader->patnum = LittleEndian::GET_WORD(hdrBuff+6);\n\theader->insnum = LittleEndian::GET_WORD(hdrBuff+8);\n\theader->freqtab = LittleEndian::GET_WORD(hdrBuff+10);\n\theader->tempo = LittleEndian::GET_WORD(hdrBuff+12);\n\theader->speed = LittleEndian::GET_WORD(hdrBuff+14);\n\tmemcpy(header->ord, hdrBuff+16, 256);\n\tif(header->ordnum > MP_MAXORDERS)\n\t\theader->ordnum = MP_MAXORDERS;\n\tif(header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\n\tdelete[] hdrBuff;\n\t\n\theader->mainvol=255;\n\theader->flags = XModule::MODULE_XMNOTECLIPPING | \n\t\tXModule::MODULE_XMARPEGGIO | \n\t\tXModule::MODULE_XMPORTANOTEBUFFER | \n\t\tXModule::MODULE_XMVOLCOLUMNVIBRATO;\n\n\theader->uppernotebound = 119;\n\t\n\tmp_sint32 i,y,sc;\n\tfor (i=0;i<32;i++) header->pan[i]=0x80;\n\t\n\t// old version?\n\tif (header->ver == 0x102 || header->ver == 0x103)\n\t{\n\t\tmp_sint32 s = 0;\n\t\tmp_sint32 e = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\t\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\tf.read(&instr[y].name,1,22);\t\t\n\t\t\tf.read(&instr[y].type,1,1);\n\t\t\tmp_uword numSamples = 0;\n\t\t\tf.readWords(&numSamples,1);\n\t\t\tif(numSamples > MP_MAXINSSAMPS)\n\t\t\t\treturn MP_LOADER_FAILED;\n\t\t\tinstr[y].samp = numSamples;\n\n\t\t\tif (instr[y].size == 29)\n\t\t\t{\n#ifdef MILKYTRACKER\n\t\t\t\ts+=16;\n#endif\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf.readDwords(&instr[y].shsize,1);\n\n\t\t\tmemset(insData, 0, 230);\n\t\t\t\n\t\t\tif (instr[y].size - 33 > 230)\n\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\n\t\t\tf.read(insData, 1, instr[y].size - 33);\n\t\t\t\t\t\t\n\t\t\tif (instr[y].samp) {\n\t\t\t\tmp_ubyte* insDataPtr = insData;\n\t\t\t\t\n\t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n\t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n\t\t\t\t\n\t\t\t\tTEnvelope venv;\n\t\t\t\tTEnvelope penv;\n\t\t\t\tmemset(&venv,0,sizeof(venv));\n\t\t\t\tmemset(&penv,0,sizeof(penv));\n\t\t\t\t\n\t\t\t\tmp_sint32 k;\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvenv.num = *insDataPtr++;\t\n\t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tpenv.num = *insDataPtr++;\t\n\t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tvenv.sustain = *insDataPtr++;\n\t\t\t\tvenv.loops = *insDataPtr++;\n\t\t\t\tvenv.loope = *insDataPtr++;\n\t\t\t\tpenv.sustain = *insDataPtr++;\n\t\t\t\tpenv.loops = *insDataPtr++;\n\t\t\t\tpenv.loope = *insDataPtr++;\n\t\t\t\tvenv.type = *insDataPtr++;\n\t\t\t\tpenv.type = *insDataPtr++;\t\t\t\t\n\t\t\t\t\n\t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n\t\t\t\tmp_uword volfade;\n\t\t\t\t\n\t\t\t\tvibtype = *insDataPtr++;\n\t\t\t\tvibsweep = *insDataPtr++;\n\t\t\t\tvibdepth = *insDataPtr++;\n\t\t\t\tvibrate = *insDataPtr++;\n\t\t\t\t\n\t\t\t\tvibdepth<<=1;\n\t\t\t\t\n\t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\tvolfade<<=1;\n\t\t\t\t\n\t\t\t\t//instr[y].res = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\t\n\t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n\t\t\t\t\tvenv.env[l][1]<<=2;\n\t\t\t\t\tpenv.env[l][1]<<=2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!module->addVolumeEnvelope(venv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\tif (!module->addPanningEnvelope(penv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\n\t\t\t\tmp_sint32 g=0, sc;\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].flags=3;\n\t\t\t\t\tsmp[g+s].venvnum=e+1;\n\t\t\t\t\tsmp[g+s].penvnum=e+1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].vibtype=vibtype;\n\t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n\t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n\t\t\t\t\tsmp[g+s].vibrate=vibrate;\n\t\t\t\t\tsmp[g+s].volfade=volfade;\n\t\t\t\t\t\n\t\t\t\t\t// not sure why I did that, actually doesn't make sense\n\t\t\t\t\t//if (!(venv.type&1)) smp[g+s].volfade=0;\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n\t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n\t\t\t\t\t//f.read(&smp[g+s].vol,1,1);\n\t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n\t\t\t\t\tf.read(&smp[g+s].type,1,1);\n#ifdef VERBOSE\n\t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n#endif\n\t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n\t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n\t\t\t\t\tf.read(&smp[g+s].res,1,1);\n\t\t\t\t\tf.read(&smp[g+s].name,1,22);\n\t\t\t\t\t\n\t\t\t\t\tchar line[30];\n\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\t\t\t\t\t\n\t\t\t\t\tif (line[0])\n\t\t\t\t\t\tmodule->addSongMessageLine(line);\n\t\t\t\t\t\n\t\t\t\t\t// ignore empty samples\n#ifndef MILKYTRACKER\n\t\t\t\t\t// ignore empty samples when not being a tracker\n\t\t\t\t\tif (smp[g+s].samplen) {\n\t\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsmpReloc[sc] = -1;\n#else\n\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\tg++;\n#endif\n\t\t\t\t}\n\n\t\t\t\tinstr[y].samp = g;\n\n\t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\n\t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n\t\t\t\t\t\tinstr[y].snum[sc] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\te++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t}\n\n#ifdef MILKYTRACKER\n\t\t\ts+=16;\n#else\n\t\t\ts+=instr[y].samp;\n#endif\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\theader->smpnum=s;\n\t\theader->volenvnum=e;\n\t\theader->panenvnum=e;\n\t}\n\t\n\tfor (y=0;y<header->patnum;y++) {\n\t\t\n\t\tif (header->ver == 0x104 || header->ver == 0x103)\n\t\t{\n\t\t\tf.readDwords(&phead[y].len,1);\n\t\t\tf.read(&phead[y].ptype,1,1);\n\t\t\tf.readWords(&phead[y].rows,1);\n\t\t\tf.readWords(&phead[y].patdata,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf.readDwords(&phead[y].len,1);\n\t\t\tf.read(&phead[y].ptype,1,1);\n\t\t\tphead[y].rows = (mp_uword)f.readByte()+1;\n\t\t\tf.readWords(&phead[y].patdata,1);\t\t\t\n\t\t}\n\t\t\n\t\tphead[y].effnum=2;\n\t\tphead[y].channum=(mp_ubyte)header->channum;\n\t\t\n\t\tphead[y].patternData = new mp_ubyte[phead[y].rows*header->channum*6];\n\t\t\n\t\t// out of memory?\n\t\tif (phead[y].patternData == NULL)\n\t\t{\n\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t}\n\t\t\n\t\tmemset(phead[y].patternData,0,phead[y].rows*header->channum*6);\n\t\t\n\t\tif (phead[y].patdata) {\n\t\t\tmp_ubyte *buffer = new mp_ubyte[phead[y].patdata];\n\t\t\t\n\t\t\t// out of memory?\n\t\t\tif (buffer == NULL)\n\t\t\t{\n\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tf.read(buffer,1,phead[y].patdata);\n\t\t\t\n\t\t\t//printf(\"%i\\n\", phead[y].patdata);\n\t\t\t\n\t\t\tmp_sint32 pc = 0, bc = 0;\n\t\t\tfor (mp_sint32 r=0;r<phead[y].rows;r++) {\n\t\t\t\tfor (mp_sint32 c=0;c<header->channum;c++) {\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte slot[5];\n\t\t\t\t\tmemset(slot,0,5);\n\t\t\t\t\t\n\t\t\t\t\tif ((buffer[pc]&128)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tmp_ubyte pb = buffer[pc];\n\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((pb&1)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc]=buffer[pc];\n\t\t\t\t\t\t\tslot[0]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&2)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+1]=buffer[pc];\n\t\t\t\t\t\t\tslot[1]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&4)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+2]=buffer[pc];\n\t\t\t\t\t\t\tslot[2]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&8)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+3]=buffer[pc];\n\t\t\t\t\t\t\tslot[3]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&16)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+4]=buffer[pc];\n\t\t\t\t\t\t\tslot[4]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//memcpy(phead[y].patternData+bc,buffer+pc,5);\n\t\t\t\t\t\tmemcpy(slot,buffer+pc,5);\n\t\t\t\t\t\tpc+=5;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tchar gl=0;\n\t\t\t\t\tfor (mp_sint32 i=0;i<XModule::numValidXMEffects;i++)\n\t\t\t\t\t\tif (slot[3]==XModule::validXMEffects[i]) gl=1;\n\t\t\t\t\t\n\t\t\t\t\tif (!gl) slot[3]=slot[4]=0;\n\t\t\t\t\t\n\t\t\t\t\tif ((slot[3]==0xC)||(slot[3]==0x10)) {\n\t\t\t\t\t\tslot[4] = XModule::vol64to255(slot[4]);\n\t\t\t\t\t\t/*mp_sint32 bl = slot[4];\n\t\t\t\t\t\tif (bl>64) bl=64;\n\t\t\t\t\t\tslot[4]=(bl*261120)>>16;*/\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((!slot[3])&&(slot[4])) slot[3]=0x20;\n\t\t\t\t\t\n\t\t\t\t\tif (slot[3]==0xE) {\n\t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x30;\n\t\t\t\t\t\tslot[4]=slot[4]&0xf;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (slot[3]==0x21) {\n\t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x40;\n\t\t\t\t\t\tslot[4]=slot[4]&0xf;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (slot[0]==97) slot[0]=XModule::NOTE_OFF;\n\t\t\t\t\t\n\t\t\t\t\tphead[y].patternData[bc]=slot[0];\n\t\t\t\t\tphead[y].patternData[bc+1]=slot[1];\n\t\t\t\t\t\n\t\t\t\t\tXModule::convertXMVolumeEffects(slot[2], phead[y].patternData[bc+2], phead[y].patternData[bc+3]);\n\n\t\t\t\t\tphead[y].patternData[bc+4]=slot[3];\n\t\t\t\t\tphead[y].patternData[bc+5]=slot[4];\n\t\t\t\t\t\n\t\t\t\t\t/*if ((y==3)&&(c==2)) {\n\t\t\t\t\t\tfor (mp_sint32 bl=0;bl<6;bl++) cprintf(\"%x \",phead[y].patternData[bc+bl]);\n\t\t\t\t\tcprintf(\"\\r\\n\");\n\t\t\t\t\tgetch();\n\t\t\t\t\t};*/\n\t\t\t\t\t\n\t\t\t\t\t/*printf(\"Note : %i\\r\\n\",phead[y].patternData[bc]);\n\t\t\t\t\tprintf(\"Ins  : %i\\r\\n\",phead[y].patternData[bc+1]);\n\t\t\t\t\tprintf(\"Vol  : %i\\r\\n\",phead[y].patternData[bc+2]);\n\t\t\t\t\tprintf(\"Eff  : %i\\r\\n\",phead[y].patternData[bc+3]);\n\t\t\t\t\tprintf(\"Effop: %i\\r\\n\",phead[y].patternData[bc+4]);\n\t\t\t\t\tgetch();*/\n\t\t\t\t\t\n\t\t\t\t\tbc+=6;\n\t\t\t\t} // for c\n\t\t\t\t\t\n\t\t\t} // for r\n\t\t\t\t\n\t\t\tdelete[] buffer;\n\t\t}\n\t\t\t\n\t}\n\t\t\n\tif (header->ver == 0x104)\n\t{\n\t\tmp_sint32 s = 0;\n\t\tmp_sint32 e = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\n\t\t\t// fixes MOOH.XM loading problems\n\t\t\t// seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tf.read(&instr[y].name,1,22);\t\t\n\t\t\t\tf.read(&instr[y].type,1,1);\n\t\t\t\tf.readWords(&instr[y].samp,1);\n\t\t\t}\n\t\t\tif (instr[y].samp > MP_MAXINSSAMPS)\n\t\t\t\treturn MP_LOADER_FAILED;\n\n\t\t\t//printf(\"%i, %i\\n\", instr[y].size, instr[y].samp);\n\n\t\t\tif (instr[y].size <= 29)\n\t\t\t{\n#ifdef MILKYTRACKER\n\t\t\t\ts+=16;\n#endif\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf.readDwords(&instr[y].shsize,1);\n#ifdef VERBOSE\n\t\t\tprintf(\"%i/%i: %i, %i, %i, %s\\n\",y,header->insnum-1,instr[y].size,instr[y].shsize,instr[y].samp,instr[y].name);\t\t\t\n#endif\n\t\t\tmemset(insData, 0, 230);\n\t\t\t\n\t\t\tif (instr[y].size - 33 > 230)\n\t\t\t{\n\t\t\t\t//return -7;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tf.read(insData, 1, instr[y].size - 33);\n\t\t\t\n\t\t\t/*printf(\"%i\\r\\n\",instr[y].size);\n\t\t\tprintf(\"%s\\r\\n\",instr[y].name);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].type);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].samp);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].shsize);*/\n\t\t\t//getch();\n\t\t\t\t\t\n\t\t\tmemset(smpReloc, 0, sizeof(smpReloc));\n\t\t\t\n\t\t\tif (instr[y].samp) {\n\t\t\t\tmp_ubyte* insDataPtr = insData;\n\t\t\t\t\n\t\t\t\t//f.read(&nbu,1,96);\n\t\t\t\t\n\t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n\t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n\t\t\t\t\n\t\t\t\tTEnvelope venv;\n\t\t\t\tTEnvelope penv;\n\t\t\t\tmemset(&venv,0,sizeof(venv));\n\t\t\t\tmemset(&penv,0,sizeof(penv));\n\t\t\t\t\n\t\t\t\tmp_sint32 k;\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvenv.num = *insDataPtr++;\t\n\t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tpenv.num = *insDataPtr++;\t\t\t\t\t\n\t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tvenv.sustain = *insDataPtr++;\n\t\t\t\tvenv.loops = *insDataPtr++;\n\t\t\t\tvenv.loope = *insDataPtr++;\n\t\t\t\tpenv.sustain = *insDataPtr++;\n\t\t\t\tpenv.loops = *insDataPtr++;\n\t\t\t\tpenv.loope = *insDataPtr++;\n\t\t\t\tvenv.type = *insDataPtr++;\n\t\t\t\tpenv.type = *insDataPtr++;\t\t\t\t\n\t\t\t\t\n\t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n\t\t\t\tmp_uword volfade;\n\t\t\t\t\n\t\t\t\tvibtype = *insDataPtr++;\n\t\t\t\tvibsweep = *insDataPtr++;\n\t\t\t\tvibdepth = *insDataPtr++;\n\t\t\t\tvibrate = *insDataPtr++;\n\t\t\t\t\n\t\t\t\tvibdepth<<=1;\n\t\t\t\t\n\t\t\t\t//f.readWords(&volfade,1);\n\t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\tvolfade<<=1;\n\t\t\t\t\n\t\t\t\t//instr[y].res = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\t\n\t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n\t\t\t\t\tvenv.env[l][1]<<=2;\n\t\t\t\t\tpenv.env[l][1]<<=2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!module->addVolumeEnvelope(venv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\tif (!module->addPanningEnvelope(penv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\n\t\t\t\tmp_sint32 g=0, sc;\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\t//TXMSample* smpl = &smp[g+s];\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].flags=3;\n\t\t\t\t\tsmp[g+s].venvnum=e+1;\n\t\t\t\t\tsmp[g+s].penvnum=e+1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].vibtype=vibtype;\n\t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n\t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n\t\t\t\t\tsmp[g+s].vibrate=vibrate;\n\t\t\t\t\tsmp[g+s].volfade=volfade;\n\t\t\t\t\t\n\t\t\t\t\t// not sure why I did that, actually doesn't make sense\n\t\t\t\t\t//if (!(venv.type&1)) smp[g+s].volfade=0;\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n\t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n\t\t\t\t\t//f.read(&smp[g+s].vol,1,1);\n\t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n\t\t\t\t\tf.read(&smp[g+s].type,1,1);\n#ifdef VERBOSE\n\t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n#endif\n\t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n\t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n\t\t\t\t\tf.read(&smp[g+s].res,1,1);\n\t\t\t\t\tf.read(&smp[g+s].name,1,22);\n\n\t\t\t\t\tchar line[30];\n\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\t\t\t\t\t\n\t\t\t\t\tif (line[0])\n\t\t\t\t\t\tmodule->addSongMessageLine(line);\n\t\t\t\t\t\n#ifndef MILKYTRACKER\n\t\t\t\t\t// ignore empty samples when not being a tracker\n\t\t\t\t\tif (smp[g+s].samplen) {\n\t\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsmpReloc[sc] = -1;\n#else\n\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\tg++;\n#endif\n\t\t\t\t}\n\n\t\t\t\tinstr[y].samp = g;\n\n\t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\t\t\t\t\t\n\t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n\t\t\t\t\t\tinstr[y].snum[sc] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\n\t\t\t\t\tif (smp[s].samplen)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\t\t\t\n\t\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n\t\t\t\t\t\tif (smp[s].type&16) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_DELTA, \n\t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? (XModule::ST_PACKING_ADPCM | XModule::ST_16BIT) : (XModule::ST_DELTA | XModule::ST_16BIT), \n\t\t\t\t\t\t\t\t\t\t\t\t\t oldSize);\n\t\t\t\t\t\tif (result != MP_OK)\n\t\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (adpcm)\n\t\t\t\t\t\t\tsmp[s].res = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t\t\n\t\t\t\t\tif (s>=MP_MAXSAMPLES)\n\t\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\te++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t}\n\n#ifdef MILKYTRACKER\n\t\t\ts+=16 - instr[y].samp;\n#endif\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\theader->smpnum=s;\n\t\theader->volenvnum=e;\n\t\theader->panenvnum=e;\t\t\n\t\t\n\t}\n\telse\n\t{\n\t\tmp_sint32 s = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\n\t\t\t\tif (smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n\t\t\t\t\tif (smp[s].type&16) \n\t\t\t\t\t{\n\t\t\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, XModule::ST_DELTA, XModule::ST_DELTA | XModule::ST_16BIT, oldSize);\n\t\t\t\t\tif (result != MP_OK)\n\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts++;\n\t\t\t\t\n\t\t\t\tif (s>=MP_MAXSAMPLES)\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t}\n\t\t\t\n#ifdef MILKYTRACKER\n\t\t\ts+=16 - instr[y].samp;\n#endif\n\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t// convert modplug stereo samples\n\tfor (mp_sint32 s = 0; s < header->smpnum; s++)\n\t{\n\t\tif (smp[s].type & 32)\n\t\t{\t\t\n\t\t\t// that's what's allowed, stupid modplug tracker\n\t\t\tsmp[s].type &= 3+16;\t\t\t\t\t\n\n\t\t\tif (smp[s].sample == NULL)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (!(smp[s].type&16)) {\t\t\t\n\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\n\t\t\t\tmp_sbyte* sample = (mp_sbyte*)smp[s].sample;\n\t\t\t\tmp_sint32 samplen = smp[s].samplen;\n\t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n\t\t\t\t{\n\t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n\t\t\t\t\tif (s < -128) s = -128;\n\t\t\t\t\tif (s > 127) s = 127;\n\t\t\t\t\tsample[i] = (mp_sbyte)s;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\n\t\t\t\tmp_sword* sample = (mp_sword*)smp[s].sample;\n\t\t\t\tmp_sint32 samplen = smp[s].samplen;\n\t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n\t\t\t\t{\n\t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n\t\t\t\t\tif (s < -32768) s = -32768;\n\t\t\t\t\tif (s > 32767) s = 32767;\n\t\t\t\t\tsample[i] = (mp_sword)s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// correct loop type 0x03 (undefined)\n\t\t// will become ping pong loop\n\t\t// note that FT2 will refuse to load XM files with such a loop type\n\t\tif ((smp[s].type & 0x3) == 0x3)\n\t\t\tsmp[s].type&=~1;\t\t\n\t}\n\n\t// correct number of patterns if necessary, otherwise the post processing will remove\n\t// the \"invalid\" patterns from the order list\n\tbool addPatterns = false;\n\tfor (i = 0; i < header->ordnum; i++)\n\t\tif (header->ord[i]+1 > header->patnum)\n\t\t{\n\t\t\theader->patnum = header->ord[i]+1;\t\n\t\t\taddPatterns = true;\n\t\t}\n\t\n\t// if the pattern number has been adjusted, add some empty patterns\n\tif (addPatterns)\n\t{\n\t\tfor (i = 0; i < header->patnum; i++)\n\t\t\tif (phead[i].patternData == NULL)\n\t\t\t{\n\t\t\t\tphead[i].rows = 64;\n\t\t\t\tphead[i].effnum = 2;\n\t\t\t\tphead[i].channum = (mp_ubyte)header->channum;\n\n\t\t\t\tphead[i].patternData = new mp_ubyte[phead[i].rows*header->channum*6];\n\t\t\t\n\t\t\t\t// out of memory?\n\t\t\t\tif (phead[i].patternData == NULL)\n\t\t\t\t{\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\n\t\t\t\tmemset(phead[i].patternData,0,phead[i].rows*header->channum*6);\n\t\t\t}\n\t}\n\t\n\t// check for MODPLUG extensions\n\tif (f.posWithBaseOffset() + 8 <= fileSize)\n\t{\n\t\tchar buffer[4];\n\t\tf.read(buffer, 1, 4);\n\t\tif (memcmp(buffer, \"text\", 4) == 0)\n\t\t{\n\t\t\tmp_uint32 len = f.readDword();\n\t\t\tmodule->allocateSongMessage(len+1);\n\t\t\t\n\t\t\tmemset(module->message, 0, len+1);\n\t\t\t\n\t\t\tf.read(module->message, 1, len);\n\t\t}\n\t}\n\t\n\tmodule->postProcessSamples();\n\t\n\treturn MP_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34927"
    },
    {
        "index": 88,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n\n    int64 top_pad_planes, bottom_pad_planes;\n    int64 top_pad_rows, bottom_pad_rows;\n    int64 left_pad_cols, right_pad_cols;\n\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[0].input_size,\n                                dims.spatial_dims[0].filter_size,\n                                dims.spatial_dims[0].stride, padding_,\n                                &dims.spatial_dims[0].output_size,\n                                &top_pad_planes, &bottom_pad_planes));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[1].input_size,\n                                dims.spatial_dims[1].filter_size,\n                                dims.spatial_dims[1].stride, padding_,\n                                &dims.spatial_dims[1].output_size,\n                                &top_pad_rows, &bottom_pad_rows));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[2].input_size,\n                                dims.spatial_dims[2].filter_size,\n                                dims.spatial_dims[2].stride, padding_,\n                                &dims.spatial_dims[2].output_size,\n                                &left_pad_cols, &right_pad_cols));\n\n    // TODO(ezhulenev): Extract work size and shard estimation to shared\n    // functions in conv_grad_ops, and update 2d convolution backprop.\n\n    // The total dimension size of each kernel.\n    const int64 filter_total_size =\n        dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *\n        dims.spatial_dims[2].filter_size * dims.in_depth;\n    // The output image size is the spatial size of the output.\n    const int64 output_image_size = dims.spatial_dims[0].output_size *\n                                    dims.spatial_dims[1].output_size *\n                                    dims.spatial_dims[2].output_size;\n\n    // Shard 'batch' images (volumes) into 'shard_size' groups of images\n    // (volumes) to be fed into the parallel matmul. Calculate 'shard_size' by\n    // dividing the L3 cache size ('target_working_set_size') by the matmul size\n    // of an individual image ('work_unit_size').\n\n    const auto cache_sizes = Eigen::internal::CacheSizes();\n    const ptrdiff_t l3_cache_size = cache_sizes.m_l3;\n\n    // TODO(andydavis)\n    // *) Consider reducing 'target_working_set_size' if L3 is shared by\n    //    other concurrently running tensorflow ops.\n    const size_t target_working_set_size = l3_cache_size / sizeof(T);\n\n    const int64 size_A = output_image_size * filter_total_size;\n\n    const int64 size_B = output_image_size * dims.out_depth;\n\n    const int64 size_C = filter_total_size * dims.out_depth;\n\n    const int64 work_unit_size = size_A + size_B + size_C;\n\n    const size_t shard_size =\n        (target_working_set_size + work_unit_size - 1) / work_unit_size;\n\n    // Total number of elements in all the tensors used by this kernel.\n    int64 total_tensor_elements = input_shape.num_elements() +\n                                  filter_shape.num_elements() +\n                                  out_backprop_shape.num_elements();\n\n    // Shape of the temporary workspace buffer.\n    TensorShape col_buffer_shape = {static_cast<int64>(shard_size),\n                                    static_cast<int64>(output_image_size),\n                                    static_cast<int64>(filter_total_size)};\n    int64 col_buffer_elements = col_buffer_shape.num_elements();\n\n    // If the temporary allocation overhead is too large, fallback on Eigen\n    // implementation which requires much less memory.\n    int64 col_buffer_overhead = col_buffer_elements / total_tensor_elements;\n    if (col_buffer_overhead > kMaxTempAllocationOverhead) {\n      VLOG(2) << \"Fallback on Eigen implementation of Conv3DBackpropFilterOp: \"\n                 \"col_buffer_overhead=\"\n              << col_buffer_overhead;\n\n      functor::CuboidConvolutionBackwardFilter<Device, T>()(\n          context->eigen_device<Device>(),\n          filter_backprop->tensor<T, 5>(),                 // filter_backward\n          input.tensor<T, 5>(),                            // input\n          out_backprop.tensor<T, 5>(),                     // output_backward\n          static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n          static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n          static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n\n      return;\n    }\n\n    Tensor col_buffer;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          col_buffer_shape, &col_buffer));\n\n    // The input offset corresponding to a single input image.\n    const int64 input_offset = dims.spatial_dims[0].input_size *\n                               dims.spatial_dims[1].input_size *\n                               dims.spatial_dims[2].input_size * dims.in_depth;\n    // The output offset corresponding to a single output image.\n    const int64 output_offset =\n        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *\n        dims.spatial_dims[2].output_size * dims.out_depth;\n\n    const T* input_data = input.template flat<T>().data();\n    T* col_buffer_data = col_buffer.template flat<T>().data();\n    const T* out_backprop_data = out_backprop.template flat<T>().data();\n    T* filter_backprop_data = filter_backprop->template flat<T>().data();\n\n    typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,\n                             Eigen::Unaligned>\n        TensorMap;\n    typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                             Eigen::Unaligned>\n        ConstTensorMap;\n\n    TensorMap C(filter_backprop_data, filter_total_size, dims.out_depth);\n    C.setZero();\n\n    // Initialize contraction dims (we need to transpose 'A' below).\n    Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;\n    contract_dims[0].first = 0;\n    contract_dims[0].second = 0;\n\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n\n    for (int image_id = 0; image_id < dims.batch_size; image_id += shard_size) {\n      const int shard_limit =\n          std::min(static_cast<int>(shard_size),\n                   static_cast<int>(dims.batch_size) - image_id);\n\n      auto shard = [&input_data, &col_buffer_data, &dims, &top_pad_planes,\n                    &top_pad_rows, &left_pad_cols, &bottom_pad_planes,\n                    &bottom_pad_rows, &right_pad_cols, &input_offset,\n                    &size_A](int64 start, int64 limit) {\n        for (int shard_id = start; shard_id < limit; ++shard_id) {\n          const T* input_data_shard = input_data + shard_id * input_offset;\n          T* col_data_shard = col_buffer_data + shard_id * size_A;\n\n          // When we compute the gradient with respect to the filters, we need\n          // to do im2col to allow gemm-type computation.\n          Im2col<T>(input_data_shard, dims.in_depth,\n                    // Input spatial dimensions.\n                    dims.spatial_dims[0].input_size,  // input planes\n                    dims.spatial_dims[1].input_size,  // input rows\n                    dims.spatial_dims[2].input_size,  // input cols\n                    // Filter spatial dimensions.\n                    dims.spatial_dims[0].filter_size,  // filter planes\n                    dims.spatial_dims[1].filter_size,  // filter rows\n                    dims.spatial_dims[2].filter_size,  // filter cols\n                    // Spatial padding.\n                    top_pad_planes, top_pad_rows, left_pad_cols,\n                    bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                    // Spatial striding.\n                    dims.spatial_dims[0].stride,  // stride planes\n                    dims.spatial_dims[1].stride,  // stride rows\n                    dims.spatial_dims[2].stride,  // stride cols\n                    col_data_shard);\n        }\n      };\n      Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n            size_A, shard);\n\n      ConstTensorMap A(col_buffer_data, output_image_size * shard_limit,\n                       filter_total_size);\n      ConstTensorMap B(out_backprop_data, output_image_size * shard_limit,\n                       dims.out_depth);\n\n      // Gradient with respect to filter.\n      C.device(context->eigen_cpu_device()) += A.contract(B, contract_dims);\n\n      input_data += input_offset * shard_limit;\n      out_backprop_data += output_offset * shard_limit;\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29520"
    },
    {
        "index": 89,
        "code": "njs_promise_perform_all_settled_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled, *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    capability = pargs->capability;\n\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n\n    context = on_fulfilled->context;\n\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n\n    on_rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n\n    on_fulfilled->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->magic8 = 1; /* rejected. */\n\n    on_fulfilled->args_count = 1;\n    on_rejected->args_count = 1;\n\n    on_rejected->context = context;\n\n    (*pargs->remaining)++;\n\n    njs_set_function(&arguments[0], on_fulfilled);\n    njs_set_function(&arguments[1], on_rejected);\n\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-32414"
    },
    {
        "index": 90,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *nack_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */\n    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length);\n    if (cnt > 2) cnt -= 2; else cnt = 0;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *nack_cnt = PJ_MIN(*nack_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *nack_cnt; ++i) {\n\tpj_uint16_t val;\n\n\tpj_memcpy(&val, p, 2);\n\tnack[i].pid = pj_ntohs(val);\n\tpj_memcpy(&val, p+2, 2);\n\tnack[i].blp = pj_ntohs(val);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 91,
        "code": "PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 92,
        "code": "GF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n\t*e = GF_OK;\n\treturn tmp;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-31261"
    },
    {
        "index": 93,
        "code": "ins_compl_stop(int c, int prev_mode, int retval)\n{\n    char_u\t*ptr;\n    int\t\twant_cindent;\n\n    // Get here when we have finished typing a sequence of ^N and\n    // ^P or other completion characters in CTRL-X mode.  Free up\n    // memory that was used, and make sure we can redo the insert.\n    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)\n    {\n\t// If any of the original typed text has been changed, eg when\n\t// ignorecase is set, we must add back-spaces to the redo\n\t// buffer.  We add as few as necessary to delete just the part\n\t// of the original text that has changed.\n\t// When using the longest match, edited the match or used\n\t// CTRL-E then don't use the current match.\n\tif (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)\n\t    ptr = compl_curr_match->cp_str;\n\telse\n\t    ptr = NULL;\n\tins_compl_fixRedoBufForLeader(ptr);\n    }\n\n    want_cindent = (get_can_cindent() && cindent_on());\n\n    // When completing whole lines: fix indent for 'cindent'.\n    // Otherwise, break line if it's too long.\n    if (compl_cont_mode == CTRL_X_WHOLE_LINE)\n    {\n\t// re-indent the current line\n\tif (want_cindent)\n\t{\n\t    do_c_expr_indent();\n\t    want_cindent = FALSE;\t// don't do it again\n\t}\n    }\n    else\n    {\n\tint prev_col = curwin->w_cursor.col;\n\n\t// put the cursor on the last char, for 'tw' formatting\n\tif (prev_col > 0)\n\t    dec_cursor();\n\t// only format when something was inserted\n\tif (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)\n\t    insertchar(NUL, 0, -1);\n\tif (prev_col > 0\n\t\t&& ml_get_curline()[curwin->w_cursor.col] != NUL)\n\t    inc_cursor();\n    }\n\n    // If the popup menu is displayed pressing CTRL-Y means accepting\n    // the selection without inserting anything.  When\n    // compl_enter_selects is set the Enter key does the same.\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n\n    // CTRL-E means completion is Ended, go back to the typed text.\n    // but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    ins_bytes(compl_leader + get_compl_len());\n\telse if (compl_first_match != NULL)\n\t    ins_bytes(compl_orig_text + get_compl_len());\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n\n    // Trigger the CompleteDonePre event to give scripts a chance to\n    // act upon the completion before clearing the info, and restore\n    // ctrl_x_mode, so that complete_info() can be used.\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    if (!shortmess(SHM_COMPLETIONMENU))\n\tmsg_clr_cmdline();\t// necessary for \"noshowmode\"\n    ctrl_x_mode = CTRL_X_NORMAL;\n    compl_enter_selects = FALSE;\n    if (edit_submode != NULL)\n    {\n\tedit_submode = NULL;\n\tshowmode();\n    }\n\n#ifdef FEAT_CMDWIN\n    if (c == Ctrl_C && cmdwin_type != 0)\n\t// Avoid the popup menu remains displayed when leaving the\n\t// command line window.\n\tupdate_screen(0);\n#endif\n    // Indent now if a key was typed that is in 'cinkeys'.\n    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))\n\tdo_c_expr_indent();\n    // Trigger the CompleteDone event to give scripts a chance to act\n    // upon the end of completion.\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n\n    return retval;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2286"
    },
    {
        "index": 94,
        "code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-31255"
    },
    {
        "index": 95,
        "code": "MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                /* found match */\n                if (last_border != tag_open) {\n                    /* opening char not found, not an attribute */\n                    data += needle_length;\n                    continue;\n                }\n                /* go to attribute  beginning */\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                /* now go forward */\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1907"
    },
    {
        "index": 96,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 8 > sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 97,
        "code": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-44109"
    },
    {
        "index": 98,
        "code": "MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < 33; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3889"
    },
    {
        "index": 99,
        "code": "int __cil_resolve_ast_node_helper(struct cil_tree_node *node, uint32_t *finished, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = args->pass;\n\tstruct cil_tree_node *block = args->block;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *optional = args->optional;\n\tstruct cil_tree_node *boolif = args->boolif;\n\n\tif (node == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (block != NULL) {\n\t\tif (node->flavor == CIL_CAT ||\n\t\t    node->flavor == CIL_SENS) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in blocks\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (node->flavor == CIL_BLOCK ||\n\t\t    node->flavor == CIL_BLOCKINHERIT ||\n\t\t    node->flavor == CIL_BLOCKABSTRACT ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in macros\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (optional != NULL) {\n\t\tif (node->flavor == CIL_TUNABLE ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\t/* tuanbles and macros are not allowed in optionals*/\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in optionals\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (node->flavor != CIL_TUNABLEIF &&\n\t\t\tnode->flavor != CIL_CALL &&\n\t\t\tnode->flavor != CIL_CONDBLOCK &&\n\t\t\tnode->flavor != CIL_AVRULE &&\n\t\t\tnode->flavor != CIL_TYPE_RULE &&\n\t\t\tnode->flavor != CIL_NAMETYPETRANSITION) {\n\t\t\trc = SEPOL_ERR;\n\t\t} else if (node->flavor == CIL_AVRULE) {\n\t\t\tstruct cil_avrule *rule = node->data;\n\t\t\tif (rule->rule_kind == CIL_AVRULE_NEVERALLOW) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t\tif (rc == SEPOL_ERR) {\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs (tunableif treated as a booleanif)\", cil_node_to_string(node));\n\t\t\t} else {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs\", cil_node_to_string(node));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_MACRO) {\n\t\tif (pass != CIL_PASS_TIF && pass != CIL_PASS_MACRO) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_BLOCK && ((((struct cil_block*)node->data)->is_abstract == CIL_TRUE) && (pass > CIL_PASS_BLKABS))) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\trc = __cil_resolve_ast_node(node, extra_args);\n\tif (rc == SEPOL_ENOENT) {\n\t\tenum cil_log_level lvl = CIL_ERR;\n\n\t\tif (optional != NULL) {\n\t\t\tlvl = CIL_INFO;\n\n\t\t\tstruct cil_optional *opt = (struct cil_optional *)optional->data;\n\t\t\tstruct cil_tree_node *opt_node = NODE(opt);;\n\t\t\t/* disable an optional if something failed to resolve */\n\t\t\topt->enabled = CIL_FALSE;\n\t\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\t\tcil_tree_log(opt_node, lvl, \"Disabling optional '%s'\", opt->datum.name);\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36087"
    },
    {
        "index": 100,
        "code": "static Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_Value *func, *vpargs;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    \n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 101,
        "code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8904"
    },
    {
        "index": 102,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_tensor = ctx->input(1);\n    const Tensor& input_max_tensor = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor float_output =\n        need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n    if (num_slices == 1) {\n      const float min_range = input_min_tensor.flat<float>()(0);\n      const float max_range = input_max_tensor.flat<float>()(0);\n      DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n    } else {\n      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                  errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                        \"Dequantize with axis != -1.\"));\n\n      int64 pre_dim = 1, post_dim = 1;\n      for (int i = 0; i < axis_; ++i) {\n        pre_dim *= float_output.dim_size(i);\n      }\n      for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n        post_dim *= float_output.dim_size(i);\n      }\n      auto input_tensor = input.template bit_casted_shaped<T, 3>(\n          {pre_dim, num_slices, post_dim});\n      auto output_tensor =\n          float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n      auto min_ranges = input_min_tensor.vec<float>();\n      auto max_ranges = input_max_tensor.vec<float>();\n      for (int i = 0; i < num_slices; ++i) {\n        DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                        input_tensor.template chip<1>(i), min_ranges(i),\n                        max_ranges(i), output_tensor.template chip<1>(i));\n      }\n    }\n    if (need_cast_) {\n      S* out_ptr = output->flat<S>().data();\n      float* in_ptr = float_output.flat<float>().data();\n      for (int64 i = 0; i < float_output.NumElements(); ++i) {\n        out_ptr[i] = static_cast<S>(in_ptr[i]);\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29582"
    },
    {
        "index": 103,
        "code": "static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tsdump->indent++;\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");\n\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");\n\t\t\tsdump->indent--;\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t}\n\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t}\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\twhile (list) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\tlist = list->next;\n\t\t\t\t}\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tif (mffield) {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2549"
    },
    {
        "index": 105,
        "code": "static const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (drive_params[drive].native_format)\n\t\t\tfloppy = floppy_type + drive_params[drive].native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-33981"
    },
    {
        "index": 106,
        "code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n\n        /* Align blocks to start on a 'long' in the bitmap\n         * which makes the bitmap sync'ing take the fast path.\n         */\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n\n        /* Search for the closest following block\n         * and find the gap.\n         */\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n\n        /* If it fits remember our place and remember the size\n         * of gap, but keep going so that we might find a smaller\n         * gap to fill so avoiding fragmentation.\n         */\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n\n    return offset;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 107,
        "code": "PJ_DEF(pj_status_t) pjsip_ua_unregister_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t     pjsip_dialog *dlg )\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *d;\n\n    /* Sanity-check arguments. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* Check that dialog has been registered. */\n    PJ_ASSERT_RETURN(dlg->dlg_set, PJ_EINVALIDOP);\n\n    /* Lock user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* Find this dialog from the dialog set. */\n    dlg_set = (struct dlg_set*) dlg->dlg_set;\n    d = dlg_set->dlg_list.next;\n    while (d != (pjsip_dialog*)&dlg_set->dlg_list && d != dlg) {\n\td = d->next;\n    }\n\n    if (d != dlg) {\n\tpj_assert(!\"Dialog is not registered!\");\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Remove this dialog from the list. */\n    pj_list_erase(dlg);\n\n    /* If dialog list is empty, remove the dialog set from the hash table. */\n    if (pj_list_empty(&dlg_set->dlg_list)) {\n\tpj_hash_set_lower(NULL, mod_ua.dlg_table, dlg->local.info->tag.ptr,\n\t\t          (unsigned)dlg->local.info->tag.slen, \n\t\t\t  dlg->local.tag_hval, NULL);\n\n\t/* Return dlg_set to free nodes. */\n\tpj_list_push_back(&mod_ua.free_dlgset_nodes, dlg_set);\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23608"
    },
    {
        "index": 108,
        "code": "\n * back of the queue.\n\n */\n\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,\n\n                                      const void * pvItemToQueue,\n\n                                      const BaseType_t xPosition ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n\n * Copies an item out of a queue.\n\n */\n\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue,\n\n                                  void * const pvBuffer ) PRIVILEGED_FUNCTION;\n\n\n\n#if ( configUSE_QUEUE_SETS == 1 )\n\n\n\n/*\n\n * Checks to see if a queue is a member of a queue set, and if so, notifies\n\n * the queue set that the queue contains data.\n\n */\n\n    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\n\n#endif\n\n\n\n/*\n\n * Called after a Queue_t structure has been allocated either statically or\n\n * dynamically to fill in the structure's members.\n\n */\n\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,\n\n                                   const UBaseType_t uxItemSize,\n\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-31571"
    },
    {
        "index": 109,
        "code": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0522"
    },
    {
        "index": 110,
        "code": "GF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet\n\t\tif (ctx->hdr.frame_size + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30019"
    },
    {
        "index": 111,
        "code": "PortForwardSourceResponse PortForwardHandler::createSource(\n    const PortForwardSourceRequest& pfsr, string* sourceName, uid_t userid,\n    gid_t groupid) {\n  try {\n    if (pfsr.has_source() && sourceName) {\n      throw runtime_error(\n          \"Do not set a source when forwarding named pipes with environment \"\n          \"variables\");\n    }\n    SocketEndpoint source;\n    if (pfsr.has_source()) {\n      source = pfsr.source();\n    } else {\n      // Make a random file to forward the pipe\n      string sourcePattern =\n          GetTempDirectory() + string(\"et_forward_sock_XXXXXX\");\n      string sourceDirectory = string(mkdtemp(&sourcePattern[0]));\n      FATAL_FAIL(::chmod(sourceDirectory.c_str(), S_IRUSR | S_IWUSR | S_IXUSR));\n      FATAL_FAIL(::chown(sourceDirectory.c_str(), userid, groupid));\n      string sourcePath = string(sourceDirectory) + \"/sock\";\n\n      source.set_name(sourcePath);\n      if (sourceName == nullptr) {\n        STFATAL\n            << \"Tried to create a pipe but without a place to put the name!\";\n      }\n      *sourceName = sourcePath;\n      LOG(INFO) << \"Creating pipe at \" << sourcePath;\n    }\n    if (pfsr.source().has_port()) {\n      if (sourceName != nullptr) {\n        STFATAL << \"Tried to create a port forward but with a place to put \"\n                   \"the name!\";\n      }\n      auto handler = shared_ptr<ForwardSourceHandler>(new ForwardSourceHandler(\n          networkSocketHandler, source, pfsr.destination()));\n      sourceHandlers.push_back(handler);\n      return PortForwardSourceResponse();\n    } else {\n      if (userid < 0 || groupid < 0) {\n        STFATAL\n            << \"Tried to create a unix socket forward with no userid/groupid\";\n      }\n      auto handler = shared_ptr<ForwardSourceHandler>(new ForwardSourceHandler(\n          pipeSocketHandler, source, pfsr.destination()));\n      FATAL_FAIL(::chmod(source.name().c_str(), S_IRUSR | S_IWUSR | S_IXUSR));\n      FATAL_FAIL(::chown(source.name().c_str(), userid, groupid));\n      sourceHandlers.push_back(handler);\n      return PortForwardSourceResponse();\n    }\n  } catch (const std::runtime_error& ex) {\n    PortForwardSourceResponse pfsr;\n    pfsr.set_error(ex.what());\n    return pfsr;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 112,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_sli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned sli_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && sli_cnt && sli, PJ_EINVAL);\n\n    len = (3 + sli_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB SLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 2; /* FMT = 2 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB SLI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\t*p++  = (pj_uint8_t)((sli[i].first >> 5) & 0xFF);   /* 8 MSB bits */\n\t*p    = (pj_uint8_t)((sli[i].first & 31) << 3);\t    /* 5 LSB bits */\n\t/* 'number' takes 13 bit */\n\t*p++ |= (pj_uint8_t)((sli[i].number >> 10) & 7);    /* 3 MSB bits */\n\t*p++  = (pj_uint8_t)((sli[i].number >> 2) & 0xFF);  /* 8 mid bits */\n\t*p    = (pj_uint8_t)((sli[i].number & 3) << 6);\t    /* 2 LSB bits */\n\t/* 'pict_id' takes 6 bit */\n\t*p++ |= (sli[i].pict_id & 63);\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 113,
        "code": "  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    // The shape of 'image' is [batch_size, image_height, image_width,\n    // channels].\n    const Tensor& image = context->input(0);\n    // The shape of 'boxes' is [num_boxes, 4].\n    const Tensor& boxes = context->input(1);\n    // The shape of 'box_index' is [num_boxes].\n    const Tensor& box_index = context->input(2);\n    // The shape of 'crop_size' is [2].\n    const Tensor& crop_size = context->input(3);\n\n    // Validate inputs dimensions.\n    OP_REQUIRES_ASYNC(context, image.dims() == 4,\n                      errors::InvalidArgument(\"input image must be 4-D\",\n                                              image.shape().DebugString()),\n                      done);\n    const int batch_size = image.dim_size(0);\n    const int image_height = image.dim_size(1);\n    const int image_width = image.dim_size(2);\n    const int depth = image.dim_size(3);\n    OP_REQUIRES_ASYNC(\n        context, image_height > 0 && image_width > 0,\n        errors::InvalidArgument(\"image dimensions must be positive\"), done);\n    int num_boxes = 0;\n    OP_REQUIRES_OK_ASYNC(\n        context, ParseAndCheckBoxSizes(boxes, box_index, &num_boxes), done);\n\n    OP_REQUIRES_ASYNC(context, crop_size.dims() == 1,\n                      errors::InvalidArgument(\"crop_size must be 1-D\",\n                                              crop_size.shape().DebugString()),\n                      done);\n    OP_REQUIRES_ASYNC(\n        context, crop_size.dim_size(0) == 2,\n        errors::InvalidArgument(\"crop_size must have two elements\",\n                                crop_size.shape().DebugString()),\n        done);\n\n    // Copy and validate crop sizes.\n    auto crop_size_vec = crop_size.vec<int32>();\n    const int crop_height = internal::SubtleMustCopy(crop_size_vec(0));\n    const int crop_width = internal::SubtleMustCopy(crop_size_vec(1));\n    OP_REQUIRES_ASYNC(\n        context, crop_height > 0 && crop_width > 0,\n        errors::InvalidArgument(\"crop dimensions must be positive\"), done);\n\n    // Allocate output tensor.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        context->allocate_output(\n            0, TensorShape({num_boxes, crop_height, crop_width, depth}),\n            &output),\n        done);\n\n    auto compute_callback = [this, context, output]() {\n      const Tensor& image = context->input(0);\n      const Tensor& boxes = context->input(1);\n      const Tensor& box_index = context->input(2);\n      const bool status = functor::CropAndResize<Device, T>()(\n          context, image.tensor<T, 4>(), boxes.tensor<float, 2>(),\n          box_index.tensor<int32, 1>(), method_, extrapolation_value_,\n          output->tensor<float, 4>());\n\n      if (!status) {\n        context->SetStatus(\n            errors::Internal(\"Failed to launch CropAndResizeKernel.\"));\n      }\n    };\n\n    RunIfBoxIndexIsValid<Device>(context, box_index.tensor<int32, 1>(),\n                                 batch_size, std::move(compute_callback),\n                                 std::move(done));\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-41197"
    },
    {
        "index": 115,
        "code": "void carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray,\n                uint64_t _hexArrayLen) {\n\n    CHECK_STATE(d);\n    CHECK_STATE(_hexArray);\n\n    char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    CHECK_STATE(_hexArrayLen > 2 * _len);\n\n    for (int j = 0; j < _len; j++) {\n        _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];\n        _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];\n    }\n\n    _hexArray[_len * 2] = 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 116,
        "code": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-24370"
    },
    {
        "index": 117,
        "code": "static void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tuint16_t handle = 0;\n\tstruct async_write_op *op = NULL;\n\tuint8_t ecode;\n\n\tif (length < 2) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\n\thandle = get_le16(pdu);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Write %s - handle: 0x%04x\",\n\t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\",\n\t\t\t\thandle);\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\top = new0(struct async_write_op, 1);\n\top->chan = chan;\n\top->server = bt_gatt_server_ref(server);\n\top->opcode = opcode;\n\n\tif (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,\n\t\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\t\twrite_complete_cb, op))\n\t\treturn;\n\n\tasync_write_op_destroy(op);\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (opcode == BT_ATT_OP_WRITE_CMD)\n\t\treturn;\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0204"
    },
    {
        "index": 118,
        "code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 14) {\n        n++;\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0717"
    },
    {
        "index": 119,
        "code": "IOBuf::IOBuf(\n    CopyBufferOp op,\n    ByteRange br,\n    std::size_t headroom,\n    std::size_t minTailroom)\n    : IOBuf(op, br.data(), br.size(), headroom, minTailroom) {}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-24036"
    },
    {
        "index": 120,
        "code": "bool SetOpAttrScalar(TFE_Context* ctx, TFE_Op* op, const char* key,\n                     PyObject* py_value, TF_AttrType type,\n                     tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,\n                     TF_Status* status) {\n  if (type == TF_ATTR_STRING) {\n    tensorflow::StringPiece value;\n    if (!ParseStringValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrString(op, key, value.data(), value.size());\n  } else if (type == TF_ATTR_INT) {\n    int64_t value;\n    if (!ParseInt64Value(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrInt(op, key, value);\n    // attr_list_sizes is set for all int attributes (since at this point we are\n    // not aware if that attribute might be used to calculate the size of an\n    // output list or not).\n    if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = value;\n  } else if (type == TF_ATTR_FLOAT) {\n    float value;\n    if (!ParseFloatValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrFloat(op, key, value);\n  } else if (type == TF_ATTR_BOOL) {\n    unsigned char value;\n    if (!ParseBoolValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrBool(op, key, value);\n  } else if (type == TF_ATTR_TYPE) {\n    int value;\n    if (!ParseTypeValue(key, py_value, status, &value)) return false;\n    TFE_OpSetAttrType(op, key, static_cast<TF_DataType>(value));\n  } else if (type == TF_ATTR_SHAPE) {\n    if (py_value == Py_None) {\n      TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n    } else {\n      if (!PySequence_Check(py_value)) {\n        TF_SetStatus(status, TF_INVALID_ARGUMENT,\n                     tensorflow::strings::StrCat(\n                         \"Expecting None or sequence value for attr\", key,\n                         \", got \", py_value->ob_type->tp_name)\n                         .c_str());\n        return false;\n      }\n      const auto num_dims = TensorShapeNumDims(py_value);\n      if (num_dims == -1) {\n        TFE_OpSetAttrShape(op, key, nullptr, -1, status);\n        return true;\n      }\n      std::unique_ptr<int64_t[]> dims(new int64_t[num_dims]);\n      for (int i = 0; i < num_dims; ++i) {\n        tensorflow::Safe_PyObjectPtr inner_py_value(\n            PySequence_ITEM(py_value, i));\n        if (inner_py_value.get() == Py_None) {\n          dims[i] = -1;\n        } else if (!ParseDimensionValue(key, inner_py_value.get(), status,\n                                        &dims[i])) {\n          return false;\n        }\n      }\n      TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);\n    }\n    if (!status->status.ok()) return false;\n  } else if (type == TF_ATTR_FUNC) {\n    // Allow:\n    // (1) String function name, OR\n    // (2) A Python object with a .name attribute\n    //     (A crude test for being a\n    //     tensorflow.python.framework.function._DefinedFunction)\n    //     (which is what the various \"defun\" or \"Defun\" decorators do).\n    // And in the future also allow an object that can encapsulate\n    // the function name and its attribute values.\n    tensorflow::StringPiece func_name;\n    if (!ParseStringValue(key, py_value, status, &func_name)) {\n      PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");\n      if (name_attr == nullptr ||\n          !ParseStringValue(key, name_attr, status, &func_name)) {\n        TF_SetStatus(\n            status, TF_INVALID_ARGUMENT,\n            tensorflow::strings::StrCat(\n                \"unable to set function value attribute from a \",\n                py_value->ob_type->tp_name,\n                \" object. If you think this is an error, please file an issue \"\n                \"at https://github.com/tensorflow/tensorflow/issues/new\")\n                .c_str());\n        return false;\n      }\n    }\n    TF_SetStatus(status, TF_OK, \"\");\n    TFE_OpSetAttrFunctionName(op, key, func_name.data(), func_name.size());\n  } else {\n    TF_SetStatus(\n        status, TF_UNIMPLEMENTED,\n        tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)\n            .c_str());\n    return false;\n  }\n  return true;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29205"
    },
    {
        "index": 121,
        "code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29560"
    },
    {
        "index": 122,
        "code": "static bool w2p(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  bool openwdone = 0;\n  uint8_t *x = 0, *b = 0;\n  png_struct *p = 0;\n  png_info *n = 0;\n  uint8_t i[12];\n  char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",\n    \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};\n  // unsupported feature, suspended, canceled\n  if(!fread(i, 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;\n  // ^ RIFF header size\n  x = malloc(l);\n  if(!x) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_close;\n  }\n  memcpy(x, i, 12); // should optimize out\n  if(!fread(x + 12, l - 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  fclose(fp);\n#if defined LOSSYISERROR || defined NOTHREADS\n  WebPBitstreamFeatures I;\n#else\n  WebPDecoderConfig c = {.options.use_threads = 1};\n#define I c.input\n#endif\n  VP8StatusCode r = WebPGetFeatures(x, l, &I);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#define V I.format\n#define W ((uint32_t)I.width)\n#define H ((uint32_t)I.height)\n#define A I.has_alpha\n#ifdef LOSSYISERROR\n#define FMTSTR\n#define FMTARG\n#define ANMSTR \"%s\"\n#define ANMARG , \"animat\"\n#else\n  char *f[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};\n#define FMTSTR \"\\nFormat: %s\"\n#define FMTARG , f[V]\n#define ANMSTR \"animat\"\n#define ANMARG\n#endif\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,\n    IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);\n  if(I.has_animation) {\n    PF(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);\n    goto w2p_free;\n  }\n#ifdef LOSSYISERROR\n  if(V != 2) {\n    PF(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");\n    goto w2p_free;\n  }\n#endif\n#define B ((unsigned)(3 + A))\n  b = malloc(W * H * B);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_free;\n  }\n#if defined LOSSYISERROR || defined NOTHREADS\n  if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(\n       x, l, b, W * H * B, (int)(W * B))) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_free;\n  }\n#else\n  c.output.colorspace = A ? MODE_RGBA : MODE_RGB;\n  c.output.is_external_memory = 1;\n#define D c.output.u.RGBA\n  D.rgba = b;\n  D.stride = (int)(W * B);\n  D.size = W * H * B;\n  r = WebPDecode(x, l, &c);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#endif\n  free(x);\n  x = 0;\n  if(!(fp = openw(op))) goto w2p_free;\n  openwdone = !!op;\n  p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  w2p_close:\n    fclose(fp);\n  w2p_free:\n    if(openwdone) remove(op);\n    free(x);\n    free(b);\n    png_destroy_write_struct(&p, &n);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_write_fn(p, fp, pngwrite, pngflush);\n  png_set_filter(p, 0, PNG_ALL_FILTERS);\n  png_set_compression_level(p, 9);\n  // png_set_compression_memlevel(p, 9);\n  png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);\n  png_write_info(p, n);\n  uint8_t *w = b;\n  for(unsigned y = H; y; y--) {\n    png_write_row(p, w);\n    w += W * B;\n  }\n  png_write_end(p, n);\n  png_destroy_write_struct(&p, &n);\n  p = 0;\n  n = 0;\n  free(b);\n  b = 0;\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto w2p_free;\n  }\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? \"RGBA\" : \"RGB\", \"\",\n    \"\", 1 / 2.2);\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-36752"
    },
    {
        "index": 123,
        "code": "bool CPlayListASX::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing ASX\");\n\n  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    CXBMCTinyXML xmlDoc;\n    stream >> xmlDoc;\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    // lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;\n    value = pNode->Value();\n    StringUtils::ToLower(value);\n    pNode->SetValue(value);\n    while(pNode)\n    {\n      pChild = pNode->IterateChildren(pChild);\n      if(pChild)\n      {\n        if (pChild->Type() == TiXmlNode::TINYXML_ELEMENT)\n        {\n          value = pChild->Value();\n          StringUtils::ToLower(value);\n          pChild->SetValue(value);\n\n          TiXmlAttribute* pAttr = pChild->ToElement()->FirstAttribute();\n          while(pAttr)\n          {\n            value = pAttr->Name();\n            StringUtils::ToLower(value);\n            pAttr->SetName(value);\n            pAttr = pAttr->Next();\n          }\n        }\n\n        pNode = pChild;\n        pChild = NULL;\n        continue;\n      }\n\n      pChild = pNode;\n      pNode = pNode->Parent();\n    }\n    std::string roottitle;\n    TiXmlElement *pElement = pRootElement->FirstChildElement();\n    while (pElement)\n    {\n      value = pElement->Value();\n      if (value == \"title\" && !pElement->NoChildren())\n      {\n        roottitle = pElement->FirstChild()->ValueStr();\n      }\n      else if (value == \"entry\")\n      {\n        std::string title(roottitle);\n\n        TiXmlElement *pRef = pElement->FirstChildElement(\"ref\");\n        TiXmlElement *pTitle = pElement->FirstChildElement(\"title\");\n\n        if(pTitle && !pTitle->NoChildren())\n          title = pTitle->FirstChild()->ValueStr();\n\n        while (pRef)\n        { // multiple references may appear for one entry\n          // duration may exist on this level too\n          value = XMLUtils::GetAttribute(pRef, \"href\");\n          if (!value.empty())\n          {\n            if(title.empty())\n              title = value;\n\n            CLog::Log(LOGINFO, \"Adding element {}, {}\", title, value);\n            CFileItemPtr newItem(new CFileItem(title));\n            newItem->SetPath(value);\n            Add(newItem);\n          }\n          pRef = pRef->NextSiblingElement(\"ref\");\n        }\n      }\n      else if (value == \"entryref\")\n      {\n        value = XMLUtils::GetAttribute(pElement, \"href\");\n        if (!value.empty())\n        { // found an entryref, let's try loading that url\n          std::unique_ptr<CPlayList> playlist(CPlayListFactory::Create(value));\n          if (nullptr != playlist)\n            if (playlist->Load(value))\n              Add(*playlist);\n        }\n      }\n      pElement = pElement->NextSiblingElement();\n    }\n  }\n\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-42917"
    },
    {
        "index": 124,
        "code": "s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 125,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1452"
    },
    {
        "index": 126,
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2126"
    },
    {
        "index": 127,
        "code": "void IOBuf::decrementRefcount() noexcept {\n  // Externally owned buffers don't have a SharedInfo object and aren't managed\n  // by the reference count\n  SharedInfo* info = sharedInfo();\n  if (!info) {\n    return;\n  }\n\n  // Avoid doing atomic decrement if the refcount is 1.\n  // This is safe, because it means that we're the last reference and destroying\n  // the object. Anything trying to copy it is already undefined behavior.\n  if (info->refcount.load(std::memory_order_acquire) > 1) {\n    // Decrement the refcount\n    uint32_t newcnt = info->refcount.fetch_sub(1, std::memory_order_acq_rel);\n    // Note that fetch_sub() returns the value before we decremented.\n    // If it is 1, we were the only remaining user; if it is greater there are\n    // still other users.\n    if (newcnt > 1) {\n      return;\n    }\n  }\n\n  // save the useHeapFullStorage flag here since\n  // freeExtBuffer can delete the sharedInfo()\n  bool useHeapFullStorage = info->useHeapFullStorage;\n\n  // We were the last user.  Free the buffer\n  freeExtBuffer();\n\n  // Free the SharedInfo if it was allocated separately.\n  //\n  // This is only used by takeOwnership().\n  //\n  // To avoid this special case handling in decrementRefcount(), we could have\n  // takeOwnership() set a custom freeFn() that calls the user's free function\n  // then frees the SharedInfo object.  (This would require that\n  // takeOwnership() store the user's free function with its allocated\n  // SharedInfo object.)  However, handling this specially with a flag seems\n  // like it shouldn't be problematic.\n  if (flags() & kFlagFreeSharedInfo) {\n    delete info;\n  } else {\n    if (useHeapFullStorage) {\n      SharedInfo::releaseStorage(info);\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-24036"
    },
    {
        "index": 128,
        "code": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5204"
    },
    {
        "index": 129,
        "code": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tut32 cnt;\n\tsize_t i;\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (shdr->sh_size < sizeof (Elf_(Verdef)) || shdr->sh_size < sizeof (Elf_(Verdaux))) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n\tif (!defs) {\n\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\tfree (defs);\n\t\treturn false;\n\t}\n\tsize_t shsize = shdr->sh_size;\n\tif (shdr->sh_size > bin->size) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)shdr->sh_size, (int)bin->size);\n\t\t}\n\t\tif (bin->size > shdr->sh_offset) {\n\t\t\tshsize = bin->size - shdr->sh_offset;\n\t\t} else {\n\t\t\tshsize = bin->size;\n\t\t}\n\t}\n\tend = (char *)defs + shsize; //& shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; cnt < shdr->sh_info && i < shdr->sh_size; cnt++) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tif (vstart + sizeof (*verdef) > end) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j);\n\t\tverdef->vd_flags = READ16 (dfs, j);\n\t\tverdef->vd_ndx = READ16 (dfs, j);\n\t\tverdef->vd_cnt = READ16 (dfs, j);\n\t\tverdef->vd_hash = READ32 (dfs, j);\n\t\tverdef->vd_aux = READ32 (dfs, j);\n\t\tverdef->vd_next = READ32 (dfs, j);\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j);\n\t\taux.vda_next = READ32 (vstart, j);\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; j++) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tif (shdr->sh_size - vstart_off < aux.vda_next) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k);\n\t\t\taux.vda_next = READ32 (vstart, k);\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%u\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next || shdr->sh_size - i < verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 130,
        "code": "s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \"irap_or_gdr_pic\");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \"non_ref_pic\");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \"gdr_pic\");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"inter_slice_allowed_flag\")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \"intra_slice_allowed_flag\");\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \"gdr_recovery_count\");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \"ph_extra_bits\");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_present_flag\"))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \"poc_msb_cycle\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 131,
        "code": "composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-25258"
    },
    {
        "index": 132,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableTypeAttribute *lvattr;\n\tut64 offset = 6;\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, 0);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR;\n\tattr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_type_table_attr.local_variable_table = r_list_newf (r_bin_java_local_variable_type_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_type_table_attr.table_length; i++) {\n\t\tut64 curpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableTypeAttribute);\n\t\tif (!lvattr) {\n\t\t\tperror (\"calloc\");\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + 10 > sz) {\n\t\t\teprintf (\"oob\");\n\t\t\tfree (lvattr);\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->signature = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->signature_idx);\n\t\tif (!lvattr->signature) {\n\t\t\tlvattr->signature = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->signature_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_type_table_attr.local_variable_table, lvattr);\n\t}\n\t// IFDBG r_bin_java_print_local_variable_type_table_attr_summary(attr);\n\tattr->size = offset;\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 133,
        "code": "static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3881"
    },
    {
        "index": 134,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45939"
    },
    {
        "index": 135,
        "code": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tut16 *depArray = NULL;\n\t\tcache_imgxtr_t *extras = NULL;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0676"
    },
    {
        "index": 136,
        "code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n\n  // Scale up our output bit depth to the nearest factor of 8\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n  \n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n\n  process( res, layers, x, y, w, h, rawtile.data );\n\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n\n  return rawtile;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 137,
        "code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        /* early config file error processing routines call this */\n        windowprocs.win_wait_synch = def_wait_synch;\n\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5209"
    },
    {
        "index": 138,
        "code": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 139,
        "code": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->symmetric_difference (*other);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45931"
    },
    {
        "index": 140,
        "code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29788"
    },
    {
        "index": 141,
        "code": "static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 142,
        "code": "int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n\n  if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n      LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n      return -1;\n  }\n\n\n\n  uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n\n  if (msgLen < len) {\n        LOG_ERROR(\"Output buffer not large enough\");\n        return -2;\n  }\n\n  sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_key,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n                                                   (unsigned char*) message,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                   NULL, 0,\n                                                   (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n  return status;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 143,
        "code": "MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < 33; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3881"
    },
    {
        "index": 144,
        "code": "R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);\n\tif (!element_value) {\n\t\treturn NULL;\n\t}\n\tRBinJavaElementValuePair *evps = NULL;\n\telement_value->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!element_value->metas) {\n\t\tR_FREE (element_value);\n\t\treturn NULL;\n\t}\n\telement_value->file_offset = buf_offset;\n\telement_value->tag = buffer[offset];\n\telement_value->size += 1;\n\toffset += 1;\n\telement_value->metas->type_info = (void *) r_bin_java_get_ev_meta_from_tag (element_value->tag);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// look up value in bin->cp_list\n\t\t// (ut16) read and set const_value.const_value_idx\n\t\telement_value->value.const_value.const_value_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\t// look-up, deep copy, and set const_value.const_value_cp_obj\n\t\telement_value->value.const_value.const_value_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.const_value.const_value_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// (ut16) read and set enum_const_value.type_name_idx\n\t\telement_value->value.enum_const_value.type_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// (ut16) read and set enum_const_value.const_name_idx\n\t\telement_value->value.enum_const_value.const_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set enum_const_value.const_name_cp_obj\n\t\telement_value->value.enum_const_value.const_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.const_name_idx);\n\t\t// look-up, deep copy, and set enum_const_value.type_name_cp_obj\n\t\telement_value->value.enum_const_value.type_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.type_name_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// (ut16) read and set class_value.class_info_idx\n\t\telement_value->value.class_value.class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set class_value.class_info_cp_obj\n\t\telement_value->value.class_value.class_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.class_value.class_info_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// (ut16) read and set array_value.num_values\n\t\telement_value->value.array_value.num_values = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\telement_value->value.array_value.values = r_list_new ();\n\t\tfor (i = 0; i < element_value->value.array_value.num_values; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaElementValue *ev_element = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (ev_element) {\n\t\t\t\telement_value->size += ev_element->size;\n\t\t\t\toffset += ev_element->size;\n\t\t\t\t// read array_value.num_values, and append to array_value.values\n\t\t\t\tr_list_append (element_value->value.array_value.values, (void *) ev_element);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// annotation new is not used here.\n\t\t// (ut16) read and set annotation_value.type_idx;\n\t\tif (offset + 8 < sz) {\n\t\t\telement_value->value.annotation_value.type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\telement_value->size += 2;\n\t\t\toffset += 2;\n\t\t\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\t\t\telement_value->value.annotation_value.num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\telement_value->size += 2;\n\t\t\toffset += 2;\n\t\t}\n\t\telement_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\t// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs\n\t\tfor (i = 0; i < element_value->value.annotation_value.num_element_value_pairs; i++) {\n\t\t\tif (offset > sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (evps) {\n\t\t\t\telement_value->size += evps->size;\n\t\t\t\toffset += evps->size;\n\t\t\t}\n\t\t\tif (evps == NULL) {\n\t\t\t\t// TODO: eprintf error when reading element pair\n\t\t\t}\n\t\t\tr_list_append (element_value->value.annotation_value.element_value_pairs, (void *) evps);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n\treturn element_value;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 145,
        "code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23308"
    },
    {
        "index": 146,
        "code": "decodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    \n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    \n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n\n    ctx->depth--;\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36429"
    },
    {
        "index": 147,
        "code": "static void test_thumb(void)\n{\n    uc_engine *uc;\n    uc_err err;\n    uc_hook trace1, trace2;\n\n    int sp = 0x1234;     // R0 register\n\n    printf(\"Emulate THUMB code\\n\");\n\n    // Initialize emulator in ARM mode\n    err = uc_open(UC_ARCH_ARM, UC_MODE_THUMB, &uc);\n    if (err) {\n        printf(\"Failed on uc_open() with error returned: %u (%s)\\n\",\n                err, uc_strerror(err));\n        return;\n    }\n\n    // map 2MB memory for this emulation\n    uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL);\n\n    // write machine code to be emulated to memory\n    uc_mem_write(uc, ADDRESS, THUMB_CODE, sizeof(THUMB_CODE) - 1);\n\n    // initialize machine registers\n    uc_reg_write(uc, UC_ARM_REG_SP, &sp);\n\n    // tracing all basic blocks with customized callback\n    uc_hook_add(uc, &trace1, UC_HOOK_BLOCK, hook_block, NULL, 1, 0);\n\n    // tracing one instruction at ADDRESS with customized callback\n    uc_hook_add(uc, &trace2, UC_HOOK_CODE, hook_code, NULL, ADDRESS, ADDRESS);\n\n    // emulate machine code in infinite time (last param = 0), or when\n    // finishing all the code.\n    // Note we start at ADDRESS | 1 to indicate THUMB mode.\n    err = uc_emu_start(uc, ADDRESS | 1, ADDRESS + sizeof(THUMB_CODE) -1, 0, 0);\n    if (err) {\n        printf(\"Failed on uc_emu_start() with error returned: %u\\n\", err);\n    }\n\n    // now print out some registers\n    printf(\">>> Emulation done. Below is the CPU context\\n\");\n\n    uc_reg_read(uc, UC_ARM_REG_SP, &sp);\n    printf(\">>> SP = 0x%x\\n\", sp);\n\n    uc_close(uc);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36979"
    },
    {
        "index": 148,
        "code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-38201"
    },
    {
        "index": 149,
        "code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23308"
    },
    {
        "index": 151,
        "code": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->intersect (*other);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45931"
    },
    {
        "index": 152,
        "code": "find_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1897"
    },
    {
        "index": 153,
        "code": "static bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1437"
    },
    {
        "index": 154,
        "code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 155,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  int embedding_size = 1;\n  int lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const int dim = dense_shape->data.i32[i];\n    lookup_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const int dim = SizeOfDimension(value, i);\n    embedding_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const int output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23559"
    },
    {
        "index": 156,
        "code": "int enc_untrusted_rename(const char *oldpath, const char *newpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_rename,\n                                             oldpath, newpath);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8942"
    },
    {
        "index": 157,
        "code": "static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\t/*\n\t * Count is always specified\n\t */\n\tcount = hextoul(argv[3], NULL);\n\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\t/*\n\t * CRC a byte at a time.  This is going to be slooow, but hey, the\n\t * memories are small and slow too so hopefully nobody notices.\n\t */\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34835"
    },
    {
        "index": 158,
        "code": "void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,\n                                uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(pub_key_x);\n    CHECK_STATE(pub_key_y);\n\n    RANDOM_CHAR_BUF(rand_char, 32);\n\n    mpz_t seed;\n    mpz_init(seed);\n    mpz_t skey;\n    mpz_init(skey);\n\n    point Pkey = point_init();\n\n    mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);\n\n    mpz_mod(skey, seed, curve->p);\n\n    signature_extract_public_key(Pkey, skey, curve);\n\n    SAFE_CHAR_BUF(arr_x, BUF_LEN);\n    mpz_get_str(arr_x, ECDSA_SKEY_BASE, Pkey->x);\n    int n_zeroes = 64 - strlen(arr_x);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_x[i] = '0';\n    }\n\n    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(arr_y, BUF_LEN);\n    mpz_get_str(arr_y, ECDSA_SKEY_BASE, Pkey->y);\n    n_zeroes = 64 - strlen(arr_y);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_y[i] = '0';\n    }\n    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN);SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n    mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);\n    n_zeroes = 64 - strlen(arr_skey_str);\n    for (int i = 0; i < n_zeroes; i++) {\n        skey_str[i] = '0';\n    }\n    strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);\n    skey_str[ECDSA_SKEY_LEN - 1] = 0;\n    snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));\n\n    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);\n    CHECK_STATUS(\"ecdsa private key encryption failed\");\n\n    *enc_len = strlen(skey_str) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");\n\n    SET_SUCCESS\n    clean:\n    mpz_clear(seed);\n    mpz_clear(skey);\n    point_clear(Pkey);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 159,
        "code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n\n    *t = op_def.output_arg(i).experimental_full_type();\n\n    // Resolve dependent types. The convention for op registrations is to use\n    // attributes as type variables.\n    // See https://www.tensorflow.org/guide/create_op#type_polymorphism.\n    // Once the op signature can be defined entirely in FullType, this\n    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n\n        arg->clear_s();\n      }\n    }\n  }\n\n  return ft;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-23570"
    },
    {
        "index": 160,
        "code": "    void WebPImage::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    data   [WEBP_TAG_SIZE*3];\n        DataBuf chunkId(WEBP_TAG_SIZE+1);\n        chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n\n        io_->read(data, WEBP_TAG_SIZE * 3);\n        uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n\n        /* Set up header */\n        if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)\n            throw Error(kerImageWriteFailed);\n\n        /* Parse Chunks */\n        bool has_size  = false;\n        bool has_xmp   = false;\n        bool has_exif  = false;\n        bool has_vp8x  = false;\n        bool has_alpha = false;\n        bool has_icc   = iccProfileDefined();\n\n        int width      = 0;\n        int height     = 0;\n\n        byte       size_buff[WEBP_TAG_SIZE];\n        Blob       blob;\n\n        if (exifData_.count() > 0) {\n            ExifParser::encode(blob, littleEndian, exifData_);\n            if (blob.size() > 0) {\n                has_exif = true;\n            }\n        }\n\n        if (xmpData_.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(xmpPacket_, xmpData_,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        has_xmp = xmpPacket_.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* Verify for a VP8X Chunk First before writing in\n         case we have any exif or xmp data, also check\n         for any chunks with alpha frame/layer set */\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            long size = Exiv2::getULong(size_buff, littleEndian);\n            DataBuf payload(size);\n            io_->read(payload.pData_, payload.size_);\n            byte c;\n            if ( payload.size_ % 2 ) io_->read(&c,1);\n\n            /* Chunk with information about features\n             used in the file. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {\n                has_vp8x = true;\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with with animation control data. */\n#ifdef __CHECK_FOR_ALPHA__  // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANIM) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n\n            /* Chunk with with lossy image data. */\n#ifdef __CHECK_FOR_ALPHA__ // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n                has_size = true;\n                byte size_buf[2];\n\n                /* Refer to this https://tools.ietf.org/html/rfc6386\n                   for height and width reference for VP8 chunks */\n\n                // Fetch width - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n            }\n\n            /* Chunk with with lossless image data. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n                if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n                has_size = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                /* For VP8L chunks width & height are stored in 28 bits\n                   of a 32 bit field requires bitshifting to get actual\n                   sizes. Width and height are split even into 14 bits\n                   each. Refer to this https://goo.gl/bpgMJf */\n\n                // Fetch width - 14 bits wide\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height - 14 bits wide\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] =\n                  ((size_buf_h[0] >> 6) & 0x3) |\n                    ((size_buf_h[1] & 0x3F) << 0x2);\n                size_buf_h[1] =\n                  ((size_buf_h[1] >> 6) & 0x3) |\n                    ((size_buf_h[2] & 0xF) << 0x2);\n                height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            }\n\n            /* Chunk with animation frame. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n                if ((payload.pData_[5] & 0x2) == 0x2) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with alpha data. */\n            if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {\n                has_alpha = true;\n            }\n        }\n\n        /* Inject a VP8X chunk if one isn't available. */\n        if (!has_vp8x) {\n            inject_VP8X(outIo, has_xmp, has_exif, has_alpha,\n                        has_icc, width, height);\n        }\n\n        io_->seek(12, BasicIo::beg);\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, 4);\n            io_->read(size_buff, 4);\n\n            long size = Exiv2::getULong(size_buff, littleEndian);\n\n            DataBuf payload(size);\n            io_->read(payload.pData_, size);\n            if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n                if (has_icc){\n                    payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;\n                }\n\n                if (has_xmp){\n                    payload.pData_[0] |= WEBP_VP8X_XMP_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;\n                }\n\n                if (has_exif) {\n                    payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;\n                }\n\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.tell() % 2) {\n                    if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n                }\n\n                if (has_icc) {\n                    if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);\n                    if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {\n                        throw Error(kerImageWriteFailed);\n                    }\n                    has_icc = false;\n                }\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                // Skip it altogether handle it prior to here :)\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                // Skip and add new data afterwards\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                // Skip and add new data afterwards\n            } else {\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n            }\n\n            // Encoder required to pad odd sized data with a null byte\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_exif) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            us2Data(data, (uint16_t) blob.size()+8, bigEndian);\n            ul2Data(data, (uint32_t) blob.size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())\n            {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_xmp) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        // Fix File Size Payload Data\n        outIo.seek(0, BasicIo::beg);\n        filesize = outIo.size() - 8;\n        outIo.seek(4, BasicIo::beg);\n        ul2Data(data, (uint32_t) filesize, littleEndian);\n        if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n\n    } // WebPImage::writeMetadata\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29463"
    },
    {
        "index": 161,
        "code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t//\tbin->phdr[i].p_flags |= 1; tiny.elf needs this somehow :? LOAD0 is always +x for linux?\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\t/* Here is the where all the fun starts.\n\t * Linux kernel since 2005 calculates phdr offset wrongly\n\t * adding it to the load address (va of the LOAD0).\n\t * See `fs/binfmt_elf.c` file this line:\n\t *    NEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\t * So after the first read, we fix the address and read it again\n\t */\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 162,
        "code": "static uint8_t authorize_req(struct bt_gatt_server *server,\n\t\t\t\t\tuint8_t opcode, uint16_t handle)\n{\n\tif (!server->authorize)\n\t\treturn 0;\n\n\treturn server->authorize(server->att, opcode, handle,\n\t\t\t\t\t\tserver->authorize_data);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0204"
    },
    {
        "index": 163,
        "code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  // Special cases.\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    // Invariant: Both values are known and greater than 1.\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-29203"
    },
    {
        "index": 164,
        "code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n\n  return context->ResizeTensor(context, output, output_dims);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37685"
    },
    {
        "index": 165,
        "code": "nodeVPop(xmlValidCtxtPtr ctxt)\n{\n    xmlNodePtr ret;\n\n    if (ctxt->nodeNr <= 0)\n        return (NULL);\n    ctxt->nodeNr--;\n    if (ctxt->nodeNr > 0)\n        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];\n    else\n        ctxt->node = NULL;\n    ret = ctxt->nodeTab[ctxt->nodeNr];\n    ctxt->nodeTab[ctxt->nodeNr] = NULL;\n    return (ret);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23308"
    },
    {
        "index": 166,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29590"
    },
    {
        "index": 167,
        "code": "static int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (fdc_state[current_fdc].rawcmd <= 1)\n\t\tfdc_state[current_fdc].rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != current_fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (drive_state[drive].fd_ref > 1) {\n\t\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (drive_state[drive].fd_ref) {\n\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && fdc_state[current_fdc].reset)\n\t\tret = -EIO;\n\n\tdrive_state[current_drive].track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-33981"
    },
    {
        "index": 168,
        "code": "njs_vm_start(njs_vm_t *vm)\n{\n    njs_int_t  ret;\n\n    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-25139"
    },
    {
        "index": 169,
        "code": "pixReadFromTiffStream(TIFF  *tif)\n{\nchar      *text;\nl_uint8   *linebuf, *data, *rowptr;\nl_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\nl_int32    xres, yres, tiffbpl, packedbpl, halfsize;\nl_uint32   w, h, tiffword, read_oriented;\nl_uint32  *line, *ppixel, *tiffdata, *pixdata;\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n    read_oriented = 0;\n\n        /* Only accept uint image data:\n         *   SAMPLEFORMAT_UINT = 1;\n         *   SAMPLEFORMAT_INT = 2;\n         *   SAMPLEFORMAT_IEEEFP = 3;\n         *   SAMPLEFORMAT_VOID = 4;   */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n    if (sample_fmt != SAMPLEFORMAT_UINT) {\n        L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n        return NULL;\n    }\n\n        /* Can't read tiff in tiled format. For what is involved, see, e.g:\n         *   https://www.cs.rochester.edu/~nelson/courses/vision/\\\n         *     resources/tiff/libtiff.html#Tiles\n         * A tiled tiff can be converted to a normal (strip) tif:\n         *   tiffcp -s <input-tiled-tif> <output-strip-tif>    */\n    if (TIFFIsTiled(tif)) {\n        L_ERROR(\"tiled format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Old style jpeg is not supported.  We tried supporting 8 bpp.\n         * TIFFReadScanline() fails on this format, so we used RGBA\n         * reading, which generates a 4 spp image, and pulled out the\n         * red component.  However, there were problems with double-frees\n         * in cleanup.  For RGB, tiffbpl is exactly half the size that\n         * you would expect for the raster data in a scanline, which\n         * is 3 * w.  */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    if (tiffcomp == COMPRESSION_OJPEG) {\n        L_ERROR(\"old style jpeg format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n        L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n        return NULL;\n    }\n    if (spp == 2 && bps != 8) {\n        L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n        return NULL;\n    }\n    if (spp == 1)\n        d = bps;\n    else if (spp == 2)  /* gray plus alpha */\n        d = 32;  /* will convert to RGBA */\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    if (w > MaxTiffWidth) {\n        L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n        return NULL;\n    }\n    if (h > MaxTiffHeight) {\n        L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n        return NULL;\n    }\n\n        /* The relation between the size of a byte buffer required to hold\n           a raster of image pixels (packedbpl) and the size of the tiff\n           buffer (tiffbuf) is either 1:1 or approximately 2:1, depending\n           on how the data is stored and subsampled.  Allow some slop\n           when validating the relation between buffer size and the image\n           parameters w, spp and bps. */\n    tiffbpl = TIFFScanlineSize(tif);\n    packedbpl = (bps * spp * w + 7) / 8;\n    halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;\n#if 0\n    if (halfsize)\n        L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,\n               packedbpl, tiffbpl);\n#endif\n    if (tiffbpl != packedbpl && !halfsize) {\n        L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \"\n                \"bps = %d, spp = %d, w = %d\\n\",\n                procName, tiffbpl, packedbpl, bps, spp, w);\n        return NULL;\n    }\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    pixSetInputFormat(pix, IFF_TIFF);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n    if (spp == 1) {\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy(data, linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        LEPT_FREE(linebuf);\n    } else if (spp == 2 && bps == 8) {  /* gray plus alpha */\n        L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n        pixSetSpp(pix, 4);\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        pixdata = pixGetData(pix);\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            rowptr = linebuf;\n            ppixel = pixdata + i * wpl;\n            for (j = k = 0; j < w; j++) {\n                    /* Copy gray value into r, g and b */\n                SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                ppixel++;\n            }\n        }\n        LEPT_FREE(linebuf);\n    } else {  /* rgb and rgba */\n        if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                 sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n            /* TIFFReadRGBAImageOriented() converts to 8 bps */\n        if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            LEPT_FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        } else {\n            read_oriented = 1;\n        }\n\n        if (spp == 4) pixSetSpp(pix, 4);\n        line = pixGetData(pix);\n        for (i = 0; i < h; i++, line += wpl) {\n            for (j = 0, ppixel = line; j < w; j++) {\n                    /* TIFFGet* are macros */\n                tiffword = tiffdata[i * w + j];\n                rval = TIFFGetR(tiffword);\n                gval = TIFFGetG(tiffword);\n                bval = TIFFGetB(tiffword);\n                if (spp == 3) {\n                    composeRGBPixel(rval, gval, bval, ppixel);\n                } else {  /* spp == 4 */\n                    aval = TIFFGetA(tiffword);\n                    composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                }\n                ppixel++;\n            }\n        }\n        LEPT_FREE(tiffdata);\n    }\n\n    if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if (bps > 8) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n        }\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        if (pixSetColormap(pix, cmap)) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n        }\n\n            /* Remove the colormap for 1 bpp. */\n        if (bps == 1) {\n            pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            pixDestroy(&pix);\n            pix = pix1;\n        }\n    } else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            } else {\n                photometry = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform = (read_oriented) ?\n                &tiff_partial_orientation_transforms[orientation - 1] :\n                &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    text = NULL;\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n    if (text) pixSetText(pix, text);\n    return pix;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36280"
    },
    {
        "index": 170,
        "code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-46822"
    },
    {
        "index": 171,
        "code": "static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 172,
        "code": "  void CreateNgrams(const tstring* data, tstring* output, int num_ngrams,\n                    int ngram_width) const {\n    for (int ngram_index = 0; ngram_index < num_ngrams; ++ngram_index) {\n      int pad_width = get_pad_width(ngram_width);\n      int left_padding = std::max(0, pad_width - ngram_index);\n      int right_padding =\n          std::max(0, pad_width - (num_ngrams - (ngram_index + 1)));\n      int num_tokens = ngram_width - (left_padding + right_padding);\n      int data_start_index = left_padding > 0 ? 0 : ngram_index - pad_width;\n\n      // Calculate the total expected size of the ngram so we can reserve the\n      // correct amount of space in the string.\n      int ngram_size = 0;\n      // Size of the left padding.\n      ngram_size += left_padding * left_pad_.length();\n      // Size of the tokens.\n      for (int n = 0; n < num_tokens; ++n) {\n        ngram_size += data[data_start_index + n].length();\n      }\n      // Size of the right padding.\n      ngram_size += right_padding * right_pad_.length();\n      // Size of the separators.\n      int num_separators = left_padding + right_padding + num_tokens - 1;\n      ngram_size += num_separators * separator_.length();\n\n      // Build the ngram.\n      tstring* ngram = &output[ngram_index];\n      ngram->reserve(ngram_size);\n      for (int n = 0; n < left_padding; ++n) {\n        ngram->append(left_pad_);\n        ngram->append(separator_);\n      }\n      for (int n = 0; n < num_tokens - 1; ++n) {\n        ngram->append(data[data_start_index + n]);\n        ngram->append(separator_);\n      }\n      ngram->append(data[data_start_index + num_tokens - 1]);\n      for (int n = 0; n < right_padding; ++n) {\n        ngram->append(separator_);\n        ngram->append(right_pad_);\n      }\n\n      // In debug mode only: validate that we've reserved enough space for the\n      // ngram.\n      DCHECK_EQ(ngram_size, ngram->size());\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29542"
    },
    {
        "index": 173,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    // This call processes inputs 1 and 2 to write output 0.\n    ReshapeOp::Compute(ctx);\n\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29536"
    },
    {
        "index": 174,
        "code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29606"
    },
    {
        "index": 175,
        "code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8937"
    },
    {
        "index": 176,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45933"
    },
    {
        "index": 177,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        regs[a] = mrb_hash_get(mrb, va, vb);\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      regs[a] = mrb_vm_const_get(mrb, syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      regs[a] = mrb_hash_get(mrb, kdict, k);\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      size_t len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_assert(mrb_hash_p(hash));\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0623"
    },
    {
        "index": 178,
        "code": "static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3889"
    },
    {
        "index": 179,
        "code": "read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tstatic uint32_t fru_data_rqst_size = 20;\n\tuint32_t off = offset, tmp, finish;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n#ifdef LIMIT_ALL_REQUEST_SIZE\n\tif (fru_data_rqst_size > 16)\n#else\n\tif (fru->access && fru_data_rqst_size > 16)\n#endif\n\t\tfru_data_rqst_size = 16;\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru_data_rqst_size)\n\t\t\tmsg_data[3] = (uint8_t)fru_data_rqst_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7 or C8  or CA return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) {\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\"Retrying FRU read with request size %d\",\n\t\t\t\t\tfru_data_rqst_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tmemcpy((frubuf + off)-offset, rsp->data + 1, tmp);\n\t\toff += tmp;\n\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish)\n\t\t\treturn 0;\n\n\t} while (off < finish);\n\n\tif (off < finish)\n\t\treturn -1;\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5208"
    },
    {
        "index": 180,
        "code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 181,
        "code": "static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"temporal_id_nesting_flag\");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \"update_rep_format_flag\");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \"rep_format_idx\");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\t\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\"))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_luma_minus8\");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_chroma_minus8\");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \"log2_max_pic_order_cnt_lsb_minus4\");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"sub_layer_ordering_info_present_flag\");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_dec_pic_buffering\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_latency_increase\", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \"log2_min_luma_coding_block_size_minus3\");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_luma_coding_block_size\");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \"log2_min_transform_block_size_minus2\");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \"log2_max_transform_block_size\");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_inter\");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_intra\");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_enable_flag\");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \"infer_scaling_list_flag\");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \"scaling_list_ref_layer_id\");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_data_present_flag\");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \"asymmetric_motion_partitions_enabled_flag\");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \"sample_adaptive_offset_enabled_flag\");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \"pcm_enabled_flag\")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_luma_minus1\");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_chroma_minus1\");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \"log2_min_pcm_luma_coding_block_size_minus3\");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_pcm_luma_coding_block_size\");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \"pcm_loop_filter_disable_flag\");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \"num_short_term_ref_pic_sets\");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \"long_term_ref_pics_present_flag\");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \"num_long_term_ref_pic_sps\");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"lt_ref_pic_poc_lsb_sps\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \"used_by_curr_pic_lt_sps_flag\", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \"temporal_mvp_enable_flag\");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \"strong_intra_smoothing_enable_flag\");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \"aspect_ratio_width\");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \"aspect_ratio_height\");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \"overscan_info_present\")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \"overscan_appropriate\");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\"))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \"transfer_characteristic\");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \"chroma_loc_info_present_flag\"))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_top_field\");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_bottom_field\");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \"neutra_chroma_indication_flag\");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \"field_seq_flag\");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \"frame_field_info_present_flag\");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \"default_display_window_flag\"))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \"display_window_left_offset\");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \"display_window_right_offset\");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \"display_window_top_offset\");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \"display_window_bottom_offset\");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \"has_timing_info\");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \"poc_proportional_to_timing_flag\");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \"num_ticks_poc_diff_one_minus1\");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"hrd_parameters_present_flag\"))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"bitstream_restriction_flag\")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"tiles_fixed_structure_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"motion_vectors_over_pic_boundaries_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"restricted_ref_pic_lists_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"min_spatial_segmentation_idc\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bytes_per_pic_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bits_per_min_cu_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_horizontal\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_vertical\");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"sps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 182,
        "code": "static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"temporal_id_nesting_flag\");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \"update_rep_format_flag\");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \"rep_format_idx\");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\t\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\"))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_luma_minus8\");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_chroma_minus8\");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \"log2_max_pic_order_cnt_lsb_minus4\");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"sub_layer_ordering_info_present_flag\");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_dec_pic_buffering\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_latency_increase\", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \"log2_min_luma_coding_block_size_minus3\");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_luma_coding_block_size\");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \"log2_min_transform_block_size_minus2\");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \"log2_max_transform_block_size\");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_inter\");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_intra\");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_enable_flag\");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \"infer_scaling_list_flag\");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \"scaling_list_ref_layer_id\");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_data_present_flag\");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \"asymmetric_motion_partitions_enabled_flag\");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \"sample_adaptive_offset_enabled_flag\");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \"pcm_enabled_flag\")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_luma_minus1\");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_chroma_minus1\");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \"log2_min_pcm_luma_coding_block_size_minus3\");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_pcm_luma_coding_block_size\");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \"pcm_loop_filter_disable_flag\");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \"num_short_term_ref_pic_sets\");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \"long_term_ref_pics_present_flag\");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \"num_long_term_ref_pic_sps\");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"lt_ref_pic_poc_lsb_sps\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \"used_by_curr_pic_lt_sps_flag\", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \"temporal_mvp_enable_flag\");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \"strong_intra_smoothing_enable_flag\");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \"aspect_ratio_width\");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \"aspect_ratio_height\");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \"overscan_info_present\")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \"overscan_appropriate\");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\"))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \"transfer_characteristic\");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \"chroma_loc_info_present_flag\"))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_top_field\");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_bottom_field\");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \"neutra_chroma_indication_flag\");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \"field_seq_flag\");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \"frame_field_info_present_flag\");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \"default_display_window_flag\"))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \"display_window_left_offset\");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \"display_window_right_offset\");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \"display_window_top_offset\");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \"display_window_bottom_offset\");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \"has_timing_info\");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \"poc_proportional_to_timing_flag\");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \"num_ticks_poc_diff_one_minus1\");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"hrd_parameters_present_flag\"))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"bitstream_restriction_flag\")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"tiles_fixed_structure_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"motion_vectors_over_pic_boundaries_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"restricted_ref_pic_lists_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"min_spatial_segmentation_idc\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bytes_per_pic_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bits_per_min_cu_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_horizontal\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_vertical\");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"sps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 183,
        "code": "GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_ChunkOffsetBox *stco;\n\tGF_SampleToChunkBox *stsc;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\tu32 i, k, *newOff, new_chunk_idx=0;\n\tu64 *newLarge;\n\ts32 insert_idx = -1;\n\n\tstbl = mdia->information->sampleTable;\n\tstsc = stbl->SampleToChunk;\n\n//\tif (stsc->w_lastSampleNumber + 1 < sampleNumber ) return GF_BAD_PARAM;\n\tif (!nb_pack_samples)\n\t\tnb_pack_samples = 1;\n\n\tif (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {\n\t\tif (!stsc->alloc_size) stsc->alloc_size = 1;\n\t\tALLOC_INC(stsc->alloc_size);\n\t\tstsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);\n\t\tif (!stsc->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );\n\t}\n\tif (sampleNumber == stsc->w_lastSampleNumber + 1) {\n\t\tent = &stsc->entries[stsc->nb_entries];\n\t\tstsc->w_lastChunkNumber ++;\n\t\tent->firstChunk = stsc->w_lastChunkNumber;\n\t\tif (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;\n\n\t\tnew_chunk_idx = stsc->w_lastChunkNumber;\n\t\tstsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1;\n\t\tstsc->nb_entries += 1;\n\t} else {\n\t\tu32 cur_samp = 1;\n\t\tu32 samples_in_next_entry = 0;\n\t\tu32 next_entry_first_chunk = 1;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tu32 nb_chunks = 1;\n\t\t\tent = &stsc->entries[i];\n\t\t\tif (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;\n\t\t\tfor (k=0; k<nb_chunks; k++) {\n\t\t\t\tif ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {\n\t\t\t\t\tinsert_idx = i;\n\t\t\t\t\t//stsc entry has samples before inserted sample, split\n\t\t\t\t\tif (sampleNumber>cur_samp) {\n\t\t\t\t\t\tsamples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);\n\t\t\t\t\t\tent->samplesPerChunk = sampleNumber-cur_samp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_samp += ent->samplesPerChunk;\n\t\t\t\tnext_entry_first_chunk++;\n\t\t\t}\n\t\t\tif (insert_idx>=0) break;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (samples_in_next_entry) {\n\t\t\tmemmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));\n\t\t\t//copy over original entry\n\t\t\tent = &stsc->entries[insert_idx];\n\t\t\tstsc->entries[insert_idx+2] = *ent;\n\t\t\tstsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;\n\t\t\tstsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;\n\n\t\t\t//setup new entry\n\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\n\t\t\tstsc->nb_entries += 2;\n\t\t} else {\n\t\t\tif (insert_idx<0) {\n\t\t\t\tent = &stsc->entries[stsc->nb_entries];\n\t\t\t\tinsert_idx = stsc->nb_entries;\n\t\t\t} else {\n\t\t\t\tmemmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));\n\t\t\t\tent = &stsc->entries[insert_idx+1];\n\t\t\t}\n\n\t\t\tent->firstChunk = next_entry_first_chunk;\n\t\t\tstsc->nb_entries += 1;\n\t\t}\n\t\tnew_chunk_idx = next_entry_first_chunk;\n\t}\n\tent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;\n\tent->sampleDescriptionIndex = StreamDescIndex;\n\tent->samplesPerChunk = nb_pack_samples;\n\tent->nextChunk = ent->firstChunk+1;\n\n\t//OK, now if we've inserted a chunk, update the sample to chunk info...\n\tif (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) {\n\t\tif (stsc->nb_entries)\n\t\t\tstsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;\n\n\t\tstbl->SampleToChunk->currentIndex = stsc->nb_entries-1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;\n\t\t//write - edit mode: sample number = chunk number\n\t\tstbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t} else {\n\t\t/*offset remaining entries*/\n\t\tfor (i = insert_idx+1; i<stsc->nb_entries+1; i++) {\n\t\t\tstsc->entries[i].firstChunk++;\n\t\t\tif (i+1<stsc->nb_entries)\n\t\t\t\tstsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;\n\t\t}\n\t}\n\n\t//add the offset to the chunk...\n\t//and we change our offset\n\tif (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t//if the new offset is a large one, we have to rewrite our table entry by entry (32->64 bit conv)...\n\t\tif (offset > 0xFFFFFFFF) {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);\n\t\t\tif (!co64) return GF_OUT_OF_MEM;\n\t\t\tco64->nb_entries = stco->nb_entries + 1;\n\t\t\tco64->alloc_size = co64->nb_entries;\n\t\t\tco64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);\n\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\tk = 0;\n\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\tif (i + 1 == new_chunk_idx) {\n\t\t\t\t\tco64->offsets[i] = offset;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\tco64->offsets[i+k] = (u64) stco->offsets[i];\n\t\t\t}\n\t\t\tif (!k) co64->offsets[co64->nb_entries - 1] = offset;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);\n\t\t\tstbl->ChunkOffset = (GF_Box *) co64;\n\t\t} else {\n\t\t\t//no, we can use this one.\n\t\t\tif (new_chunk_idx > stco->nb_entries) {\n\t\t\t\tif (!stco->alloc_size) stco->alloc_size = stco->nb_entries;\n\t\t\t\tif (stco->nb_entries == stco->alloc_size) {\n\t\t\t\t\tALLOC_INC(stco->alloc_size);\n\t\t\t\t\tstco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);\n\t\t\t\t\tif (!stco->offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );\n\t\t\t\t}\n\t\t\t\tstco->offsets[stco->nb_entries] = (u32) offset;\n\t\t\t\tstco->nb_entries += 1;\n\t\t\t} else {\n\t\t\t\t//nope. we're inserting\n\t\t\t\tnewOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));\n\t\t\t\tif (!newOff) return GF_OUT_OF_MEM;\n\t\t\t\tk=0;\n\t\t\t\tfor (i=0; i<stco->nb_entries; i++) {\n\t\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\t\tnewOff[i] = (u32) offset;\n\t\t\t\t\t\tk=1;\n\t\t\t\t\t}\n\t\t\t\t\tnewOff[i+k] = stco->offsets[i];\n\t\t\t\t}\n\t\t\t\tgf_free(stco->offsets);\n\t\t\t\tstco->offsets = newOff;\n\t\t\t\tstco->nb_entries ++;\n\t\t\t\tstco->alloc_size = stco->nb_entries;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//use large offset...\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (sampleNumber > co64->nb_entries) {\n\t\t\tif (!co64->alloc_size) co64->alloc_size = co64->nb_entries;\n\t\t\tif (co64->nb_entries == co64->alloc_size) {\n\t\t\t\tALLOC_INC(co64->alloc_size);\n\t\t\t\tco64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);\n\t\t\t\tif (!co64->offsets) return GF_OUT_OF_MEM;\n\t\t\t\tmemset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );\n\t\t\t}\n\t\t\tco64->offsets[co64->nb_entries] = offset;\n\t\t\tco64->nb_entries += 1;\n\t\t} else {\n\t\t\t//nope. we're inserting\n\t\t\tnewLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));\n\t\t\tif (!newLarge) return GF_OUT_OF_MEM;\n\t\t\tk=0;\n\t\t\tfor (i=0; i<co64->nb_entries; i++) {\n\t\t\t\tif (i+1 == new_chunk_idx) {\n\t\t\t\t\tnewLarge[i] = offset;\n\t\t\t\t\tk=1;\n\t\t\t\t}\n\t\t\t\tnewLarge[i+k] = co64->offsets[i];\n\t\t\t}\n\t\t\tgf_free(co64->offsets);\n\t\t\tco64->offsets = newLarge;\n\t\t\tco64->nb_entries++;\n\t\t\tco64->alloc_size++;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 184,
        "code": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1785"
    },
    {
        "index": 185,
        "code": "MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute value beginning */\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            /* now go forward */\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1908"
    },
    {
        "index": 186,
        "code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t// this is the \"new\" ABI, the old was reverse order\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\n\t\t\"gpr\tpc\t.16 0 0\\n\" // same as r0\n\t\t\"gpr\tsp\t.16 2 0\\n\" // same as r1\n\t\t\"flg\tsr\t.16 4 0\\n\" // same as r2\n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t// between is SCG1 SCG0 OSOFF CPUOFF GIE\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 187,
        "code": "win_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows );\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0319"
    },
    {
        "index": 188,
        "code": "_dwarf_fix_up_offset_irix(Dwarf_Debug dbg,\n    Dwarf_Unsigned * varp, char *caller_site_name)\n{\n\n    Dwarf_Unsigned var = *varp;\n\n#define UPPER33 0xffffffff80000000LL\n#define LOWER32         0xffffffffLL\n    /*  Restrict the hack to the known case. Upper 32 bits erroneously\n        sign extended from lower 32 upper bit. */\n    if ((var & UPPER33) == UPPER33) {\n        var &= LOWER32;\n        /* Apply the fix. Dreadful hack. */\n        *varp = var;\n    }\n#undef UPPER33\n#undef LOWER32\n    return;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-32200"
    },
    {
        "index": 189,
        "code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29379"
    },
    {
        "index": 190,
        "code": "static void parse_rtcp_report( pjmedia_rtcp_session *sess,\n\t\t\t       const void *pkt,\n\t\t\t       pj_size_t size)\n{\n    pjmedia_rtcp_common *common = (pjmedia_rtcp_common*) pkt;\n    const pjmedia_rtcp_rr *rr = NULL;\n    const pjmedia_rtcp_sr *sr = NULL;\n    pj_uint32_t last_loss, jitter_samp, jitter;\n\n    /* Parse RTCP */\n    if (common->pt == RTCP_SR) {\n\tsr = (pjmedia_rtcp_sr*) (((char*)pkt) + sizeof(pjmedia_rtcp_common));\n\tif (common->count > 0 && size >= (sizeof(pjmedia_rtcp_sr_pkt))) {\n\t    rr = (pjmedia_rtcp_rr*)(((char*)pkt) + (sizeof(pjmedia_rtcp_common)\n\t\t\t\t    + sizeof(pjmedia_rtcp_sr)));\n\t}\n    } else if (common->pt == RTCP_RR && common->count > 0) {\n\trr = (pjmedia_rtcp_rr*)(((char*)pkt) + sizeof(pjmedia_rtcp_common));\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n    } else if (common->pt == RTCP_XR) {\n\tif (sess->xr_enabled)\n\t    pjmedia_rtcp_xr_rx_rtcp_xr(&sess->xr_session, pkt, size);\n\n\treturn;\n#endif\n    }\n\n\n    if (sr) {\n\t/* Save LSR from NTP timestamp of RTCP packet */\n\tsess->rx_lsr = ((pj_ntohl(sr->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(sr->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate SR arrival time for DLSR */\n\tpj_get_timestamp(&sess->rx_lsr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", \n\t\tsess->rx_lsr,\n\t\t(pj_uint32_t)(sess->rx_lsr_time.u64*65536/sess->ts_freq.u64)));\n    }\n\n\n    /* Nothing more to do if there's no RR packet */\n    if (rr == NULL)\n\treturn;\n\n\n    last_loss = sess->stat.tx.loss;\n\n    /* Get packet loss */\n    sess->stat.tx.loss = (rr->total_lost_2 << 16) +\n\t\t\t (rr->total_lost_1 << 8) +\n\t\t\t  rr->total_lost_0;\n\n    TRACE_((sess->name, \"Rx RTCP RR: total_lost_2=%x, 1=%x, 0=%x, lost=%d\", \n\t    (int)rr->total_lost_2,\n\t    (int)rr->total_lost_1,\n\t    (int)rr->total_lost_0,\n\t    sess->stat.tx.loss));\n    \n    /* We can't calculate the exact loss period for TX, so just give the\n     * best estimation.\n     */\n    if (sess->stat.tx.loss > last_loss) {\n\tunsigned period;\n\n\t/* Loss period in msec */\n\tperiod = (sess->stat.tx.loss - last_loss) * sess->pkt_size *\n\t\t 1000 / sess->clock_rate;\n\n\t/* Loss period in usec */\n\tperiod *= 1000;\n\n\t/* Update loss period stat */\n\tpj_math_stat_update(&sess->stat.tx.loss_period, period);\n    }\n\n    /* Get jitter value in usec */\n    jitter_samp = pj_ntohl(rr->jitter);\n    /* Calculate jitter in usec, avoiding overflows */\n    if (jitter_samp <= 4294)\n\tjitter = jitter_samp * 1000000 / sess->clock_rate;\n    else {\n\tjitter = jitter_samp * 1000 / sess->clock_rate;\n\tjitter *= 1000;\n    }\n\n    /* Update jitter statistics */\n    pj_math_stat_update(&sess->stat.tx.jitter, jitter);\n\n    /* Can only calculate if LSR and DLSR is present in RR */\n    if (rr->lsr && rr->dlsr) {\n\tpj_uint32_t lsr, now, dlsr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LSR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlsr = pj_ntohl(rr->lsr);\n\n\t/* DLSR is delay since LSR, also in 1/65536 resolution */\n\tdlsr = pj_ntohl(rr->dlsr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lsr-dlsr) */\n\teedelay = now - lsr - dlsr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP RR: lsr=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlsr, dlsr, dlsr/65536, (dlsr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lsr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlsr >= lsr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay > 30 * 1000 * 1000UL) {\n\n\t\tTRACE_((sess->name, \"RTT not making any sense, ignored..\"));\n\t\tgoto end_rtt_calc;\n\t    }\n\n#if defined(PJMEDIA_RTCP_NORMALIZE_FACTOR) && PJMEDIA_RTCP_NORMALIZE_FACTOR!=0\n\t    /* \"Normalize\" rtt value that is exceptionally high. For such\n\t     * values, \"normalize\" the rtt to be PJMEDIA_RTCP_NORMALIZE_FACTOR\n\t     * times the average value.\n\t     */\n\t    if (rtt > ((unsigned)sess->stat.rtt.mean *\n\t\t       PJMEDIA_RTCP_NORMALIZE_FACTOR) && sess->stat.rtt.n!=0)\n\t    {\n\t\tunsigned orig_rtt = rtt;\n\t\trtt = sess->stat.rtt.mean * PJMEDIA_RTCP_NORMALIZE_FACTOR;\n\t\tPJ_LOG(5,(sess->name,\n\t\t\t  \"RTT value %d usec is normalized to %d usec\",\n\t\t\t  orig_rtt, rtt));\n\t    }\n#endif\n\t    TRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\n\t    /* Update RTT stat */\n\t    pj_math_stat_update(&sess->stat.rtt, rtt);\n\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lsr=%p, now=%p, dlsr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lsr, now, dlsr, dlsr/65536,\n\t\t\t\t   (dlsr%65536)*1000/65536,\n\t\t\t\t   dlsr-(now-lsr)));\n\t}\n    }\n\nend_rtt_calc:\n\n    pj_gettimeofday(&sess->stat.tx.update);\n    sess->stat.tx.update_cnt++;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21722"
    },
    {
        "index": 191,
        "code": "normal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n#ifdef FEAT_CMDL_INFO\n    need_flushbuf = add_to_showcmd(c);\n#endif\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))\n    {\n\t// This command is not allowed while editing a cmdline: beep.\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\tgoto normal_end;\n    }\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked())\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n#ifdef FEAT_CMDL_INFO\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n#endif\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n#ifdef FEAT_CMDL_INFO\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n#endif\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1897"
    },
    {
        "index": 193,
        "code": "void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,\n                                 uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t privateKeyMpz;\n    mpz_init(privateKeyMpz);\n    point pKey = point_init();\n\n    point pKey_test = point_init();\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(pub_key_x);\n    CHECK_STATE(pub_key_y);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n    CHECK_STATUS2(\"AES_decrypt failed with status %d\");\n\n    skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n    strncpy(errString, skey, 1024);\n\n    status = mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE);\n\n    CHECK_STATUS(\"mpz_set_str failed for private key\");\n\n    signature_extract_public_key(pKey, privateKeyMpz, curve);\n\n\n    point_multiplication(pKey_test, privateKeyMpz, curve->G, curve);\n\n    if (!point_cmp(pKey, pKey_test)) {\n        snprintf(errString, BUF_LEN, \"Points are not equal\");\n        LOG_ERROR(errString);\n        *errStatus = -11;\n        goto clean;\n    }\n\n    SAFE_CHAR_BUF(arr_x, BUF_LEN);\n    mpz_get_str(arr_x, ECDSA_SKEY_BASE, pKey->x);\n\n    int n_zeroes = 64 - strlen(arr_x);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_x[i] = '0';\n    }\n\n    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(arr_y, BUF_LEN);\n    mpz_get_str(arr_y, ECDSA_SKEY_BASE, pKey->y);\n\n    n_zeroes = 64 - strlen(arr_y);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_y[i] = '0';\n    }\n    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n\n    SET_SUCCESS\n    clean:\n    mpz_clear(privateKeyMpz);\n    point_clear(pKey);\n    point_clear(pKey_test);\n\n    static uint64_t counter = 0;\n\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 194,
        "code": "void luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  /* \"all\" values already concatenated */\n  do {\n    StkId top = L->top;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  /* second operand is empty? */\n      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */\n    else if (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      /* collect total length and number of strings */\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */\n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  /* copy strings to buffer */\n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  /* long string; copy strings directly to final result */\n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  /* create result */\n    }\n    total -= n-1;  /* got 'n' strings to create 1 new */\n    L->top -= n-1;  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-33099"
    },
    {
        "index": 195,
        "code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-28874"
    },
    {
        "index": 196,
        "code": "R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\t// RBinJavaLocalVariableTypeAttribute *lvattr;\n\tRListIter *iter;\n\tut64 size = 0;\n\tif (attr) {\n\t\tRList *list = attr->info.local_variable_type_table_attr.local_variable_table;\n\t\tsize += 6;\n\t\t// attr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// r_list_foreach (list, iter, lvattr) {\n\t\tr_list_foreach_iter (list, iter) {\n\t\t\t// lvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t}\n\treturn size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 197,
        "code": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-38160"
    },
    {
        "index": 198,
        "code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36978"
    },
    {
        "index": 199,
        "code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n\n    if (!server || !prefix)\n        return;\n\n    /* free previous values */\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    /* assign new values */\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-9760"
    },
    {
        "index": 200,
        "code": "static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1586"
    },
    {
        "index": 201,
        "code": "void Transform::interpolate_bilinear( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n\n  // Pointer to input buffer\n  unsigned char *input = (unsigned char*) in.data;\n\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n\n  // Define a max index position on the input buffer\n  unsigned long max = ( (width*height) - 1 ) * channels;\n\n  // Create new buffer and pointer for our output - make sure we have enough digits via unsigned long long\n  unsigned char *output = new unsigned char[(unsigned long long)resampled_width*resampled_height*channels];\n\n  // Calculate our scale\n  float xscale = (float)(width) / (float)resampled_width;\n  float yscale = (float)(height) / (float)resampled_height;\n\n\n  // Do not parallelize for small images (256x256 pixels) as this can be slower that single threaded\n#if defined(__ICC) || defined(__INTEL_COMPILER)\n#pragma ivdep\n#elif defined(_OPENMP)\n#pragma omp parallel for if( resampled_width*resampled_height > PARALLEL_THRESHOLD )\n#endif\n  for( unsigned int j=0; j<resampled_height; j++ ){\n\n    // Index to the current pyramid resolution's top left pixel\n    int jj = (int) floor( j*yscale );\n\n    // Calculate some weights - do this in the highest loop possible\n    float jscale = j*yscale;\n    float c = (float)(jj+1) - jscale;\n    float d = jscale - (float)jj;\n\n    for( unsigned int i=0; i<resampled_width; i++ ){\n\n      // Index to the current pyramid resolution's top left pixel\n      int ii = (int) floor( i*xscale );\n\n      // Calculate the indices of the 4 surrounding pixels\n      unsigned long p11, p12, p21, p22;\n      unsigned long jj_w = jj*width;\n      p11 = (unsigned long) ( channels * ( ii + jj_w ) );\n      p12 = (unsigned long) ( channels * ( ii + (jj_w+width) ) );\n      p21 = (unsigned long) ( channels * ( (ii+1) + jj_w ) );\n      p22 = (unsigned long) ( channels * ( (ii+1) + (jj_w+width) ) );\n\n      // Make sure we don't stray outside our input buffer boundary\n      // - replicate at the edge\n      p12 = (p12<=max)? p12 : max;\n      p21 = (p21<=max)? p21 : max;\n      p22 = (p22<=max)? p22 : max;\n\n      // Calculate the rest of our weights\n      float iscale = i*xscale;\n      float a = (float)(ii+1) - iscale;\n      float b = iscale - (float)ii;\n\n      // Output buffer index\n      unsigned long long resampled_index = (unsigned long long)( (j*resampled_width + i) * channels );\n\n      for( int k=0; k<channels; k++ ){\n\tfloat tx = input[p11+k]*a + input[p21+k]*b;\n\tfloat ty = input[p12+k]*a + input[p22+k]*b;\n\tunsigned char r = (unsigned char)( c*tx + d*ty );\n\toutput[resampled_index+k] = r;\n      }\n    }\n  }\n\n  // Delete original buffer\n  delete[] (unsigned char*) input;\n\n  // Correctly set our Rawtile info\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 202,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        regs[a] = mrb_hash_get(mrb, va, vb);\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      regs[a] = mrb_vm_const_get(mrb, syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      regs[a] = mrb_hash_get(mrb, kdict, k);\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      size_t len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_assert(mrb_hash_p(hash));\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0630"
    },
    {
        "index": 203,
        "code": "static int jit_compile(pcre2_code *code, sljit_u32 mode)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\nstruct sljit_compiler *compiler;\nbacktrack_common rootbacktrack;\ncompiler_common common_data;\ncompiler_common *common = &common_data;\nconst sljit_u8 *tables = re->tables;\nvoid *allocator_data = &re->memctl;\nint private_data_size;\nPCRE2_SPTR ccend;\nexecutable_functions *functions;\nvoid *executable_func;\nsljit_uw executable_size;\nsljit_uw total_length;\nstruct sljit_label *mainloop_label = NULL;\nstruct sljit_label *continue_match_label;\nstruct sljit_label *empty_match_found_label = NULL;\nstruct sljit_label *empty_match_backtrack_label = NULL;\nstruct sljit_label *reset_match_label;\nstruct sljit_label *quit_label;\nstruct sljit_jump *jump;\nstruct sljit_jump *minlength_check_failed = NULL;\nstruct sljit_jump *empty_match = NULL;\nstruct sljit_jump *end_anchor_failed = NULL;\njump_list *reqcu_not_found = NULL;\n\nSLJIT_ASSERT(tables);\n\n#if HAS_VIRTUAL_REGISTERS == 1\nSLJIT_ASSERT(sljit_get_register_index(TMP3) < 0 && sljit_get_register_index(ARGUMENTS) < 0 && sljit_get_register_index(RETURN_ADDR) < 0);\n#elif HAS_VIRTUAL_REGISTERS == 0\nSLJIT_ASSERT(sljit_get_register_index(TMP3) >= 0 && sljit_get_register_index(ARGUMENTS) >= 0 && sljit_get_register_index(RETURN_ADDR) >= 0);\n#else\n#error \"Invalid value for HAS_VIRTUAL_REGISTERS\"\n#endif\n\nmemset(&rootbacktrack, 0, sizeof(backtrack_common));\nmemset(common, 0, sizeof(compiler_common));\ncommon->re = re;\ncommon->name_table = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\nrootbacktrack.cc = common->name_table + re->name_count * re->name_entry_size;\n\n#ifdef SUPPORT_UNICODE\ncommon->invalid_utf = (mode & PCRE2_JIT_INVALID_UTF) != 0;\n#endif /* SUPPORT_UNICODE */\nmode &= ~PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS;\n\ncommon->start = rootbacktrack.cc;\ncommon->read_only_data_head = NULL;\ncommon->fcc = tables + fcc_offset;\ncommon->lcc = (sljit_sw)(tables + lcc_offset);\ncommon->mode = mode;\ncommon->might_be_empty = (re->minlength == 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->allow_empty_partial = (re->max_lookbehind > 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR: common->newline = CHAR_CR; break;\n  case PCRE2_NEWLINE_LF: common->newline = CHAR_NL; break;\n  case PCRE2_NEWLINE_CRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; break;\n  case PCRE2_NEWLINE_ANY: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANY; break;\n  case PCRE2_NEWLINE_ANYCRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANYCRLF; break;\n  case PCRE2_NEWLINE_NUL: common->newline = CHAR_NUL; break;\n  default: return PCRE2_ERROR_INTERNAL;\n  }\ncommon->nlmax = READ_CHAR_MAX;\ncommon->nlmin = 0;\nif (re->bsr_convention == PCRE2_BSR_UNICODE)\n  common->bsr_nltype = NLTYPE_ANY;\nelse if (re->bsr_convention == PCRE2_BSR_ANYCRLF)\n  common->bsr_nltype = NLTYPE_ANYCRLF;\nelse\n  {\n#ifdef BSR_ANYCRLF\n  common->bsr_nltype = NLTYPE_ANYCRLF;\n#else\n  common->bsr_nltype = NLTYPE_ANY;\n#endif\n  }\ncommon->bsr_nlmax = READ_CHAR_MAX;\ncommon->bsr_nlmin = 0;\ncommon->endonly = (re->overall_options & PCRE2_DOLLAR_ENDONLY) != 0;\ncommon->ctypes = (sljit_sw)(tables + ctypes_offset);\ncommon->name_count = re->name_count;\ncommon->name_entry_size = re->name_entry_size;\ncommon->unset_backref = (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) != 0;\ncommon->alt_circumflex = (re->overall_options & PCRE2_ALT_CIRCUMFLEX) != 0;\n#ifdef SUPPORT_UNICODE\n/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */\ncommon->utf = (re->overall_options & PCRE2_UTF) != 0;\ncommon->ucp = (re->overall_options & PCRE2_UCP) != 0;\nif (common->utf)\n  {\n  if (common->nltype == NLTYPE_ANY)\n    common->nlmax = 0x2029;\n  else if (common->nltype == NLTYPE_ANYCRLF)\n    common->nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  else\n    {\n    /* We only care about the first newline character. */\n    common->nlmax = common->newline & 0xff;\n    }\n\n  if (common->nltype == NLTYPE_FIXED)\n    common->nlmin = common->newline & 0xff;\n  else\n    common->nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n\n  if (common->bsr_nltype == NLTYPE_ANY)\n    common->bsr_nlmax = 0x2029;\n  else\n    common->bsr_nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  common->bsr_nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n  }\nelse\n  common->invalid_utf = FALSE;\n#endif /* SUPPORT_UNICODE */\nccend = bracketend(common->start);\n\n/* Calculate the local space size on the stack. */\ncommon->ovector_start = LIMIT_MATCH + sizeof(sljit_sw);\ncommon->optimized_cbracket = (sljit_u8 *)SLJIT_MALLOC(re->top_bracket + 1, allocator_data);\nif (!common->optimized_cbracket)\n  return PCRE2_ERROR_NOMEMORY;\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 1\nmemset(common->optimized_cbracket, 0, re->top_bracket + 1);\n#else\nmemset(common->optimized_cbracket, 1, re->top_bracket + 1);\n#endif\n\nSLJIT_ASSERT(*common->start == OP_BRA && ccend[-(1 + LINK_SIZE)] == OP_KET);\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 2\ncommon->capture_last_ptr = common->ovector_start;\ncommon->ovector_start += sizeof(sljit_sw);\n#endif\nif (!check_opcode_types(common, common->start, ccend))\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Checking flags and updating ovector_start. */\nif (mode == PCRE2_JIT_COMPLETE && (re->flags & PCRE2_LASTSET) != 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  common->req_char_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->start_used_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  if (mode == PCRE2_JIT_PARTIAL_SOFT)\n    {\n    common->hit_start = common->ovector_start;\n    common->ovector_start += sizeof(sljit_sw);\n    }\n  }\nif ((re->overall_options & (PCRE2_FIRSTLINE | PCRE2_USE_OFFSET_LIMIT)) != 0)\n  {\n  common->match_end_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\ncommon->control_head_ptr = 1;\n#endif\nif (common->control_head_ptr != 0)\n  {\n  common->control_head_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (common->has_set_som)\n  {\n  /* Saving the real start pointer is necessary. */\n  common->start_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n\n/* Aligning ovector to even number of sljit words. */\nif ((common->ovector_start & sizeof(sljit_sw)) != 0)\n  common->ovector_start += sizeof(sljit_sw);\n\nif (common->start_ptr == 0)\n  common->start_ptr = OVECTOR(0);\n\n/* Capturing brackets cannot be optimized if callouts are allowed. */\nif (common->capture_last_ptr != 0)\n  memset(common->optimized_cbracket, 0, re->top_bracket + 1);\n\nSLJIT_ASSERT(!(common->req_char_ptr != 0 && common->start_used_ptr != 0));\ncommon->cbra_ptr = OVECTOR_START + (re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\ntotal_length = ccend - common->start;\ncommon->private_data_ptrs = (sljit_s32 *)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);\nif (!common->private_data_ptrs)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\nmemset(common->private_data_ptrs, 0, total_length * sizeof(sljit_s32));\n\nprivate_data_size = common->cbra_ptr + (re->top_bracket + 1) * sizeof(sljit_sw);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 && !common->has_skip_in_assert_back)\n  detect_early_fail(common, common->start, &private_data_size, 0, 0, TRUE);\n\nset_private_data_ptrs(common, &private_data_size, ccend);\n\nSLJIT_ASSERT(common->early_fail_start_ptr <= common->early_fail_end_ptr);\n\nif (private_data_size > SLJIT_MAX_LOCAL_SIZE)\n  {\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif (common->has_then)\n  {\n  common->then_offsets = (sljit_u8 *)(common->private_data_ptrs + total_length);\n  memset(common->then_offsets, 0, total_length);\n  set_then_offsets(common, common->start, NULL);\n  }\n\ncompiler = sljit_create_compiler(allocator_data, NULL);\nif (!compiler)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\ncommon->compiler = compiler;\n\n/* Main pcre2_jit_exec entry. */\nsljit_emit_enter(compiler, 0, SLJIT_ARGS1(W, W), 5, 5, 0, 0, private_data_size);\n\n/* Register init. */\nreset_ovector(common, (re->top_bracket + 1) * 2);\nif (common->req_char_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, SLJIT_R0, 0);\n\nOP1(SLJIT_MOV, ARGUMENTS, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\nOP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, end));\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, limit_match));\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, end));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, start));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH, TMP1, 0);\n\nif (common->early_fail_start_ptr < common->early_fail_end_ptr)\n  reset_early_fail(common);\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\n/* Main part of the matching */\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  mainloop_label = mainloop_entry(common);\n  continue_match_label = LABEL();\n  /* Forward search if possible. */\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    if (mode == PCRE2_JIT_COMPLETE && fast_forward_first_n_chars(common))\n      ;\n    else if ((re->flags & PCRE2_FIRSTSET) != 0)\n      fast_forward_first_char(common);\n    else if ((re->flags & PCRE2_STARTLINE) != 0)\n      fast_forward_newline(common);\n    else if ((re->flags & PCRE2_FIRSTMAPSET) != 0)\n      fast_forward_start_bits(common);\n    }\n  }\nelse\n  continue_match_label = LABEL();\n\nif (mode == PCRE2_JIT_COMPLETE && re->minlength > 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(re->minlength));\n  minlength_check_failed = CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0);\n  }\nif (common->req_char_ptr != 0)\n  reqcu_not_found = search_requested_char(common, (PCRE2_UCHAR)(re->last_codeunit), (re->flags & PCRE2_LASTCASELESS) != 0, (re->flags & PCRE2_FIRSTSET) != 0);\n\n/* Store the current STR_PTR in OVECTOR(0). */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n/* Copy the limit of allowed recursions. */\nOP1(SLJIT_MOV, COUNT_MATCH, 0, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH);\nif (common->capture_last_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, 0);\nif (common->fast_forward_bc_ptr != NULL)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3, STR_PTR, 0);\n\nif (common->start_ptr != OVECTOR(0))\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_ptr, STR_PTR, 0);\n\n/* Copy the beginning of the string. */\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (mode == PCRE2_JIT_PARTIAL_HARD)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n\ncompile_matchingpath(common, common->start, ccend, &rootbacktrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  end_anchor_failed = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0);\n\nif (common->might_be_empty)\n  {\n  empty_match = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n  empty_match_found_label = LABEL();\n  }\n\ncommon->accept_label = LABEL();\nif (common->accept != NULL)\n  set_jumps(common->accept, common->accept_label);\n\n/* This means we have a match. Update the ovector. */\ncopy_ovector(common, re->top_bracket + 1);\ncommon->quit_label = common->abort_label = LABEL();\nif (common->quit != NULL)\n  set_jumps(common->quit, common->quit_label);\nif (common->abort != NULL)\n  set_jumps(common->abort, common->abort_label);\nif (minlength_check_failed != NULL)\n  SET_LABEL(minlength_check_failed, common->abort_label);\n\nsljit_emit_op0(compiler, SLJIT_SKIP_FRAMES_BEFORE_RETURN);\nsljit_emit_return(compiler, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\nif (common->failed_match != NULL)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n  set_jumps(common->failed_match, LABEL());\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  JUMPTO(SLJIT_JUMP, common->abort_label);\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  JUMPHERE(end_anchor_failed);\n\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->partialmatchlabel = LABEL();\n  set_jumps(common->partialmatch, common->partialmatchlabel);\n  return_with_partial_match(common, common->quit_label);\n  }\n\nif (common->might_be_empty)\n  empty_match_backtrack_label = LABEL();\ncompile_backtrackingpath(common, rootbacktrack.top);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nSLJIT_ASSERT(rootbacktrack.prev == NULL);\nreset_match_label = LABEL();\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* Update hit_start only in the first time. */\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, TMP1, 0);\n  JUMPHERE(jump);\n  }\n\n/* Check we have remaining characters. */\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP),\n    (common->fast_forward_bc_ptr != NULL) ? (PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3) : common->start_ptr);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  if (common->ff_newline_shortcut != NULL)\n    {\n    /* There cannot be more newlines if PCRE2_FIRSTLINE is set. */\n    if ((re->overall_options & PCRE2_FIRSTLINE) == 0)\n      {\n      if (common->match_end_ptr != 0)\n        {\n        OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n        OP1(SLJIT_MOV, STR_END, 0, TMP1, 0);\n        CMPTO(SLJIT_LESS, STR_PTR, 0, TMP1, 0, common->ff_newline_shortcut);\n        OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n        }\n      else\n        CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, common->ff_newline_shortcut);\n      }\n    }\n  else\n    CMPTO(SLJIT_LESS, STR_PTR, 0, (common->match_end_ptr == 0) ? STR_END : TMP1, 0, mainloop_label);\n  }\n\n/* No more remaining characters. */\nif (reqcu_not_found != NULL)\n  set_jumps(reqcu_not_found, LABEL());\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1, common->partialmatchlabel);\n\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nflush_stubs(common);\n\nif (common->might_be_empty)\n  {\n  JUMPHERE(empty_match);\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\n  JUMPTO(SLJIT_NOT_ZERO, empty_match_backtrack_label);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\n  JUMPTO(SLJIT_ZERO, empty_match_found_label);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, empty_match_found_label);\n  JUMPTO(SLJIT_JUMP, empty_match_backtrack_label);\n  }\n\ncommon->fast_forward_bc_ptr = NULL;\ncommon->early_fail_start_ptr = 0;\ncommon->early_fail_end_ptr = 0;\ncommon->currententry = common->entries;\ncommon->local_quit_available = TRUE;\nquit_label = common->quit_label;\nwhile (common->currententry != NULL)\n  {\n  /* Might add new entries. */\n  compile_recurse(common);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    sljit_free_compiler(compiler);\n    SLJIT_FREE(common->optimized_cbracket, allocator_data);\n    SLJIT_FREE(common->private_data_ptrs, allocator_data);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  flush_stubs(common);\n  common->currententry = common->currententry->next;\n  }\ncommon->local_quit_available = FALSE;\ncommon->quit_label = quit_label;\n\n/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */\n/* This is a (really) rare case. */\nset_jumps(common->stackalloc, LABEL());\n/* RETURN_ADDR is not a saved register. */\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\nOP2(SLJIT_SUB, SLJIT_R1, 0, STACK_LIMIT, 0, SLJIT_IMM, STACK_GROWTH_RATE);\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, TMP2, 0);\n\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(sljit_stack_resize));\n\njump = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nOP1(SLJIT_MOV, TMP2, 0, STACK_LIMIT, 0);\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_RETURN_REG, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n/* Allocation failed. */\nJUMPHERE(jump);\n/* We break the return address cache here, but this is a really rare case. */\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_JIT_STACKLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\n/* Call limit reached. */\nset_jumps(common->calllimit, LABEL());\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_MATCHLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nif (common->revertframes != NULL)\n  {\n  set_jumps(common->revertframes, LABEL());\n  do_revertframes(common);\n  }\nif (common->wordboundary != NULL)\n  {\n  set_jumps(common->wordboundary, LABEL());\n  check_wordboundary(common);\n  }\nif (common->anynewline != NULL)\n  {\n  set_jumps(common->anynewline, LABEL());\n  check_anynewline(common);\n  }\nif (common->hspace != NULL)\n  {\n  set_jumps(common->hspace, LABEL());\n  check_hspace(common);\n  }\nif (common->vspace != NULL)\n  {\n  set_jumps(common->vspace, LABEL());\n  check_vspace(common);\n  }\nif (common->casefulcmp != NULL)\n  {\n  set_jumps(common->casefulcmp, LABEL());\n  do_casefulcmp(common);\n  }\nif (common->caselesscmp != NULL)\n  {\n  set_jumps(common->caselesscmp, LABEL());\n  do_caselesscmp(common);\n  }\nif (common->reset_match != NULL)\n  {\n  set_jumps(common->reset_match, LABEL());\n  do_reset_match(common, (re->top_bracket + 1) * 2);\n  CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP1, 0, continue_match_label);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP1, 0);\n  JUMPTO(SLJIT_JUMP, reset_match_label);\n  }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utfreadchar != NULL)\n  {\n  set_jumps(common->utfreadchar, LABEL());\n  do_utfreadchar(common);\n  }\nif (common->utfreadtype8 != NULL)\n  {\n  set_jumps(common->utfreadtype8, LABEL());\n  do_utfreadtype8(common);\n  }\nif (common->utfpeakcharback != NULL)\n  {\n  set_jumps(common->utfpeakcharback, LABEL());\n  do_utfpeakcharback(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utfreadchar_invalid != NULL)\n  {\n  set_jumps(common->utfreadchar_invalid, LABEL());\n  do_utfreadchar_invalid(common);\n  }\nif (common->utfreadnewline_invalid != NULL)\n  {\n  set_jumps(common->utfreadnewline_invalid, LABEL());\n  do_utfreadnewline_invalid(common);\n  }\nif (common->utfmoveback_invalid)\n  {\n  set_jumps(common->utfmoveback_invalid, LABEL());\n  do_utfmoveback_invalid(common);\n  }\nif (common->utfpeakcharback_invalid)\n  {\n  set_jumps(common->utfpeakcharback_invalid, LABEL());\n  do_utfpeakcharback_invalid(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */\nif (common->getucd != NULL)\n  {\n  set_jumps(common->getucd, LABEL());\n  do_getucd(common);\n  }\nif (common->getucdtype != NULL)\n  {\n  set_jumps(common->getucdtype, LABEL());\n  do_getucdtype(common);\n  }\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_FREE(common->optimized_cbracket, allocator_data);\nSLJIT_FREE(common->private_data_ptrs, allocator_data);\n\nexecutable_func = sljit_generate_code(compiler);\nexecutable_size = sljit_get_generated_code_size(compiler);\nsljit_free_compiler(compiler);\n\nif (executable_func == NULL)\n  {\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Reuse the function descriptor if possible. */\nif (re->executable_jit != NULL)\n  functions = (executable_functions *)re->executable_jit;\nelse\n  {\n  functions = SLJIT_MALLOC(sizeof(executable_functions), allocator_data);\n  if (functions == NULL)\n    {\n    /* This case is highly unlikely since we just recently\n    freed a lot of memory. Not impossible though. */\n    sljit_free_code(executable_func, NULL);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  memset(functions, 0, sizeof(executable_functions));\n  functions->top_bracket = re->top_bracket + 1;\n  functions->limit_match = re->limit_match;\n  re->executable_jit = functions;\n  }\n\n/* Turn mode into an index. */\nif (mode == PCRE2_JIT_COMPLETE)\n  mode = 0;\nelse\n  mode = (mode == PCRE2_JIT_PARTIAL_SOFT) ? 1 : 2;\n\nSLJIT_ASSERT(mode < JIT_NUMBER_OF_COMPILE_MODES);\nfunctions->executable_funcs[mode] = executable_func;\nfunctions->read_only_data_heads[mode] = common->read_only_data_head;\nfunctions->executable_sizes[mode] = executable_size;\nreturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1587"
    },
    {
        "index": 204,
        "code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n\n  // Note: technically, we could use a very generic type when some of the inputs\n  // are unknown. But there is an expectation that a node will have complete\n  // inputs soon, so updating intermediate types is largely unnecessary.\n\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  static FullTypeDef* no_type = new FullTypeDef();\n\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23592"
    },
    {
        "index": 205,
        "code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, /*new_shape=*/nullptr);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37687"
    },
    {
        "index": 206,
        "code": "vector<PortForwardSourceRequest> parseRangesToRequests(const string& input) {\n  vector<PortForwardSourceRequest> pfsrs;\n  auto j = split(input, ',');\n  for (auto& pair : j) {\n    vector<string> sourceDestination = split(pair, ':');\n    try {\n      if (sourceDestination[0].find_first_not_of(\"0123456789-\") !=\n              string::npos &&\n          sourceDestination[1].find_first_not_of(\"0123456789-\") !=\n              string::npos) {\n        PortForwardSourceRequest pfsr;\n        pfsr.mutable_source()->set_name(sourceDestination[0]);\n        pfsr.mutable_destination()->set_name(sourceDestination[1]);\n        pfsrs.push_back(pfsr);\n      } else if (sourceDestination[0].find('-') != string::npos &&\n                 sourceDestination[1].find('-') != string::npos) {\n        vector<string> sourcePortRange = split(sourceDestination[0], '-');\n        int sourcePortStart = stoi(sourcePortRange[0]);\n        int sourcePortEnd = stoi(sourcePortRange[1]);\n\n        vector<string> destinationPortRange = split(sourceDestination[1], '-');\n        int destinationPortStart = stoi(destinationPortRange[0]);\n        int destinationPortEnd = stoi(destinationPortRange[1]);\n\n        if (sourcePortEnd - sourcePortStart !=\n            destinationPortEnd - destinationPortStart) {\n          STFATAL << \"source/destination port range mismatch\";\n          exit(1);\n        } else {\n          int portRangeLength = sourcePortEnd - sourcePortStart + 1;\n          for (int i = 0; i < portRangeLength; ++i) {\n            PortForwardSourceRequest pfsr;\n            pfsr.mutable_source()->set_port(sourcePortStart + i);\n            pfsr.mutable_destination()->set_port(destinationPortStart + i);\n            pfsrs.push_back(pfsr);\n          }\n        }\n      } else if (sourceDestination[0].find('-') != string::npos ||\n                 sourceDestination[1].find('-') != string::npos) {\n        STFATAL << \"Invalid port range syntax: if source is range, \"\n                   \"destination must be range\";\n      } else {\n        PortForwardSourceRequest pfsr;\n        pfsr.mutable_source()->set_port(stoi(sourceDestination[0]));\n        pfsr.mutable_destination()->set_port(stoi(sourceDestination[1]));\n        pfsrs.push_back(pfsr);\n      }\n    } catch (const std::logic_error& lr) {\n      STFATAL << \"Logic error: \" << lr.what();\n      exit(1);\n    }\n  }\n  return pfsrs;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 207,
        "code": "static int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t pad = 0;\n\tint result = RLC_OK;\n\tbn_t t;\n\n\tRLC_TRY {\n\t\tbn_null(t);\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\t*p_len = 1;\n\t\t\t\tdo {\n\t\t\t\t\t(*p_len)++;\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad == 0 && m_len > 0);\n\t\t\t\tif (pad != RSA_PAD) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36316"
    },
    {
        "index": 208,
        "code": "void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share,\n                         uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(public_shares);\n    CHECK_STATE(s_share);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t s;\n    mpz_init(s);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");\n\n    SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);\n\n    strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);\n\n    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n    status = session_key_recover(skey, s_share, common_key);\n\n    CHECK_STATUS(\"session_key_recover failed\");\n\n    SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);\n\n    status=xor_decrypt(common_key, encr_sshare, decr_sshare);\n\n    CHECK_STATUS(\"xor_decrypt failed\")\n\n\n    status  = mpz_set_str(s, decr_sshare, 16);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    *result = Verification(public_shares, s, _t, _ind);\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(s);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 209,
        "code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1674"
    },
    {
        "index": 210,
        "code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n\n  // The residual scan uses all components here, not just for, but\n  // it does not require the component count either.\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-32201"
    },
    {
        "index": 211,
        "code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\n\tdown_write(&_hash_lock);\n\n\t/*\n\t * Loop through all the devices working out how much\n\t * space we need.\n\t */\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\n\t/*\n\t * Grab our output buffer.\n\t */\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\n\tnl->dev = 0;\t/* Flags no data */\n\n\t/*\n\t * Now loop through filling out the names.\n\t */\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\t/*\n\t * If mismatch happens, security may be compromised due to buffer\n\t * overflow, so it's better to crash.\n\t */\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-31916"
    },
    {
        "index": 212,
        "code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      png::CommonFreeDecode(&decode);\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    Status status;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      status = context->allocate_output(\n          0, TensorShape({1, height, width, decode.channels}), &output);\n    } else {\n      status = context->allocate_output(\n          0, TensorShape({height, width, decode.channels}), &output);\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (!status.ok()) png::CommonFreeDecode(&decode);\n    OP_REQUIRES_OK(context, status);\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23584"
    },
    {
        "index": 213,
        "code": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->subtract (*other);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45931"
    },
    {
        "index": 214,
        "code": "void TileManager::crop( RawTile *ttt ){\n\n  int tw = image->getTileWidth();\n  int th = image->getTileHeight();\n\n  if( loglevel >= 5 ){\n    *logfile << \"TileManager :: Edge tile: Base size: \" << tw << \"x\" << th\n\t     << \": This tile: \" << ttt->width << \"x\" << ttt->height\n\t     << endl;\n  }\n\n  // Create a new buffer, fill it with the old data, then copy\n  // back the cropped part into the RawTile buffer\n  int len = tw * th * ttt->channels * (ttt->bpc/8);\n  unsigned char* buffer = (unsigned char*) malloc( len );\n  unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len );\n  unsigned char* dst_ptr = (unsigned char*) ttt->data;\n\n  // Copy one scanline at a time\n  len =  ttt->width * ttt->channels * (ttt->bpc/8);\n  for( unsigned int i=0; i<ttt->height; i++ ){\n    memcpy( dst_ptr, src_ptr, len );\n    dst_ptr += len;\n    src_ptr += tw * ttt->channels * (ttt->bpc/8);\n  }\n\n  free( buffer );\n\n  // Reset the data length\n  len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8);\n  ttt->dataLength = len;\n  ttt->padded = false;\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 215,
        "code": "void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs && i < bin->segs_count; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tswitch (pointer_format) {\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64:\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64_OFFSET:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\t\t\tptr_value += bin->baddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1649"
    },
    {
        "index": 216,
        "code": "static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tint ret;\n\tstruct msp430_cmd cmd;\n\n\tmemset (&cmd, 0, sizeof (cmd));\n\t//op->id = ???;\n\top->size = -1;\n\top->nopcode = 1;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->family = R_ANAL_OP_FAMILY_CPU;\n\n\tret = op->size = msp430_decode_command (buf, len, &cmd);\n\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\tif (ret < 1) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t} else if (ret > 0) {\n\t\t\tif (cmd.operands[0]) {\n\t\t\t\top->mnemonic = r_str_newf (\"%s %s\",cmd.instr, cmd.operands);\n\t\t\t} else {\n\t\t\t\top->mnemonic = strdup (cmd.instr);\n\t\t\t}\n\t\t}\n\t\t{ // if (a->syntax != R_ASM_SYNTAX_ATT)\n\t\t\tchar *ba = op->mnemonic;\n\t\t\tr_str_replace_ch (ba, '#', 0, 1);\n\t\t\t// r_str_replace_ch (ba, \"$\", \"$$\", 1);\n\t\t\tr_str_replace_ch (ba, '&', 0, 1);\n\t\t\tr_str_replace_ch (ba, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\top->addr = addr;\n\n\tswitch (cmd.type) {\n\tcase MSP430_ONEOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_RRA:\n\t\tcase MSP430_RRC:\n\t\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\t\tbreak;\n\t\tcase MSP430_PUSH:\n\t\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t\tbreak;\n\t\tcase MSP430_CALL:\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->fail = addr + op->size;\n\t\t\top->jump = r_read_at_le16 (buf, 2);\n\t\t\tbreak;\n\t\tcase MSP430_RETI:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MSP430_TWOOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_BIT:\n\t\tcase MSP430_BIC:\n\t\tcase MSP430_BIS:\n\t\tcase MSP430_MOV:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tif ((cmd.instr)[0] == 'b' && (cmd.instr)[1] == 'r') {\n\t\t\t\t// Emulated branch instruction, moves source operand to PC register.\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_DADD:\n\t\tcase MSP430_ADDC:\n\t\tcase MSP430_ADD: op->type = R_ANAL_OP_TYPE_ADD; break;\n\t\tcase MSP430_SUBC:\n\t\tcase MSP430_SUB: op->type = R_ANAL_OP_TYPE_SUB; break;\n\t\tcase MSP430_CMP: op->type = R_ANAL_OP_TYPE_CMP; break;\n\t\tcase MSP430_XOR: op->type = R_ANAL_OP_TYPE_XOR; break;\n\t\tcase MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;\n\t\t}\n\t\tbreak;\n\tcase MSP430_JUMP:\n\t\tif (cmd.jmp_cond == MSP430_JMP) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t}\n\t\top->jump = addr + cmd.jmp_addr;\n\t\top->fail = addr + 2;\n\t\tbreak;\n\tcase MSP430_INV:\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 217,
        "code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34299"
    },
    {
        "index": 218,
        "code": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1383"
    },
    {
        "index": 219,
        "code": "int __cil_build_ast_node_helper(struct cil_tree_node *parse_current, uint32_t *finished, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_db *db = args->db;\n\tstruct cil_tree_node *ast_current = args->ast;\n\tstruct cil_tree_node *tunif = args->tunif;\n\tstruct cil_tree_node *in = args->in;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *boolif = args->boolif;\n\tstruct cil_tree_node *ast_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current->parent->cl_head != parse_current) {\n\t\t/* ignore anything that isn't following a parenthesis */\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (parse_current->data == NULL) {\n\t\t/* the only time parenthesis can immediately following parenthesis is if\n\t\t * the parent is the root node */\n\t\tif (parse_current->parent->parent == NULL) {\n\t\t\trc = SEPOL_OK;\n\t\t} else {\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Keyword expected after open parenthesis\");\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (tunif != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found tunable\");\n\t\t\tcil_log(CIL_ERR, \"Tunables cannot be defined within tunableif statement\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tif (parse_current->data == CIL_KEY_IN) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found in-statement\");\n\t\t\tcil_log(CIL_ERR, \"in-statements cannot be defined within in-statements\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE ||\n\t\t\tparse_current->data == CIL_KEY_IN ||\n\t\t\tparse_current->data == CIL_KEY_BLOCK ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKINHERIT ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKABSTRACT ||\n\t\t\tparse_current->data == CIL_KEY_MACRO) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"%s is not allowed in macros\", (char *)parse_current->data);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (parse_current->data != CIL_KEY_TUNABLEIF &&\n\t\t\tparse_current->data != CIL_KEY_CALL &&\n\t\t\tparse_current->data != CIL_KEY_CONDTRUE &&\n\t\t\tparse_current->data != CIL_KEY_CONDFALSE &&\n\t\t\tparse_current->data != CIL_KEY_ALLOW &&\n\t\t\tparse_current->data != CIL_KEY_DONTAUDIT &&\n\t\t\tparse_current->data != CIL_KEY_AUDITALLOW &&\n\t\t\tparse_current->data != CIL_KEY_TYPETRANSITION &&\n\t\t\tparse_current->data != CIL_KEY_TYPECHANGE &&\n\t\t\tparse_current->data != CIL_KEY_TYPEMEMBER) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found %s\", (char*)parse_current->data);\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_log(CIL_ERR, \"%s cannot be defined within tunableif statement (treated as a booleanif due to preserve-tunables)\\n\",\n\t\t\t\t\t\t(char*)parse_current->data);\n\t\t\t} else {\n\t\t\t\tcil_log(CIL_ERR, \"%s cannot be defined within booleanif statement\\n\",\n\t\t\t\t\t\t(char*)parse_current->data);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tcil_tree_node_init(&ast_node);\n\n\tast_node->parent = ast_current;\n\tast_node->line = parse_current->line;\n\tast_node->hll_line = parse_current->hll_line;\n\n\tif (parse_current->data == CIL_KEY_BLOCK) {\n\t\trc = cil_gen_block(db, parse_current, ast_node, 0);\n\t} else if (parse_current->data == CIL_KEY_BLOCKINHERIT) {\n\t\trc = cil_gen_blockinherit(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_BLOCKABSTRACT) {\n\t\trc = cil_gen_blockabstract(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_IN) {\n\t\trc = cil_gen_in(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CLASS) {\n\t\trc = cil_gen_class(db, parse_current, ast_node);\n\t\t// To avoid parsing list of perms again\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSORDER) {\n\t\trc = cil_gen_classorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MAP_CLASS) {\n\t\trc = cil_gen_map_class(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSMAPPING) {\n\t\trc = cil_gen_classmapping(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSPERMISSION) {\n\t\trc = cil_gen_classpermission(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSPERMISSIONSET) {\n\t\trc = cil_gen_classpermissionset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_COMMON) {\n\t\trc = cil_gen_common(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSCOMMON) {\n\t\trc = cil_gen_classcommon(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SID) {\n\t\trc = cil_gen_sid(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SIDCONTEXT) {\n\t\trc = cil_gen_sidcontext(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SIDORDER) {\n\t\trc = cil_gen_sidorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USER) {\n\t\trc = cil_gen_user(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERATTRIBUTE) {\n\t\trc = cil_gen_userattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERATTRIBUTESET) {\n\t\trc = cil_gen_userattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERLEVEL) {\n\t\trc = cil_gen_userlevel(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERRANGE) {\n\t\trc = cil_gen_userrange(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_USER);\n\t} else if (parse_current->data == CIL_KEY_USERPREFIX) {\n\t\trc = cil_gen_userprefix(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SELINUXUSER) {\n\t\trc = cil_gen_selinuxuser(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SELINUXUSERDEFAULT) {\n\t\trc = cil_gen_selinuxuserdefault(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPE) {\n\t\trc = cil_gen_type(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPEATTRIBUTE) {\n\t\trc = cil_gen_typeattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPEATTRIBUTESET) {\n\t\trc = cil_gen_typeattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_EXPANDTYPEATTRIBUTE) {\n\t\trc = cil_gen_expandtypeattribute(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPEALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_TYPEALIAS);\n\t} else if (parse_current->data == CIL_KEY_TYPEALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_TYPEALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_TYPEBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_TYPE);\n\t} else if (parse_current->data == CIL_KEY_TYPEPERMISSIVE) {\n\t\trc = cil_gen_typepermissive(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_RANGETRANSITION) {\n\t\trc = cil_gen_rangetransition(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ROLE) {\n\t\trc = cil_gen_role(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERROLE) {\n\t\trc = cil_gen_userrole(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLETYPE) {\n\t\trc = cil_gen_roletype(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLETRANSITION) {\n\t\trc = cil_gen_roletransition(parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEALLOW) {\n\t\trc = cil_gen_roleallow(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEATTRIBUTE) {\n\t\trc = cil_gen_roleattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEATTRIBUTESET) {\n\t\trc = cil_gen_roleattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ROLEBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_ROLE);\n\t} else if (parse_current->data == CIL_KEY_BOOL) {\n\t\trc = cil_gen_bool(db, parse_current, ast_node, CIL_FALSE);\n\t} else if (parse_current->data == CIL_KEY_BOOLEANIF) {\n\t\trc = cil_gen_boolif(db, parse_current, ast_node, CIL_FALSE);\n\t} else if(parse_current->data == CIL_KEY_TUNABLE) {\n\t\tif (db->preserve_tunables) {\n\t\t\trc = cil_gen_bool(db, parse_current, ast_node, CIL_TRUE);\n\t\t} else {\n\t\t\trc = cil_gen_tunable(db, parse_current, ast_node);\n\t\t}\n\t} else if (parse_current->data == CIL_KEY_TUNABLEIF) {\n\t\tif (db->preserve_tunables) {\n\t\t\trc = cil_gen_boolif(db, parse_current, ast_node, CIL_TRUE);\n\t\t} else {\n\t\t\trc = cil_gen_tunif(db, parse_current, ast_node);\n\t\t}\n\t} else if (parse_current->data == CIL_KEY_CONDTRUE) {\n\t\trc = cil_gen_condblock(db, parse_current, ast_node, CIL_CONDTRUE);\n\t} else if (parse_current->data == CIL_KEY_CONDFALSE) {\n\t\trc = cil_gen_condblock(db, parse_current, ast_node, CIL_CONDFALSE);\n\t} else if (parse_current->data == CIL_KEY_ALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_ALLOWED);\n\t\t// So that the object and perms lists do not get parsed again\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_AUDITALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_AUDITALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DONTAUDIT) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_DONTAUDIT);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NEVERALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_NEVERALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_ALLOWED);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_AUDITALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_AUDITALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DONTAUDITX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_DONTAUDIT);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NEVERALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_NEVERALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PERMISSIONX) {\n\t\trc = cil_gen_permissionx(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPETRANSITION) {\n\t\trc = cil_gen_typetransition(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPECHANGE) {\n\t\trc = cil_gen_type_rule(parse_current, ast_node, CIL_TYPE_CHANGE);\n\t} else if (parse_current->data == CIL_KEY_TYPEMEMBER) {\n\t\trc = cil_gen_type_rule(parse_current, ast_node, CIL_TYPE_MEMBER);\n\t} else if (parse_current->data == CIL_KEY_SENSITIVITY) {\n\t\trc = cil_gen_sensitivity(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SENSALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_SENSALIAS);\n\t} else if (parse_current->data == CIL_KEY_SENSALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_SENSALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_CATEGORY) {\n\t\trc = cil_gen_category(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CATALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_CATALIAS);\n\t} else if (parse_current->data == CIL_KEY_CATALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_CATALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_CATSET) {\n\t\trc = cil_gen_catset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CATORDER) {\n\t\trc = cil_gen_catorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SENSITIVITYORDER) {\n\t\trc = cil_gen_sensitivityorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SENSCAT) {\n\t\trc = cil_gen_senscat(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_LEVEL) {\n\t\trc = cil_gen_level(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_LEVELRANGE) {\n\t\trc = cil_gen_levelrange(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CONSTRAIN) {\n\t\trc = cil_gen_constrain(db, parse_current, ast_node, CIL_CONSTRAIN);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLSCONSTRAIN) {\n\t\trc = cil_gen_constrain(db, parse_current, ast_node, CIL_MLSCONSTRAIN);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_VALIDATETRANS) {\n\t\trc = cil_gen_validatetrans(db, parse_current, ast_node, CIL_VALIDATETRANS);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLSVALIDATETRANS) {\n\t\trc = cil_gen_validatetrans(db, parse_current, ast_node, CIL_MLSVALIDATETRANS);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CONTEXT) {\n\t\trc = cil_gen_context(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_FILECON) {\n\t\trc = cil_gen_filecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IBPKEYCON) {\n\t\trc = cil_gen_ibpkeycon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IBENDPORTCON) {\n\t\trc = cil_gen_ibendportcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PORTCON) {\n\t\trc = cil_gen_portcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NODECON) {\n\t\trc = cil_gen_nodecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_GENFSCON) {\n\t\trc = cil_gen_genfscon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NETIFCON) {\n\t\trc = cil_gen_netifcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PIRQCON) {\n\t\trc = cil_gen_pirqcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IOMEMCON) {\n\t\trc = cil_gen_iomemcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IOPORTCON) {\n\t\trc = cil_gen_ioportcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PCIDEVICECON) {\n\t\trc = cil_gen_pcidevicecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEVICETREECON) {\n\t\trc = cil_gen_devicetreecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_FSUSE) {\n\t\trc = cil_gen_fsuse(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MACRO) {\n\t\trc = cil_gen_macro(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CALL) {\n\t\trc = cil_gen_call(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_POLICYCAP) {\n\t\trc = cil_gen_policycap(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_OPTIONAL) {\n\t\trc = cil_gen_optional(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_IPADDR) {\n\t\trc = cil_gen_ipaddr(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_DEFAULTUSER) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTUSER);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTROLE) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTROLE);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTTYPE) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTTYPE);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTRANGE) {\n\t\trc = cil_gen_defaultrange(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_HANDLEUNKNOWN) {\n\t\trc = cil_gen_handleunknown(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLS) {\n\t\trc = cil_gen_mls(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SRC_INFO) {\n\t\trc = cil_gen_src_info(parse_current, ast_node);\n\t} else {\n\t\tcil_log(CIL_ERR, \"Error: Unknown keyword %s\\n\", (char *)parse_current->data);\n\t\trc = SEPOL_ERR;\n\t}\n\n\tif (rc == SEPOL_OK) {\n\t\tif (ast_current->cl_head == NULL) {\n\t\t\tast_current->cl_head = ast_node;\n\t\t} else {\n\t\t\tast_current->cl_tail->next = ast_node;\n\t\t}\n\t\tast_current->cl_tail = ast_node;\n\t\tast_current = ast_node;\n\t\targs->ast = ast_current;\n\t} else {\n\t\tcil_tree_node_destroy(&ast_node);\n\t}\n\nexit:\n\treturn rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36087"
    },
    {
        "index": 220,
        "code": "static void get_over(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice, *p_voice2, *p_voice3;\n\tint range, voice, voice2, voice3;\nstatic char tx_wrong_dur[] = \"Wrong duration in voice overlay\";\nstatic char txt_no_note[] = \"No note in voice overlay\";\n\n\t/* treat the end of overlay */\n\tp_voice = curvoice;\n\tif (p_voice->ignore)\n\t\treturn;\n\tif (s->abc_type == ABC_T_BAR\n\t || s->u.v_over.type == V_OVER_E)  {\n\t\tif (!p_voice->last_sym) {\n\t\t\terror(1, s, txt_no_note);\n\t\t\treturn;\n\t\t}\n\t\tp_voice->last_sym->sflags |= S_BEAM_END;\n\t\tover_bar = 0;\n\t\tif (over_time < 0) {\n\t\t\terror(1, s, \"Erroneous end of voice overlap\");\n\t\t\treturn;\n\t\t}\n\t\tif (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t\tcurvoice = &voice_tb[over_voice];\n\t\tover_mxtime = 0;\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\treturn;\n\t}\n\n\t/* treat the full overlay start */\n\tif (s->u.v_over.type == V_OVER_S) {\n\t\tover_voice = p_voice - voice_tb;\n\t\tover_time = p_voice->time;\n\t\treturn;\n\t}\n\n\t/* (here is treated a new overlay - '&') */\n\t/* create the extra voice if not done yet */\n\tif (!p_voice->last_sym) {\n\t\terror(1, s, txt_no_note);\n\t\treturn;\n\t}\n\tp_voice->last_sym->sflags |= S_BEAM_END;\n\tvoice2 = s->u.v_over.voice;\n\tp_voice2 = &voice_tb[voice2];\n\tif (parsys->voice[voice2].range < 0) {\n\t\tint clone;\n\n\t\tif (cfmt.abc2pscompat) {\n\t\t\terror(1, s, \"Cannot have %%%%abc2pscompat\");\n\t\t\tcfmt.abc2pscompat = 0;\n\t\t}\n\t\tclone = p_voice->clone >= 0;\n\t\tp_voice2->id[0] = '&';\n\t\tp_voice2->id[1] = '\\0';\n\t\tp_voice2->second = 1;\n\t\tparsys->voice[voice2].second = 1;\n\t\tp_voice2->scale = p_voice->scale;\n\t\tp_voice2->octave = p_voice->octave;\n\t\tp_voice2->transpose = p_voice->transpose;\n\t\tmemcpy(&p_voice2->key, &p_voice->key,\n\t\t\t\t\tsizeof p_voice2->key);\n\t\tmemcpy(&p_voice2->ckey, &p_voice->ckey,\n\t\t\t\t\tsizeof p_voice2->ckey);\n\t\tmemcpy(&p_voice2->okey, &p_voice->okey,\n\t\t\t\t\tsizeof p_voice2->okey);\n\t\tp_voice2->posit = p_voice->posit;\n\t\tp_voice2->staff = p_voice->staff;\n\t\tp_voice2->cstaff = p_voice->cstaff;\n\t\tp_voice2->color = p_voice->color;\n\t\tp_voice2->map_name = p_voice->map_name;\n\t\trange = parsys->voice[p_voice - voice_tb].range;\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tif (parsys->voice[voice].range > range)\n\t\t\t\tparsys->voice[voice].range += clone + 1;\n\t\t}\n\t\tparsys->voice[voice2].range = range + 1;\n\t\tvoice_link(p_voice2);\n\t\tif (clone) {\n\t\t\tfor (voice3 = MAXVOICE; --voice3 >= 0; ) {\n\t\t\t\tif (parsys->voice[voice3].range < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice3 > 0) {\n\t\t\t\tp_voice3 = &voice_tb[voice3];\n\t\t\t\tstrcpy(p_voice3->id, p_voice2->id);\n\t\t\t\tp_voice3->second = 1;\n\t\t\t\tparsys->voice[voice3].second = 1;\n\t\t\t\tp_voice3->scale = voice_tb[p_voice->clone].scale;\n\t\t\t\tparsys->voice[voice3].range = range + 2;\n\t\t\t\tvoice_link(p_voice3);\n\t\t\t\tp_voice2->clone = voice3;\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Too many voices for overlay cloning\");\n\t\t\t}\n\t\t}\n\t}\n\tvoice = p_voice - voice_tb;\n//\tp_voice2->cstaff = p_voice2->staff = parsys->voice[voice2].staff\n//\t\t\t= parsys->voice[voice].staff;\n//\tif ((voice3 = p_voice2->clone) >= 0) {\n//\t\tp_voice3 = &voice_tb[voice3];\n//\t\tp_voice3->cstaff = p_voice3->staff\n//\t\t\t\t= parsys->voice[voice3].staff\n//\t\t\t\t= parsys->voice[p_voice->clone].staff;\n//\t}\n\n\tif (over_time < 0) {\t\t\t/* first '&' in a measure */\n\t\tint time;\n\n\t\tover_bar = 1;\n\t\tover_mxtime = p_voice->time;\n\t\tover_voice = voice;\n\t\ttime = p_voice2->time;\n\t\tfor (s = p_voice->last_sym; /*s*/; s = s->prev) {\n\t\t\tif (s->type == BAR\n\t\t\t || s->time <= time)\t/* (if start of tune) */\n\t\t\t\tbreak;\n\t\t}\n\t\tover_time = s->time;\n\t} else {\n\t\tif (over_mxtime == 0)\n\t\t\tover_mxtime = p_voice->time;\n\t\telse if (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t}\n\tp_voice2->time = over_time;\n\tcurvoice = p_voice2;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32436"
    },
    {
        "index": 221,
        "code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n\n    /*\n     * Create the Ref table if needed.\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    /* To add a reference :-\n     * References are maintained as a list of references,\n     * Lookup the entry, if no entry create new nodelist\n     * Add the owning node to the NodeList\n     * Return the ref\n     */\n\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23308"
    },
    {
        "index": 222,
        "code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8941"
    },
    {
        "index": 223,
        "code": "  explicit QuantizedMaxPoolingOp(OpKernelConstruction* context)\n      : MaxPoolingOp<Device, T>(context) {}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-21739"
    },
    {
        "index": 224,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 225,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *nack_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */\n    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *nack_cnt = PJ_MIN(*nack_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *nack_cnt; ++i) {\n\tpj_uint16_t val;\n\n\tpj_memcpy(&val, p, 2);\n\tnack[i].pid = pj_ntohs(val);\n\tpj_memcpy(&val, p+2, 2);\n\tnack[i].blp = pj_ntohs(val);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21722"
    },
    {
        "index": 226,
        "code": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\n\targs->ast = ast->parent;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\t// At this point we no longer have any need for parse_current or any of its\n\t// siblings; they have all been converted to the appropriate AST node. The\n\t// full parse tree will get deleted elsewhere, but in an attempt to\n\t// minimize memory usage (of which the parse tree uses a lot), start\n\t// deleting the parts we don't need now.\n\tcil_tree_children_destroy(parse_current->parent);\n\n\treturn SEPOL_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36087"
    },
    {
        "index": 227,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor* hypothesis_indices;\n    const Tensor* hypothesis_values;\n    const Tensor* hypothesis_shape;\n    const Tensor* truth_indices;\n    const Tensor* truth_values;\n    const Tensor* truth_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_indices\", &hypothesis_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_values\", &hypothesis_values));\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_shape\", &hypothesis_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_indices\", &truth_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_values\", &truth_values));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_shape\", &truth_shape));\n\n    OP_REQUIRES_OK(\n        ctx, ValidateShapes(ctx, *hypothesis_indices, *hypothesis_values,\n                            *hypothesis_shape, *truth_indices, *truth_values,\n                            *truth_shape));\n\n    TensorShape hypothesis_st_shape;\n    OP_REQUIRES_OK(ctx,\n                   TensorShapeUtils::MakeShape(\n                       hypothesis_shape->vec<int64_t>().data(),\n                       hypothesis_shape->NumElements(), &hypothesis_st_shape));\n    TensorShape truth_st_shape;\n    OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                            truth_shape->vec<int64_t>().data(),\n                            truth_shape->NumElements(), &truth_st_shape));\n\n    // Assume indices are sorted in row-major order.\n    std::vector<int64_t> sorted_order(truth_st_shape.dims());\n    std::iota(sorted_order.begin(), sorted_order.end(), 0);\n\n    sparse::SparseTensor hypothesis;\n    OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                            *hypothesis_indices, *hypothesis_values,\n                            hypothesis_st_shape, sorted_order, &hypothesis));\n\n    sparse::SparseTensor truth;\n    OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                            *truth_indices, *truth_values, truth_st_shape,\n                            sorted_order, &truth));\n\n    // Group dims 0, 1, ..., RANK - 1.  The very last dim is assumed\n    // to store the variable length sequences.\n    std::vector<int64_t> group_dims(truth_st_shape.dims() - 1);\n    std::iota(group_dims.begin(), group_dims.end(), 0);\n\n    TensorShape output_shape;\n    for (int d = 0; d < static_cast<int>(group_dims.size()); ++d) {\n      output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d),\n                                   truth_st_shape.dim_size(d)));\n    }\n    const auto output_elements = output_shape.num_elements();\n    OP_REQUIRES(\n        ctx, output_elements > 0,\n        errors::InvalidArgument(\"Got output shape \", output_shape.DebugString(),\n                                \" which has 0 elements\"));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"output\", output_shape, &output));\n    auto output_t = output->flat<float>();\n    output_t.setZero();\n\n    std::vector<int64_t> output_strides(output_shape.dims());\n    output_strides[output_shape.dims() - 1] = 1;\n    for (int d = output_shape.dims() - 2; d >= 0; --d) {\n      output_strides[d] = output_strides[d + 1] * output_shape.dim_size(d + 1);\n    }\n\n    auto hypothesis_grouper = hypothesis.group(group_dims);\n    auto truth_grouper = truth.group(group_dims);\n\n    auto hypothesis_iter = hypothesis_grouper.begin();\n    auto truth_iter = truth_grouper.begin();\n\n    auto cmp = std::equal_to<T>();\n\n    while (hypothesis_iter != hypothesis_grouper.end() &&\n           truth_iter != truth_grouper.end()) {\n      sparse::Group truth_i = *truth_iter;\n      sparse::Group hypothesis_j = *hypothesis_iter;\n      std::vector<int64_t> g_truth = truth_i.group();\n      std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n      auto truth_seq = truth_i.values<T>();\n      auto hypothesis_seq = hypothesis_j.values<T>();\n\n      if (g_truth == g_hypothesis) {\n        auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require in writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) =\n            gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp);\n        if (normalize_) output_t(loc) /= truth_seq.size();\n\n        ++hypothesis_iter;\n        ++truth_iter;\n      } else if (g_truth > g_hypothesis) {  // zero-length truth\n        auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require in writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) = hypothesis_seq.size();\n        if (normalize_ && output_t(loc) != 0.0f) {\n          output_t(loc) = std::numeric_limits<float>::infinity();\n        }\n        ++hypothesis_iter;\n      } else {  // zero-length hypothesis\n        auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require in writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n        ++truth_iter;\n      }\n    }\n    while (hypothesis_iter != hypothesis_grouper.end()) {  // zero-length truths\n      sparse::Group hypothesis_j = *hypothesis_iter;\n      std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n      auto hypothesis_seq = hypothesis_j.values<T>();\n      auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                    output_strides.begin(), int64_t{0});\n      OP_REQUIRES(\n          ctx, loc < output_elements,\n          errors::Internal(\"Got an inner product \", loc,\n                           \" which would require in writing to outside of the \"\n                           \"buffer for the output tensor (max elements \",\n                           output_elements, \")\"));\n      output_t(loc) = hypothesis_seq.size();\n      if (normalize_ && output_t(loc) != 0.0f) {\n        output_t(loc) = std::numeric_limits<float>::infinity();\n      }\n      ++hypothesis_iter;\n    }\n    while (truth_iter != truth_grouper.end()) {  // missing hypotheses\n      sparse::Group truth_i = *truth_iter;\n      std::vector<int64_t> g_truth = truth_i.group();\n      auto truth_seq = truth_i.values<T>();\n      auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                    output_strides.begin(), int64_t{0});\n      OP_REQUIRES(\n          ctx, loc < output_elements,\n          errors::Internal(\"Got an inner product \", loc,\n                           \" which would require in writing to outside of the \"\n                           \"buffer for the output tensor (max elements \",\n                           output_elements, \")\"));\n      output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n      ++truth_iter;\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29208"
    },
    {
        "index": 228,
        "code": "TEST(ImmutableConstantOpTest, FromFile) {\n  const TensorShape kFileTensorShape({1000, 1});\n  Env* env = Env::Default();\n  auto root = Scope::NewRootScope().ExitOnError();\n\n  string two_file, three_file;\n  TF_ASSERT_OK(CreateTempFile(env, 2.0f, 1000, &two_file));\n  TF_ASSERT_OK(CreateTempFile(env, 3.0f, 1000, &three_file));\n  auto node1 = ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, two_file);\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, three_file);\n  auto result = ops::MatMul(root, node1, node2, ops::MatMul::TransposeB(true));\n\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41227"
    },
    {
        "index": 229,
        "code": "static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n{\n    qreal x0 = 0, y0 = 0;              // starting point\n    qreal x = 0, y = 0;                // current point\n    char lastMode = 0;\n    QPointF ctrlPt;\n    const QChar *str = dataStr.constData();\n    const QChar *end = str + dataStr.size();\n\n    while (str != end) {\n        while (str->isSpace() && (str + 1) != end)\n            ++str;\n        QChar pathElem = *str;\n        ++str;\n        QChar endc = *end;\n        *const_cast<QChar *>(end) = u'\\0'; // parseNumbersArray requires 0-termination that QStringView cannot guarantee\n        const char *pattern = nullptr;\n        if (pathElem == QLatin1Char('a') || pathElem == QLatin1Char('A'))\n            pattern = \"rrrffrr\";\n        QVarLengthArray<qreal, 8> arg;\n        parseNumbersArray(str, arg, pattern);\n        *const_cast<QChar *>(end) = endc;\n        if (pathElem == QLatin1Char('z') || pathElem == QLatin1Char('Z'))\n            arg.append(0);//dummy\n        const qreal *num = arg.constData();\n        int count = arg.count();\n        while (count > 0) {\n            qreal offsetX = x;        // correction offsets\n            qreal offsetY = y;        // for relative commands\n            switch (pathElem.unicode()) {\n            case 'm': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = x0 = num[0] + offsetX;\n                y = y0 = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                 // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                 // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                 // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                 pathElem = QLatin1Char('l');\n            }\n                break;\n            case 'M': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = x0 = num[0];\n                y = y0 = num[1];\n                num += 2;\n                count -= 2;\n                path.moveTo(x0, y0);\n\n                // As per 1.2  spec 8.3.2 The \"moveto\" commands\n                // If a 'moveto' is followed by multiple pairs of coordinates without explicit commands,\n                // the subsequent pairs shall be treated as implicit 'lineto' commands.\n                pathElem = QLatin1Char('L');\n            }\n                break;\n            case 'z':\n            case 'Z': {\n                x = x0;\n                y = y0;\n                count--; // skip dummy\n                num++;\n                path.closeSubpath();\n            }\n                break;\n            case 'l': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = num[0] + offsetX;\n                y = num[1] + offsetY;\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n\n            }\n                break;\n            case 'L': {\n                if (count < 2) {\n                    num++;\n                    count--;\n                    break;\n                }\n                x = num[0];\n                y = num[1];\n                num += 2;\n                count -= 2;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'h': {\n                x = num[0] + offsetX;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'H': {\n                x = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'v': {\n                y = num[0] + offsetY;\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'V': {\n                y = num[0];\n                num++;\n                count--;\n                path.lineTo(x, y);\n            }\n                break;\n            case 'c': {\n                if (count < 6) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1(num[0] + offsetX, num[1] + offsetY);\n                QPointF c2(num[2] + offsetX, num[3] + offsetY);\n                QPointF e(num[4] + offsetX, num[5] + offsetY);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'C': {\n                if (count < 6) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1(num[0], num[1]);\n                QPointF c2(num[2], num[3]);\n                QPointF e(num[4], num[5]);\n                num += 6;\n                count -= 6;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 's': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'S': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c1;\n                if (lastMode == 'c' || lastMode == 'C' ||\n                    lastMode == 's' || lastMode == 'S')\n                    c1 = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c1 = QPointF(x, y);\n                QPointF c2(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.cubicTo(c1, c2, e);\n                ctrlPt = c2;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'q': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c(num[0] + offsetX, num[1] + offsetY);\n                QPointF e(num[2] + offsetX, num[3] + offsetY);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'Q': {\n                if (count < 4) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF c(num[0], num[1]);\n                QPointF e(num[2], num[3]);\n                num += 4;\n                count -= 4;\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 't': {\n                if (count < 2) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF e(num[0] + offsetX, num[1] + offsetY);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'T': {\n                if (count < 2) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                QPointF e(num[0], num[1]);\n                num += 2;\n                count -= 2;\n                QPointF c;\n                if (lastMode == 'q' || lastMode == 'Q' ||\n                    lastMode == 't' || lastMode == 'T')\n                    c = QPointF(2*x-ctrlPt.x(), 2*y-ctrlPt.y());\n                else\n                    c = QPointF(x, y);\n                path.quadTo(c, e);\n                ctrlPt = c;\n                x = e.x();\n                y = e.y();\n                break;\n            }\n            case 'a': {\n                if (count < 7) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++) + offsetX;\n                qreal ey = (*num++) + offsetY;\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            case 'A': {\n                if (count < 7) {\n                    num += count;\n                    count = 0;\n                    break;\n                }\n                qreal rx = (*num++);\n                qreal ry = (*num++);\n                qreal xAxisRotation = (*num++);\n                qreal largeArcFlag  = (*num++);\n                qreal sweepFlag = (*num++);\n                qreal ex = (*num++);\n                qreal ey = (*num++);\n                count -= 7;\n                qreal curx = x;\n                qreal cury = y;\n                pathArc(path, rx, ry, xAxisRotation, int(largeArcFlag),\n                        int(sweepFlag), ex, ey, curx, cury);\n\n                x = ex;\n                y = ey;\n            }\n                break;\n            default:\n                return false;\n            }\n            lastMode = pathElem.toLatin1();\n        }\n    }\n    return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45930"
    },
    {
        "index": 231,
        "code": "RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *host,\n                                   MemoryRegion *mr)\n{\n    RAMBlock *new_block;\n    ram_addr_t max_size = size;\n\n    size = HOST_PAGE_ALIGN(uc, size);\n    max_size = HOST_PAGE_ALIGN(uc, max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    if (new_block == NULL)\n        return NULL;\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->page_size = uc->qemu_real_host_page_size;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    ram_block_add(mr->uc, new_block);\n\n    return new_block;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 232,
        "code": "RawTile TileManager::getRegion( unsigned int res, int seq, int ang, int layers, unsigned int x, unsigned int y, unsigned int width, unsigned int height ){\n\n  // If our image type can directly handle region compositing, simply return that\n  if( image->regionDecoding() ){\n    if( loglevel >= 3 ){\n      *logfile << \"TileManager getRegion :: requesting region directly from image\" << endl;\n    }\n    return image->getRegion( seq, ang, res, layers, x, y, width, height );\n  }\n\n  // Otherwise do the compositing ourselves\n\n  // The tile size of the source tile\n  unsigned int src_tile_width = image->getTileWidth();\n  unsigned int src_tile_height = image->getTileHeight();\n\n  // The tile size of the destination tile\n  unsigned int dst_tile_width = src_tile_width;\n  unsigned int dst_tile_height = src_tile_height;\n\n  // The basic tile size ie. not the current tile\n  unsigned int basic_tile_width = src_tile_width;\n  unsigned int basic_tile_height = src_tile_height;\n\n  int num_res = image->getNumResolutions();\n  unsigned int im_width = image->image_widths[num_res-res-1];\n  unsigned int im_height = image->image_heights[num_res-res-1];\n\n  unsigned int rem_x = im_width % src_tile_width;\n  unsigned int rem_y = im_height % src_tile_height;\n\n  // The number of tiles in each direction\n  unsigned int ntlx = (im_width / src_tile_width) + (rem_x == 0 ? 0 : 1);\n  unsigned int ntly = (im_height / src_tile_height) + (rem_y == 0 ? 0 : 1);\n\n  // Start and end tiles and pixel offsets\n  unsigned int startx, endx, starty, endy, xoffset, yoffset;\n\n\n  if( ! ( x==0 && y==0 && width==im_width && height==im_height ) ){\n    // Calculate the start tiles\n    startx = (unsigned int) ( x / src_tile_width );\n    starty = (unsigned int) ( y / src_tile_height );\n    xoffset = x % src_tile_width;\n    yoffset = y % src_tile_height;\n\n    endx = (unsigned int) ceil( (float)(width + x) / (float)src_tile_width );\n    endy = (unsigned int) ceil( (float)(height + y) / (float)src_tile_height );\n\n    if( loglevel >= 3 ){\n      *logfile << \"TileManager getRegion :: Total tiles in image: \" << ntlx << \"x\" << ntly << \" tiles\" << endl\n\t       << \"TileManager getRegion :: Tile start: \" << startx << \",\" << starty << \" with offset: \"\n\t       << xoffset << \",\" << yoffset << endl\n\t       << \"TileManager getRegion :: Tile end: \" << endx-1 << \",\" << endy-1 << endl;\n    }\n  }\n  else{\n    startx = starty = xoffset = yoffset = 0;\n    endx = ntlx;\n    endy = ntly;\n  }\n\n\n  unsigned int channels = image->getNumChannels();\n  unsigned int bpc = image->getNumBitsPerPixel();\n  SampleType sampleType = image->getSampleType();\n\n  // Assume 1 bit data has been unpacked to 8 bits per channel\n  if( bpc == 1 ) bpc = 8;\n\n  // Create an empty tile with the correct dimensions\n  RawTile region( 0, res, seq, ang, width, height, channels, bpc );\n  region.dataLength = width * height * channels * (bpc/8);\n  region.sampleType = sampleType;\n\n  // Allocate memory for the region\n  if( bpc == 8 ) region.data = new unsigned char[width*height*channels];\n  else if( bpc == 16 ) region.data = new unsigned short[width*height*channels];\n  else if( bpc == 32 && sampleType == FIXEDPOINT ) region.data = new int[width*height*channels];\n  else if( bpc == 32 && sampleType == FLOATINGPOINT ) region.data = new float[width*height*channels];\n\n  unsigned int current_height = 0;\n\n  // Decode the image strip by strip\n  for( unsigned int i=starty; i<endy; i++ ){\n\n    unsigned int buffer_index = 0;\n\n    // Keep track of the current pixel boundary horizontally. ie. only up\n    //  to the beginning of the current tile boundary.\n    unsigned int current_width = 0;\n\n    for( unsigned int j=startx; j<endx; j++ ){\n\n      // Time the tile retrieval\n      if( loglevel >= 3 ) tile_timer.start();\n\n      // Get an uncompressed tile\n      RawTile rawtile = this->getTile( res, (i*ntlx) + j, seq, ang, layers, UNCOMPRESSED );\n\n      if( loglevel >= 5 ){\n\t*logfile << \"TileManager getRegion :: Tile access time \" << tile_timer.getTime() << \" microseconds for tile \"\n\t\t << (i*ntlx) + j << \" at resolution \" << res << endl;\n      }\n\n\n      // Only print this out once per image\n      if( (loglevel >= 5) && (i==starty) && (j==starty) ){\n\t*logfile << \"TileManager getRegion :: Tile data is \" << rawtile.channels << \" channels, \"\n\t\t << rawtile.bpc << \" bits per channel\" << endl;\n      }\n\n      // Set the tile width and height to be that of the source tile - Use the rawtile data\n      // because if we take a tile from cache the image pointer will not necessarily be pointing\n      // to the the current tile\n      src_tile_width = rawtile.width;\n      src_tile_height = rawtile.height;\n      dst_tile_width = src_tile_width;\n      dst_tile_height = src_tile_height;\n\n      // Variables for the pixel offset within the current tile\n      unsigned int xf = 0;\n      unsigned int yf = 0;\n\n      // If our viewport has been set, we need to modify our start\n      // and end points on the source image\n      if( !( x==0 && y==0 && width==im_width && height==im_height ) ){\n\n\tunsigned int remainder;  // Remaining pixels in the final row or column\n\n\tif( j == startx ){\n\t  // Calculate the width used in the current tile\n\t  // If there is only 1 tile, the width is just the view width\n\t  if( j < endx - 1 ) dst_tile_width = src_tile_width - xoffset;\n\t  else dst_tile_width = width;\n\t  xf = xoffset;\n\t}\n\telse if( j == endx-1 ){\n\t  // If this is the final row, calculate the remaining number of pixels\n\t  remainder = (width+x) % basic_tile_width;\n\t  if( remainder != 0 ) dst_tile_width = remainder;\n\t}\n\n\tif( i == starty ){\n\t  // Calculate the height used in the current row of tiles\n\t  // If there is only 1 row the height is just the view height\n\t  if( i < endy - 1 ) dst_tile_height = src_tile_height - yoffset;\n\t  else dst_tile_height = height;\n\t  yf = yoffset;\n\t}\n\telse if( i == endy-1 ){\n\t  // If this is the final row, calculate the remaining number of pixels\n\t  remainder = (height+y) % basic_tile_height;\n\t  if( remainder != 0 ) dst_tile_height = remainder;\n\t}\n\n\tif( loglevel >= 5 ){\n\t  *logfile << \"TileManager getRegion :: destination tile width: \" << dst_tile_width\n\t\t   << \", tile height: \" << dst_tile_height << endl;\n\t}\n      }\n\n\n      // Copy our tile data into the appropriate part of the strip memory\n      // one whole tile width at a time\n      for( unsigned int k=0; k<dst_tile_height; k++ ){\n\n\tbuffer_index = (current_width*channels) + (k*width*channels) + (current_height*width*channels);\n\tunsigned int inx = ((k+yf)*rawtile.width*channels) + (xf*channels);\n\n\t// Simply copy the line of data across\n\tif( bpc == 8 ){\n\t  unsigned char* ptr = (unsigned char*) rawtile.data;\n\t  unsigned char* buf = (unsigned char*) region.data;\n\t  memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels );\n\t}\n\telse if( bpc ==  16 ){\n\t  unsigned short* ptr = (unsigned short*) rawtile.data;\n\t  unsigned short* buf = (unsigned short*) region.data;\n\t  memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels*2 );\n\t}\n\telse if( bpc == 32 && sampleType == FIXEDPOINT ){\n\t  unsigned int* ptr = (unsigned int*) rawtile.data;\n\t  unsigned int* buf = (unsigned int*) region.data;\n\t  memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels*4 );\n\t}\n\telse if( bpc == 32 && sampleType == FLOATINGPOINT ){\n\t  float* ptr = (float*) rawtile.data;\n\t  float* buf = (float*) region.data;\n\t  memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels*4 );\n\t}\n      }\n\n      current_width += dst_tile_width;\n    }\n\n    current_height += dst_tile_height;\n\n  }\n\n  return region;\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 233,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 234,
        "code": "static pj_status_t respond_digest( pj_pool_t *pool,\n\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n         pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5_STR)==0))\n    {\n\tPJ_LOG(4,(THIS_FILE, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Build digest credential from arguments. */\n    pj_strdup(pool, &cred->username, &cred_info->username);\n    pj_strdup(pool, &cred->realm, &chal->realm);\n    pj_strdup(pool, &cred->nonce, &chal->nonce);\n    pj_strdup(pool, &cred->uri, uri);\n    pj_strdup(pool, &cred->algorithm, &chal->algorithm);\n    pj_strdup(pool, &cred->opaque, &chal->opaque);\n\n    /* Allocate memory. */\n    cred->response.slen = algo_sha256? PJSIP_SHA256STRLEN : PJSIP_MD5STRLEN;\n    cred->response.ptr = (char*) pj_pool_alloc(pool, cred->response.slen);\n\n    if (chal->qop.slen == 0) {\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\n\tif (cnonce && cnonce->slen) {\n\t    pj_strdup(pool, &cred->cnonce, cnonce);\n\t} else {\n\t    pj_str_t dummy_cnonce = { \"b39971\", 6};\n\t    pj_strdup(pool, &cred->cnonce, &dummy_cnonce);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24754"
    },
    {
        "index": 235,
        "code": "static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 236,
        "code": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t    name = tagstack[tagstackidx].tagname;\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2946"
    },
    {
        "index": 237,
        "code": "void fx_TypedArray(txMachine* the)\n{\n\ttxSlot* instance = fxConstructTypedArray(the);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* data = C_NULL;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\ttxSlot* slot;\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\ttxInteger offset = fxArgToByteLength(the, 1, 0);\n\t\t\ttxInteger size;\n\t\t\ttxSlot* info;\n\t\t\tif (offset & ((1 << shift) - 1))\n\t\t\t\tmxRangeError(\"invalid byteOffset %ld\", offset);\n\t\t\tsize = fxArgToByteLength(the, 2, -1);\n\t\t\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\t\t\tif (size >= 0) {\n\t\t\t\tsize <<= shift;\n\t\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (info->value.bufferInfo.length & ((1 << shift) - 1))\n\t\t\t\t\tmxRangeError(\"invalid byteLength %ld\", info->value.bufferInfo.length);\n\t\t\t\tsize = info->value.bufferInfo.length - offset;\n\t\t\t\tif (size < 0)\n\t\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t\t\tif (info->value.bufferInfo.maxLength >= 0)\n\t\t\t\t\tsize = -1;\n\t\t\t}\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tbuffer->kind = XS_REFERENCE_KIND;\n\t\t\tbuffer->value.reference = mxArgv(0)->value.reference;\n\t\t}\n\t\telse if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\ttxSlot* sourceDispatch = slot;\n\t\t\ttxSlot* sourceView = sourceDispatch->next;\n\t\t\ttxSlot* sourceBuffer = sourceView->next;\n\t\t\ttxU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift;\n\t\t\ttxInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\ttxSlot* sourceData = sourceBuffer->value.reference->next;\n\t\t\ttxInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size;\n\t\t\ttxInteger sourceOffset = sourceView->value.dataView.offset;\n\t\t\ttxInteger offset = 0;\n\t\t\ttxInteger size = sourceLength << shift;\n\t\t\t/* THIS */\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* FUNCTION */\n\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* TARGET */\n\t\t\tif (sourceData->kind == XS_ARRAY_BUFFER_KIND) {\n\t\t\t\tmxPushSlot(sourceBuffer);\n\t\t\t\tmxGetID(mxID(_constructor));\n\t\t\t\tfxToSpeciesConstructor(the, &mxArrayBufferConstructor);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* RESULT */\n\t\t\tmxPushUndefined();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* ARGUMENTS */\n\t\t\tsourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\tmxPushInteger(size);\n\t\t\tmxRunCount(1);\n\t\t\tmxPullSlot(buffer);\n\t\t\tsourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\t\n\t\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tif (dispatch == sourceDispatch)\n\t\t\t\tc_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size);\n\t\t\telse {\n\t\t\t\ttxBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\ttxBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\tif (contentType != sourceContentType)\n\t\t\t\t\tmxTypeError(\"incompatible content type\");\n\t\t\t\tmxPushUndefined();\n\t\t\t\twhile (offset < size) {\n\t\t\t\t\t(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\t\t\tsourceOffset += sourceDelta;\n\t\t\t\t\toffset += 1 << shift;\n\t\t\t\t}\n\t\t\t\tmxPop();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfx_TypedArray_from_object(the, instance, C_NULL, C_NULL);\n\t\t}\n\t}\n\telse {\n        txInteger length = fxArgToByteLength(the, 0, 0);\n        if (length & (((1 << shift) - 1) << (32 - shift)))\n\t\t\tmxRangeError(\"out of range byteLength\");\n        length <<= shift;\n\t\tmxPush(mxArrayBufferConstructor);\n\t\tmxNew();\n\t\tmxPushInteger(length);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(buffer);\n        view->value.dataView.offset = 0;\n        view->value.dataView.size = length;\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29368"
    },
    {
        "index": 238,
        "code": "static int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tsize_t i, j, len;\n\n\tr_return_val_if_fail (bin && !bin->shdr, false);\n\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = R_NEWS0 (Elf_(Shdr), bin->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_flags = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_addr = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_offset = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_size = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_addralign = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_entsize = R_BIN_ELF_READWORD (shdr, j);\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 239,
        "code": "    void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            int32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    } // Jp2Image::encodeJp2Header\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29464"
    },
    {
        "index": 240,
        "code": "MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2279"
    },
    {
        "index": 241,
        "code": "TEST(CudnnRNNOpsTest, ForwardV3Lstm_ShapeFn) {\n  int max_seq_length = 2;\n  int batch_size = 3;\n  int num_units = 4;\n  int num_layers = 5;\n  int dir_count = 1;\n  std::vector<int> input_shape = {max_seq_length, batch_size, num_units};\n  std::vector<int> input_h_shape = {num_layers * dir_count, batch_size,\n                                    num_units};\n  std::vector<int> input_c_shape = {num_layers * dir_count, batch_size,\n                                    num_units};\n  std::vector<int> output_shape = {max_seq_length, batch_size,\n                                   num_units * dir_count};\n  std::vector<int> seq_lengths_shape = {batch_size};\n  auto shape_to_str = [](const std::vector<int>& v) {\n    return strings::StrCat(\"[\", absl::StrJoin(v, \",\"), \"]\");\n  };\n  string input_shapes_desc = strings::StrCat(\n      shape_to_str(input_shape), \";\", shape_to_str(input_h_shape), \";\",\n      shape_to_str(input_c_shape), \";\", \"[?]\", \";\",\n      shape_to_str(seq_lengths_shape));\n  string output_shapes_desc = \"[d0_0,d0_1,d1_2];in1;in2;?;?\";\n\n  ShapeInferenceTestOp op(\"CudnnRNNV3\");\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"CudnnRNNV3\")\n                   .Input({\"input\", 0, DT_FLOAT})\n                   .Input({\"input_h\", 0, DT_FLOAT})\n                   .Input({\"input_c\", 0, DT_FLOAT})\n                   .Input({\"params\", 0, DT_FLOAT})\n                   .Input({\"sequence_lengths\", 0, DT_INT32})\n                   .Attr(\"rnn_mode\", \"lstm\")\n                   .Attr(\"input_mode\", \"auto_select\")\n                   .Attr(\"direction\", \"unidirectional\")\n                   .Finalize(&op.node_def));\n  INFER_OK(op, input_shapes_desc, output_shapes_desc);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41221"
    },
    {
        "index": 242,
        "code": "utf_find_illegal(void)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*p;\n    int\t\tlen;\n    vimconv_T\tvimconv;\n    char_u\t*tofree = NULL;\n\n    vimconv.vc_type = CONV_NONE;\n    if (enc_utf8 && (enc_canon_props(curbuf->b_p_fenc) & ENC_8BIT))\n    {\n\t// 'encoding' is \"utf-8\" but we are editing a 8-bit encoded file,\n\t// possibly a utf-8 file with illegal bytes.  Setup for conversion\n\t// from utf-8 to 'fileencoding'.\n\tconvert_setup(&vimconv, p_enc, curbuf->b_p_fenc);\n    }\n\n    curwin->w_cursor.coladd = 0;\n    for (;;)\n    {\n\tp = ml_get_cursor();\n\tif (vimconv.vc_type != CONV_NONE)\n\t{\n\t    vim_free(tofree);\n\t    tofree = string_convert(&vimconv, p, NULL);\n\t    if (tofree == NULL)\n\t\tbreak;\n\t    p = tofree;\n\t}\n\n\twhile (*p != NUL)\n\t{\n\t    // Illegal means that there are not enough trail bytes (checked by\n\t    // utf_ptr2len()) or too many of them (overlong sequence).\n\t    len = utf_ptr2len(p);\n\t    if (*p >= 0x80 && (len == 1\n\t\t\t\t     || utf_char2len(utf_ptr2char(p)) != len))\n\t    {\n\t\tif (vimconv.vc_type == CONV_NONE)\n\t\t    curwin->w_cursor.col += (colnr_T)(p - ml_get_cursor());\n\t\telse\n\t\t{\n\t\t    int\t    l;\n\n\t\t    len = (int)(p - tofree);\n\t\t    for (p = ml_get_cursor(); *p != NUL && len-- > 0; p += l)\n\t\t    {\n\t\t\tl = utf_ptr2len(p);\n\t\t\tcurwin->w_cursor.col += l;\n\t\t    }\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    p += len;\n\t}\n\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t    break;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // didn't find it: don't move and beep\n    curwin->w_cursor = pos;\n    beep_flush();\n\ntheend:\n    vim_free(tofree);\n    convert_setup(&vimconv, NULL, NULL);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1621"
    },
    {
        "index": 243,
        "code": "extern \"C\" int64_t enc_untrusted_syscall(int sysno, ...) {\n  if (!enc_is_error_handler_set()) {\n    enc_set_error_handler(default_error_handler);\n  }\n\n  asylo::system_call::SystemCallDescriptor descriptor{sysno};\n  if (!descriptor.is_valid()) {\n    error_handler(\"system_call.cc: Invalid SystemCallDescriptor encountered.\");\n  }\n\n  // Collect the passed parameter list into an array.\n  std::array<uint64_t, asylo::system_call::kParameterMax> parameters;\n  va_list args;\n  va_start(args, sysno);\n  for (int i = 0; i < descriptor.parameter_count(); i++) {\n    parameters[i] = va_arg(args, uint64_t);\n  }\n  va_end(args);\n\n  // Allocate a buffer for the serialized request.\n  asylo::primitives::Extent request;\n  asylo::primitives::PrimitiveStatus status;\n  status = asylo::system_call::SerializeRequest(sysno, parameters, &request);\n  if (!status.ok()) {\n    error_handler(\n        \"system_call.cc: Encountered serialization error when serializing \"\n        \"syscall parameters.\");\n  }\n\n  std::unique_ptr<uint8_t, MallocDeleter> request_owner(request.As<uint8_t>());\n\n  // Invoke the system call dispatch callback to execute the system call.\n  uint8_t *response_buffer;\n  size_t response_size;\n\n  if (!enc_is_syscall_dispatcher_set()) {\n    error_handler(\"system_.cc: system call dispatcher not set.\");\n  }\n  status = global_syscall_callback(request.As<uint8_t>(), request.size(),\n                                   &response_buffer, &response_size);\n  if (!status.ok()) {\n    error_handler(\n        \"system_call.cc: Callback from syscall dispatcher was unsuccessful.\");\n  }\n\n  std::unique_ptr<uint8_t, MallocDeleter> response_owner(response_buffer);\n\n  if (!response_buffer) {\n    error_handler(\n        \"system_call.cc: null response buffer received for the syscall.\");\n  }\n\n  // Copy outputs back into pointer parameters.\n  auto response_reader =\n      asylo::system_call::MessageReader({response_buffer, response_size});\n  const asylo::primitives::PrimitiveStatus response_status =\n      response_reader.Validate();\n  if (!response_status.ok()) {\n    error_handler(\n        \"system_call.cc: Error deserializing response buffer into response \"\n        \"reader.\");\n  }\n\n  for (int i = 0; i < asylo::system_call::kParameterMax; i++) {\n    asylo::system_call::ParameterDescriptor parameter = descriptor.parameter(i);\n    if (parameter.is_out()) {\n      size_t size;\n      if (parameter.is_fixed()) {\n        size = parameter.size();\n      } else {\n        size = parameters[parameter.size()] * parameter.element_size();\n      }\n      const void *src = response_reader.parameter_address(i);\n      void *dst = reinterpret_cast<void *>(parameters[i]);\n      if (dst != nullptr) {\n        memcpy(dst, src, size);\n      }\n    }\n  }\n\n  uint64_t result = response_reader.header()->result;\n  if (static_cast<int64_t>(result) == -1) {\n    int klinux_errno = response_reader.header()->error_number;\n\n    // Simply having a return value of -1 from a syscall is not a necessary\n    // condition that the syscall failed. Some syscalls can return -1 when\n    // successful (eg., lseek). The reliable way to check for syscall failure is\n    // to therefore check both return value and presence of a non-zero errno.\n    if (klinux_errno != 0) {\n      errno = FromkLinuxErrno(klinux_errno);\n    }\n  }\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-22552"
    },
    {
        "index": 244,
        "code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-37600"
    },
    {
        "index": 245,
        "code": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tif (node) {\n\t\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*proto coding*/\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n\t\tIf IsLocal is TRUE remove the node*/\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t\t}\n\t\t}\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2453"
    },
    {
        "index": 246,
        "code": "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n\t\t\t\tconst pj_uint8_t *start, const pj_uint8_t *max, \n\t\t\t\tint *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n\t/* Too many name recursion */\n\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n\tif ((*p & 0xc0) == 0xc0) {\n\t    /* Compression is found! */\n\t    int ptr_len = 0;\n\t    int dummy;\n\t    pj_uint16_t offset;\n\n\t    /* Get the 14bit offset */\n\t    pj_memcpy(&offset, p, 2);\n\t    offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n\t    offset = pj_ntohs(offset);\n\n\t    /* Check that offset is valid */\n\t    if (offset >= max - pkt)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    /* Get the name length from that offset. */\n\t    status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n\t\t\t\t  &dummy, &ptr_len);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    *parsed_len += 2;\n\t    *name_len += ptr_len;\n\n\t    return PJ_SUCCESS;\n\t} else {\n\t    unsigned label_len = *p;\n\n\t    /* Check that label length is valid */\n\t    if (pkt+label_len > max)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    p += (label_len + 1);\n\t    *parsed_len += (label_len + 1);\n\n\t    if (*p != 0)\n\t\t++label_len;\n\t    \n\t    *name_len += label_len;\n\n\t    if (p >= max)\n\t\treturn PJLIB_UTIL_EDNSINSIZE;\n\t}\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24793"
    },
    {
        "index": 247,
        "code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n\n  UBYTE i;\n\n  BuildCommon();\n\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-31796"
    },
    {
        "index": 248,
        "code": "int64 CSteamNetworkConnectionBase::SNP_SendMessage( CSteamNetworkingMessage *pSendMessage, SteamNetworkingMicroseconds usecNow, bool *pbThinkImmediately )\n{\n\tint cbData = (int)pSendMessage->m_cbSize;\n\n\t// Assume we won't want to wake up immediately\n\tif ( pbThinkImmediately )\n\t\t*pbThinkImmediately = false;\n\n\t// Check if we're full\n\tif ( m_senderState.PendingBytesTotal() + cbData > m_connectionConfig.m_SendBufferSize.Get() )\n\t{\n\t\tSpewWarningRateLimited( usecNow, \"Connection already has %u bytes pending, cannot queue any more messages\\n\", m_senderState.PendingBytesTotal() );\n\t\tpSendMessage->Release();\n\t\treturn -k_EResultLimitExceeded; \n\t}\n\n\t// Check if they try to send a really large message\n\tif ( cbData > k_cbMaxUnreliableMsgSize && !( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )  )\n\t{\n\t\tSpewWarningRateLimited( usecNow, \"Trying to send a very large (%d bytes) unreliable message.  Sending as reliable instead.\\n\", cbData );\n\t\tpSendMessage->m_nFlags |= k_nSteamNetworkingSend_Reliable;\n\t}\n\n\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoDelay )\n\t{\n\t\t// FIXME - need to check how much data is currently pending, and return\n\t\t// k_EResultIgnored if we think it's going to be a while before this\n\t\t// packet goes on the wire.\n\t}\n\n\t// First, accumulate tokens, and also limit to reasonable burst\n\t// if we weren't already waiting to send\n\tSNP_ClampSendRate();\n\tSNP_TokenBucket_Accumulate( usecNow );\n\n\t// Assign a message number\n\tpSendMessage->m_nMessageNumber = ++m_senderState.m_nLastSentMsgNum;\n\n\t// Reliable, or unreliable?\n\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )\n\t{\n\t\tpSendMessage->SNPSend_SetReliableStreamPos( m_senderState.m_nReliableStreamPos );\n\n\t\t// Generate the header\n\t\tbyte *hdr = pSendMessage->SNPSend_ReliableHeader();\n\t\thdr[0] = 0;\n\t\tbyte *hdrEnd = hdr+1;\n\t\tint64 nMsgNumGap = pSendMessage->m_nMessageNumber - m_senderState.m_nLastSendMsgNumReliable;\n\t\tAssert( nMsgNumGap >= 1 );\n\t\tif ( nMsgNumGap > 1 )\n\t\t{\n\t\t\thdrEnd = SerializeVarInt( hdrEnd, (uint64)nMsgNumGap );\n\t\t\thdr[0] |= 0x40;\n\t\t}\n\t\tif ( cbData < 0x20 )\n\t\t{\n\t\t\thdr[0] |= (byte)cbData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thdr[0] |= (byte)( 0x20 | ( cbData & 0x1f ) );\n\t\t\thdrEnd = SerializeVarInt( hdrEnd, cbData>>5U );\n\t\t}\n\t\tpSendMessage->m_cbSNPSendReliableHeader = hdrEnd - hdr;\n\n\t\t// Grow the total size of the message by the header\n\t\tpSendMessage->m_cbSize += pSendMessage->m_cbSNPSendReliableHeader;\n\n\t\t// Advance stream pointer\n\t\tm_senderState.m_nReliableStreamPos += pSendMessage->m_cbSize;\n\n\t\t// Update stats\n\t\t++m_senderState.m_nMessagesSentReliable;\n\t\tm_senderState.m_cbPendingReliable += pSendMessage->m_cbSize;\n\n\t\t// Remember last sent reliable message number, so we can know how to\n\t\t// encode the next one\n\t\tm_senderState.m_nLastSendMsgNumReliable = pSendMessage->m_nMessageNumber;\n\n\t\tAssert( pSendMessage->SNPSend_IsReliable() );\n\t}\n\telse\n\t{\n\t\tpSendMessage->SNPSend_SetReliableStreamPos( 0 );\n\t\tpSendMessage->m_cbSNPSendReliableHeader = 0;\n\n\t\t++m_senderState.m_nMessagesSentUnreliable;\n\t\tm_senderState.m_cbPendingUnreliable += pSendMessage->m_cbSize;\n\n\t\tAssert( !pSendMessage->SNPSend_IsReliable() );\n\t}\n\n\t// Add to pending list\n\tm_senderState.m_messagesQueued.push_back( pSendMessage );\n\tSpewVerboseGroup( m_connectionConfig.m_LogLevel_Message.Get(), \"[%s] SendMessage %s: MsgNum=%lld sz=%d\\n\",\n\t\t\t\t GetDescription(),\n\t\t\t\t pSendMessage->SNPSend_IsReliable() ? \"RELIABLE\" : \"UNRELIABLE\",\n\t\t\t\t (long long)pSendMessage->m_nMessageNumber,\n\t\t\t\t pSendMessage->m_cbSize );\n\n\t// Use Nagle?\n\t// We always set the Nagle timer, even if we immediately clear it.  This makes our clearing code simpler,\n\t// since we can always safely assume that once we find a message with the nagle timer cleared, all messages\n\t// queued earlier than this also have it cleared.\n\t// FIXME - Don't think this works if the configuration value is changing.  Since changing the\n\t// config value could violate the assumption that nagle times are increasing.  Probably not worth\n\t// fixing.\n\tpSendMessage->SNPSend_SetUsecNagle( usecNow + m_connectionConfig.m_NagleTime.Get() );\n\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoNagle )\n\t\tm_senderState.ClearNagleTimers();\n\n\t// Save the message number.  The code below might end up deleting the message we just queued\n\tint64 result = pSendMessage->m_nMessageNumber;\n\n\t// Schedule wakeup at the appropriate time.  (E.g. right now, if we're ready to send, \n\t// or at the Nagle time, if Nagle is active.)\n\t//\n\t// NOTE: Right now we might not actually be capable of sending end to end data.\n\t// But that case is relatievly rare, and nothing will break if we try to right now.\n\t// On the other hand, just asking the question involved a virtual function call,\n\t// and it will return success most of the time, so let's not make the check here.\n\tif ( GetState() == k_ESteamNetworkingConnectionState_Connected )\n\t{\n\t\tSteamNetworkingMicroseconds usecNextThink = SNP_GetNextThinkTime( usecNow );\n\n\t\t// Ready to send now?\n\t\tif ( usecNextThink > usecNow )\n\t\t{\n\n\t\t\t// We are rate limiting.  Spew about it?\n\t\t\tif ( m_senderState.m_messagesQueued.m_pFirst->SNPSend_UsecNagle() == 0 )\n\t\t\t{\n\t\t\t\tSpewVerbose( \"[%s] RATELIM QueueTime is %.1fms, SendRate=%.1fk, BytesQueued=%d\\n\", \n\t\t\t\t\tGetDescription(),\n\t\t\t\t\tm_senderState.CalcTimeUntilNextSend() * 1e-3,\n\t\t\t\t\tm_senderState.m_n_x * ( 1.0/1024.0),\n\t\t\t\t\tm_senderState.PendingBytesTotal()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Set a wakeup call.\n\t\t\tEnsureMinThinkTime( usecNextThink );\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\t// We're ready to send right now.  Check if we should!\n\t\t\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_UseCurrentThread )\n\t\t\t{\n\n\t\t\t\t// We should send in this thread, before the API entry point\n\t\t\t\t// that the app used returns.  Is the caller gonna handle this?\n\t\t\t\tif ( pbThinkImmediately )\n\t\t\t\t{\n\t\t\t\t\t// Caller says they will handle it\n\t\t\t\t\t*pbThinkImmediately = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Caller wants us to just do it here.\n\t\t\t\t\tCheckConnectionStateAndSetNextThinkTime( usecNow );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Wake up the service thread ASAP to send this in the background thread\n\t\t\t\tSetNextThinkTimeASAP();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-6017"
    },
    {
        "index": 249,
        "code": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-24122"
    },
    {
        "index": 250,
        "code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-38160"
    },
    {
        "index": 251,
        "code": "PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD) {\n\t/***\n\t *** ha1 = MD5(username \":\" realm \":\" password)\n\t ***/\n\tpj_md5_init(&pms);\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, uri->ptr, uri->slen);\n    pj_md5_final(&pms, digest);\n    digestNtoStr(digest, 16, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \"  ha2=%.32s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***    response = MD5(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***    response = MD5(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, ha1, PJSIP_MD5STRLEN);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, nc->ptr, nc->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cnonce->ptr, cnonce->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, qop->ptr, qop->slen);\n    }\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24754"
    },
    {
        "index": 252,
        "code": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->union_ (*other);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45931"
    },
    {
        "index": 253,
        "code": "static int readOHDRHeaderMessageDataLayout(struct READER *reader,\n                                           struct DATAOBJECT *data) {\n\n  int i, err;\n  unsigned size;\n\n  uint8_t dimensionality, layout_class;\n  uint32_t dataset_element_size;\n  uint64_t data_address, store, data_size;\n\n  UNUSED(dataset_element_size);\n  UNUSED(data_size);\n\n  if (fgetc(reader->fhd) != 3) {\n    // LCOV_EXCL_START\n    mylog(\"object OHDR message data layout message must have version 3\\n\");\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  layout_class = (uint8_t)fgetc(reader->fhd);\n  mylog(\"data layout %d\\n\", layout_class);\n\n  switch (layout_class) {\n#if 0\n\tcase 0:\n\tdata_size = readValue(reader, 2);\n\tfseek(reader->fhd, data_size, SEEK_CUR);\n\tmylog(\"TODO 0 SIZE %u\\n\", data_size);\n\tbreak;\n#endif\n  case 1:\n    data_address = readValue(reader, reader->superblock.size_of_offsets);\n    data_size = readValue(reader, reader->superblock.size_of_lengths);\n    mylog(\"CHUNK Contiguous SIZE %\" PRIu64 \"\\n\", data_size);\n\n    if (validAddress(reader, data_address)) {\n      store = ftell(reader->fhd);\n      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n      if (!data->data) {\n        if (data_size > 0x10000000)\n          return MYSOFA_INVALID_FORMAT;\n        data->data_len = data_size;\n        data->data = calloc(1, data_size);\n        if (!data->data)\n          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n      }\n      err = fread(data->data, 1, data_size, reader->fhd);\n      if (err != data_size)\n        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE\n      if (fseek(reader->fhd, store, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n    }\n    break;\n\n  case 2:\n    dimensionality = (uint8_t)fgetc(reader->fhd);\n    mylog(\"dimensionality %d\\n\", dimensionality);\n\n    if (dimensionality < 1 || dimensionality > DATAOBJECT_MAX_DIMENSIONALITY) {\n      mylog(\"data layout 2: invalid dimensionality %d %lu %lu\\n\",\n            dimensionality, sizeof(data->datalayout_chunk),\n            sizeof(data->datalayout_chunk[0]));\n      return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n    }\n    data_address = readValue(reader, reader->superblock.size_of_offsets);\n    mylog(\" CHUNK %\" PRIX64 \"\\n\", data_address);\n    for (i = 0; i < dimensionality; i++) {\n      data->datalayout_chunk[i] = readValue(reader, 4);\n      mylog(\" %d\\n\", data->datalayout_chunk[i]);\n    }\n    /* TODO last entry? error in spec: ?*/\n\n    size = data->datalayout_chunk[dimensionality - 1];\n    for (i = 0; i < data->ds.dimensionality; i++)\n      size *= data->ds.dimension_size[i];\n\n    if (validAddress(reader, data_address) && dimensionality <= 4) {\n      store = ftell(reader->fhd);\n      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n      if (!data->data) {\n        if (size > 0x10000000)\n          return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE\n        data->data_len = size;\n        data->data = calloc(1, size);\n        if (!data->data)\n          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE\n      }\n      err = treeRead(reader, data);\n      if (err)\n        return err; // LCOV_EXCL_LINE\n      if (fseek(reader->fhd, store, SEEK_SET) < 0)\n        return errno; // LCOV_EXCL_LINE\n    }\n    break;\n\n  default:\n    // LCOV_EXCL_START\n    mylog(\"object OHDR message data layout message has unknown layout class \"\n          \"%d\\n\",\n          layout_class);\n    return MYSOFA_INVALID_FORMAT;\n    // LCOV_EXCL_STOP\n  }\n\n  return MYSOFA_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3756"
    },
    {
        "index": 254,
        "code": "static void rose_timer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, timer);\n\tstruct sock *sk = &rose->sock;\n\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\t/* T1 */\n\tcase ROSE_STATE_4:\t/* T2 */\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose->state = ROSE_STATE_2;\n\t\trose_start_t3timer(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_2:\t/* T3 */\n\t\trose->neighbour->use--;\n\t\trose_disconnect(sk, ETIMEDOUT, -1, -1);\n\t\tbreak;\n\n\tcase ROSE_STATE_3:\t/* HB */\n\t\tif (rose->condition & ROSE_COND_ACK_PENDING) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_enquiry_response(sk);\n\t\t}\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2318"
    },
    {
        "index": 255,
        "code": "  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *dense_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"sp_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense\", &dense_t));\n\n    // Validations.\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),\n                errors::InvalidArgument(\n                    \"Input sp_indices should be a matrix but received shape: \",\n                    indices_t->shape().DebugString()));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(values_t->shape()) &&\n                    TensorShapeUtils::IsVector(shape_t->shape()),\n                errors::InvalidArgument(\n                    \"Inputs sp_values and sp_shape should be vectors \"\n                    \"but received shapes: \",\n                    values_t->shape().DebugString(), \" and \",\n                    shape_t->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, values_t->dim_size(0) == indices_t->dim_size(0),\n        errors::InvalidArgument(\n            \"The first dimension of values and indices should match. (\",\n            values_t->dim_size(0), \" vs. \", indices_t->dim_size(0), \")\"));\n\n    const auto indices_mat = indices_t->matrix<int64_t>();\n    const auto shape_vec = shape_t->vec<int64_t>();\n    const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));\n    const auto rhs_dims = BCast::FromShape(dense_t->shape());\n    BCast b(lhs_dims, rhs_dims, false);  // false for keeping the same num dims.\n\n    // True iff (size(lhs) >= size(rhs)) and all dims in lhs is greater or equal\n    // to dims in rhs (from right to left).\n    auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {\n      if (lhs.size() < rhs.size()) return false;\n      for (size_t i = 0; i < rhs.size(); ++i) {\n        if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;\n      }\n      return true;\n    };\n    OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),\n                errors::InvalidArgument(\n                    \"SparseDenseBinaryOpShared broadcasts dense to sparse \"\n                    \"only; got incompatible shapes: [\",\n                    absl::StrJoin(lhs_dims, \",\"), \"] vs. [\",\n                    absl::StrJoin(rhs_dims, \",\"), \"]\"));\n\n    Tensor *output_values = nullptr;\n    Tensor dense_gathered;\n    const int64_t nnz = indices_t->dim_size(0);\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nnz}), &output_values));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),\n                                &dense_gathered));\n    bool op_is_div = false;\n    if (absl::StrContains(ctx->op_kernel().type_string_view(), \"Div\")) {\n      op_is_div = true;\n    }\n    // Pulls relevant entries from the dense side, with reshape and broadcasting\n    // *of the dense side* taken into account.  Use a TensorRef to avoid blowing\n    // up memory.\n    //\n    // We can directly use the sparse indices to look up dense side, because\n    // \"b.y_reshape()\" and \"b.y_bcast()\" are guaranteed to have rank \"ndims\".\n    auto dense_gathered_flat = dense_gathered.flat<T>();\n    const int ndims = lhs_dims.size();\n    switch (ndims) {\n#define CASE(NDIM)                                                             \\\n  case NDIM: {                                                                 \\\n    TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \\\n        dense_t->shaped<T, NDIM>(b.y_reshape())                                \\\n            .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \\\n    Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \\\n    bool indices_valid = true;                                                 \\\n    for (int i = 0; i < nnz; ++i) {                                            \\\n      for (int d = 0; d < NDIM; ++d) {                                         \\\n        idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \\\n        if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \\\n          indices_valid = false;                                               \\\n        }                                                                      \\\n      }                                                                        \\\n      OP_REQUIRES(                                                             \\\n          ctx, indices_valid,                                                  \\\n          errors::InvalidArgument(\"Provided indices are out-of-bounds w.r.t. \" \\\n                                  \"dense side with broadcasted shape\"));       \\\n      dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \\\n      if (op_is_div) {                                                         \\\n        OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \\\n                    errors::InvalidArgument(                                   \\\n                        \"SparseDenseCwiseDiv cannot divide by zero,\"           \\\n                        \"but input dense tensor contains zero \"));             \\\n      }                                                                        \\\n    }                                                                          \\\n    break;                                                                     \\\n  }\n\n      CASE(1);\n      CASE(2);\n      CASE(3);\n      CASE(4);\n      CASE(5);\n      default:\n        OP_REQUIRES(\n            ctx, false,\n            errors::InvalidArgument(\"Only tensors with ranks between 1 and 5 \"\n                                    \"are currently supported.  Tensor rank: \",\n                                    ndims));\n#undef CASE\n    }\n\n    output_values->flat<T>().device(ctx->eigen_device<Device>()) =\n        values_t->flat<T>().binaryExpr(dense_gathered_flat,\n                                       typename Functor::func());\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23567"
    },
    {
        "index": 256,
        "code": "void LosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanDecoder *dc = m_pDCDecoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        LONG v;\n        UBYTE symbol = dc->Get(&m_Stream);\n        \n        if (symbol == 0) {\n          v = 0;\n        } else if (symbol == 16) {\n          v = -32768;\n        } else {\n          LONG thre = 1L << (symbol - 1);\n          LONG diff = m_Stream.Get(symbol); // get the number of bits \n          if (diff < thre) {\n            diff += (-1L << symbol) + 1;\n          }\n          v = diff;\n        }\n        //\n        // Set the current pixel, do the inverse pointwise transformation.\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-31620"
    },
    {
        "index": 257,
        "code": "static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1987"
    },
    {
        "index": 258,
        "code": "static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t *id, pad = 0;\n\tint len, result = RLC_OK;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* EB = 00 | 02 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PUB);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tdo {\n\t\t\t\t\t\trand_bytes(&pad, 1);\n\t\t\t\t\t} while (pad == 0);\n\t\t\t\t\tbn_add_dig(m, m, pad);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\n\t\t\t\t*p_len = m_len;\n\t\t\t\tm_len--;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad != RSA_PUB) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t*p_len -= (m_len - 1);\n\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len - len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\tbn_lsh(m, m, 8 * len);\n\t\t\t\tbn_read_bin(t, id, len);\n\t\t\t\tbn_add(m, m, t);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tm_len--;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad != RSA_PRV) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\tif (m_len == 0) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tm_len -= len;\n\n\t\t\t\tbn_rsh(t, m, m_len * 8);\n\t\t\t\tint r = 0;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tr |= pad - id[len - i - 1];\n\t\t\t\t\tbn_rsh(t, t, 8);\n\t\t\t\t}\n\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\tresult = (r == 0 ? RLC_OK : RLC_ERR);\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tm_len--;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad != RSA_PRV) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\tif (m_len == 0) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36316"
    },
    {
        "index": 259,
        "code": "eval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\t// Truncate before a trailing comment, so that concatenating the lines\n\t// won't turn the rest into a comment.\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2889"
    },
    {
        "index": 260,
        "code": "de265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps)\n{\n  int vlc;\n\n  nal_hrd_parameters_present_flag = get_bits(br, 1);\n  vcl_hrd_parameters_present_flag = get_bits(br, 1);\n\n  if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag)\n  {\n    sub_pic_hrd_params_present_flag = get_bits(br, 1);\n    if (sub_pic_hrd_params_present_flag)\n    {\n      tick_divisor_minus2 = get_bits(br, 8);\n      du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5);\n      sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1);\n      dpb_output_delay_du_length_minus1 = get_bits(br, 5);\n    }\n    bit_rate_scale = get_bits(br, 4);\n    cpb_size_scale = get_bits(br, 4);\n\n\n    if (sub_pic_hrd_params_present_flag)\n    {\n      cpb_size_du_scale = get_bits(br, 4);\n    }\n    initial_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    au_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    dpb_output_delay_length_minus1 = get_bits(br, 5);\n  }\n  int  i, j, nalOrVcl;\n\n  for (i = 0; i < sps->sps_max_sub_layers; i++)\n  {\n    fixed_pic_rate_general_flag[i] = get_bits(br, 1);\n    if (!fixed_pic_rate_general_flag[i])\n    {\n      fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1);\n    }\n    else\n    {\n      fixed_pic_rate_within_cvs_flag[i] = true;\n    }\n\n    low_delay_hrd_flag[i] = 0;// Infered to be 0 when not present\n    cpb_cnt_minus1[i] = 0;    // Infered to be 0 when not present\n\n    if (fixed_pic_rate_within_cvs_flag[i])\n    {\n      READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0);\n    }\n    else\n    {\n      low_delay_hrd_flag[i] = get_bits(br, 1);\n    }\n    if (!low_delay_hrd_flag[i])\n    {\n      READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0);\n    }\n\n    for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)\n    {\n      if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) ||\n        ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag))\n      {\n        for (j = 0; j <= cpb_cnt_minus1[i]; j++)\n        {\n          READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0);\n\n          if (sub_pic_hrd_params_present_flag)\n          {\n            READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n            READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          }\n          cbr_flag[i][j][nalOrVcl] = get_bits(br, 1);\n        }\n      }\n    }\n  }\n  return DE265_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1253"
    },
    {
        "index": 261,
        "code": "njs_promise_perform_race_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_value_t                  arguments[2], next;\n    njs_promise_capability_t     *capability;\n    njs_promise_iterator_args_t  *pargs;\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    capability = pargs->capability;\n\n    arguments[0] = capability->resolve;\n    arguments[1] = capability->reject;\n\n    (void) njs_promise_invoke_then(vm, &next, arguments, 2);\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-32414"
    },
    {
        "index": 262,
        "code": "win_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0319"
    },
    {
        "index": 263,
        "code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), len);\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8905"
    },
    {
        "index": 264,
        "code": "compile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2874"
    },
    {
        "index": 265,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length)\n{\n    pjmedia_rtcp_common *hdr;\n    unsigned len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    len = 12;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB PLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 266,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_tensor = ctx->input(1);\n    const Tensor& input_max_tensor = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,\n                errors::InvalidArgument(\n                    \"input_min_tensor must have as many elements as input on \"\n                    \"the dequantization axis (\",\n                    axis_, \"), got \", input_min_tensor.NumElements(),\n                    \", expected \", num_slices));\n    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,\n                errors::InvalidArgument(\n                    \"input_max_tensor must have as many elements as input on \"\n                    \"the dequantization axis (\",\n                    axis_, \"), got \", input_max_tensor.NumElements(),\n                    \", expected \", num_slices));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor float_output =\n        need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n    if (num_slices == 1) {\n      const float min_range = input_min_tensor.flat<float>()(0);\n      const float max_range = input_max_tensor.flat<float>()(0);\n      DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n    } else {\n      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                  errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                        \"Dequantize with axis != -1.\"));\n\n      int64_t pre_dim = 1, post_dim = 1;\n      for (int i = 0; i < axis_; ++i) {\n        pre_dim *= float_output.dim_size(i);\n      }\n      for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n        post_dim *= float_output.dim_size(i);\n      }\n      auto input_tensor = input.template bit_casted_shaped<T, 3>(\n          {pre_dim, num_slices, post_dim});\n      auto output_tensor =\n          float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n      auto min_ranges = input_min_tensor.vec<float>();\n      auto max_ranges = input_max_tensor.vec<float>();\n      for (int i = 0; i < num_slices; ++i) {\n        DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                        input_tensor.template chip<1>(i), min_ranges(i),\n                        max_ranges(i), output_tensor.template chip<1>(i));\n      }\n    }\n    if (need_cast_) {\n      S* out_ptr = output->flat<S>().data();\n      float* in_ptr = float_output.flat<float>().data();\n      for (int64_t i = 0; i < float_output.NumElements(); ++i) {\n        out_ptr[i] = static_cast<S>(in_ptr[i]);\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21726"
    },
    {
        "index": 267,
        "code": "  void Compute(OpKernelContext* context) override {\n    // Get inputs\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n\n    // Since we limit to a 2-D input (flat_values of rank 1 and a single splits\n    // tensor), our output dimension will be 1 with it's size equal to the\n    // number of splits (outer dimension or ragged tensor).\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n\n    // Use a single index over the flattened input values tensor.\n    int idx = 0;\n    // Loop through our split dimension to create a new string at each split.\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32 code_point = input_tensor_flat(idx);\n        // Check for invalid code point\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      // Encode our string and save in the output.\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29559"
    },
    {
        "index": 268,
        "code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-33099"
    },
    {
        "index": 269,
        "code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    //XXX do error handling\n    parsePathDataFast(data, qpath);\n\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45930"
    },
    {
        "index": 270,
        "code": "njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,\n    uint32_t append)\n{\n    uint32_t     free_before, free_after;\n    uint64_t     size;\n    njs_value_t  *start, *old;\n\n    free_before = array->start - array->data;\n    free_after = array->size - array->length - free_before;\n\n    if (njs_fast_path(free_before >= prepend && free_after >= append)) {\n        return NJS_OK;\n    }\n\n    size = (uint64_t) prepend + array->length + append;\n\n    if (size < 16) {\n        size *= 2;\n\n    } else {\n        size += size / 2;\n    }\n\n    if (njs_slow_path(size > (UINT32_MAX / sizeof(njs_value_t)))) {\n        goto memory_error;\n    }\n\n    start = njs_mp_align(vm->mem_pool, sizeof(njs_value_t),\n                         size * sizeof(njs_value_t));\n    if (njs_slow_path(start == NULL)) {\n        goto memory_error;\n    }\n\n    array->size = size;\n\n    old = array->data;\n    array->data = start;\n    start += prepend;\n\n    if (array->length != 0) {\n        memcpy(start, array->start, array->length * sizeof(njs_value_t));\n    }\n\n    array->start = start;\n\n    njs_mp_free(vm->mem_pool, old);\n\n    return NJS_OK;\n\nmemory_error:\n\n    njs_memory_error(vm);\n\n    return NJS_ERROR;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27008"
    },
    {
        "index": 271,
        "code": "diff_mark_adjust_tp(\n    tabpage_T\t*tp,\n    int\t\tidx,\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dnext;\n    int\t\ti;\n    int\t\tinserted, deleted;\n    int\t\tn, off;\n    linenr_T\tlast;\n    linenr_T\tlnum_deleted = line1;\t// lnum of remaining deletion\n    int\t\tcheck_unchanged;\n\n    if (diff_internal())\n    {\n\t// Will update diffs before redrawing.  Set _invalid to update the\n\t// diffs themselves, set _update to also update folds properly just\n\t// before redrawing.\n\t// Do update marks here, it is needed for :%diffput.\n\ttp->tp_diff_invalid = TRUE;\n\ttp->tp_diff_update = TRUE;\n    }\n\n    if (line2 == MAXLNUM)\n    {\n\t// mark_adjust(99, MAXLNUM, 9, 0): insert lines\n\tinserted = amount;\n\tdeleted = 0;\n    }\n    else if (amount_after > 0)\n    {\n\t// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines\n\tinserted = amount_after;\n\tdeleted = 0;\n    }\n    else\n    {\n\t// mark_adjust(98, 99, MAXLNUM, -2): delete lines\n\tinserted = 0;\n\tdeleted = -amount_after;\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    for (;;)\n    {\n\t// If the change is after the previous diff block and before the next\n\t// diff block, thus not touching an existing change, create a new diff\n\t// block.  Don't do this when ex_diffgetput() is busy.\n\tif ((dp == NULL || dp->df_lnum[idx] - 1 > line2\n\t\t    || (line2 == MAXLNUM && dp->df_lnum[idx] > line1))\n\t\t&& (dprev == NULL\n\t\t    || dprev->df_lnum[idx] + dprev->df_count[idx] < line1)\n\t\t&& !diff_busy)\n\t{\n\t    dnext = diff_alloc_new(tp, dprev, dp);\n\t    if (dnext == NULL)\n\t\treturn;\n\n\t    dnext->df_lnum[idx] = line1;\n\t    dnext->df_count[idx] = inserted;\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t{\n\t\t    if (dprev == NULL)\n\t\t\tdnext->df_lnum[i] = line1;\n\t\t    else\n\t\t\tdnext->df_lnum[i] = line1\n\t\t\t    + (dprev->df_lnum[i] + dprev->df_count[i])\n\t\t\t    - (dprev->df_lnum[idx] + dprev->df_count[idx]);\n\t\t    dnext->df_count[i] = deleted;\n\t\t}\n\t}\n\n\t// if at end of the list, quit\n\tif (dp == NULL)\n\t    break;\n\n\t/*\n\t * Check for these situations:\n\t *\t  1  2\t3\n\t *\t  1  2\t3\n\t * line1     2\t3  4  5\n\t *\t     2\t3  4  5\n\t *\t     2\t3  4  5\n\t * line2     2\t3  4  5\n\t *\t\t3     5  6\n\t *\t\t3     5  6\n\t */\n\t// compute last line of this change\n\tlast = dp->df_lnum[idx] + dp->df_count[idx] - 1;\n\n\t// 1. change completely above line1: nothing to do\n\tif (last >= line1 - 1)\n\t{\n\t    // 6. change below line2: only adjust for amount_after; also when\n\t    // \"deleted\" became zero when deleted all lines between two diffs\n\t    if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2)\n\t    {\n\t\tif (amount_after == 0)\n\t\t    break;\t// nothing left to change\n\t\tdp->df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\toff = dp->df_lnum[idx] - lnum_deleted;\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp->df_count[idx];\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\toff = 0;\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - 1 - last;\n\t\t\t\tdeleted -= dp->df_next->df_lnum[idx]\n\t\t\t\t\t\t\t       - lnum_deleted;\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = line2 - last;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 3. delete lines inside the diff\n\t\t\t    n = 0;\n\t\t\t    dp->df_count[idx] -= deleted;\n\t\t\t}\n\t\t    }\n\n\t\t    for (i = 0; i < DB_COUNT; ++i)\n\t\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t\t{\n\t\t\t    dp->df_lnum[i] -= off;\n\t\t\t    dp->df_count[i] += n;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (dp->df_lnum[idx] <= line1)\n\t\t    {\n\t\t\t// inserted lines somewhere in this diff\n\t\t\tdp->df_count[idx] += inserted;\n\t\t\tcheck_unchanged = TRUE;\n\t\t    }\n\t\t    else\n\t\t\t// inserted lines somewhere above this diff\n\t\t\tdp->df_lnum[idx] += inserted;\n\t\t}\n\n\t\tif (check_unchanged)\n\t\t    // Check if inserted lines are equal, may reduce the\n\t\t    // size of the diff.  TODO: also check for equal lines\n\t\t    // in the middle and perhaps split the block.\n\t\t    diff_check_unchanged(tp, dp);\n\t    }\n\t}\n\n\t// check if this block touches the previous one, may merge them.\n\tif (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx]\n\t\t\t\t\t\t\t  == dp->df_lnum[idx])\n\t{\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL)\n\t\t    dprev->df_count[i] += dp->df_count[i];\n\t    dprev->df_next = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dprev->df_next;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    while (dp != NULL)\n    {\n\t// All counts are zero, remove this entry.\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0)\n\t\tbreak;\n\tif (i == DB_COUNT)\n\t{\n\t    dnext = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dnext;\n\t    if (dprev == NULL)\n\t\ttp->tp_first_diff = dnext;\n\t    else\n\t\tdprev->df_next = dnext;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n\n    }\n\n    if (tp == curtab)\n    {\n\t// Don't redraw right away, this updates the diffs, which can be slow.\n\tneed_diff_redraw = TRUE;\n\n\t// Need to recompute the scroll binding, may remove or add filler\n\t// lines (e.g., when adding lines above w_topline). But it's slow when\n\t// making many changes, postpone until redrawing.\n\tdiff_need_scrollbind = TRUE;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2210"
    },
    {
        "index": 272,
        "code": "diff_buf_delete(buf_T *buf)\n{\n    int\t\ti;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diffbuf[i] = NULL;\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t\tdiff_redraw(TRUE);\n\t}\n    }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2208"
    },
    {
        "index": 273,
        "code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-31306"
    },
    {
        "index": 274,
        "code": "static void get_over(struct SYMBOL *s)\n{\n\tstruct VOICE_S *p_voice, *p_voice2, *p_voice3;\n\tint range, voice, voice2, voice3;\nstatic char tx_wrong_dur[] = \"Wrong duration in voice overlay\";\nstatic char txt_no_note[] = \"No note in voice overlay\";\n\n\t/* treat the end of overlay */\n\tp_voice = curvoice;\n\tif (p_voice->ignore)\n\t\treturn;\n\tif (s->abc_type == ABC_T_BAR\n\t || s->u.v_over.type == V_OVER_E)  {\n\t\tif (!p_voice->last_sym) {\n\t\t\terror(1, s, txt_no_note);\n\t\t\treturn;\n\t\t}\n\t\tp_voice->last_sym->sflags |= S_BEAM_END;\n\t\tover_bar = 0;\n\t\tif (over_time < 0) {\n\t\t\terror(1, s, \"Erroneous end of voice overlap\");\n\t\t\treturn;\n\t\t}\n\t\tif (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t\tcurvoice = &voice_tb[over_voice];\n\t\tover_mxtime = 0;\n\t\tover_voice = -1;\n\t\tover_time = -1;\n\t\treturn;\n\t}\n\n\t/* treat the full overlay start */\n\tif (s->u.v_over.type == V_OVER_S) {\n\t\tover_voice = p_voice - voice_tb;\n\t\tover_time = p_voice->time;\n\t\treturn;\n\t}\n\n\t/* (here is treated a new overlay - '&') */\n\t/* create the extra voice if not done yet */\n\tif (!p_voice->last_sym) {\n\t\terror(1, s, txt_no_note);\n\t\treturn;\n\t}\n\tp_voice->last_sym->sflags |= S_BEAM_END;\n\tvoice2 = s->u.v_over.voice;\n\tp_voice2 = &voice_tb[voice2];\n\tif (parsys->voice[voice2].range < 0) {\n\t\tint clone;\n\n\t\tif (cfmt.abc2pscompat) {\n\t\t\terror(1, s, \"Cannot have %%%%abc2pscompat\");\n\t\t\tcfmt.abc2pscompat = 0;\n\t\t}\n\t\tclone = p_voice->clone >= 0;\n\t\tp_voice2->id[0] = '&';\n\t\tp_voice2->id[1] = '\\0';\n\t\tp_voice2->second = 1;\n\t\tparsys->voice[voice2].second = 1;\n\t\tp_voice2->scale = p_voice->scale;\n\t\tp_voice2->octave = p_voice->octave;\n\t\tp_voice2->transpose = p_voice->transpose;\n\t\tmemcpy(&p_voice2->key, &p_voice->key,\n\t\t\t\t\tsizeof p_voice2->key);\n\t\tmemcpy(&p_voice2->ckey, &p_voice->ckey,\n\t\t\t\t\tsizeof p_voice2->ckey);\n\t\tmemcpy(&p_voice2->okey, &p_voice->okey,\n\t\t\t\t\tsizeof p_voice2->okey);\n\t\tp_voice2->posit = p_voice->posit;\n\t\tp_voice2->staff = p_voice->staff;\n\t\tp_voice2->cstaff = p_voice->cstaff;\n\t\tp_voice2->color = p_voice->color;\n\t\tp_voice2->map_name = p_voice->map_name;\n\t\trange = parsys->voice[p_voice - voice_tb].range;\n\t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n\t\t\tif (parsys->voice[voice].range > range)\n\t\t\t\tparsys->voice[voice].range += clone + 1;\n\t\t}\n\t\tparsys->voice[voice2].range = range + 1;\n\t\tvoice_link(p_voice2);\n\t\tif (clone) {\n\t\t\tfor (voice3 = MAXVOICE; --voice3 >= 0; ) {\n\t\t\t\tif (parsys->voice[voice3].range < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (voice3 > 0) {\n\t\t\t\tp_voice3 = &voice_tb[voice3];\n\t\t\t\tstrcpy(p_voice3->id, p_voice2->id);\n\t\t\t\tp_voice3->second = 1;\n\t\t\t\tparsys->voice[voice3].second = 1;\n\t\t\t\tp_voice3->scale = voice_tb[p_voice->clone].scale;\n\t\t\t\tparsys->voice[voice3].range = range + 2;\n\t\t\t\tvoice_link(p_voice3);\n\t\t\t\tp_voice2->clone = voice3;\n\t\t\t} else {\n\t\t\t\terror(1, s,\n\t\t\t\t      \"Too many voices for overlay cloning\");\n\t\t\t}\n\t\t}\n\t}\n\tvoice = p_voice - voice_tb;\n//\tp_voice2->cstaff = p_voice2->staff = parsys->voice[voice2].staff\n//\t\t\t= parsys->voice[voice].staff;\n//\tif ((voice3 = p_voice2->clone) >= 0) {\n//\t\tp_voice3 = &voice_tb[voice3];\n//\t\tp_voice3->cstaff = p_voice3->staff\n//\t\t\t\t= parsys->voice[voice3].staff\n//\t\t\t\t= parsys->voice[p_voice->clone].staff;\n//\t}\n\n\tif (over_time < 0) {\t\t\t/* first '&' in a measure */\n\t\tint time;\n\n\t\tover_bar = 1;\n\t\tover_mxtime = p_voice->time;\n\t\tover_voice = voice;\n\t\ttime = p_voice2->time;\n\t\tfor (s = p_voice->last_sym; /*s*/; s = s->prev) {\n\t\t\tif (s->type == BAR\n\t\t\t || s->time <= time)\t/* (if start of tune) */\n\t\t\t\tbreak;\n\t\t}\n\t\tover_time = s->time;\n\t} else {\n\t\tif (over_mxtime == 0)\n\t\t\tover_mxtime = p_voice->time;\n\t\telse if (p_voice->time != over_mxtime)\n\t\t\terror(1, s, tx_wrong_dur);\n\t}\n\tp_voice2->time = over_time;\n\tcurvoice = p_voice2;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32434"
    },
    {
        "index": 275,
        "code": "ex_diffgetput(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tcount;\n    linenr_T\toff = 0;\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dfree;\n    int\t\tidx_cur;\n    int\t\tidx_other;\n    int\t\tidx_from;\n    int\t\tidx_to;\n    int\t\ti;\n    int\t\tadded;\n    char_u\t*p;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    int\t\tstart_skip, end_skip;\n    int\t\tnew_count;\n    int\t\tbuf_empty;\n    int\t\tfound_not_ma = FALSE;\n\n    // Find the current buffer in the list of diff buffers.\n    idx_cur = diff_buf_idx(curbuf);\n    if (idx_cur == DB_COUNT)\n    {\n\temsg(_(e_current_buffer_is_not_in_diff_mode));\n\treturn;\n    }\n\n    if (*eap->arg == NUL)\n    {\n\t// No argument: Find the other buffer in the list of diff buffers.\n\tfor (idx_other = 0; idx_other < DB_COUNT; ++idx_other)\n\t    if (curtab->tp_diffbuf[idx_other] != curbuf\n\t\t    && curtab->tp_diffbuf[idx_other] != NULL)\n\t    {\n\t\tif (eap->cmdidx != CMD_diffput\n\t\t\t\t     || curtab->tp_diffbuf[idx_other]->b_p_ma)\n\t\t    break;\n\t\tfound_not_ma = TRUE;\n\t    }\n\tif (idx_other == DB_COUNT)\n\t{\n\t    if (found_not_ma)\n\t\temsg(_(e_no_other_buffer_in_diff_mode_is_modifiable));\n\t    else\n\t\temsg(_(e_no_other_buffer_in_diff_mode));\n\t    return;\n\t}\n\n\t// Check that there isn't a third buffer in the list\n\tfor (i = idx_other + 1; i < DB_COUNT; ++i)\n\t    if (curtab->tp_diffbuf[i] != curbuf\n\t\t    && curtab->tp_diffbuf[i] != NULL\n\t\t    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))\n\t    {\n\t\temsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use));\n\t\treturn;\n\t    }\n    }\n    else\n    {\n\t// Buffer number or pattern given.  Ignore trailing white space.\n\tp = eap->arg + STRLEN(eap->arg);\n\twhile (p > eap->arg && VIM_ISWHITE(p[-1]))\n\t    --p;\n\tfor (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)\n\t    ;\n\tif (eap->arg + i == p)\t    // digits only\n\t    i = atol((char *)eap->arg);\n\telse\n\t{\n\t    i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);\n\t    if (i < 0)\n\t\treturn;\t\t// error message already given\n\t}\n\tbuf = buflist_findnr(i);\n\tif (buf == NULL)\n\t{\n\t    semsg(_(e_cant_find_buffer_str), eap->arg);\n\t    return;\n\t}\n\tif (buf == curbuf)\n\t    return;\t\t// nothing to do\n\tidx_other = diff_buf_idx(buf);\n\tif (idx_other == DB_COUNT)\n\t{\n\t    semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg);\n\t    return;\n\t}\n    }\n\n    diff_busy = TRUE;\n\n    // When no range given include the line above or below the cursor.\n    if (eap->addr_count == 0)\n    {\n\t// Make it possible that \":diffget\" on the last line gets line below\n\t// the cursor line when there is no difference above the cursor.\n\tif (eap->cmdidx == CMD_diffget\n\t\t&& eap->line1 == curbuf->b_ml.ml_line_count\n\t\t&& diff_check(curwin, eap->line1) == 0\n\t\t&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0))\n\t    ++eap->line2;\n\telse if (eap->line1 > 0)\n\t    --eap->line1;\n    }\n\n    if (eap->cmdidx == CMD_diffget)\n    {\n\tidx_from = idx_other;\n\tidx_to = idx_cur;\n    }\n    else\n    {\n\tidx_from = idx_cur;\n\tidx_to = idx_other;\n\t// Need to make the other buffer the current buffer to be able to make\n\t// changes in it.\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);\n    }\n\n    // May give the warning for a changed buffer here, which can trigger the\n    // FileChangedRO autocommand, which may do nasty things and mess\n    // everything up.\n    if (!curbuf->b_changed)\n    {\n\tchange_warning(0);\n\tif (diff_buf_idx(curbuf) != idx_to)\n\t{\n\t    emsg(_(e_buffer_changed_unexpectedly));\n\t    goto theend;\n\t}\n    }\n\n    dprev = NULL;\n    for (dp = curtab->tp_first_diff; dp != NULL; )\n    {\n\tif (dp->df_lnum[idx_cur] > eap->line2 + off)\n\t    break;\t// past the range that was specified\n\n\tdfree = NULL;\n\tlnum = dp->df_lnum[idx_to];\n\tcount = dp->df_count[idx_to];\n\tif (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off\n\t\t&& u_save(lnum - 1, lnum + count) != FAIL)\n\t{\n\t    // Inside the specified range and saving for undo worked.\n\t    start_skip = 0;\n\t    end_skip = 0;\n\t    if (eap->addr_count > 0)\n\t    {\n\t\t// A range was specified: check if lines need to be skipped.\n\t\tstart_skip = eap->line1 + off - dp->df_lnum[idx_cur];\n\t\tif (start_skip > 0)\n\t\t{\n\t\t    // range starts below start of current diff block\n\t\t    if (start_skip > count)\n\t\t    {\n\t\t\tlnum += count;\n\t\t\tcount = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tcount -= start_skip;\n\t\t\tlnum += start_skip;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    start_skip = 0;\n\n\t\tend_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1\n\t\t\t\t\t\t\t - (eap->line2 + off);\n\t\tif (end_skip > 0)\n\t\t{\n\t\t    // range ends above end of current/from diff block\n\t\t    if (idx_cur == idx_from)\t// :diffput\n\t\t    {\n\t\t\ti = dp->df_count[idx_cur] - start_skip - end_skip;\n\t\t\tif (count > i)\n\t\t\t    count = i;\n\t\t    }\n\t\t    else\t\t\t// :diffget\n\t\t    {\n\t\t\tcount -= end_skip;\n\t\t\tend_skip = dp->df_count[idx_from] - start_skip - count;\n\t\t\tif (end_skip < 0)\n\t\t\t    end_skip = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    end_skip = 0;\n\t    }\n\n\t    buf_empty = BUFEMPTY();\n\t    added = 0;\n\t    for (i = 0; i < count; ++i)\n\t    {\n\t\t// remember deleting the last line of the buffer\n\t\tbuf_empty = curbuf->b_ml.ml_line_count == 1;\n\t\tml_delete(lnum);\n\t\t--added;\n\t    }\n\t    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)\n\t    {\n\t\tlinenr_T nr;\n\n\t\tnr = dp->df_lnum[idx_from] + start_skip + i;\n\t\tif (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count)\n\t\t    break;\n\t\tp = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from],\n\t\t\t\t\t\t\t\t  nr, FALSE));\n\t\tif (p != NULL)\n\t\t{\n\t\t    ml_append(lnum + i - 1, p, 0, FALSE);\n\t\t    vim_free(p);\n\t\t    ++added;\n\t\t    if (buf_empty && curbuf->b_ml.ml_line_count == 2)\n\t\t    {\n\t\t\t// Added the first line into an empty buffer, need to\n\t\t\t// delete the dummy empty line.\n\t\t\tbuf_empty = FALSE;\n\t\t\tml_delete((linenr_T)2);\n\t\t    }\n\t\t}\n\t    }\n\t    new_count = dp->df_count[idx_to] + added;\n\t    dp->df_count[idx_to] = new_count;\n\n\t    if (start_skip == 0 && end_skip == 0)\n\t    {\n\t\t// Check if there are any other buffers and if the diff is\n\t\t// equal in them.\n\t\tfor (i = 0; i < DB_COUNT; ++i)\n\t\t    if (curtab->tp_diffbuf[i] != NULL && i != idx_from\n\t\t\t\t\t\t\t\t&& i != idx_to\n\t\t\t    && !diff_equal_entry(dp, idx_from, i))\n\t\t\tbreak;\n\t\tif (i == DB_COUNT)\n\t\t{\n\t\t    // delete the diff entry, the buffers are now equal here\n\t\t    dfree = dp;\n\t\t    dp = dp->df_next;\n\t\t    if (dprev == NULL)\n\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    // Adjust marks.  This will change the following entries!\n\t    if (added != 0)\n\t    {\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    // Adjust the cursor position if it's in/after the changed\n\t\t    // lines.\n\t\t    if (curwin->w_cursor.lnum >= lnum + count)\n\t\t\tcurwin->w_cursor.lnum += added;\n\t\t    else if (added < 0)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t}\n\t    }\n\t    changed_lines(lnum, 0, lnum + count, (long)added);\n\n\t    if (dfree != NULL)\n\t    {\n\t\t// Diff is deleted, update folds in other windows.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\t    else\n\t\t// mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    // When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)\n\t\toff += added;\n\t}\n\n\t// If before the range or not deleted, go to next diff.\n\tif (dfree == NULL)\n\t{\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    // restore curwin/curbuf and a few other things\n    if (eap->cmdidx != CMD_diffget)\n    {\n\t// Syncing undo only works for the current buffer, but we change\n\t// another buffer.  Sync undo if the command was typed.  This isn't\n\t// 100% right when \":diffput\" is used in a function or mapping.\n\tif (KeyTyped)\n\t    u_sync(FALSE);\n\taucmd_restbuf(&aco);\n    }\n\ntheend:\n    diff_busy = FALSE;\n    if (diff_need_update)\n\tex_diffupdate(NULL);\n\n    // Check that the cursor is on a valid character and update its\n    // position.  When there were filler lines the topline has become\n    // invalid.\n    check_cursor();\n    changed_line_abv_curs();\n\n    if (diff_need_update)\n\t// redraw already done by ex_diffupdate()\n\tdiff_need_update = FALSE;\n    else\n    {\n\t// Also need to redraw the other buffers.\n\tdiff_redraw(FALSE);\n\tapply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);\n    }\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2289"
    },
    {
        "index": 276,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 8 > sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 277,
        "code": "MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                /* found match */\n                if (last_border != tag_open) {\n                    /* opening char not found, not an attribute */\n                    data += needle_length;\n                    continue;\n                }\n                /* go to attribute  beginning */\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                /* now go forward */\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1908"
    },
    {
        "index": 278,
        "code": "GF_Err stbl_unpackCTS(GF_SampleTableBox *stbl)\n{\n\tGF_DttsEntry *packed;\n\tu32 i, j, count;\n\tGF_CompositionOffsetBox *ctts;\n\tctts = stbl->CompositionOffset;\n\tif (!ctts || ctts->unpack_mode) return GF_OK;\n\tctts->unpack_mode = 1;\n\n\tpacked = ctts->entries;\n\tcount = ctts->nb_entries;\n\tctts->entries = NULL;\n\tctts->nb_entries = 0;\n\tctts->alloc_size = 0;\n\tfor (i=0; i<count; i++) {\n\t\tfor (j=0; j<packed[i].sampleCount; j++) {\n\t\t\tif (ctts->nb_entries == ctts->alloc_size) {\n\t\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\n\t\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t\t}\n\t\t\tctts->entries[ctts->nb_entries].decodingOffset = packed[i].decodingOffset;\n\t\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\t\tctts->nb_entries++;\n\t\t}\n\t}\n\tgf_free(packed);\n\n\twhile (stbl->SampleSize->sampleCount > ctts->nb_entries) {\n\t\tif (ctts->nb_entries == ctts->alloc_size) {\n\t\t\tALLOC_INC(ctts->alloc_size);\n\t\t\tctts->entries = gf_realloc(ctts->entries, sizeof(GF_DttsEntry)*ctts->alloc_size);\n\t\t\tif (!ctts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&ctts->entries[ctts->nb_entries], 0, sizeof(GF_DttsEntry)*(ctts->alloc_size-ctts->nb_entries) );\n\t\t}\n\t\tctts->entries[ctts->nb_entries].decodingOffset = 0;\n\t\tctts->entries[ctts->nb_entries].sampleCount = 1;\n\t\tctts->nb_entries++;\n\t}\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 279,
        "code": "static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"temporal_id_nesting_flag\");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \"update_rep_format_flag\");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \"rep_format_idx\");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\t\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\"))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_luma_minus8\");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \"bit_depth_chroma_minus8\");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \"log2_max_pic_order_cnt_lsb_minus4\");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"sub_layer_ordering_info_present_flag\");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_dec_pic_buffering\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"max_latency_increase\", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \"log2_min_luma_coding_block_size_minus3\");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_luma_coding_block_size\");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \"log2_min_transform_block_size_minus2\");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \"log2_max_transform_block_size\");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_inter\");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \"max_transform_hierarchy_depth_intra\");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_enable_flag\");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \"infer_scaling_list_flag\");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \"scaling_list_ref_layer_id\");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"scaling_list_data_present_flag\");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \"asymmetric_motion_partitions_enabled_flag\");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \"sample_adaptive_offset_enabled_flag\");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \"pcm_enabled_flag\")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_luma_minus1\");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \"pcm_sample_bit_depth_chroma_minus1\");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \"log2_min_pcm_luma_coding_block_size_minus3\");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \"log2_diff_max_min_pcm_luma_coding_block_size\");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \"pcm_loop_filter_disable_flag\");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \"num_short_term_ref_pic_sets\");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \"long_term_ref_pics_present_flag\");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \"num_long_term_ref_pic_sps\");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"lt_ref_pic_poc_lsb_sps\", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \"used_by_curr_pic_lt_sps_flag\", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \"temporal_mvp_enable_flag\");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \"strong_intra_smoothing_enable_flag\");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \"aspect_ratio_width\");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \"aspect_ratio_height\");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \"overscan_info_present\")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \"overscan_appropriate\");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\"))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \"transfer_characteristic\");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \"chroma_loc_info_present_flag\"))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_top_field\");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \"chroma_sample_loc_type_bottom_field\");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \"neutra_chroma_indication_flag\");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \"field_seq_flag\");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \"frame_field_info_present_flag\");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \"default_display_window_flag\"))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \"display_window_left_offset\");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \"display_window_right_offset\");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \"display_window_top_offset\");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \"display_window_bottom_offset\");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \"has_timing_info\");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \"poc_proportional_to_timing_flag\");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \"num_ticks_poc_diff_one_minus1\");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"hrd_parameters_present_flag\"))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"bitstream_restriction_flag\")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"tiles_fixed_structure_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"motion_vectors_over_pic_boundaries_flag\");\n\t\t\tgf_bs_read_int_log(bs, 1, \"restricted_ref_pic_lists_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"min_spatial_segmentation_idc\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bytes_per_pic_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"max_bits_per_min_cu_denom\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_horizontal\");\n\t\t\tgf_bs_read_ue_log(bs, \"log2_max_mv_length_vertical\");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"sps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 280,
        "code": "do_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag && drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click && which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn't move the mouse, just insert the\n\t// contents of a register.  '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    // Check for clicking in the tab page line.\n    if (mouse_row == 0 && firstwin->w_winrow > 0)\n    {\n\tif (is_drag)\n\t{\n\t    if (in_tab_line)\n\t    {\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n\t    }\n\t    return FALSE;\n\t}\n\n\t// click in a tab selects that tab page\n\tif (is_click\n# ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n# endif\n\t\t&& mouse_col < Columns)\n\t{\n\t    in_tab_line = TRUE;\n\t    c1 = TabPageIdxs[mouse_col];\n\t    if (c1 >= 0)\n\t    {\n\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t{\n\t\t    // double click opens new page\n\t\t    end_visual_mode_keep_button();\n\t\t    tabpage_new();\n\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Go to specified tab page, or next one if not clicking\n\t\t    // on a label.\n\t\t    goto_tabpage(c1);\n\n\t\t    // It's like clicking on the status line of a window.\n\t\t    if (curwin != old_curwin)\n\t\t\tend_visual_mode_keep_button();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttabpage_T\t*tp;\n\n\t\t// Close the current or specified tab page.\n\t\tif (c1 == -999)\n\t\t    tp = curtab;\n\t\telse\n\t\t    tp = find_tabpage(-c1);\n\t\tif (tp == curtab)\n\t\t{\n\t\t    if (first_tabpage->tp_next != NULL)\n\t\t\ttabpage_close(FALSE);\n\t\t}\n\t\telse if (tp != NULL)\n\t\t    tabpage_close_other(tp, FALSE);\n\t    }\n\t}\n\treturn TRUE;\n    }\n    else if (is_drag && in_tab_line)\n    {\n\tc1 = TabPageIdxs[mouse_col];\n\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\treturn FALSE;\n    }\n\n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n    // right button up   -> pop-up menu\n    // shift-left button -> right button\n    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol, &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags & IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That's a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col - curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT) && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname = '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t    {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t    find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active && old_active && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2980"
    },
    {
        "index": 281,
        "code": "static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segments_enabled_flag\");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \"num_extra_slice_header_bits\");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \"sign_data_hiding_flag\");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"cabac_init_present_flag\");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active\");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active\");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \"pic_init_qp_minus26\");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \"constrained_intra_pred_flag\");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"transform_skip_enabled_flag\");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"cu_qp_delta_enabled_flag\")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \"diff_cu_qp_delta_depth\");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \"pic_cb_qp_offset\");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \"pic_cr_qp_offset\");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"slice_chroma_qp_offsets_present_flag\");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"weighted_bipred_flag\");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \"transquant_bypass_enable_flag\");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"tiles_enabled_flag\");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_tile_columns_minus1\");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_tile_rows_minus1\");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_spacing_flag\");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \"column_width_minus1\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \"row_height_minus1\", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_tiles_enabled_flag\");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_slices_enabled_flag\");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\"))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_enabled_flag\");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \"pic_disable_deblocking_filter_flag\"))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \"beta_offset_div2\");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \"tc_offset_div2\");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"pic_scaling_list_data_present_flag\"))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \"lists_modification_present_flag\");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \"log2_parallel_merge_level_minus2\");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"slice_segment_header_extension_present_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 282,
        "code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-32762"
    },
    {
        "index": 283,
        "code": "static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                          size_t *out_len, const unsigned char *key,\n                          size_t key_len)\n{\n    PSKeyTransport_gost *pst = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    unsigned char expkeys[64];\n    EVP_PKEY *sec_key = NULL;\n    int ret = 0;\n    int mac_nid = NID_undef;\n    size_t mac_len = 0;\n    int exp_len = 0, iv_len = 0;\n    unsigned char *exp_buf = NULL;\n    int key_is_ephemeral = 0;\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        mac_len = 8;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        mac_len = 16;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    exp_len = key_len + mac_len;\n    exp_buf = OPENSSL_malloc(exp_len);\n    if (!exp_buf) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n\n    sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!sec_key)\n    {\n      sec_key = EVP_PKEY_new();\n      if (sec_key == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE );\n        goto err;\n      }\n\n      if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n          || !EVP_PKEY_copy_parameters(sec_key, pubk)\n          || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n            GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n      }\n      key_is_ephemeral = 1;\n    }\n\n    if (data->shared_ukm_size == 0) {\n        if (RAND_bytes(data->shared_ukm, 32) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        data->shared_ukm_size = 32;\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                 EVP_PKEY_get0(sec_key), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32,\n                    mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len,\n                    exp_buf, &exp_len) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    pst = PSKeyTransport_gost_new();\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pst->ukm = ASN1_OCTET_STRING_new();\n    if (pst->ukm == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    if ((*out_len = i2d_PSKeyTransport_gost(pst, out ? &out : NULL)) > 0)\n        ret = 1;\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n\n    PSKeyTransport_gost_free(pst);\n    OPENSSL_free(exp_buf);\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29242"
    },
    {
        "index": 284,
        "code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n\n    // version/flags\n    u32in();\n    // Sample size\n    u32in();\n    // Number of entries\n    mp4config.frame.ents = u32in();\n    // fixme: check atom size\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n\n        mp4config.frame.data[cnt + 1] = ofs;\n\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n\n    return size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32272"
    },
    {
        "index": 285,
        "code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, /*parent=*/nullptr, \"ToTFRecordOpIterator\", &iterator));\n\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37650"
    },
    {
        "index": 286,
        "code": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n\t\t\t} else {\n\t\t\t\tsect->name = strdup (\"\");\n\t\t\t}\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1437"
    },
    {
        "index": 287,
        "code": "changed_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1735"
    },
    {
        "index": 288,
        "code": "void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n\t\t\t\t const void *pkt,\n\t\t\t\t pj_size_t size)\n{\n    const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) \n\t\t\t\t\t\trtcp_xr->buf;\n    unsigned pkt_len, rb_len;\n\n    if (rtcp_xr->common.pt != RTCP_XR)\n\treturn;\n\n    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n\n    if ((pkt_len + 1) > (size / 4))\n\treturn;\n\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */\n    if (rb_rr_time) {\n\t/* Save LRR from NTP timestamp of the RR time block report */\n\tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate RR arrival time for DLRR */\n\tpj_get_timestamp(&sess->rx_lrr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n\t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n\t\t\t     sess->rtcp_session->ts_freq.u64)));\n    }\n\n    /* Receiving DLRR */\n    if (rb_dlrr) {\n\tpj_uint32_t lrr, now, dlrr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LRR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlrr = pj_ntohl(rb_dlrr->item.lrr);\n\n\t/* DLRR is delay since LRR, also in 1/65536 resolution */\n\tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lrr-dlrr) */\n\teedelay = now - lrr - dlrr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lrr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlrr >= lrr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay <= 30 * 1000 * 1000UL) {\n\t\t/* \"Normalize\" rtt value that is exceptionally high.\n\t\t * For such values, \"normalize\" the rtt to be three times\n\t\t * the average value.\n\t\t */\n\t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n\t\t{\n\t\t    unsigned orig_rtt = rtt;\n\t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n\t\t    PJ_LOG(5,(sess->name, \n\t\t\t      \"RTT value %d usec is normalized to %d usec\",\n\t\t\t      orig_rtt, rtt));\n\t\t}\n    \t\n\t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n\t    }\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lrr, now, dlrr, dlrr/65536,\n\t\t\t\t   (dlrr%65536)*1000/65536,\n\t\t\t\t   dlrr-(now-lrr)));\n\t}\n    }\n\n    /* Receiving Statistics Summary */\n    if (rb_stats) {\n\tpj_uint8_t flags = rb_stats->header.specific;\n\n\tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n\n\t/* Range of packets sequence reported in this blocks */\n\tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n\tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n\n\t/* Get flags of valid fields */\n\tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n\tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n\tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n\tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n\n\t/* Fetch the reports info */\n\tif (sess->stat.tx.stat_sum.l) {\n\t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n\t}\n\n\tif (sess->stat.tx.stat_sum.d) {\n\t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n\t}\n\n\tif (sess->stat.tx.stat_sum.j) {\n\t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n\t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n\t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, \n\t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n\t}\n\n\tif (sess->stat.tx.stat_sum.t) {\n\t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n\t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n\t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, \n\t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n\t}\n\n\tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n    }\n\n    /* Receiving VoIP Metrics */\n    if (rb_voip_mtc) {\n\tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n\tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n\tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n\tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n\tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n\tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n\tsess->stat.tx.voip_mtc.rnd_trip_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n\tsess->stat.tx.voip_mtc.end_sys_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->signal_lvl);\n\tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->noise_lvl);\n\tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n\tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n\tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n\tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n\tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n\tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n\tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n\tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n\tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n\tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n\n\tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-43845"
    },
    {
        "index": 289,
        "code": "R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 290,
        "code": "static int nfs_lookup_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tswitch (ntohl(rpc_pkt.u.reply.astatus)) {\n\t\tcase NFS_RPC_SUCCESS: /* Not an error */\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_MISMATCH:\n\t\t\t/* Remote can't support NFS version */\n\t\t\tswitch (ntohl(rpc_pkt.u.reply.data[0])) {\n\t\t\t/* Minimal supported NFS version */\n\t\t\tcase 3:\n\t\t\t\tdebug(\"*** Warning: NFS version not supported: Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tdebug(\"Will retry with NFSv3\\n\");\n\t\t\t\t/* Clear NFSV2_FLAG from supported versions */\n\t\t\t\tsupported_nfs_versions &= ~NFSV2_FLAG;\n\t\t\t\treturn -NFS_RPC_PROG_MISMATCH;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tputs(\"*** ERROR: NFS version not supported\");\n\t\t\t\tdebug(\": Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tputs(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_UNAVAIL:\n\t\tcase NFS_RPC_PROC_UNAVAIL:\n\t\tcase NFS_RPC_GARBAGE_ARGS:\n\t\tcase NFS_RPC_SYSTEM_ERR:\n\t\tdefault: /* Unknown error on 'accept state' flag */\n\t\t\tdebug(\"*** ERROR: accept state error (%d)\\n\",\n\t\t\t      ntohl(rpc_pkt.u.reply.astatus));\n\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\t} else {  /* NFSV3_FLAG */\n\t\tfilefh3_length = ntohl(rpc_pkt.u.reply.data[1]);\n\t\tif (filefh3_length > NFS3_FHSIZE)\n\t\t\tfilefh3_length  = NFS3_FHSIZE;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 2, filefh3_length);\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-30767"
    },
    {
        "index": 291,
        "code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29206"
    },
    {
        "index": 292,
        "code": "int __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\n\treturn SEPOL_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36087"
    },
    {
        "index": 293,
        "code": "void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_poly);\n\n    memset(getThreadLocalDecryptedDkgPoly(), 0, DKG_BUFER_LENGTH);\n\n    int status = AES_decrypt(encrypted_poly, enc_len, (char *) getThreadLocalDecryptedDkgPoly(),\n                             DKG_BUFER_LENGTH);\n\n    CHECK_STATUS2(\"sgx_unseal_data - encrypted_poly failed with status %d\")\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 294,
        "code": "void IOBuf::SharedInfo::releaseStorage(SharedInfo* info) noexcept {\n  if (info->useHeapFullStorage) {\n    auto storageAddr =\n        reinterpret_cast<uint8_t*>(info) - offsetof(HeapFullStorage, shared);\n    auto storage = reinterpret_cast<HeapFullStorage*>(storageAddr);\n    info->~SharedInfo();\n    IOBuf::releaseStorage(&storage->hs, kSharedInfoInUse);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-24036"
    },
    {
        "index": 296,
        "code": "get_user_name(char_u *buf, int len)\n{\n    if (username == NULL)\n    {\n\tif (mch_get_user_name(buf, len) == FAIL)\n\t    return FAIL;\n\tusername = vim_strsave(buf);\n    }\n    else\n\tvim_strncpy(buf, username, len - 1);\n    return OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1735"
    },
    {
        "index": 297,
        "code": "static int parse_json(ogs_sbi_message_t *message,\n        char *content_type, char *json)\n{\n    int rv = OGS_OK;\n    cJSON *item = NULL;\n\n    ogs_assert(message);\n\n    if (!json)\n        return OGS_OK;\n\n    if (!content_type) {\n        ogs_error(\"No Content-type\");\n        return OGS_ERROR;\n    }\n\n    ogs_log_print(OGS_LOG_TRACE, \"%s\", json);\n    item = cJSON_Parse(json);\n    if (!item) {\n        ogs_error(\"JSON parse error\");\n        return OGS_ERROR;\n    }\n\n    if (content_type &&\n        !strncmp(content_type, OGS_SBI_CONTENT_PROBLEM_TYPE,\n            strlen(OGS_SBI_CONTENT_PROBLEM_TYPE))) {\n        message->ProblemDetails = OpenAPI_problem_details_parseFromJSON(item);\n    } else if (content_type &&\n                !strncmp(content_type, OGS_SBI_CONTENT_PATCH_TYPE,\n                    strlen(OGS_SBI_CONTENT_PATCH_TYPE))) {\n        if (item) {\n            OpenAPI_patch_item_t *patch_item = NULL;\n            cJSON *patchJSON = NULL;\n            message->PatchItemList = OpenAPI_list_create();\n            cJSON_ArrayForEach(patchJSON, item) {\n                if (!cJSON_IsObject(patchJSON)) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown JSON\");\n                    goto cleanup;\n                }\n\n                patch_item = OpenAPI_patch_item_parseFromJSON(patchJSON);\n                OpenAPI_list_add(message->PatchItemList, patch_item);\n            }\n        }\n    } else {\n        SWITCH(message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NNRF_NFM)\n\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NF_INSTANCES)\n                message->NFProfile =\n                    OpenAPI_nf_profile_parseFromJSON(item);\n                if (!message->NFProfile) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SUBSCRIPTIONS)\n                message->SubscriptionData =\n                    OpenAPI_subscription_data_parseFromJSON(item);\n                if (!message->SubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_NF_STATUS_NOTIFY)\n                message->NotificationData =\n                    OpenAPI_notification_data_parseFromJSON(item);\n                if (!message->NotificationData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NNRF_DISC)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NF_INSTANCES)\n                message->SearchResult =\n                    OpenAPI_search_result_parseFromJSON(item);\n                if (!message->SearchResult) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n                SWITCH(message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    if (message->res_status == 0) {\n                        message->AuthenticationInfo =\n                            OpenAPI_authentication_info_parseFromJSON(item);\n                        if (!message->AuthenticationInfo) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->UeAuthenticationCtx =\n                        OpenAPI_ue_authentication_ctx_parseFromJSON(item);\n                        if (!message->UeAuthenticationCtx) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    if (message->res_status == 0) {\n                        message->ConfirmationData =\n                            OpenAPI_confirmation_data_parseFromJSON(item);\n                        if (!message->ConfirmationData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->ConfirmationDataResponse =\n                            OpenAPI_confirmation_data_response_parseFromJSON(\n                                    item);\n                        if (!message->ConfirmationDataResponse) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown method [%s]\", message->h.method);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UEAU)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_SECURITY_INFORMATION)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_GENERATE_AUTH_DATA)\n                    if (message->res_status == 0) {\n                        message->AuthenticationInfoRequest =\n                        OpenAPI_authentication_info_request_parseFromJSON(\n                                item);\n                        if (!message->AuthenticationInfoRequest) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->AuthenticationInfoResult =\n                        OpenAPI_authentication_info_result_parseFromJSON(\n                                item);\n                        if (!message->AuthenticationInfoResult) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_AUTH_EVENTS)\n                message->AuthEvent = OpenAPI_auth_event_parseFromJSON(item);\n                if (!message->AuthEvent) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_AMF_3GPP_ACCESS)\n                    message->Amf3GppAccessRegistration =\n                        OpenAPI_amf3_gpp_access_registration_parseFromJSON(\n                                item);\n                    if (!message->Amf3GppAccessRegistration) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_SDM)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n                message->AccessAndMobilitySubscriptionData =\n                    OpenAPI_access_and_mobility_subscription_data_parseFromJSON(\n                            item);\n                if (!message->AccessAndMobilitySubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECT_DATA)\n                message->SmfSelectionSubscriptionData =\n                    OpenAPI_smf_selection_subscription_data_parseFromJSON(item);\n                if (!message->SmfSelectionSubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n                message->UeContextInSmfData =\n                    OpenAPI_ue_context_in_smf_data_parseFromJSON(item);\n                if (!message->UeContextInSmfData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n                message->SessionManagementSubscriptionData =\n                    OpenAPI_session_management_subscription_data_parseFromJSON(\n                            item);\n                if (!message->SessionManagementSubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDR_DR)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SUBSCRIPTION_DATA)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_DATA)\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_SUBSCRIPTION)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->AuthenticationSubscription =\n                                OpenAPI_authentication_subscription_parseFromJSON(item);\n                            if (!message->AuthenticationSubscription) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_STATUS)\n                        message->AuthEvent =\n                            OpenAPI_auth_event_parseFromJSON(item);\n                        if (!message->AuthEvent) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                    break;\n\n                CASE(OGS_SBI_RESOURCE_NAME_CONTEXT_DATA)\n                    message->Amf3GppAccessRegistration =\n                        OpenAPI_amf3_gpp_access_registration_parseFromJSON(\n                                item);\n                    if (!message->Amf3GppAccessRegistration) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n\n                DEFAULT\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_PROVISIONED_DATA)\n                        SWITCH(message->h.resource.component[4])\n                        CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n                            message->AccessAndMobilitySubscriptionData =\n                                OpenAPI_access_and_mobility_subscription_data_parseFromJSON(item);\n                            if (!message->AccessAndMobilitySubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECTION_SUBSCRIPTION_DATA)\n                            message->SmfSelectionSubscriptionData =\n                                OpenAPI_smf_selection_subscription_data_parseFromJSON(item);\n                            if (!message->SmfSelectionSubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n                            message->UeContextInSmfData =\n                                OpenAPI_ue_context_in_smf_data_parseFromJSON(\n                                        item);\n                            if (!message->UeContextInSmfData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n                            message->SessionManagementSubscriptionData =\n                                OpenAPI_session_management_subscription_data_parseFromJSON(item);\n                            if (!message->SessionManagementSubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"Unknown resource name [%s]\",\n                                    message->h.resource.component[4]);\n                        END\n                        break;\n\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_POLICY_DATA)\n                SWITCH(message->h.resource.component[1])\n                CASE(OGS_SBI_RESOURCE_NAME_UES)\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n\n                        message->AmPolicyData =\n                            OpenAPI_am_policy_data_parseFromJSON(item);\n                        if (!message->AmPolicyData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n\n                    CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n\n                        message->SmPolicyData =\n                            OpenAPI_sm_policy_data_parseFromJSON(item);\n                        if (!message->SmPolicyData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[1]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NSMF_PDUSESSION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_CONTEXTS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_MODIFY)\n                    if (message->res_status == 0) {\n                        message->SmContextUpdateData =\n                            OpenAPI_sm_context_update_data_parseFromJSON(item);\n                        if (!message->SmContextUpdateData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->SmContextUpdatedData =\n                            OpenAPI_sm_context_updated_data_parseFromJSON(item);\n                        if (!message->SmContextUpdatedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_BAD_REQUEST ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_FORBIDDEN ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_NOT_FOUND ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_SERVICE_UNAVAILABLE ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_GATEWAY_TIMEOUT) {\n                        message->SmContextUpdateError =\n                            OpenAPI_sm_context_update_error_parseFromJSON(item);\n                        if (!message->SmContextUpdateError) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                CASE(OGS_SBI_RESOURCE_NAME_RELEASE)\n                    if (message->res_status == 0) {\n                        message->SmContextReleaseData =\n                            OpenAPI_sm_context_release_data_parseFromJSON(item);\n                        if (!message->SmContextReleaseData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NO_CONTENT) {\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->SmContextReleasedData =\n                            OpenAPI_sm_context_released_data_parseFromJSON(\n                                    item);\n                        if (!message->SmContextReleasedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    if (message->res_status == 0) {\n                        message->SmContextCreateData =\n                            OpenAPI_sm_context_create_data_parseFromJSON(item);\n                        if (!message->SmContextCreateData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->SmContextCreatedData =\n                            OpenAPI_sm_context_created_data_parseFromJSON(item);\n                        if (!message->SmContextCreatedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_BAD_REQUEST ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_FORBIDDEN ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_NOT_FOUND ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_SERVICE_UNAVAILABLE ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_GATEWAY_TIMEOUT) {\n                        message->SmContextCreateError =\n                            OpenAPI_sm_context_create_error_parseFromJSON(item);\n                        if (!message->SmContextCreateError) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_COMM)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXTS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES)\n                    if (message->res_status == 0) {\n                        message->N1N2MessageTransferReqData =\n                            OpenAPI_n1_n2_message_transfer_req_data_parseFromJSON(item);\n                        if (!message->N1N2MessageTransferReqData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                                OGS_SBI_HTTP_STATUS_OK ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_ACCEPTED) {\n                        message->N1N2MessageTransferRspData =\n                            OpenAPI_n1_n2_message_transfer_rsp_data_parseFromJSON(item);\n                        if (!message->N1N2MessageTransferRspData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_AM_POLICY_CONTROL)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_POLICIES)\n                if (message->res_status == 0) {\n                    message->PolicyAssociationRequest =\n                        OpenAPI_policy_association_request_parseFromJSON(\n                                item);\n                    if (!message->PolicyAssociationRequest) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                } else if (message->res_status == OGS_SBI_HTTP_STATUS_CREATED) {\n                    message->PolicyAssociation =\n                        OpenAPI_policy_association_parseFromJSON(item);\n                    if (!message->PolicyAssociation) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_SMPOLICYCONTROL)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_POLICIES)\n                if (!message->h.resource.component[1]) {\n                    if (message->res_status == 0) {\n                        message->SmPolicyContextData =\n                            OpenAPI_sm_policy_context_data_parseFromJSON(item);\n                        if (!message->SmPolicyContextData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->SmPolicyDecision =\n                            OpenAPI_sm_policy_decision_parseFromJSON(item);\n                        if (!message->SmPolicyDecision) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                } else {\n                    SWITCH(message->h.resource.component[2])\n                    CASE(OGS_SBI_RESOURCE_NAME_DELETE)\n                        if (message->res_status == 0) {\n                            message->SmPolicyDeleteData =\n                                OpenAPI_sm_policy_delete_data_parseFromJSON(\n                                        item);\n                            if (!message->SmPolicyDeleteData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[2]);\n                    END\n                    break;\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NNSSF_NSSELECTION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NETWORK_SLICE_INFORMATION)\n                if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                    message->AuthorizedNetworkSliceInfo =\n                        OpenAPI_authorized_network_slice_info_parseFromJSON(\n                                item);\n                    if (!message->AuthorizedNetworkSliceInfo) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NBSF_MANAGEMENT)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_PCF_BINDINGS)\n                if (message->h.resource.component[1]) {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_PATCH)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    CASE(OGS_SBI_HTTP_METHOD_DELETE)\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                    break;\n                } else {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_POST)\n                        if (message->res_status == 0 ||\n                            message->res_status ==\n                                OGS_SBI_HTTP_STATUS_CREATED) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n\n                    CASE(OGS_SBI_HTTP_METHOD_GET)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                    break;\n                }\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_POLICYAUTHORIZATION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_APP_SESSIONS)\n                if (message->h.resource.component[1]) {\n                    if (message->h.resource.component[2]) {\n                        SWITCH(message->h.resource.component[2])\n                        CASE(OGS_SBI_RESOURCE_NAME_DELETE)\n                            /* Nothing */\n                            break;\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        END\n                    } else {\n                        SWITCH(message->h.method)\n                        CASE(OGS_SBI_HTTP_METHOD_PATCH)\n                            message->AppSessionContextUpdateDataPatch =\n                                OpenAPI_app_session_context_update_data_patch_parseFromJSON(item);\n                            if (!message->AppSessionContextUpdateDataPatch) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        END\n                    }\n                } else {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_POST)\n                        if (message->res_status == 0 ||\n                            message->res_status ==\n                                OGS_SBI_HTTP_STATUS_CREATED) {\n                            message->AppSessionContext =\n                                OpenAPI_app_session_context_parseFromJSON(item);\n                            if (!message->AppSessionContext) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                }\n                break;\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_CALLBACK)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_CONTEXT_STATUS)\n                message->SmContextStatusNotification =\n                    OpenAPI_sm_context_status_notification_parseFromJSON(item);\n                if (!message->SmContextStatusNotification) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NSMF_CALLBACK)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_N1_N2_FAILURE_NOTIFY)\n                message->N1N2MsgTxfrFailureNotification =\n                    OpenAPI_n1_n2_msg_txfr_failure_notification_parseFromJSON(\n                            item);\n                if (!message->N1N2MsgTxfrFailureNotification) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SM_POLICY_NOTIFY)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_UPDATE)\n                    message->SmPolicyNotification =\n                        OpenAPI_sm_policy_notification_parseFromJSON(item);\n                    if (!message->SmPolicyNotification) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n                CASE(OGS_SBI_RESOURCE_NAME_TERMINATE)\n                    message->TerminationNotification =\n                        OpenAPI_termination_notification_parseFromJSON(item);\n                    if (!message->TerminationNotification) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        DEFAULT\n            rv = OGS_ERROR;\n            ogs_error(\"Not implemented API name [%s]\",\n                    message->h.service.name);\n        END\n    }\n\ncleanup:\n\n    cJSON_Delete(item);\n    return rv;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-44109"
    },
    {
        "index": 298,
        "code": "ex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interrupted));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0572"
    },
    {
        "index": 299,
        "code": "    void CFontFileType1::Parse()\n    {\n        // \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e pfb \u0444\u0430\u0439\u043b, \u0442\u043e\u0433\u0434\u0430 \u0438\u0437\u0431\u0430\u0432\u0438\u043c\u0441\u044f \u043e\u0442 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432.\n        Reset();\n\n        while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\\t' == m_sFile[m_nPos] || '\\r' == m_sFile[m_nPos] || '\\n' == m_sFile[m_nPos] ) )\n            ++m_nPos;\n\n        bool bSuccess = true;\n        int nChar = GetU8( m_nPos, &bSuccess );\n        if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )\n            return;\n        else if ( PFB_MARKER == nChar )\n        {\n            if ( !RemovePfbMarkers() )\n                return;\n        }\n\n        char *sLine, *sLine1, *pCur, *pTemp;\n        char sBuffer[256];\n        int nCount, nCode;\n        int nIndex = 0;\n        unsigned char *sEexec = NULL;\n\n        m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;\n        m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;\n\n        m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;\n        m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;\n        m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;\n\n        for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )\n        {\n            if ( !m_sName && !strncmp( sLine, \"/FontName\", 9) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n                if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, \" \\t\\n\\r\" ) ) )\n                {\n                    m_sName = CopyString( pCur );\n                }\n                sLine = GetNextLine(sLine);\n\n            }\n            else if ( !strncmp( sLine, \"/FontMatrix\", 11 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );\n                sLine = GetNextLine( sLine );\n            }\n            else if ( !strncmp( sLine, \"/FontBBox\", 9 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );\n                sLine = GetNextLine( sLine );\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding StandardEncoding def\", 30))\n            {\n                m_arrEncoding = c_arrsFontFileType1StandardEncoding;\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding 256 array\", 19))\n            {\n                m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));\n                int nJ = 0;\n                for (nJ = 0; nJ < 256; ++nJ )\n                {\n                    m_arrEncoding[nJ] = NULL;\n                }\n                for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)\n                {\n                    if ( ( nCount = sLine1 - sLine ) > 255 )\n                    {\n                        nCount = 255;\n                    }\n                    strncpy( sBuffer, sLine, nCount);\n                    sBuffer[ nCount ] = '\\0';\n                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                            {\n                                for ( pCur = pTemp; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                                if ( *pCur == '/')\n                                {\n                                    ++pCur;\n                                    for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\\t'; ++pTemp ) ;\n                                    *pTemp = '\\0';\n                                    m_arrEncoding[ nCode ] = CopyString( pCur );\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if ( strtok( sBuffer, \" \\t\") && ( pCur = strtok(NULL, \" \\t\\n\\r\")) && !strcmp( pCur, \"def\"))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if ( !sEexec )\n                    sEexec = (unsigned char*)strstr( sLine, \"currentfile eexec\" );\n\n                sLine = GetNextLine(sLine);\n            }\n        }\n\n        if ( NULL != sEexec )\n        {\n            unsigned char* sTemp = sEexec;\n            while ( sTemp != (unsigned char*)strstr( (char*)sTemp, \"cleartomark\" ) && sTemp < m_sFile + m_nLen )\n                sTemp++;\n\n            int nBufferLen = sTemp - ( sEexec + 17 );\n            unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );\n            if ( !sEexecBuffer )\n                return;\n\n            memcpy( sEexecBuffer, sEexec + 17, nBufferLen );\n            DecryptEexec( &sEexecBuffer, nBufferLen );\n\n            sEexec = sEexecBuffer + 4; // \u041f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u0431\u044b\u043b\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438\n            int nEexecLen = nBufferLen - 4;\n\n            // \u0422\u0435\u043f\u0435\u0440\u044c \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 Private Dict\n            bool bGlyphsSection = false, bSubrsSection = false;\n            //unsigned short ushChar = '';\n            std::wstring sToken, sGlyph;\n            int nLength = 0;\n\n            // \u0412\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 Private Dict\n            m_oPrivateDict.nBlueValues       = 0;\n            m_oPrivateDict.nOtherBlues       = 0;\n            m_oPrivateDict.nFamilyBlues      = 0;\n            m_oPrivateDict.nFamilyOtherBlues = 0;\n            m_oPrivateDict.dBlueScale        = 0.039625;\n            m_oPrivateDict.nBlueShift        = 7;\n            m_oPrivateDict.nBlueFuzz         = 1;\n            m_oPrivateDict.bHasStdHW         = false;\n            m_oPrivateDict.bHasStdVW         = false;\n            m_oPrivateDict.nStemSnapH        = 0;\n            m_oPrivateDict.nStemSnapV        = 0;\n            m_oPrivateDict.bHasForceBold     = false;\n            m_oPrivateDict.nLanguageGroup    = 0;\n            m_oPrivateDict.nLenIV            = 4;\n            m_oPrivateDict.dExpansionFactor  = 0.06;\n\n            for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )\n            {\n                unsigned char nChar = sEexec[nIndex];\n\n                if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )\n                {\n                    unsigned char *sData = new unsigned char[nLength];\n                    if ( sData )\n                    {\n                        memcpy( sData, sEexec + nIndex + 3, nLength );\n                        unsigned short unKey = 4330U;\n                        unsigned char *sCur = sData;\n                        EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );\n\n                        if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )\n                        {\n                            Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );\n                            if ( bGlyphsSection )\n                            {\n                                int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );\n\n                                if ( 0 != nUnicode )\n                                    m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );\n                            }\n                            else // if ( bSubrsSection )\n                            {\n                                m_arrSubrs.Add( oCharstring );\n                            }\n                        }\n\n                        delete []sData;\n                    }\n\n                    nIndex += nLength + 3;\n                }\n                else if ( IS_PS_SPACE( nChar ) )\n                {\n                    nLength = Utils::GetInteger( sToken );\n                    sToken.clear();\n                }\n                else\n                {\n                    sToken.push_back( (wchar_t)nChar );\n                    if ( !bGlyphsSection && '/' == sToken[0] )\n                    {\n                        int nTempChar = sToken[1];\n                        switch (nTempChar)\n                        {\n                        case 'B':\n                            {\n                                if ( L\"/BlueValues\" == sToken )\n                                    m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );\n                                else if ( L\"/BlueScale\" == sToken )\n                                    m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueShift\" == sToken )\n                                    m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueFuzz\" == sToken )\n                                    m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'C':\n                            {\n                                if ( L\"/CharString\" == sToken )\n                                    bGlyphsSection = true;\n\n                                break;\n                            }\n                        case 'E':\n                            {\n                                if ( L\"/ExpansionFactor\" == sToken )\n                                    m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'F':\n                            {\n                                if ( L\"/FamilyBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );\n                                else if ( L\"/FamilyOtherBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );\n                                else if ( L\"/ForceBold\" == sToken )\n                                {\n                                    m_oPrivateDict.bHasForceBold = true;\n                                    m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                }\n\n                                break;\n                            }\n                        case 'L':\n                            {\n                                if ( L\"/LanguageGroup\" == sToken )\n                                    m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/lenIV\" == sToken )\n                                    m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'S':\n                            {\n                                if ( L\"/Subrs\" == sToken )\n                                    bSubrsSection = true;\n                                else if ( L\"/StemSnapH\" == sToken )\n                                    m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );\n                                else if ( L\"/StemSnapV\" == sToken )\n                                    m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );\n                                else if ( L\"/StdHW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdHW = dTemp[0];\n                                    }\n                                }\n                                else if ( L\"/StdVW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdVW = dTemp[0];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n\n        m_bParsed = true;\n    }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29777"
    },
    {
        "index": 300,
        "code": "R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaElementValuePair *evp = NULL;\n\tif (!annotation) {\n\t\t// TODO eprintf invalid annotation\n\t\treturn;\n\t}\n\tprintf (\"  Annotation Type Index: 0x%02x\\n\", annotation->type_idx);\n\tprintf (\"  Annotation Number of EV Pairs: 0x%04x\\n\", annotation->num_element_value_pairs);\n\tprintf (\"  Annotation EV Pair Values:\\n\");\n\tif (annotation->element_value_pairs) {\n\t\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, evp) {\n\t\t\tr_bin_java_print_element_pair_summary (evp);\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 301,
        "code": "string LogHandler::stderrToFile(const string &pathPrefix) {\n  time_t rawtime;\n  struct tm *timeinfo;\n  char buffer[80];\n  time(&rawtime);\n  timeinfo = localtime(&rawtime);\n  strftime(buffer, sizeof(buffer), \"%Y-%m-%d_%I-%M\", timeinfo);\n  string current_time(buffer);\n  string stderrFilename = pathPrefix + \"_stderr_\" + current_time;\n  FILE *stderr_stream = freopen(stderrFilename.c_str(), \"w\", stderr);\n  if (!stderr_stream) {\n    STFATAL << \"Invalid filename \" << stderrFilename;\n  }\n  setvbuf(stderr_stream, NULL, _IOLBF, BUFSIZ);  // set to line buffering\n  return stderrFilename;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 302,
        "code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v;\n        //\n        // Get the sign coding context.\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        //\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); // true for negative.\n          //\n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            //\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            //\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          //\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        //\n        // Use the prediction to fill in the sample.\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        // Update Da and Db.\n        // Is this a bug? 32768 does not exist, but -32768 does. The streams\n        // seem to use -32768 instead.\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-31620"
    },
    {
        "index": 303,
        "code": "void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,\n                                  int level, int prev_idx, int* src_data_ptr,\n                                  T* dest_data) {\n  if (level == indices.size()) {\n    int orig_rank = dense_shape_.size();\n    std::vector<int> orig_idx;\n    orig_idx.resize(orig_rank);\n    int i = 0;\n    for (; i < orig_idx.size(); i++) {\n      int orig_dim = traversal_order_[i];\n      orig_idx[orig_dim] = indices[i];\n    }\n\n    for (; i < indices.size(); i++) {\n      const int block_idx = traversal_order_[i] - orig_rank;\n      const int orig_dim = block_map_[block_idx];\n      orig_idx[orig_dim] =\n          orig_idx[orig_dim] * block_size_[block_idx] + indices[i];\n    }\n\n    dest_data[GetFlattenedIndex(orig_idx, dense_shape_)] =\n        src_data[*src_data_ptr];\n\n    *src_data_ptr = *src_data_ptr + 1;\n    return;\n  }\n\n  const int metadata_idx = 2 * level;\n  const int shape_of_level = dim_metadata_[metadata_idx][0];\n  if (format_[level] == kTfLiteDimDense) {\n    for (int i = 0; i < shape_of_level; i++) {\n      indices[level] = i;\n      Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,\n               src_data_ptr, dest_data);\n    }\n  } else {\n    const auto& array_segments = dim_metadata_[metadata_idx];\n    const auto& array_indices = dim_metadata_[metadata_idx + 1];\n    for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];\n         i++) {\n      indices[level] = array_indices[i];\n      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23560"
    },
    {
        "index": 304,
        "code": "static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signalling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 305,
        "code": "static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n\n    /* Create a surface with memory:\n     * - pitch is rounded to alignment\n     * - adress is aligned\n     */\n    void *pixels, *ptr;\n    /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        /* Overflow... */\n        return NULL;\n    }\n\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* address is aligned */\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n\n    /* Let SDL handle the memory allocation */\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n\n    /* Initialize with background to 0 */\n    SDL_memset(pixels, 0, height * pitch);\n\n    /* Underline/Strikethrough color style */\n    *color = 1;\n\n    /* Fill the palette: 1 is foreground */\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n\n    return textbuf;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27470"
    },
    {
        "index": 306,
        "code": "string gen_dkg_poly(int _t) {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    uint32_t enc_len = 0;\n\n    vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);\n\n\n\n    sgx_status_t status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    uint64_t length = enc_len;;\n\n    vector<char> hexEncrPoly(BUF_LEN, 0);\n    CHECK_STATE(encrypted_dkg_secret.size() >= length);\n    carray2Hex(encrypted_dkg_secret.data(), length, hexEncrPoly.data(), BUF_LEN);\n    string result(hexEncrPoly.data());\n\n    return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 307,
        "code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-38593"
    },
    {
        "index": 308,
        "code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64 out_batch = out_backprop.dim_size(0);\n    const int64 out_rows = out_backprop.dim_size(1);\n    const int64 out_cols = out_backprop.dim_size(2);\n    const int64 out_depth = out_backprop.dim_size(3);\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n\n    const int64 in_batch = orig_input_tensor_shape_flat(0);\n    const int64 in_rows = orig_input_tensor_shape_flat(1);\n    const int64 in_cols = orig_input_tensor_shape_flat(2);\n    const int64 in_depth = orig_input_tensor_shape_flat(3);\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64 in_max_row_index = in_rows - 1;\n    const int64 in_max_col_index = in_cols - 1;\n    for (int64 b = 0; b < out_batch; ++b) {\n      for (int64 r = 0; r < out_rows; ++r) {\n        const int64 in_row_start = row_seq_tensor_flat(r);\n        int64 in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                        : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64 c = 0; c < out_cols; ++c) {\n          const int64 in_col_start = col_seq_tensor_flat(c);\n          int64 in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                          : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64 num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64 out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64 in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64 in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64 in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64 d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64 i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29578"
    },
    {
        "index": 309,
        "code": "Variant HHVM_FUNCTION(fwrite,\n                      const Resource& handle,\n                      const String& data,\n                      int64_t length /* = 0 */) {\n  CHECK_HANDLE(handle, f);\n  int64_t ret = f->write(data, length);\n  if (ret < 0) {\n    raise_notice(\"fwrite(): send of %d bytes failed with errno=%d %s\",\n                 data.size(), errno, folly::errnoStr(errno).c_str());\n    ret = 0;\n  }\n  return ret;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 310,
        "code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            /* If an identical palette, no need to map */\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-33657"
    },
    {
        "index": 311,
        "code": "int main(int argc, char *argv[])\n{\n\tbool lrzcat = false, compat = false, recurse = false;\n\tbool options_file = false, conf_file_compression_set = false; /* for environment and tracking of compression setting */\n\tstruct timeval start_time, end_time;\n\tstruct sigaction handler;\n\tdouble seconds,total_time; // for timers\n\tbool nice_set = false;\n\tint c, i;\n\tint hours,minutes;\n\textern int optind;\n\tchar *eptr, *av; /* for environment */\n\tchar *endptr = NULL;\n\n        control = &base_control;\n\n\tinitialise_control(control);\n\n\tav = basename(argv[0]);\n\tif (!strcmp(av, \"lrunzip\"))\n\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\telse if (!strcmp(av, \"lrzcat\")) {\n\t\tcontrol->flags |= FLAG_DECOMPRESS | FLAG_STDOUT;\n\t\tlrzcat = true;\n\t} else if (!strcmp(av, \"lrz\")) {\n\t\t/* Called in gzip compatible command line mode */\n\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\tcompat = true;\n\t\tlong_options[1].name = \"stdout\";\n\t\tlong_options[11].name = \"keep\";\n\t}\n\n\t/* generate crc table */\n\tCrcGenerateTable();\n\n\t/* Get Preloaded Defaults from lrzip.conf\n\t * Look in ., $HOME/.lrzip/, /etc/lrzip.\n\t * If LRZIP=NOCONFIG is set, then ignore config\n\t * If lrzip.conf sets a compression mode, options_file will be true.\n\t * This will allow for a test to permit an override of compression mode.\n\t * If there is an override, then all compression settings will be reset\n\t * and command line switches will prevail, including for --lzma.\n\t */\n\teptr = getenv(\"LRZIP\");\n\tif (eptr == NULL)\n\t\toptions_file = read_config(control);\n\telse if (!strstr(eptr,\"NOCONFIG\"))\n\t\toptions_file = read_config(control);\n\tif (options_file && (control->flags & FLAG_NOT_LZMA))\t\t/* if some compression set in lrzip.conf    */\n\t\tconf_file_compression_set = true;\t\t\t/* need this to allow command line override */\n\n\twhile ((c = getopt_long(argc, argv, compat ? coptions : loptions, long_options, &i)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\tcase 'g':\n\t\tcase 'l':\n\t\tcase 'n':\n\t\tcase 'z':\n\t\t\t/* If some compression was chosen in lrzip.conf, allow this one time\n\t\t\t * because conf_file_compression_set will be true\n\t\t\t */\n\t\t\tif ((control->flags & FLAG_NOT_LZMA) && conf_file_compression_set == false)\n\t\t\t\tfailure(\"Can only use one of -l, -b, -g, -z or -n\\n\");\n\t\t\t/* Select Compression Mode */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA; /* must clear all compressions first */\n\t\t\tif (c == 'b')\n\t\t\t\tcontrol->flags |= FLAG_BZIP2_COMPRESS;\n\t\t\telse if (c == 'g')\n\t\t\t\tcontrol->flags |= FLAG_ZLIB_COMPRESS;\n\t\t\telse if (c == 'l')\n\t\t\t\tcontrol->flags |= FLAG_LZO_COMPRESS;\n\t\t\telse if (c == 'n')\n\t\t\t\tcontrol->flags |= FLAG_NO_COMPRESS;\n\t\t\telse if (c == 'z')\n\t\t\t\tcontrol->flags |= FLAG_ZPAQ_COMPRESS;\n\t\t\t/* now FLAG_NOT_LZMA will evaluate as true */\n\t\t\tconf_file_compression_set = false;\n\t\t\tbreak;\n\t\tcase '/':\t\t\t\t\t\t\t/* LZMA Compress selected */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA;\t\t\t/* clear alternate compression flags */\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tset_stdout(control);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'C':\n\t\t\tcontrol->flags |= FLAG_CHECK;\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcontrol->flags |= FLAG_ENCRYPT;\n\t\t\tcontrol->passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tcontrol->flags |= FLAG_FORCE_REPLACE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(compat);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcontrol->flags |= FLAG_INFO;\n\t\t\tcontrol->flags &= ~FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'K':\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (compat) {\n\t\t\t\tlicense();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontrol->compression_level = strtol(optarg, &endptr, 10);\n\t\t\tif (control->compression_level < 1 || control->compression_level > 9)\n\t\t\t\tfailure(\"Invalid compression level (must be 1-9)\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after compression level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcontrol->ramsize = strtol(optarg, &endptr, 10) * 1024 * 1024 * 100;\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after ramsize: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnice_set = true;\n\t\t\tcontrol->nice_val = strtol(optarg, &endptr, 10);\n\t\t\tif (control->nice_val < PRIO_MIN || control->nice_val > PRIO_MAX)\n\t\t\t\tfailure(\"Invalid nice value (must be %d...%d)\\n\", PRIO_MIN, PRIO_MAX);\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after nice level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (control->outdir)\n\t\t\t\tfailure(\"Cannot have -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output filename when outputting to stdout\\n\");\n\t\t\tcontrol->outname = optarg;\n\t\t\tcontrol->suffix = \"\";\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (control->outname)\t/* can't mix -o and -O */\n\t\t\t\tfailure(\"Cannot have options -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output directory when outputting to stdout\\n\");\n\t\t\tcontrol->outdir = malloc(strlen(optarg) + 2);\n\t\t\tif (control->outdir == NULL)\n\t\t\t\tfatal(\"Failed to allocate for outdir\\n\");\n\t\t\tstrcpy(control->outdir,optarg);\n\t\t\tif (strcmp(optarg+strlen(optarg) - 1, \"/\")) \t/* need a trailing slash */\n\t\t\t\tstrcat(control->outdir, \"/\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcontrol->threads = strtol(optarg, &endptr, 10);\n\t\t\tif (control->threads < 1)\n\t\t\t\tfailure(\"Must have at least one thread\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after number of threads: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trecurse = true;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Specified output filename already, can't specify an extension.\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify a filename suffix when outputting to stdout\\n\");\n\t\t\tcontrol->suffix = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Cannot specify an output file name when just testing.\\n\");\n\t\t\tif (compat)\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\tif (!KEEP_FILES)\n\t\t\t\tfailure(\"Doubt that you want to delete a file when just testing.\\n\");\n\t\t\tcontrol->flags |= FLAG_TEST_ONLY;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcontrol->flags &= ~FLAG_THRESHOLD;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tcontrol->flags |= FLAG_UNLIMITED;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t/* set verbosity flag */\n\t\t\tif (!(control->flags & FLAG_SHOW_PROGRESS))\n\t\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\telse if (!(control->flags & FLAG_VERBOSITY) && !(control->flags & FLAG_VERBOSITY_MAX))\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY;\n\t\t\telse if ((control->flags & FLAG_VERBOSITY)) {\n\t\t\t\tcontrol->flags &= ~FLAG_VERBOSITY;\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY_MAX;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcontrol->msgout = stdout;\n\t\t\tprint_output(\"lrzip version %s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcontrol->window = strtol(optarg, &endptr, 10);\n\t\t\tif (control->window < 1)\n\t\t\t\tfailure(\"Window must be positive\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after window size: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tcontrol->compression_level = c - '0';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(compat);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (control->outname) {\n\t\tif (argc > 1)\n\t\t\tfailure(\"Cannot specify output filename with more than 1 file\\n\");\n\t\tif (recurse)\n\t\t\tfailure(\"Cannot specify output filename with recursive\\n\");\n\t}\n\n\tif (VERBOSE && !SHOW_PROGRESS) {\n\t\tprint_err(\"Cannot have -v and -q options. -v wins.\\n\");\n\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t}\n\n\tif (UNLIMITED && control->window) {\n\t\tprint_err(\"If -U used, cannot specify a window size with -w.\\n\");\n\t\tcontrol->window = 0;\n\t}\n\n\tif (argc < 1)\n\t\tcontrol->flags |= FLAG_STDIN;\n\n\tif (UNLIMITED && STDIN) {\n\t\tprint_err(\"Cannot have -U and stdin, unlimited mode disabled.\\n\");\n\t\tcontrol->flags &= ~FLAG_UNLIMITED;\n\t}\n\n\tsetup_overhead(control);\n\n\t/* Set the main nice value to half that of the backend threads since\n\t * the rzip stage is usually the rate limiting step */\n\tcontrol->current_priority = getpriority(PRIO_PROCESS, 0);\n\tif (nice_set) {\n\t\tif (!NO_COMPRESS) {\n\t\t\t/* If niceness can't be set. just reset process priority */\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val/2) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t} else {\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* One extra iteration for the case of no parameters means we will default to stdin/out */\n\tfor (i = 0; i <= argc; i++) {\n\t\tchar *dirlist = NULL, *infile = NULL;\n\t\tint direntries = 0, curentry = 0;\n\n\t\tif (i < argc)\n\t\t\tinfile = argv[i];\n\t\telse if (!(i == 0 && STDIN))\n\t\t\tbreak;\n\t\tif (infile) {\n\t\t\tif ((strcmp(infile, \"-\") == 0))\n\t\t\t\tcontrol->flags |= FLAG_STDIN;\n\t\t\telse {\n\t\t\t\tbool isdir = false;\n\t\t\t\tstruct stat istat;\n\n\t\t\t\tif (unlikely(stat(infile, &istat)))\n\t\t\t\t\tfailure(\"Failed to stat %s\\n\", infile);\n\t\t\t\tisdir = S_ISDIR(istat.st_mode);\n\t\t\t\tif (!recurse && (isdir || !S_ISREG(istat.st_mode))) {\n\t\t\t\t\tfailure(\"lrzip only works directly on regular FILES.\\n\"\n\t\t\t\t\t\"Use -r recursive, lrztar or pipe through tar for compressing directories.\\n\");\n\t\t\t\t}\n\t\t\t\tif (recurse && !isdir)\n\t\t\t\t\tfailure(\"%s not a directory, -r recursive needs a directory\\n\", infile);\n\t\t\t}\n\t\t}\n\n\t\tif (recurse) {\n\t\t\tif (unlikely(STDIN || STDOUT))\n\t\t\t\tfailure(\"Cannot use -r recursive with STDIO\\n\");\n\t\t\trecurse_dirlist(infile, &dirlist, &direntries);\n\t\t}\n\n\t\tif (INFO && STDIN)\n\t\t\tfailure(\"Will not get file info from STDIN\\n\");\nrecursion:\n\t\tif (recurse) {\n\t\t\tif (curentry >= direntries) {\n\t\t\t\tinfile = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfile = dirlist + MAX_PATH_LEN * curentry++;\n\t\t}\n\t\tcontrol->infile = infile;\n\n\t\t/* If no output filename is specified, and we're using\n\t\t * stdin, use stdout */\n\t\tif ((control->outname && (strcmp(control->outname, \"-\") == 0)) ||\n\t\t    (!control->outname && STDIN) || lrzcat)\n\t\t\t\tset_stdout(control);\n\n\t\tif (lrzcat) {\n\t\t\tcontrol->msgout = stderr;\n\t\t\tcontrol->outFILE = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (!STDOUT) {\n\t\t\tcontrol->msgout = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (STDIN)\n\t\t\tcontrol->inFILE = stdin;\n\n\t\t/* Implement signal handler only once flags are set */\n\t\tsigemptyset(&handler.sa_mask);\n\t\thandler.sa_flags = 0;\n\t\thandler.sa_handler = &sighandler;\n\t\tsigaction(SIGTERM, &handler, 0);\n\t\tsigaction(SIGINT, &handler, 0);\n\n\t\tif (!FORCE_REPLACE) {\n\t\t\tif (STDIN && isatty(fileno((FILE *)stdin))) {\n\t\t\t\tprint_err(\"Will not read stdin from a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t\tif (!TEST_ONLY && STDOUT && isatty(fileno((FILE *)stdout)) && !compat) {\n\t\t\t\tprint_err(\"Will not write stdout to a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t}\n\n\t\tif (CHECK_FILE) {\n\t\t\tif (!DECOMPRESS) {\n\t\t\t\tprint_err(\"Can only check file written on decompression.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t} else if (STDOUT) {\n\t\t\t\tprint_err(\"Can't check file written when writing to stdout. Checking disabled.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t}\n\t\t}\n\n\t\tsetup_ram(control);\n\t\tshow_summary();\n\n\t\tgettimeofday(&start_time, NULL);\n\n\t\tif (unlikely((STDIN || STDOUT) && ENCRYPT))\n\t\t\tfailure(\"Unable to work from STDIO while reading password\\n\");\n\n\t\tmemcpy(&local_control, &base_control, sizeof(rzip_control));\n\t\tif (DECOMPRESS || TEST_ONLY)\n\t\t\tdecompress_file(&local_control);\n\t\telse if (INFO)\n\t\t\tget_fileinfo(&local_control);\n\t\telse\n\t\t\tcompress_file(&local_control);\n\n\t\t/* compute total time */\n\t\tgettimeofday(&end_time, NULL);\n\t\ttotal_time = (end_time.tv_sec + (double)end_time.tv_usec / 1000000) -\n\t\t\t      (start_time.tv_sec + (double)start_time.tv_usec / 1000000);\n\t\thours = (int)total_time / 3600;\n\t\tminutes = (int)(total_time / 60) % 60;\n\t\tseconds = total_time - hours * 3600 - minutes * 60;\n\t\tif (!INFO)\n\t\t\tprint_progress(\"Total time: %02d:%02d:%05.2f\\n\", hours, minutes, seconds);\n\t\tif (recurse)\n\t\t\tgoto recursion;\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-28044"
    },
    {
        "index": 312,
        "code": "static void populate_cache_maps(RDyldCache *cache) {\n\tr_return_if_fail (cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tcache_map_t *maps = NULL;\n\tif (n_maps != 0) {\n\t\tcache->maps_index = R_NEWS0 (ut32, cache->n_hdr);\n\t\tif (!cache->maps_index) {\n\t\t\treturn;\n\t\t}\n\t\tmaps = R_NEWS0 (cache_map_t, n_maps);\n\t}\n\tif (!maps) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tut32 next_map = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof (cache_map_t) * hdr->mappingCount;\n\t\tif (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0676"
    },
    {
        "index": 313,
        "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 314,
        "code": "trustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len,\n                       char *bls_pub_key) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(bls_pub_key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"AES decrypt failed %d\");\n\n    skey_hex[ECDSA_SKEY_LEN - 1] = 0;\n\n    status = calc_bls_public_key(skey_hex, bls_pub_key);\n\n    CHECK_STATUS(\"could not calculate bls public key\");\n\n    SET_SUCCESS\n    static uint64_t counter = 0;\n    clean:\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 315,
        "code": "JsVar *jspNewBuiltin(const char *instanceOf) {\n  JsVar *objFunc = jswFindBuiltInFunction(0, instanceOf);\n  if (!objFunc) return 0; // out of memory\n  return objFunc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-25044"
    },
    {
        "index": 316,
        "code": "skip_string(char_u *p)\n{\n    int\t    i;\n\n    // We loop, because strings may be concatenated: \"date\"\"time\".\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    // 'c' or '\\n' or '\\000'\n\t{\n\t    if (p[1] == NUL)\t\t    // ' at end of line\n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    // '\\n' or '\\000'\n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    // check for trailing '\n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    // start of string\n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    // end of string\n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; // continue for another string\n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    // Raw string: R\"[delim](...)[delim]\"\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; // continue for another string\n\t    }\n\t}\n\tbreak;\t\t\t\t    // no string found\n    }\n    if (!*p)\n\t--p;\t\t\t\t    // backup from NUL\n    return p;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1733"
    },
    {
        "index": 317,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 318,
        "code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t}\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32268"
    },
    {
        "index": 319,
        "code": "void sealHexSEK(int *errStatus, char *errString,\n                        uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n    CHECK_STATE(strnlen(sek_hex, 33) == 32)\n    \n\n    uint64_t plaintextLen = strlen(sek_hex) + 1;\n    \n    uint64_t sealedLen = sgx_calc_sealed_data_size(0, plaintextLen);\n\n    sgx_attributes_t attribute_mask;\n    attribute_mask.flags = 0xfffffffffffffff3;\n    attribute_mask.xfrm = 0x0;\n    sgx_misc_select_t misc = 0xF0000000;\n\n    sgx_status_t status = sgx_seal_data_ex(SGX_KEYPOLICY_MRENCLAVE, attribute_mask, misc, 0, NULL, plaintextLen, (uint8_t *) sek_hex, sealedLen,\n                                           (sgx_sealed_data_t *) encrypted_sek);\n    CHECK_STATUS(\"seal SEK failed after SEK generation\");\n\n    uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n    CHECK_STATE(encrypt_text_length = plaintextLen);\n\n\n    SAFE_CHAR_BUF(unsealedKey, BUF_LEN);\n    uint32_t decLen = BUF_LEN;\n\n    uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n    CHECK_STATE(add_text_length == 0);\n    CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));\n    status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,\n                             (uint8_t *) unsealedKey, &decLen );\n\n    CHECK_STATUS(\"seal/unseal SEK failed after SEK generation in unseal\");\n    *enc_len = sealedLen;\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 320,
        "code": "void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint32_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -10;\n\n    uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);\n\n    if (keyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 321,
        "code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    // In some rare cases (usually in unit tests with very small clusters) we\n    // may end up transforming an XLA cluster with at least one GPU operation\n    // (which would normally force the cluster to be compiled using XLA:GPU)\n    // into an XLA cluster with no GPU operations (i.e. containing only CPU\n    // operations).  Such a cluster can fail compilation (in way that\n    // MarkForCompilation could not have detected) if the CPU JIT is not linked\n    // in.\n    //\n    // So bail out of _XlaCompile in this case, and let the executor handle the\n    // situation for us.\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-23595"
    },
    {
        "index": 322,
        "code": "static int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg, bool perm)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tunsigned int console = vc->vc_num;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * The use of PIT_TICK_RATE is historic, it used to be\n\t\t * the platform-dependent CLOCK_TICK_RATE between 2.6.12\n\t\t * and 2.6.36, which was a minor but unfortunate ABI\n\t\t * change. kd_mksound is locked by the input layer.\n\t\t */\n\t\tif (arg)\n\t\t\targ = PIT_TICK_RATE / arg;\n\t\tkd_mksound(arg, 0);\n\t\tbreak;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\n\t\t/*\n\t\t * Generate the tone for the appropriate number of ticks.\n\t\t * If the time is zero, turn off sound ourselves.\n\t\t */\n\t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = PIT_TICK_RATE / count;\n\t\tkd_mksound(count, ticks);\n\t\tbreak;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t/*\n\t\t * this is na\u00efve.\n\t\t */\n\t\treturn put_user(KB_101, (char __user *)arg);\n\n\t\t/*\n\t\t * These cannot be implemented on any machine that implements\n\t\t * ioperm() in user level (such as Alpha PCs) or not at all.\n\t\t *\n\t\t * XXX: you should never use these, just call ioperm directly..\n\t\t */\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t/*\n\t\t * KDADDIO and KDDELIO may be able to add ports beyond what\n\t\t * we reject here, but to be safe...\n\t\t *\n\t\t * These are locked internally via sys_ioperm\n\t\t */\n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\n\t\treturn ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn ksys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */\n\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\n\t\tret = kbd_rate(&kbrep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase KDSETMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_kdsetmode(vc, arg);\n\n\tcase KDGETMODE:\n\t\treturn put_user(vc->vc_mode, (int __user *)arg);\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t/*\n\t\t * these work like a combination of mmap and KDENABIO.\n\t\t * this could be easily finished.\n\t\t */\n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tret = vt_do_kdskbmode(console, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttty_ldisc_flush(tty);\n\t\tbreak;\n\n\tcase KDGKBMODE:\n\t\treturn put_user(vt_do_kdgkbmode(console), (int __user *)arg);\n\n\t/* this could be folded into KDSKBMODE, but for compatibility\n\t   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */\n\tcase KDSKBMETA:\n\t\treturn vt_do_kdskbmeta(console, arg);\n\n\tcase KDGKBMETA:\n\t\t/* FIXME: should review whether this is worth locking */\n\t\treturn put_user(vt_do_kdgkbmeta(console), (int __user *)arg);\n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm = 0;\n\t\treturn vt_do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn vt_do_kdsk_ioctl(cmd, up, perm, console);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn vt_do_kdgkb_ioctl(cmd, up, perm);\n\n\t/* Diacritical processing. Handled in keyboard.c as it has\n\t   to operate on the keyboard locks and structures */\n\tcase KDGKBDIACR:\n\tcase KDGKBDIACRUC:\n\tcase KDSKBDIACR:\n\tcase KDSKBDIACRUC:\n\t\treturn vt_do_diacrit(cmd, up, perm);\n\n\t/* the ioctls below read/set the flags usually shown in the leds */\n\t/* don't use them - they will go away without warning */\n\tcase KDGKBLED:\n\tcase KDSKBLED:\n\tcase KDGETLED:\n\tcase KDSETLED:\n\t\treturn vt_do_kdskled(console, cmd, arg, perm);\n\n\t/*\n\t * A process can indicate its willingness to accept signals\n\t * generated by pressing an appropriate key combination.\n\t * Thus, one can have a daemon that e.g. spawns a new console\n\t * upon a keypress and then changes to it.\n\t * See also the kbrequest field of inittab(5).\n\t */\n\tcase KDSIGACCEPT:\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t\treturn -EPERM;\n\t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&vt_spawn_con.lock);\n\t\tput_pid(vt_spawn_con.pid);\n\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n\t\tvt_spawn_con.sig = arg;\n\t\tspin_unlock_irq(&vt_spawn_con.lock);\n\t\tbreak;\n\n\tcase KDFONTOP: {\n\t\tstruct console_font_op op;\n\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\tret = con_font_op(vc, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3753"
    },
    {
        "index": 323,
        "code": "static void SpatialMaxPoolWithArgMaxHelper(\n    OpKernelContext* context, Tensor* output, Tensor* output_arg_max,\n    Tensor* input_backprop, const Tensor& tensor_in, const Tensor& out_backprop,\n    const PoolParameters& params, const bool include_batch_in_index) {\n  if (input_backprop != nullptr) {\n    OP_REQUIRES(\n        context, include_batch_in_index,\n        errors::Internal(\n            \"SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index \"\n            \"to be True when input_backprop != nullptr\"));\n    OP_REQUIRES(\n        context, (std::is_same<Targmax, int64>::value),\n        errors::Internal(\"SpatialMaxPoolWithArgMaxHelper requires Targmax \"\n                         \"to be int64 when input_backprop != nullptr\"));\n  }\n\n  typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      ConstEigenMatrixMap;\n  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenMatrixMap;\n  typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenIndexMatrixMap;\n\n  ConstEigenMatrixMap in_mat(\n      tensor_in.flat<T>().data(), params.depth,\n      params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n  EigenMatrixMap out_mat(\n      output->flat<T>().data(), params.depth,\n      params.out_width * params.out_height * params.tensor_in_batch);\n  EigenIndexMatrixMap out_arg_max_mat(\n      output_arg_max->flat<Targmax>().data(), params.depth,\n      params.out_width * params.out_height * params.tensor_in_batch);\n\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *(context->device()->tensorflow_cpu_worker_threads());\n\n  // The following code basically does the following:\n  // 1. Flattens the input and output tensors into two dimensional arrays.\n  //    tensor_in_as_matrix:\n  //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n  //    output_as_matrix:\n  //      depth by (out_width * out_height * tensor_in_batch)\n  //\n  // 2. Walks through the set of columns in the flattened tensor_in_as_matrix,\n  //    and updates the corresponding column(s) in output_as_matrix with the\n  //    max value.\n  auto shard = [&params, &in_mat, &out_mat, &out_arg_max_mat, &input_backprop,\n                &output_arg_max, &out_backprop,\n                include_batch_in_index](int64 start, int64 limit) {\n    const int32 depth = params.depth;\n    const int32 in_rows = params.tensor_in_rows;\n    const int32 in_cols = params.tensor_in_cols;\n    const int32 pad_top = params.pad_top;\n    const int32 pad_left = params.pad_left;\n    const int32 window_rows = params.window_rows;\n    const int32 window_cols = params.window_cols;\n    const int32 row_stride = params.row_stride;\n    const int32 col_stride = params.col_stride;\n    const int32 out_height = params.out_height;\n    const int32 out_width = params.out_width;\n\n    {\n      // Initializes the output tensor with MIN<T>.\n      const int32 output_image_size = out_height * out_width * depth;\n      EigenMatrixMap out_shard(out_mat.data() + start * output_image_size, 1,\n                               (limit - start) * output_image_size);\n      out_shard.setConstant(Eigen::NumTraits<T>::lowest());\n      EigenIndexMatrixMap out_arg_max_shard(\n          out_arg_max_mat.data() + start * output_image_size, 1,\n          (limit - start) * output_image_size);\n      out_arg_max_shard.setConstant(kInvalidMaxPoolingIndex);\n    }\n\n    for (int64 b = start; b < limit; ++b) {\n      for (int h = 0; h < in_rows; ++h) {\n        for (int w = 0; w < in_cols; ++w) {\n          // (h_start, h_end) * (w_start, w_end) is the range that the input\n          // vector projects to.\n          const int hpad = h + pad_top;\n          const int wpad = w + pad_left;\n          const int h_start =\n              (hpad < window_rows) ? 0 : (hpad - window_rows) / row_stride + 1;\n          const int h_end = std::min(hpad / row_stride + 1, out_height);\n          const int w_start =\n              (wpad < window_cols) ? 0 : (wpad - window_cols) / col_stride + 1;\n          const int w_end = std::min(wpad / col_stride + 1, out_width);\n          // compute elementwise max\n          const int64 in_index = (b * in_rows + h) * in_cols + w;\n          for (int ph = h_start; ph < h_end; ++ph) {\n            const int64 out_index_base = (b * out_height + ph) * out_width;\n            for (int pw = w_start; pw < w_end; ++pw) {\n              const int64 out_index = out_index_base + pw;\n              /// NOTES(zhengxq): not using the eigen matrix operation for\n              /// now.\n              for (int d = 0; d < depth; ++d) {\n                const T& input_ref = in_mat.coeffRef(d, in_index);\n                T& output_ref = out_mat.coeffRef(d, out_index);\n                Targmax& out_arg_max_ref =\n                    out_arg_max_mat.coeffRef(d, out_index);\n                if (output_ref < input_ref ||\n                    out_arg_max_ref == kInvalidMaxPoolingIndex) {\n                  output_ref = input_ref;\n                  if (include_batch_in_index) {\n                    out_arg_max_ref = in_index * depth + d;\n                  } else {\n                    out_arg_max_ref = (h * in_cols + w) * depth + d;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (input_backprop != nullptr) {\n      auto input_backprop_flat = input_backprop->flat<T>();\n      auto out_arg_max_flat = output_arg_max->flat<int64>();\n      auto out_backprop_flat = out_backprop.flat<T>();\n\n      // Initialize output to 0.\n      const int64 in_size = in_rows * in_cols * depth;\n      const int64 in_start = start * in_size;\n      const int64 in_end = limit * in_size;\n      EigenMatrixMap in_shard(input_backprop_flat.data() + in_start, 1,\n                              in_end - in_start);\n      in_shard.setConstant(T(0));\n\n      // Backpropagate.\n      const int out_size = out_height * out_width * depth;\n      const int out_start = start * out_size;\n      const int out_end = limit * out_size;\n      for (int index = out_start; index < out_end; ++index) {\n        int input_backprop_index = out_arg_max_flat(index);\n        // Although this check is in the inner loop, it is worth its value\n        // so we don't end up with memory corruptions. Our benchmark shows that\n        // the performance impact is quite small\n        // CHECK(input_backprop_index >= in_start && input_backprop_index <\n        // in_end)\n        FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);\n        input_backprop_flat(input_backprop_index) += out_backprop_flat(index);\n      }\n    }\n  };\n\n  const int64 shard_cost = params.tensor_in_rows * params.tensor_in_cols *\n                           params.depth * params.window_rows *\n                           params.window_cols;\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        params.tensor_in_batch, shard_cost, shard);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29579"
    },
    {
        "index": 324,
        "code": "win_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 325,
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n\n    MODE = get_elf_class(elf);\n\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    /* 32bit */\n    if (MODE == ELFCLASS32) {\n        /* ELF Header Information */\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            \n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            \n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            \n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            \n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            \n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n\n        /* Section Information */\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                \n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                \n                default:\n                    break;\n            }\n\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                \n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                \n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        \n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                /* Legal values for d_tag (dynamic entry type).  */\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                \n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                    \n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                \n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                \n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                \n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n                 * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n                 * approach. */\n\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                \n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n\n                /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n                 * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n                 * If any adjustment is made to the ELF object after it has been\n                 * built these entries will need to be adjusted.  */\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                    \n                /* The versioning entry types.  The next are defined as part of the\n                 * GNU extension.  */\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                \n                /* These were chosen by Sun.  */\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        \n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    \n                    break;\n\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                \n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n\n    /* 64bit */\n    if (MODE == ELFCLASS64) {\n        /* ELF Header Information */\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            \n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            \n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            \n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            \n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            \n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n\n        /* Section Information */\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                \n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                \n                default:\n                    break;\n            }\n\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                \n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                \n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        \n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                /* Legal values for d_tag (dynamic entry type).  */\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                \n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                    \n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                \n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                \n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                \n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n                 * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n                 * approach. */\n\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                \n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n\n                /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n                 * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n                 * If any adjustment is made to the ELF object after it has been\n                 * built these entries will need to be adjusted.  */\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                    \n                /* The versioning entry types.  The next are defined as part of the\n                 * GNU extension.  */\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                \n                /* These were chosen by Sun.  */\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        \n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    \n                    break;\n\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                \n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n\n    return 0;\n}",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21711"
    },
    {
        "index": 326,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* input_indices;\n    const Tensor* input_values;\n    const Tensor* input_shape;\n    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n    int new_num_elements = 1;\n    bool overflow_ocurred = false;\n    for (int i = 0; i < input_shape_vec.size(); i++) {\n      new_num_elements =\n          MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));\n      if (new_num_elements < 0) {\n        overflow_ocurred = true;\n        break;\n      }\n    }\n\n    OP_REQUIRES(\n        context, !overflow_ocurred,\n        errors::Internal(\"Encountered overflow from large input shape.\"));\n\n    TensorShape tensor_input_shape(input_shape_vec);\n    gtl::InlinedVector<int64_t, 8> std_order(rank);\n    std::iota(std_order.begin(), std_order.end(), 0);\n    SparseTensor input_st;\n    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st));\n\n    const int64_t N = input_shape_vec(0);\n\n    Tensor sparse_handles(DT_INT64, TensorShape({N}));\n    auto sparse_handles_t = sparse_handles.vec<int64_t>();\n\n    OP_REQUIRES_OK(context, input_st.IndicesValid());\n\n    // We can generate the output shape proto string now, for all\n    // minibatch entries.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                input_shape_vec.data() + 1,\n                                input_shape->NumElements() - 1, &output_shape));\n\n    // Get groups by minibatch dimension\n    std::unordered_set<int64_t> visited;\n    sparse::GroupIterable minibatch = input_st.group({0});\n    for (const auto& subset : minibatch) {\n      const int64_t b = subset.group()[0];\n      visited.insert(b);\n      OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"));\n\n      const auto indices = subset.indices();\n      const auto values = subset.values<T>();\n      const int64_t num_entries = values.size();\n\n      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n      Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n\n      auto output_indices_t = output_indices.matrix<int64_t>();\n      auto output_values_t = output_values.vec<T>();\n\n      for (int i = 0; i < num_entries; ++i) {\n        for (int d = 1; d < rank; ++d) {\n          output_indices_t(i, d - 1) = indices(i, d);\n        }\n        output_values_t(i) = values(i);\n      }\n\n      SparseTensor st_i;\n      OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i));\n      int64_t handle;\n      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n      sparse_handles_t(b) = handle;\n    }\n\n    // Fill in any gaps; we must provide an empty ST for batch entries\n    // the grouper didn't find.\n    if (visited.size() < N) {\n      Tensor empty_indices(DT_INT64, {0, rank - 1});\n      Tensor empty_values(DataTypeToEnum<T>::value, {0});\n      SparseTensor empty_st;\n      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st));\n\n      for (int64_t b = 0; b < N; ++b) {\n        // We skipped this batch entry.\n        if (visited.find(b) == visited.end()) {\n          int64_t handle;\n          OP_REQUIRES_OK(context,\n                         map->AddSparseTensor(context, empty_st, &handle));\n          sparse_handles_t(b) = handle;\n        }\n      }\n    }\n\n    context->set_output(0, sparse_handles);\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23568"
    },
    {
        "index": 327,
        "code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29575"
    },
    {
        "index": 328,
        "code": "get_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (*that == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2183"
    },
    {
        "index": 329,
        "code": "unique_ptr<IOBuf> IOBuf::takeOwnership(\n    void* buf,\n    std::size_t capacity,\n    std::size_t offset,\n    std::size_t length,\n    FreeFunction freeFn,\n    void* userData,\n    bool freeOnError,\n    TakeOwnershipOption option) {\n  // do not allow only user data without a freeFn\n  // since we use that for folly::sizedFree\n\n  DCHECK(\n      !userData || (userData && freeFn) ||\n      (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)));\n\n  HeapFullStorage* storage = nullptr;\n  auto rollback = makeGuard([&] {\n    if (storage) {\n      free(storage);\n    }\n    takeOwnershipError(freeOnError, buf, freeFn, userData);\n  });\n\n  size_t requiredStorage = sizeof(HeapFullStorage);\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n\n  new (&storage->hs.prefix)\n      HeapPrefix(kIOBufInUse | kSharedInfoInUse, mallocSize);\n  new (&storage->shared)\n      SharedInfo(freeFn, userData, true /*useHeapFullStorage*/);\n\n  auto result = unique_ptr<IOBuf>(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      static_cast<uint8_t*>(buf),\n      capacity,\n      static_cast<uint8_t*>(buf) + offset,\n      length));\n\n  rollback.dismiss();\n\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n    if (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)) {\n      // Even though we did not allocate the buffer, call io_buf_alloc_cb()\n      // since we will call io_buf_free_cb() on destruction, and we want these\n      // calls to be 1:1.\n      io_buf_alloc_cb(buf, capacity);\n    }\n  }\n\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-24036"
    },
    {
        "index": 330,
        "code": "int64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n  }\n  m_cursor += length;\n  return length;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 331,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *nack_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */\n    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length);\n    if (cnt > 2) cnt -= 2; else cnt = 0;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *nack_cnt = PJ_MIN(*nack_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *nack_cnt; ++i) {\n\tpj_uint16_t val;\n\n\tpj_memcpy(&val, p, 2);\n\tnack[i].pid = pj_ntohs(val);\n\tpj_memcpy(&val, p+2, 2);\n\tnack[i].blp = pj_ntohs(val);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 332,
        "code": "  void DoCompute(OpKernelContext* c) {\n    core::RefCountPtr<Var> v;\n    OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));\n    Tensor* params = v->tensor();\n    const Tensor& indices = c->input(1);\n    const Tensor& updates = c->input(2);\n\n    // Check that rank(updates.shape) = rank(indices.shape + params.shape[1:])\n    OP_REQUIRES(c,\n                updates.dims() == 0 ||\n                    updates.dims() == indices.dims() + params->dims() - 1,\n                errors::InvalidArgument(\n                    \"Must have updates.shape = indices.shape + \"\n                    \"params.shape[1:] or updates.shape = [], got \",\n                    \"updates.shape \", updates.shape().DebugString(),\n                    \", indices.shape \", indices.shape().DebugString(),\n                    \", params.shape \", params->shape().DebugString()));\n\n    // Check that we have enough index space\n    const int64_t N_big = indices.NumElements();\n    OP_REQUIRES(\n        c, N_big <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"indices has too many elements for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", N_big, \" > \",\n                                std::numeric_limits<Index>::max()));\n    const Index N = static_cast<Index>(N_big);\n    OP_REQUIRES(\n        c, params->dim_size(0) <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"params.shape[0] too large for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", params->dim_size(0), \" > \",\n                                std::numeric_limits<Index>::max()));\n\n    if (N > 0) {\n      auto indices_flat = indices.flat<Index>();\n      auto params_flat = params->flat_outer_dims<T>();\n      if (TensorShapeUtils::IsScalar(updates.shape())) {\n        const auto update = updates.scalar<T>();\n\n        functor::ScatterScalarFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, update, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(c, num_updates % N == 0,\n                    errors::InvalidArgument(\n                        \"shape of indices (\", indices.shape().DebugString(),\n                        \") is not compatible with the shape of updates (\",\n                        updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37655"
    },
    {
        "index": 333,
        "code": "read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tuint32_t off = offset, tmp, finish;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\tif (fru->max_read_size == 0) {\n\t\tuint16_t max_rs_size = ipmi_intf_get_max_response_data_size(intf) - 1;\n\n\t\t/* validate lower bound of the maximum response data size */\n\t\tif (max_rs_size <= 1) {\n\t\t\tlprintf(LOG_ERROR, \"Maximum response size is too small to send \"\n\t\t\t\t\t\"a read request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Read FRU Info command may read up to 255 bytes of data.\n\t\t */\n\t\tif (max_rs_size - 1 > 255) {\n\t\t\t/*  Limit the max read size with 255 bytes. */\n\t\t\tfru->max_read_size = 255;\n\t\t} else {\n\t\t\t/* subtract 1 byte for bytes count */\n\t\t\tfru->max_read_size = max_rs_size - 1;\n\t\t}\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\tfru->max_read_size &= ~1;\n\t\t}\n\t}\n\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru->max_read_size)\n\t\t\tmsg_data[3] = (uint8_t)fru->max_read_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7h or C8h or CAh return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode)\n\t\t\t    && fru->max_read_size > FRU_BLOCK_SZ)\n\t\t\t{\n\t\t\t\tif (fru->max_read_size > FRU_AREA_MAXIMUM_BLOCK_SZ) {\n\t\t\t\t\t/* subtract read length more aggressively */\n\t\t\t\t\tfru->max_read_size -= FRU_BLOCK_SZ;\n\t\t\t\t} else {\n\t\t\t\t\t/* subtract length less aggressively */\n\t\t\t\t\tfru->max_read_size--;\n\t\t\t\t}\n\n\t\t\t\tlprintf(LOG_INFO, \"Retrying FRU read with request size %d\",\n\t\t\t\t\t\tfru->max_read_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tmemcpy(frubuf, rsp->data + 1, tmp);\n\t\toff += tmp;\n\t\tfrubuf += tmp;\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish) {\n\t\t\treturn 0;\n\t\t}\n\t} while (off < finish);\n\n\tif (off < finish) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5208"
    },
    {
        "index": 334,
        "code": "  void writeStats(Array& /*ret*/) override {\n    fprintf(stderr, \"writeStats start\\n\");\n    // RetSame: the return value is the same instance every time\n    // HasThis: call has a this argument\n    // AllSame: all returns were the same data even though args are different\n    // MemberCount: number of different arg sets (including this)\n    fprintf(stderr, \"Count Function MinSerLen MaxSerLen RetSame HasThis \"\n            \"AllSame MemberCount\\n\");\n    for (auto& me : m_memos) {\n      if (me.second.m_ignore) continue;\n      if (me.second.m_count == 1) continue;\n      int min_ser_len = 999999999;\n      int max_ser_len = 0;\n      int count = 0;\n      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),\n              min_ser_len, max_ser_len,\n              me.second.m_ret_tv_same ? \" true\" : \"false\",\n              me.second.m_has_this ? \" true\" : \"false\",\n              all_same ? \" true\" : \"false\",\n              member_count\n             );\n    }\n    fprintf(stderr, \"writeStats end\\n\");\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 335,
        "code": "Json::Value SGXWalletServer::calculateAllBLSPublicKeysImpl(const Json::Value& publicShares, int t, int n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!check_n_t(t, n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n\n        if (!publicShares.isArray()) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid public shares format\");\n        }\n\n        if (publicShares.size() != (uint64_t) n) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!publicShares[i].isString()) {\n                throw SGXException(INVALID_DKG_PARAMS, \"Invalid public shares parts format\");\n            }\n\n            if (publicShares[i].asString().length() != (uint64_t) 256 * t) {\n                throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares parts\");\n            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 336,
        "code": "op_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t// keep cursor on same text char\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n\n    // Place the cursor where the \"gq\" or \"gw\" command was given, so that \"u\"\n    // can put it back there.\n    curwin->w_cursor = oap->cursor_start;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n\n    if (oap->is_VIsual)\n\t// When there is no change: need to remove the Visual selection\n\tredraw_curbuf_later(INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t// Set '[ mark at the start of the formatted area\n\tcurbuf->b_op_start = oap->start;\n\n    // For \"gw\" remember the cursor position and put it back below (adjusted\n    // for joined and split lines).\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n\n    format_lines(oap->line_count, keep_cursor);\n\n    // Leave the cursor at the first non-blank of the last formatted line.\n    // If the cursor was moved one line back (e.g. with \"Q}\") go to the next\n    // line, so \".\" will do the next lines.\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t// put '] mark on the end of the formatted area\n\tcurbuf->b_op_end = curwin->w_cursor;\n\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n    }\n\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\t// When lines have been inserted or deleted, adjust the end of\n\t\t// the Visual area to be redrawn.\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1851"
    },
    {
        "index": 337,
        "code": "bool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg) {\n    (void)data_total;\n    const TokenType *token;\n    char constr1[40], constr2[40], *arStr = \"\";\n    uint8_t *tokenAddress, *deadlineBytes;\n    bignum256 tokenAmount, tokenMinAmount, ethMinAmount;\n    uint64_t deadline;\n\n    if (isAddLiquidityEthCall(msg)) {\n        arStr = \"uniswap add liquidity\";\n    } else if (isRemoveLiquidityEthCall(msg)) {\n        arStr = \"uniswap remove liquidity\";\n    } else {\n        return false;\n    }\n\n    tokenAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 32 - 20);\n    token = tokenByChainAddress(msg->chain_id, tokenAddress);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 32, 32, &tokenAmount);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 2*32, 32, &tokenMinAmount);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 3*32, 32, &ethMinAmount);\n    deadlineBytes = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 6*32 - 8);\n    deadline = ((uint64_t)deadlineBytes[0] << 8*7) |\n               ((uint64_t)deadlineBytes[1] << 8*6) |\n               ((uint64_t)deadlineBytes[2] << 8*5) |\n               ((uint64_t)deadlineBytes[3] << 8*4) |\n               ((uint64_t)deadlineBytes[4] << 8*3) |\n               ((uint64_t)deadlineBytes[5] << 8*2) |\n               ((uint64_t)deadlineBytes[6] << 8*1) |\n               ((uint64_t)deadlineBytes[7]);\n        \n    char tokbuf[32];\n    ethereumFormatAmount(&tokenAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, \"%s\", tokbuf);\n    ethereumFormatAmount(&tokenMinAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr2, 32, \"%s\", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"%s\\nMinimum %s\", constr1, constr2);\n    if (!confirmFromAccountMatch(msg, arStr)) {\n        return false;\n    }\n    \n    ethereumFormatAmount(&ethMinAmount, NULL, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, \"%s\", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"Minimum %s\", constr1);\n\n    snprintf(constr1, 32, \"%lld\", deadline);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"Deadline %s\", ctime((const time_t *)&deadline));\n    \n    return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-31616"
    },
    {
        "index": 338,
        "code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        /* early config file error processing routines call this */\n        windowprocs.win_wait_synch = def_wait_synch;\n\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5210"
    },
    {
        "index": 339,
        "code": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >= 32) {\n\t\treturn -1;\n\t}\n\tif (sps_id < 0) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 340,
        "code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (jsvHasChildren(parent)) {\n        // else remove properly.\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-25044"
    },
    {
        "index": 341,
        "code": "generate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2874"
    },
    {
        "index": 342,
        "code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36148"
    },
    {
        "index": 343,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableAttribute *lvattr;\n\tut64 curpos = 0, offset = 6;\n\tRBinJavaAttrInfo *attr;\n\tut32 i = 0;\n\tif (!buffer || sz < 1) {\n\t\treturn NULL;\n\t}\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR;\n\tattr->info.local_variable_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_table_attr.local_variable_table =\\\n\t\tr_list_newf (r_bin_java_local_variable_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_table_attr.table_length; i++) {\n\t\tif (offset + 10 > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tcurpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableAttribute);\n\t\tif (!lvattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->descriptor_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->descriptor = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->descriptor_idx);\n\t\tif (!lvattr->descriptor) {\n\t\t\tlvattr->descriptor = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->descriptor_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_table_attr.local_variable_table, lvattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_local_variable_table_attr_summary(attr);\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 344,
        "code": "njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    capability = pargs->capability;\n\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n\n    on_fulfilled->u.native = njs_promise_all_resolve_element_functions;\n    on_fulfilled->args_count = 1;\n\n    context = on_fulfilled->context;\n\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n\n    (*pargs->remaining)++;\n\n    njs_set_function(&arguments[0], on_fulfilled);\n    arguments[1] = capability->reject;\n\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-32414"
    },
    {
        "index": 345,
        "code": "GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) {\n\t\t\tgf_free(((SFImage *)field->far_ptr)->pixels);\n\t\t\t((SFImage *)field->far_ptr)->pixels = NULL;\n\t\t}\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tgf_node_register(cbi->node, NULL);\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//if not memory dec mode, unregister previous node\n\t\t//otherwise the field points to the memory command internal field\n\t\tif (!is_mem_com) {\n\t\t\tGF_Node *old_node = *((GF_Node **) field->far_ptr);\n\t\t\tif (old_node != NULL) {\n\t\t\t\tu32 i, count = gf_list_count(codec->command_buffers);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tCommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);\n\t\t\t\t\tif (cbi->node == old_node) {\n\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\t\t\tgf_free(cbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_node_unregister(old_node, node);\n\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;\n\t\t\t}\n\t\t}\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1172"
    },
    {
        "index": 346,
        "code": "static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tuchar\tbyte;\n\tint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\t/*\n\t * Value to write is always specified.\n\t */\n\tbyte = hextoul(argv[3], NULL);\n\n\t/*\n\t * Optional count\n\t */\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t\t/*\n\t\t * Wait for the write to complete.  The write can take\n\t\t * up to 10mSec (we allow a little more time).\n\t\t */\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34835"
    },
    {
        "index": 347,
        "code": "check_shellsize(void)\n{\n    if (Rows < min_rows())\t// need room for one window and command line\n\tRows = min_rows();\n    limit_screen_size();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2206"
    },
    {
        "index": 348,
        "code": "static void cstm(JF, js_Ast *stm)\n{\n\tjs_Ast *target;\n\tint loop, cont, then, end;\n\n\temitline(J, F, stm);\n\n\tswitch (stm->type) {\n\tcase AST_FUNDEC:\n\t\tbreak;\n\n\tcase STM_BLOCK:\n\t\tcstmlist(J, F, stm->a);\n\t\tbreak;\n\n\tcase STM_EMPTY:\n\t\tif (F->script) {\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t\temit(J, F, OP_UNDEF);\n\t\t}\n\t\tbreak;\n\n\tcase STM_VAR:\n\t\tcvarinit(J, F, stm->a);\n\t\tbreak;\n\n\tcase STM_IF:\n\t\tif (stm->c) {\n\t\t\tcexp(J, F, stm->a);\n\t\t\temitline(J, F, stm);\n\t\t\tthen = emitjump(J, F, OP_JTRUE);\n\t\t\tcstm(J, F, stm->c);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JUMP);\n\t\t\tlabel(J, F, then);\n\t\t\tcstm(J, F, stm->b);\n\t\t\tlabel(J, F, end);\n\t\t} else {\n\t\t\tcexp(J, F, stm->a);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t\tcstm(J, F, stm->b);\n\t\t\tlabel(J, F, end);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DO:\n\t\tloop = here(J, F);\n\t\tcstm(J, F, stm->a);\n\t\tcont = here(J, F);\n\t\tcexp(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JTRUE, loop);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), cont);\n\t\tbreak;\n\n\tcase STM_WHILE:\n\t\tloop = here(J, F);\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\tend = emitjump(J, F, OP_JFALSE);\n\t\tcstm(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n\t\tbreak;\n\n\tcase STM_FOR:\n\tcase STM_FOR_VAR:\n\t\tif (stm->type == STM_FOR_VAR) {\n\t\t\tcvarinit(J, F, stm->a);\n\t\t} else {\n\t\t\tif (stm->a) {\n\t\t\t\tcexp(J, F, stm->a);\n\t\t\t\temit(J, F, OP_POP);\n\t\t\t}\n\t\t}\n\t\tloop = here(J, F);\n\t\tif (stm->b) {\n\t\t\tcexp(J, F, stm->b);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t} else {\n\t\t\tend = 0;\n\t\t}\n\t\tcstm(J, F, stm->d);\n\t\tcont = here(J, F);\n\t\tif (stm->c) {\n\t\t\tcexp(J, F, stm->c);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\tif (end)\n\t\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), cont);\n\t\tbreak;\n\n\tcase STM_FOR_IN:\n\tcase STM_FOR_IN_VAR:\n\t\tcexp(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_ITERATOR);\n\t\tloop = here(J, F);\n\t\t{\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_NEXTITER);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t\tcassignforin(J, F, stm);\n\t\t\tif (F->script) {\n\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\tcstm(J, F, stm->c);\n\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t} else {\n\t\t\t\tcstm(J, F, stm->c);\n\t\t\t}\n\t\t\temitline(J, F, stm);\n\t\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\t}\n\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n\t\tbreak;\n\n\tcase STM_SWITCH:\n\t\tcswitch(J, F, stm->a, stm->b);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n\t\tbreak;\n\n\tcase STM_LABEL:\n\t\tcstm(J, F, stm->b);\n\t\t/* skip consecutive labels */\n\t\twhile (stm->type == STM_LABEL)\n\t\t\tstm = stm->b;\n\t\t/* loops and switches have already been labelled */\n\t\tif (!isloop(stm->type) && stm->type != STM_SWITCH)\n\t\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n\t\tbreak;\n\n\tcase STM_BREAK:\n\t\tif (stm->a) {\n\t\t\tcheckfutureword(J, F, stm->a);\n\t\t\ttarget = breaktarget(J, F, stm->parent, stm->a->string);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"break label '%s' not found\", stm->a->string);\n\t\t} else {\n\t\t\ttarget = breaktarget(J, F, stm->parent, NULL);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"unlabelled break must be inside loop or switch\");\n\t\t}\n\t\tcexit(J, F, STM_BREAK, stm, target);\n\t\temitline(J, F, stm);\n\t\taddjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));\n\t\tbreak;\n\n\tcase STM_CONTINUE:\n\t\tif (stm->a) {\n\t\t\tcheckfutureword(J, F, stm->a);\n\t\t\ttarget = continuetarget(J, F, stm->parent, stm->a->string);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"continue label '%s' not found\", stm->a->string);\n\t\t} else {\n\t\t\ttarget = continuetarget(J, F, stm->parent, NULL);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"continue must be inside loop\");\n\t\t}\n\t\tcexit(J, F, STM_CONTINUE, stm, target);\n\t\temitline(J, F, stm);\n\t\taddjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));\n\t\tbreak;\n\n\tcase STM_RETURN:\n\t\tif (stm->a)\n\t\t\tcexp(J, F, stm->a);\n\t\telse\n\t\t\temit(J, F, OP_UNDEF);\n\t\ttarget = returntarget(J, F, stm->parent);\n\t\tif (!target)\n\t\t\tjsC_error(J, stm, \"return not in function\");\n\t\tcexit(J, F, STM_RETURN, stm, target);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_RETURN);\n\t\tbreak;\n\n\tcase STM_THROW:\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_THROW);\n\t\tbreak;\n\n\tcase STM_WITH:\n\t\tF->lightweight = 0;\n\t\tif (F->strict)\n\t\t\tjsC_error(J, stm->a, \"'with' statements are not allowed in strict mode\");\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_WITH);\n\t\tcstm(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_ENDWITH);\n\t\tbreak;\n\n\tcase STM_TRY:\n\t\temitline(J, F, stm);\n\t\tif (stm->b && stm->c) {\n\t\t\tF->lightweight = 0;\n\t\t\tif (stm->d)\n\t\t\t\tctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);\n\t\t\telse\n\t\t\t\tctrycatch(J, F, stm->a, stm->b, stm->c);\n\t\t} else {\n\t\t\tctryfinally(J, F, stm->a, stm->d);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DEBUGGER:\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_DEBUGGER);\n\t\tbreak;\n\n\tdefault:\n\t\tif (F->script) {\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t\tcexp(J, F, stm);\n\t\t} else {\n\t\t\tcexp(J, F, stm);\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tbreak;\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45005"
    },
    {
        "index": 349,
        "code": "static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\n\tif (vps_id >= 16) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \"base_layer_internal_flag\");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \"base_layer_available_flag\");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers_minus1\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \"temporal_id_nesting\");\n\tgf_bs_read_int_log(bs, 16, \"vps_reserved_ffff_16bits\");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"vps_sub_layer_ordering_info_present_flag\");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_dec_pic_buffering_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_num_reorder_pics\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_latency_increase_plus1\", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \"max_layer_id\");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \"num_layer_sets_minus1\") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"layer_id_included_flag\", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"vps_timing_info_present_flag\")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \"vps_num_units_in_tick\");\n\t\tgf_bs_read_int_log(bs, 32, \"vps_time_scale\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_poc_proportional_to_timing_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"vps_num_ticks_poc_diff_one_minus1\");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \"vps_num_hrd_parameters\");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \"hrd_layer_set_idx\", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \"cprms_present_flag\");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \"vps_extension_flag\");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_extension2_flag\")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 350,
        "code": "PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 351,
        "code": "void JTL::send( Session* session, int resolution, int tile ){\n\n  Timer function_timer;\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"JTL handler reached\" << endl;\n\n\n  // Make sure we have set our image\n  this->session = session;\n  checkImage();\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // If we have requested a rotation, remap the tile index to rotated coordinates\n  if( (int)((session->view)->getRotation()) % 360 == 90 ){\n\n  }\n  else if( (int)((session->view)->getRotation()) % 360 == 270 ){\n\n  }\n  else if( (int)((session->view)->getRotation()) % 360 == 180 ){\n    int num_res = (*session->image)->getNumResolutions();\n    unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];\n    unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];\n    unsigned int tw = (*session->image)->getTileWidth();\n    //    unsigned int th = (*session->image)->getTileHeight();\n    int ntiles = (int) ceil( (double)im_width/tw ) * (int) ceil( (double)im_height/tw );\n    tile = ntiles - tile - 1;\n  }\n\n\n  // Sanity check\n  if( (resolution<0) || (tile<0) ){\n    ostringstream error;\n    error << \"JTL :: Invalid resolution/tile number: \" << resolution << \",\" << tile;\n    throw error.str();\n  }\n\n\n  // Determine which output encoding to use\n  CompressionType ct = session->view->output_format;\n  Compressor *compressor;\n  if( session->view->output_format == JPEG ) compressor = session->jpeg;\n#ifdef HAVE_PNG\n  else if( session->view->output_format == PNG ) compressor = session->png;\n#endif\n  else compressor = session->jpeg;\n\n\n  TileManager tilemanager( session->tileCache, *session->image, session->watermark, compressor, session->logfile, session->loglevel );\n\n\n  // First calculate histogram if we have asked for either binarization,\n  //  histogram equalization or contrast stretching\n  if( session->view->requireHistogram() && (*session->image)->histogram.size()==0 ){\n\n    if( session->loglevel >= 4 ) function_timer.start();\n\n    // Retrieve an uncompressed version of our smallest tile\n    // which should be sufficient for calculating the histogram\n    RawTile thumbnail = tilemanager.getTile( 0, 0, 0, session->view->yangle, session->view->getLayers(), UNCOMPRESSED );\n\n    // Calculate histogram\n    (*session->image)->histogram =\n      session->processor->histogram( thumbnail, (*session->image)->max, (*session->image)->min );\n\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Calculated histogram in \"\n\t\t\t  << function_timer.getTime() << \" microseconds\" << endl;\n    }\n\n    // Insert the histogram into our image cache\n    const string key = (*session->image)->getImagePath();\n    imageCacheMapType::iterator i = session->imageCache->find(key);\n    if( i != session->imageCache->end() ) (i->second).histogram = (*session->image)->histogram;\n  }\n\n\n\n  // Request uncompressed tile if raw pixel data is required for processing\n  if( (*session->image)->getNumBitsPerPixel() > 8 || (*session->image)->getColourSpace() == CIELAB\n      || (*session->image)->getNumChannels() == 2 || (*session->image)->getNumChannels() > 3\n      || ( (session->view->colourspace==GREYSCALE || session->view->colourspace==BINARY) && (*session->image)->getNumChannels()==3 &&\n\t   (*session->image)->getNumBitsPerPixel()==8 )\n      || session->view->floatProcessing() || session->view->equalization\n      || session->view->getRotation() != 0.0 || session->view->flip != 0\n      ) ct = UNCOMPRESSED;\n\n\n  // Set the physical output resolution for this particular view and zoom level\n  int num_res = (*session->image)->getNumResolutions();\n  unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];\n  unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];\n  float dpi_x = (*session->image)->dpi_x * (float) im_width / (float) (*session->image)->getImageWidth();\n  float dpi_y = (*session->image)->dpi_y * (float) im_height / (float) (*session->image)->getImageHeight();\n  compressor->setResolution( dpi_x, dpi_y, (*session->image)->dpi_units );\n\n  if( session->loglevel >= 5 ){\n    *(session->logfile) << \"JTL :: Setting physical resolution of tile to \" <<  dpi_x << \" x \" << dpi_y\n                        << ( ((*session->image)->dpi_units==1) ? \" pixels/inch\" : \" pixels/cm\" ) << endl;\n  }\n\n  // Embed ICC profile\n  if( session->view->embedICC() && ((*session->image)->getMetadata(\"icc\").size()>0) ){\n    if( session->loglevel >= 3 ){\n      *(session->logfile) << \"JTL :: Embedding ICC profile with size \"\n\t\t\t  << (*session->image)->getMetadata(\"icc\").size() << \" bytes\" << endl;\n    }\n    compressor->setICCProfile( (*session->image)->getMetadata(\"icc\") );\n  }\n\n\n  RawTile rawtile = tilemanager.getTile( resolution, tile, session->view->xangle,\n\t\t\t\t\t session->view->yangle, session->view->getLayers(), ct );\n\n\n  int len = rawtile.dataLength;\n\n  if( session->loglevel >= 2 ){\n    *(session->logfile) << \"JTL :: Tile size: \" << rawtile.width << \" x \" << rawtile.height << endl\n\t\t\t<< \"JTL :: Channels per sample: \" << rawtile.channels << endl\n\t\t\t<< \"JTL :: Bits per channel: \" << rawtile.bpc << endl\n\t\t\t<< \"JTL :: Data size is \" << len << \" bytes\" << endl;\n  }\n\n\n  // Convert CIELAB to sRGB\n  if( (*session->image)->getColourSpace() == CIELAB ){\n\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Converting from CIELAB->sRGB\";\n      function_timer.start();\n    }\n    session->processor->LAB2sRGB( rawtile );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Only use our float pipeline if necessary\n  if( rawtile.bpc > 8 || session->view->floatProcessing() ){\n\n    // Make a copy of our max and min as we may change these\n    vector <float> min = (*session->image)->min;\n    vector <float> max = (*session->image)->max;\n\n    // Change our image max and min if we have asked for a contrast stretch\n    if( session->view->contrast == -1 ){\n\n      // Find first non-zero bin in histogram\n      unsigned int n0 = 0;\n      while( (*session->image)->histogram[n0] == 0 ) ++n0;\n\n      // Find highest bin\n      unsigned int n1 = (*session->image)->histogram.size() - 1;\n      while( (*session->image)->histogram[n1] == 0 ) --n1;\n\n      // Histogram has been calculated using 8 bits, so scale up to native bit depth\n      if( rawtile.bpc > 8 && rawtile.sampleType == FIXEDPOINT ){\n\tn0 = n0 << (rawtile.bpc-8);\n\tn1 = n1 << (rawtile.bpc-8);\n      }\n\n      min.assign( rawtile.bpc, (float)n0 );\n      max.assign( rawtile.bpc, (float)n1 );\n\n      // Reset our contrast\n      session->view->contrast = 1.0;\n\n      if( session->loglevel >= 5 ){\n\t*(session->logfile) << \"JTL :: Applying contrast stretch for image range of \"\n\t\t\t    << n0 << \" - \" << n1 << endl;\n      }\n    }\n\n\n    // Apply normalization and float conversion\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Normalizing and converting to float\";\n      function_timer.start();\n    }\n    session->processor->normalize( rawtile, max, min );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n\n\n    // Apply hill shading if requested\n    if( session->view->shaded ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying hill-shading\";\n\tfunction_timer.start();\n      }\n      session->processor->shade( rawtile, session->view->shade[0], session->view->shade[1] );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply color twist if requested\n    if( session->view->ctw.size() ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying color twist\";\n\tfunction_timer.start();\n      }\n      session->processor->twist( rawtile, session->view->ctw );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply any gamma or log transform\n    if( session->view->gamma != 1.0 ){\n\n      float gamma = session->view->gamma;\n      if( session->loglevel >= 4 ) function_timer.start();\n\n      // Check whether we have asked for logarithm\n      if( gamma == -1 ) session->processor->log( rawtile );\n      else session->processor->gamma( rawtile, gamma );\n\n      if( session->loglevel >= 4 ){\n\tif( gamma == -1 ) *(session->logfile) << \"JTL :: Applying logarithm transform in \";\n\telse *(session->logfile) << \"JTL :: Applying gamma of \" << gamma << \" in \";\n\t*(session->logfile) << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply inversion if requested\n    if( session->view->inverted ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying inversion\";\n\tfunction_timer.start();\n      }\n      session->processor->inv( rawtile );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply color mapping if requested\n    if( session->view->cmapped ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying color map\";\n\tfunction_timer.start();\n      }\n      session->processor->cmap( rawtile, session->view->cmap );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply any contrast adjustments and/or clip to 8bit from 16 or 32 bit\n    float contrast = session->view->contrast;\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Applying contrast of \" << contrast << \" and converting to 8 bit\";\n      function_timer.start();\n    }\n    session->processor->contrast( rawtile, contrast );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n\n  }\n\n\n  // Reduce to 1 or 3 bands if we have an alpha channel or a multi-band image and have requested a JPEG tile\n  // For PNG, strip extra bands if we have more than 4 present\n  if( ( (session->view->output_format == JPEG) && (rawtile.channels == 2 || rawtile.channels > 3) ) ||\n      ( (session->view->output_format == PNG) && (rawtile.channels > 4) ) ){\n\n    unsigned int bands = (rawtile.channels==2) ? 1 : 3;\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Flattening channels to \" << bands;\n      function_timer.start();\n    }\n    session->processor->flatten( rawtile, bands );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Convert to greyscale if requested\n  if( (*session->image)->getColourSpace() == sRGB && session->view->colourspace == GREYSCALE ){\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Converting to greyscale\";\n      function_timer.start();\n    }\n    session->processor->greyscale( rawtile );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Convert to binary (bi-level) if requested\n  if( (*session->image)->getColourSpace() != BINARY && session->view->colourspace == BINARY ){\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Converting to binary with threshold \";\n      function_timer.start();\n    }\n    unsigned int threshold = session->processor->threshold( (*session->image)->histogram );\n    session->processor->binary( rawtile, threshold );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << threshold << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Apply histogram equalization\n  if( session->view->equalization ){\n    if( session->loglevel >= 4 ) function_timer.start();\n    // Perform histogram equalization\n    session->processor->equalize( rawtile, (*session->image)->histogram );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Applying histogram equalization in \"\n                          << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Apply flip\n  if( session->view->flip != 0 ){\n    Timer flip_timer;\n    if( session->loglevel >= 5 ){\n      flip_timer.start();\n    }\n\n    session->processor->flip( rawtile, session->view->flip  );\n\n    if( session->loglevel >= 5 ){\n      *(session->logfile) << \"JTL :: Flipping image \";\n      if( session->view->flip == 1 ) *(session->logfile) << \"horizontally\";\n      else *(session->logfile) << \"vertically\";\n      *(session->logfile) << \" in \" << flip_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Apply rotation - can apply this safely after gamma and contrast adjustment\n  if( session->view->getRotation() != 0.0 ){\n    float rotation = session->view->getRotation();\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Rotating image by \" << rotation << \" degrees\";\n      function_timer.start();\n    }\n    session->processor->rotate( rawtile, rotation );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Compress to requested output format\n  if( rawtile.compressionType == UNCOMPRESSED ){\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Encoding UNCOMPRESSED tile\";\n      function_timer.start();\n    }\n    len = compressor->Compress( rawtile );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds to \"\n                          << rawtile.dataLength << \" bytes\" << endl;\n\n    }\n  }\n\n\n#ifndef DEBUG\n\n  // Send HTTP header\n  stringstream header;\n  header << session->response->createHTTPHeader( compressor->getMimeType(), (*session->image)->getTimestamp(), len );\n  if( session->out->putStr( (const char*) header.str().c_str(), header.tellp() ) == -1 ){\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"JTL :: Error writing HTTP header\" << endl;\n    }\n  }\n\n#endif\n\n\n  if( session->out->putStr( static_cast<const char*>(rawtile.data), len ) != len ){\n   if( session->loglevel >= 1 ){\n     *(session->logfile) << \"JTL :: Error writing JPEG tile\" << endl;\n   }\n  }\n\n\n  if( session->out->flush() == -1 ) {\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"JTL :: Error flushing JPEG tile\" << endl;\n    }\n  }\n\n\n  // Inform our response object that we have sent something to the client\n  session->response->setImageSent();\n\n  // Total JTL response time\n  if( session->loglevel >= 2 ){\n    *(session->logfile) << \"JTL :: Total command time \" << command_timer.getTime() << \" microseconds\" << endl;\n  }\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 352,
        "code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-26490"
    },
    {
        "index": 353,
        "code": "ut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n\tut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);\n\tut8 buf[128];\n\tif (!bin || entry == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {\n\t\tR_LOG_ERROR (\"read (init_offset)\");\n\t\treturn 0;\n\t}\n\tif (buf[0] == 0x68) { // push // x86 only\n\t\tut64 addr;\n\t\tmemmove (buf, buf + 1, 4);\n\t\taddr = (ut64)r_read_le32 (buf);\n\t\treturn Elf_(r_bin_elf_v2p) (bin, addr);\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1714"
    },
    {
        "index": 355,
        "code": "get_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n    int\t\tvim9script = in_vim9script();\n    long\tstart_lnum = SOURCING_LNUM;\n\n    if (equal_arrow && !vim9script)\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || vim9script ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tSOURCING_LNUM = start_lnum;  // used for where lambda is defined\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(e_expected_right_curly_str), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t\tvim9script && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !vim9script || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\t// Use the line number of the arguments.\n\tfp->uf_script_ctx.sc_lnum += start_lnum;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2889"
    },
    {
        "index": 356,
        "code": "static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\n\t/* Check that username and realm match. \n\t * These checks should have been performed before entering this\n\t * function.\n\t */\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\n\t/* Prepare for our digest calculation. */\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\n\t/* Create digest for comparison. */\n\tpjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\n\t/* Compare digest. */\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24754"
    },
    {
        "index": 357,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float input_min = context->input(1).flat<float>()(0);\n    const float input_max = context->input(2).flat<float>()(0);\n    const Tensor& mean = context->input(3);\n    const float mean_min = context->input(4).flat<float>()(0);\n    const float mean_max = context->input(5).flat<float>()(0);\n    const Tensor& var = context->input(6);\n    const float var_min = context->input(7).flat<float>()(0);\n    const float var_max = context->input(8).flat<float>()(0);\n    const Tensor& beta = context->input(9);\n    const float beta_min = context->input(10).flat<float>()(0);\n    const float beta_max = context->input(11).flat<float>()(0);\n    const Tensor& gamma = context->input(12);\n    const float gamma_min = context->input(13).flat<float>()(0);\n    const float gamma_max = context->input(14).flat<float>()(0);\n\n    OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be 4-dimensional\",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(context, mean.dims() == 1,\n                errors::InvalidArgument(\"mean must be 1-dimensional\",\n                                        mean.shape().DebugString()));\n    OP_REQUIRES(context, var.dims() == 1,\n                errors::InvalidArgument(\"var must be 1-dimensional\",\n                                        var.shape().DebugString()));\n    OP_REQUIRES(context, beta.dims() == 1,\n                errors::InvalidArgument(\"beta must be 1-dimensional\",\n                                        beta.shape().DebugString()));\n    OP_REQUIRES(context, gamma.dims() == 1,\n                errors::InvalidArgument(\"gamma must be 1-dimensional\",\n                                        gamma.shape().DebugString()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    float output_min;\n    float output_max;\n    FixedPointBatchNorm<T1, T2>(input, input_min, input_max, mean, mean_min,\n                                mean_max, var, var_min, var_max, beta, beta_min,\n                                beta_max, gamma, gamma_min, gamma_max,\n                                variance_epsilon_, scale_after_normalization_,\n                                output, &output_min, &output_max);\n\n    Tensor* output_min_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, {}, &output_min_tensor));\n    output_min_tensor->flat<float>()(0) = output_min;\n\n    Tensor* output_max_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, {}, &output_max_tensor));\n    output_max_tensor->flat<float>()(0) = output_max;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29547"
    },
    {
        "index": 359,
        "code": "Status SpaceToBatchOpCompute(OpKernelContext* context,\n                             const Tensor& orig_input_tensor,\n                             const Tensor& orig_block_shape,\n                             const Tensor& orig_paddings) {\n  const int input_dims = orig_input_tensor.dims();\n  if (!TensorShapeUtils::IsVector(orig_block_shape.shape())) {\n    return errors::InvalidArgument(\"block_shape rank should be 1 instead of \",\n                                   orig_block_shape.dims());\n  }\n\n  const int block_dims = orig_block_shape.dim_size(0);\n  if (orig_input_tensor.dims() < 1 + block_dims) {\n    return errors::InvalidArgument(\"input rank should be >= \", 1 + block_dims,\n                                   \" instead of \", orig_input_tensor.dims());\n  }\n\n  if (!(TensorShapeUtils::IsMatrix(orig_paddings.shape()) &&\n        block_dims == orig_paddings.dim_size(0) &&\n        2 == orig_paddings.dim_size(1))) {\n    return errors::InvalidArgument(\"paddings should have shape [\", block_dims,\n                                   \", 2] instead of \",\n                                   orig_paddings.shape().DebugString());\n  }\n\n  // To avoid out-of-bounds access in the case that the block_shape and/or\n  // paddings tensors are concurrently modified, we must copy the values.\n  gtl::InlinedVector<int64_t, 4> block_shape;\n  gtl::InlinedVector<int64_t, 8> paddings;\n  internal::spacetobatch::SubtleMustCopyFlat(orig_block_shape, &block_shape);\n  internal::spacetobatch::SubtleMustCopyFlat(orig_paddings, &paddings);\n\n  // Determine the length of the prefix of block dims that can be combined\n  // into the batch dimension due to having no padding and block_shape=1.\n  int removed_prefix_block_dims = 0;\n  for (; removed_prefix_block_dims < block_dims; ++removed_prefix_block_dims) {\n    const int dim = removed_prefix_block_dims;\n    if (paddings[2 * dim] != 0 || paddings[2 * dim + 1] != 0 ||\n        block_shape[dim] != 1) {\n      break;\n    }\n  }\n\n  // Determine the length of the suffix of block dims that can be combined\n  // into the depth dimension due to having no padding and block_shape=1.\n  int removed_suffix_block_dims = 0;\n  for (; removed_suffix_block_dims < block_dims - removed_prefix_block_dims;\n       ++removed_suffix_block_dims) {\n    const int dim = block_dims - 1 - removed_suffix_block_dims;\n    if (paddings[dim * 2] != 0 || paddings[dim * 2 + 1] != 0 ||\n        block_shape[dim] != 1) {\n      break;\n    }\n  }\n\n  // Compute the product of the block_shape values.\n  int64_t block_shape_product = 1;\n  for (int block_dim = 0; block_dim < block_dims; ++block_dim) {\n    block_shape_product *= block_shape[block_dim];\n  }\n  if (block_shape_product <= 0) {\n    return errors::InvalidArgument(\n        \"Product of block sizes must be positive, got \", block_shape_product);\n  }\n\n  const int internal_block_dims =\n      block_dims - removed_prefix_block_dims - removed_suffix_block_dims;\n  if (internal_block_dims > kMaxSpaceToBatchBlockDims) {\n    return errors::InvalidArgument(\n        \"Maximum number of non-combined block dimensions is \",\n        internal_block_dims, \" but must not exceed \",\n        kMaxSpaceToBatchBlockDims);\n  }\n\n  if (internal_block_dims == 0) {\n    context->set_output(0, orig_input_tensor);\n    return Status::OK();\n  }\n\n  // For the purpose of computing the result, the input will be treated as\n  // having this shape, of rank 2 + internal_block_dims.\n  TensorShape internal_input_shape;\n\n  // For the purpose of computing the result, the output will be treated as\n  // having this shape, of rank 2 + internal_block_dims.\n  TensorShape internal_output_shape;\n\n  // The actual output shape exposed to callers.\n  TensorShape external_output_shape;\n\n  external_output_shape.AddDim(orig_input_tensor.dim_size(0) *\n                               block_shape_product);\n\n  int64_t input_batch_size = orig_input_tensor.dim_size(0);\n  for (int block_dim = 0; block_dim < removed_prefix_block_dims; ++block_dim) {\n    const int64_t size = orig_input_tensor.dim_size(block_dim + 1);\n    input_batch_size *= size;\n    external_output_shape.AddDim(size);\n  }\n  internal_input_shape.AddDim(input_batch_size);\n  internal_output_shape.AddDim(input_batch_size * block_shape_product);\n\n  for (int block_dim = removed_prefix_block_dims;\n       block_dim < block_dims - removed_suffix_block_dims; ++block_dim) {\n    const int64_t pad_start = paddings[2 * block_dim],\n                  pad_end = paddings[2 * block_dim + 1];\n    if (pad_start < 0 || pad_end < 0) {\n      return errors::InvalidArgument(\"Paddings must be non-negative\");\n    }\n    const int64_t input_size = orig_input_tensor.dim_size(block_dim + 1);\n    const int64_t block_shape_value = block_shape[block_dim];\n    const int64_t padded_size = input_size + pad_start + pad_end;\n    if (padded_size % block_shape_value != 0) {\n      return errors::InvalidArgument(\"padded_shape[\", block_dim,\n                                     \"]=\", padded_size,\n                                     \" is not divisible by block_shape[\",\n                                     block_dim, \"]=\", block_shape_value);\n    }\n    internal_input_shape.AddDim(input_size);\n    const int64_t output_size = padded_size / block_shape_value;\n    internal_output_shape.AddDim(output_size);\n    external_output_shape.AddDim(output_size);\n  }\n\n  int64_t depth = 1;\n  for (int dim = block_dims - removed_suffix_block_dims + 1; dim < input_dims;\n       ++dim) {\n    const int64_t size = orig_input_tensor.dim_size(dim);\n    external_output_shape.AddDim(size);\n    depth *= size;\n  }\n  internal_input_shape.AddDim(depth);\n  internal_output_shape.AddDim(depth);\n\n  // Allocate output tensor.\n  Tensor* output_tensor = nullptr;\n  TF_RETURN_IF_ERROR(\n      context->allocate_output(0, external_output_shape, &output_tensor));\n\n  const int64_t* internal_paddings = &paddings[2 * removed_prefix_block_dims];\n  const int64_t* internal_block_shape = &block_shape[removed_prefix_block_dims];\n\n  switch (internal_block_dims) {\n#define TF_SPACETOBATCH_BLOCK_DIMS_CASE(NUM_BLOCK_DIMS)                   \\\n  case NUM_BLOCK_DIMS: {                                                  \\\n    TF_RETURN_IF_ERROR(                                                   \\\n        functor::SpaceToBatchFunctor<Device, T, NUM_BLOCK_DIMS, false>()( \\\n            context->eigen_device<Device>(),                              \\\n            orig_input_tensor.shaped<T, NUM_BLOCK_DIMS + 2>(              \\\n                internal_input_shape.dim_sizes()),                        \\\n            internal_block_shape, internal_paddings,                      \\\n            output_tensor->shaped<T, NUM_BLOCK_DIMS + 2>(                 \\\n                internal_output_shape.dim_sizes())));                     \\\n  } break;                                                                \\\n    /**/\n    TF_SPACETOBATCH_FOR_EACH_NUM_BLOCK_DIMS(TF_SPACETOBATCH_BLOCK_DIMS_CASE)\n#undef TF_SPACETOBATCH_BLOCK_DIMS_CASE\n  }\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-29203"
    },
    {
        "index": 360,
        "code": "block_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t{\n\t    int off;\n\n\t    // Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t    }\n\t    else\n\t    {\n\t\toff = (*mb_off_next)(oldp, oldp + offset);\n\t\toffset += off;\n\t    }\n\t    spaces -= off;\n\t    count -= off;\n\t}\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\tnewp = alloc(STRLEN(oldp) + s_len + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)(offset));\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces && !bdp->is_short)\n\t{\n\t    // insert post-padding\n\t    vim_memset(newp + offset + spaces, ' ', (size_t)(ts_val - spaces));\n\t    // We're splitting a TAB, don't copy it.\n\t    oldp++;\n\t    // We allowed for that TAB, remember this now\n\t    count++;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0261"
    },
    {
        "index": 361,
        "code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 362,
        "code": "static int parse_line(char *p)\n{\n\tstruct SYMBOL *s;\n\tchar *q, c;\n\tchar *dot = NULL;\n\tstruct SYMBOL *last_note_sav = NULL;\n\tstruct decos dc_sav;\n\tint i, flags, flags_sav = 0, slur;\n\tstatic char qtb[10] = {0, 1, 3, 2, 3, 0, 2, 0, 3, 0};\n\n\tcolnum = 0;\n\tswitch (*p) {\n\tcase '\\0':\t\t\t/* blank line */\n\t\tswitch (parse.abc_state) {\n\t\tcase ABC_S_GLOBAL:\n\t\t\tif (parse.last_sym\n\t\t\t && parse.last_sym->abc_type != ABC_T_NULL)\n\t\t\t\tabc_new(ABC_T_NULL, NULL);\n\t\tcase ABC_S_HEAD:\t/*fixme: may have blank lines in headers?*/\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase '%':\n\t\tif (p[1] == '%') {\n\t\t\ts = abc_new(ABC_T_PSCOM, p);\n\t\t\tp += 2;\t\t\t\t/* skip '%%' */\n\t\t\tif (strncasecmp(p, \"decoration \", 11) == 0) {\n\t\t\t\tp += 11;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '!':\n\t\t\t\t\tchar_tb['!'] = CHAR_DECOS;\n\t\t\t\t\tchar_tb['+'] = CHAR_BAD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tchar_tb['+'] = CHAR_DECOS;\n\t\t\t\t\tchar_tb['!'] = CHAR_BAD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"linebreak \", 10) == 0) {\n\t\t\t\tfor (i = 0; i < sizeof char_tb; i++) {\n\t\t\t\t\tif (char_tb[i] == CHAR_LINEBREAK)\n\t\t\t\t\t\tchar_tb[i] = i != '!' ?\n\t\t\t\t\t\t\t\tCHAR_BAD :\n\t\t\t\t\t\t\t\tCHAR_DECOS;\n\t\t\t\t}\n\t\t\t\tp += 10;\n\t\t\t\tfor (;;) {\n\t\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\t\tp++;\n\t\t\t\t\tif (*p == '\\0')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tswitch (*p) {\n\t\t\t\t\tcase '!':\n\t\t\t\t\tcase '$':\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase ';':\n\t\t\t\t\tcase '?':\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tchar_tb[(unsigned char) *p++]\n\t\t\t\t\t\t\t\t= CHAR_LINEBREAK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tif (strncmp(p, \"<none>\", 6) == 0)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tif (strncmp(p, \"<EOL>\", 5) == 0) {\n\t\t\t\t\t\t\tchar_tb['\\n'] = CHAR_LINEBREAK;\n\t\t\t\t\t\t\tp += 5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fall thru */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (strcmp(p, \"lock\") != 0)\n\t\t\t\t\t\t\tsyntax(\"Invalid character in %%%%linebreak\",\n\t\t\t\t\t\t\t\tp);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"microscale \", 11) == 0) {\n\t\t\t\tint v;\n\n\t\t\t\tp += 11;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tsscanf(p, \"%d\", &v);\n\t\t\t\tif (v < 4 || v >= 256 || v & 1)\n\t\t\t\t\tsyntax(\"Invalid value in %%microscale\", p);\n\t\t\t\telse\n\t\t\t\t\tmicroscale = v;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strncasecmp(p, \"user \", 5) == 0) {\n\t\t\t\tp += 5;\n\t\t\t\twhile (isspace((unsigned char) *p))\n\t\t\t\t\tp++;\n\t\t\t\tget_user(p, s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/* fall thru */\n\tcase '\\\\':\t\t\t\t/* abc2mtex specific lines */\n\t\treturn 0;\t\t\t/* skip */\n\t}\n\n\t/* header fields */\n\tif (p[1] == ':'\n\t && *p != '|' && *p != ':') {\t\t/* not '|:' nor '::' */\n\t\tint new_tune;\n\n\t\tnew_tune = parse_info(p);\n\n\t\t/* handle BarFly voice definition */\n\t\t/* 'V:n <note line ending with a bar>' */\n\t\tif (*p != 'V'\n\t\t || parse.abc_state != ABC_S_TUNE)\n\t\t\treturn new_tune;\t\t/* (normal return) */\n\t\tc = p[strlen(p) - 1];\n\t\tif (c != '|' && c != ']')\n\t\t\treturn new_tune;\n\t\twhile (!isspace((unsigned char) *p) && *p != '\\0')\n\t\t\tp++;\n\t\twhile (isspace((unsigned char) *p))\n\t\t\tp++;\n\t}\n\tif (parse.abc_state != ABC_S_TUNE)\n\t\treturn 0;\n\n\t/* music */\n\tflags = 0;\n\tif (parse.abc_vers <= (2 << 16))\n\t\tlyric_started = 0;\n\tdeco_start = deco_cont = NULL;\n\tslur = 0;\n\twhile (*p != '\\0') {\n\t\tcolnum = p - abc_line;\n\t\tswitch (char_tb[(unsigned char) *p++]) {\n\t\tcase CHAR_GCHORD:\t\t\t/* \" */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tp = parse_gchord(p);\n\t\t\tbreak;\n\t\tcase CHAR_GR_ST:\t\t/* '{' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tlast_note_sav = curvoice->last_note;\n\t\t\tcurvoice->last_note = NULL;\n\t\t\tmemcpy(&dc_sav, &dc, sizeof dc);\n\t\t\tdc.n = 0;\n\t\t\tflags_sav = flags;\n\t\t\tflags = ABC_F_GRACE;\n\t\t\tif (*p == '/') {\n\t\t\t\tflags |= ABC_F_SAPPO;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_GR_EN:\t\t/* '}' */\n\t\t\tif (!(flags & ABC_F_GRACE))\n\t\t\t\tgoto bad_char;\n\t\t\tparse.last_sym->flags |= ABC_F_GR_END;\n\t\t\tif (dc.n != 0)\n\t\t\t\tsyntax(\"Decoration ignored\", p);\n\t\t\tcurvoice->last_note = last_note_sav;\n\t\t\tmemcpy(&dc, &dc_sav, sizeof dc);\n\t\t\tflags = flags_sav;\n\t\t\tbreak;\n\t\tcase CHAR_DECOS:\n\t\t\tif (p[-1] == '!'\n\t\t\t && char_tb['\\n'] == CHAR_LINEBREAK\n\t\t\t && check_nl(p)) {\n\t\t\t\ts = abc_new(ABC_T_EOLN, NULL);\t/* abc2win EOL */\n\t\t\t\ts->u.eoln.type = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall thru */\n\t\tcase CHAR_DECO:\n\t\t\tif (p[-1] == '.') {\n\t\t\t\tif (*p == '(' || *p == '-') {\n\t\t\t\t\tdot = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tif (*p == '|') {\n//\t\t\t\t\tp = parse_bar(p + 1);\n//\t\t\t\t\tparse.last_sym->u.bar.dotted = 1;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t}\n\t\t\tp = parse_deco(p - 1, &dc, -1);\n\t\t\tbreak;\n\t\tcase CHAR_LINEBREAK:\n\t\t\ts = abc_new(ABC_T_EOLN, NULL);\n//\t\t\ts->u.eoln.type = 0;\n\t\t\tbreak;\n\t\tcase CHAR_NOTE:\n\t\t\tp = parse_note(p - 1, flags);\n\t\t\tflags &= ABC_F_GRACE;\n\t\t\tparse.last_sym->u.note.slur_st = slur;\n\t\t\tslur = 0;\n\t\t\tif (parse.last_sym->u.note.notes[0].len > 0) /* if not space */\n\t\t\t\tcurvoice->last_note = parse.last_sym;\n\t\t\tbreak;\n\t\tcase CHAR_SLASH:\t\t/* '/' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (char_tb[(unsigned char) p[-1]] != CHAR_BAR)\n\t\t\t\tgoto bad_char;\n\t\t\tq = p;\n\t\t\twhile (*q == '/')\n\t\t\t\tq++;\n\t\t\tif (char_tb[(unsigned char) *q] != CHAR_BAR)\n\t\t\t\tgoto bad_char;\n\t\t\ts = abc_new(ABC_T_MREP, NULL);\n\t\t\ts->u.bar.type = 0;\n\t\t\ts->u.bar.len = q - p + 1;\n\t\t\tsyntax(\"Non standard measure repeat syntax\", p - 1);\n\t\t\tp = q;\n\t\t\tbreak;\n\t\tcase CHAR_BSLASH:\t\t/* '\\\\' */\n\t\t\tif (*p == '\\0')\n\t\t\t\tbreak;\n\t\t\tsyntax(\"'\\\\' ignored\", p - 1);\n\t\t\tbreak;\n\t\tcase CHAR_OBRA:\t\t\t/* '[' */\n\t\t\tif (*p == '|' || *p == ']' || *p == ':'\n\t\t\t || isdigit((unsigned char) *p) || *p == '\"'\n\t\t\t || *p == ' ') {\n\t\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\t\tgoto bad_char;\n\t\t\t\tp = parse_bar(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p[1] != ':') {\n\t\t\t\tp = parse_note(p - 1, flags); /* chord */\n\t\t\t\tflags &= ABC_F_GRACE;\n\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n\t\t\t\tslur = 0;\n\t\t\t\tcurvoice->last_note = parse.last_sym;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* embedded information field */\n#if 0\n/*fixme:OK for [I:staff n], ?? for other headers*/\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n#endif\n\t\t\twhile (p[2] == ' ') {\t\t/* remove the spaces */\n\t\t\t\tp[2] = ':';\n\t\t\t\tp[1] = *p;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tc = ']';\n\t\t\tq = p;\n\t\t\twhile (*p != '\\0' && *p != c)\n\t\t\t\tp++;\n\t\t\tif (*p == '\\0') {\n\t\t\t\tsyntax(\"Escape sequence [..] not closed\", q);\n\t\t\t\tc = '\\0';\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tparse_info(q);\n\t\t\t*p = c;\n\t\t\tif (c != '\\0')\n\t\t\t\tp++;\n\t\t\tbreak;\n\t\tcase CHAR_BAR:\t\t\t/* '|', ':' or ']' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tp = parse_bar(p);\n\t\t\tbreak;\n\t\tcase CHAR_OPAR:\t\t\t/* '(' */\n\t\t\tif (*p > '0' && *p <= '9') {\n\t\t\t\tint pplet, qplet, rplet;\n\n\t\t\t\tpplet = strtol(p, &q, 10);\n\t\t\t\tp = q;\n\t\t\t\tif ((unsigned) pplet < sizeof qtb / sizeof qtb[0])\n\t\t\t\t\tqplet = qtb[pplet];\n\t\t\t\telse\n\t\t\t\t\tqplet = qtb[0];\n\t\t\t\trplet = pplet;\n\t\t\t\tif (*p == ':') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\t\t\tqplet = strtol(p, &q, 10);\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t}\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (isdigit((unsigned char) *p)) {\n\t\t\t\t\t\t\trplet = strtol(p, &q, 10);\n\t\t\t\t\t\t\tp = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rplet < 1) {\n\t\t\t\t\tsyntax(\"Invalid 'r' in tuplet\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pplet >= 128 || qplet >= 128 || rplet >= 128) {\n\t\t\t\t\tsyntax(\"Invalid 'p:q:r' in tuplet\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (qplet == 0)\n\t\t\t\t\tqplet = meter % 3 == 0 ? 3 : 2;\n\t\t\t\ts = abc_new(ABC_T_TUPLET, NULL);\n\t\t\t\ts->u.tuplet.p_plet = pplet;\n\t\t\t\ts->u.tuplet.q_plet = qplet;\n\t\t\t\ts->u.tuplet.r_plet = rplet;\n\t\t\t\ts->flags |= flags;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '&') {\n\t\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\t\tgoto bad_char;\n\t\t\t\tp++;\n\t\t\t\tif (vover != 0) {\n\t\t\t\t\tsyntax(\"Nested voice overlay\", p - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\t\ts->u.v_over.type = V_OVER_S;\n\t\t\t\ts->u.v_over.voice = curvoice - voice_tb;\n\t\t\t\tvover = -1;\t\t/* multi-bars */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tslur <<= 4;\n\t\t\tif (p == dot + 1 && dc.n == 0)\n\t\t\t\tslur |= SL_DOTTED;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\'':\n\t\t\t\tslur += SL_ABOVE;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tslur += SL_BELOW;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tslur += SL_AUTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHAR_CPAR:\t\t\t/* ')' */\n\t\t\tswitch (parse.last_sym->abc_type) {\n\t\t\tcase ABC_T_NOTE:\n\t\t\tcase ABC_T_REST:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto bad_char;\n\t\t\t}\n\t\t\tparse.last_sym->u.note.slur_end++;\n\t\t\tbreak;\n\t\tcase CHAR_VOV:\t\t\t/* '&' */\n\t\t\tif (flags & ABC_F_GRACE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (*p != ')'\n\t\t\t || vover == 0) {\t\t/*??*/\n\t\t\t\tif (!curvoice->last_note) {\n\t\t\t\t\tsyntax(\"Bad start of voice overlay\", p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\t\t/*s->u.v_over.type = V_OVER_V; */\n\t\t\t\tvover_new();\n\t\t\t\ts->u.v_over.voice = curvoice - voice_tb;\n\t\t\t\tif (vover == 0)\n\t\t\t\t\tvover = 1;\t/* single bar */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tvover = 0;\n\t\t\ts = abc_new(ABC_T_V_OVER, NULL);\n\t\t\ts->u.v_over.type = V_OVER_E;\n\t\t\ts->u.v_over.voice = curvoice->mvoice;\n\t\t\tcurvoice->last_note = NULL;\t/* ?? */\n\t\t\tcurvoice = &voice_tb[curvoice->mvoice];\n\t\t\tbreak;\n\t\tcase CHAR_SPAC:\t\t\t/* ' ' and '\\t' */\n\t\t\tflags |= ABC_F_SPACE;\n\t\t\tbreak;\n\t\tcase CHAR_MINUS: {\t\t/* '-' */\n\t\t\tint tie_pos;\n\n\t\t\tif (!curvoice->last_note\n\t\t\t || curvoice->last_note->abc_type != ABC_T_NOTE)\n\t\t\t\tgoto bad_char;\n\t\t\tif (p == dot + 1 && dc.n == 0)\n\t\t\t\ttie_pos = SL_DOTTED;\n\t\t\telse\n\t\t\t\ttie_pos = 0;\n\t\t\tswitch (*p) {\n\t\t\tcase '\\'':\n\t\t\t\ttie_pos += SL_ABOVE;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttie_pos += SL_BELOW;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttie_pos += SL_AUTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i <= curvoice->last_note->nhd; i++) {\n\t\t\t\tif (curvoice->last_note->u.note.notes[i].ti1 == 0)\n\t\t\t\t\tcurvoice->last_note->u.note.notes[i].ti1 = tie_pos;\n\t\t\t\telse if (curvoice->last_note->nhd == 0)\n\t\t\t\t\tsyntax(\"Too many ties\", p);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase CHAR_BRHY:\t\t\t/* '>' and '<' */\n\t\t\tif (!curvoice->last_note)\n\t\t\t\tgoto bad_char;\n\t\t\ti = 1;\n\t\t\twhile (*p == p[-1]) {\n\t\t\t\ti++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (i > 3) {\n\t\t\t\tsyntax(\"Bad broken rhythm\", p - 1);\n\t\t\t\ti = 3;\n\t\t\t}\n\t\t\tif (p[-1] == '<')\n\t\t\t\ti = -i;\n\t\t\tbroken_rhythm(curvoice->last_note, i);\n\t\t\tcurvoice->last_note->u.note.brhythm = i;\n\t\t\tbreak;\n\t\tcase CHAR_IGN:\t\t\t/* '*' & '`' */\n\t\t\tbreak;\n\t\tdefault:\n\t\tbad_char:\n\t\t\tsyntax((flags & ABC_F_GRACE)\n\t\t\t\t\t? \"Bad character in grace note sequence\"\n\t\t\t\t\t: \"Bad character\",\n\t\t\t\tp - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n/*fixme: may we have grace notes across lines?*/\n\tif (flags & ABC_F_GRACE) {\n\t\tsyntax(\"EOLN in grace note sequence\", p - 1);\n\t\tif (curvoice->last_note)\n\t\t\tcurvoice->last_note->flags |= ABC_F_GR_END;\n\t\tcurvoice->last_note = last_note_sav;\n\t\tmemcpy(&dc, &dc_sav, sizeof dc);\n\t}\n\n\t/* add eoln */\n\ts = abc_new(ABC_T_EOLN, NULL);\n\tif (flags & ABC_F_SPACE)\n\t\ts->flags |= ABC_F_SPACE;\n\tif (p[-1] == '\\\\'\n\t || char_tb['\\n'] != CHAR_LINEBREAK)\n\t\ts->u.eoln.type = 1;\t\t/* no break */\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32435"
    },
    {
        "index": 363,
        "code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1286"
    },
    {
        "index": 365,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 366,
        "code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n\n    *t = op_def.output_arg(i).experimental_full_type();\n\n    // Resolve dependent types. The convention for op registrations is to use\n    // attributes as type variables.\n    // See https://www.tensorflow.org/guide/create_op#type_polymorphism.\n    // Once the op signature can be defined entirely in FullType, this\n    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n\n        arg->clear_s();\n      }\n    }\n  }\n\n  return ft;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23574"
    },
    {
        "index": 367,
        "code": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-44109"
    },
    {
        "index": 368,
        "code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23645"
    },
    {
        "index": 369,
        "code": "static char *parse_note(char *p,\n\t\t\tint flags)\n{\n\tstruct SYMBOL *s;\n\tchar *q;\n\tint pit = 0, len, acc, nostem, chord, j, m, n;\n\n\tif (flags & ABC_F_GRACE) {\t/* in a grace note sequence */\n\t\ts = abc_new(ABC_T_NOTE, NULL);\n\t} else {\n\t\ts = abc_new(ABC_T_NOTE, gchord);\n\t\tif (gchord)\n\t\t\tgchord = NULL;\n\t}\n\ts->flags |= flags;\n\ts->u.note.notes[0].color = -1;\n\n\tif (!lyric_started) {\n\t\tlyric_started = 1;\n\t\ts->flags |= ABC_F_LYRIC_START;\n\t}\n\tif (*p != 'X' && *p != 'Z'\n\t && !(flags & ABC_F_GRACE)) {\n\t\tif (!deco_start)\n\t\t\tdeco_start = s;\n\t}\n\tchord = 0;\n\n\t/* rest */\n\tswitch (*p) {\n\tcase 'X':\n\t\ts->flags |= ABC_F_INVIS;\n\tcase 'Z':\t\t\t/* multi-rest */\n\t\ts->abc_type = ABC_T_MREST;\n\t\tp++;\n\t\tlen = 1;\n\t\tif (isdigit((unsigned char) *p)) {\n\t\t\tlen = strtol(p, &q, 10);\n\t\t\tif (len == 0 || len > 100) {\n\t\t\t\tsyntax(\"Bad number of measures\", p);\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tp = q;\n\t\t}\n\t\ts->u.bar.type = 0;\n\t\ts->u.bar.len = len;\n\t\tgoto add_deco;\n\tcase 'y':\t\t\t/* space (BarFly) */\n\t\ts->abc_type = ABC_T_REST;\n\t\ts->flags |= ABC_F_INVIS;\n\t\tp++;\n\t\tif (isdigit((unsigned char) *p)\t\t/* number of points */\n\t\t || *p == '-') {\t\t\t/* accept negative offset... */\n\t\t\ts->u.note.notes[0].shhd = strtol(p, &q, 10);\n\t\t\tp = q;\n\t\t} else {\n\t\t\ts->u.note.notes[0].shhd = 10;\t// default\n\t\t}\n\t\tgoto add_deco;\n\tcase 'x':\t\t\t/* invisible rest */\n\t\ts->flags |= ABC_F_INVIS;\n\t\t/* fall thru */\n\tcase 'z':\n\t\ts->abc_type = ABC_T_REST;\n\t\tp = parse_len(p + 1, ulen, &len);\n\t\ts->u.note.notes[0].len = len;\n\t\tgoto do_brhythm;\n\tcase '[':\t\t\t/* '[..]' = chord */\n\t\tchord = 1;\n\t\tp++;\n\t\tbreak;\n\t}\n\n\tq = p;\n\n\t/* get pitch, length and possible accidental */\n\tm = 0;\n\tnostem = 0;\n\tfor (;;) {\n\t\tif (chord) {\n\t\t\tif (m >= MAXHD) {\n\t\t\t\tsyntax(\"Too many notes in chord\", p);\n\t\t\t\tm--;\n\t\t\t}\n\t\t\tn = 0;\n\t\t\tif (*p == '.') {\n\t\t\t\tn = SL_DOTTED;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '(') {\n\t\t\t\tp++;\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tn += SL_ABOVE;\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ',':\n\t\t\t\t\tn += SL_BELOW;\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tn += SL_AUTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)\n\t\t\t\t\t\t\t+ n;\n\t\t\t}\n\t\t}\n\t\tp = parse_deco(p, &dc, m);\t/* note head decorations */\n\t\tp = parse_acc_pit(p, &pit, &acc);\n\t\tif (*p == '0') {\n\t\t\tnostem = 1;\n\t\t\tp++;\n\t\t}\n\t\tp = parse_len(p, (flags & ABC_F_GRACE) ?\n\t\t\t\t\tBASE_LEN / 8 :\t// for grace note alone\n\t\t\t\t\tulen,\n\t\t\t\t&len);\n\t\ts->u.note.notes[m].pit = pit;\n\t\ts->pits[m] = pit;\n\t\ts->u.note.notes[m].len = len;\n\t\ts->u.note.notes[m].acc = acc;\n\t\ts->u.note.notes[m].color = -1;\n\n\t\tif (chord) {\n\t\t\tfor (;;) {\n\t\t\t\tif (*p == '.') {\n\t\t\t\t\tif (p[1] != '-')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (*p == '-') {\n\t\t\t\t\tswitch (p[1]) {\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_ABOVE;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ',':\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_BELOW;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ts->u.note.notes[m].ti1 = SL_AUTO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (*p == ')') {\n\t\t\t\t\ts->u.note.notes[m].sl2++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tif (acc >= 0)\t\t\t/* if no error */\n\t\t\tm++;\t\t\t/* normal case */\n\n\t\tif (!chord)\n\t\t\tbreak;\n\t\tif (*p == ']') {\n\t\t\tp++;\n\t\t\tif (*p == '0') {\n\t\t\t\tnostem = 1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '/' || isdigit((unsigned char) *p)) {\n\t\t\t\tp = parse_len(p, ulen, &len);\n\t\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\t\ts->u.note.notes[j].len =\n\t\t\t\t\t\tlen * s->u.note.notes[j].len / ulen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (*p == '\\0') {\n\t\t\tsyntax(\"Chord not closed\", q);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nostem)\n\t\ts->flags |= ABC_F_STEMLESS;\n\n\tif (m == 0)\t\t\t/* if no note (or error) */\n\t\tgoto err;\n\n\ts->u.note.microscale = microscale;\n\ts->nhd = m - 1;\n\ndo_brhythm:\n\tif (curvoice->last_note\n\t && curvoice->last_note->u.note.brhythm != 0)\n\t\tbroken_rhythm(s, -curvoice->last_note->u.note.brhythm);\nadd_deco:\n\tif (dc.n > 0) {\n\t\tmemcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc\n\t\t\t\t: &s->u.bar.dc,\n\t\t\t&dc, sizeof dc);\n\t\tdc.n = 0;\n\t}\n\n\t/* forbid rests in grace note sequences */\n\tif (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {\n\t\tsyntax(\"Not a note in grace note sequence\", p);\n\t\tgoto err;\n\t}\n\treturn p;\n\nerr:\n\tif ((parse.last_sym = s->abc_prev) == NULL) {\n\t\tparse.first_sym = NULL;\n\t} else {\n\t\ts->abc_prev->abc_next = NULL;\n\t\ts->abc_prev->flags |= (s->flags & ABC_F_ERROR);\n\t}\n\treturn p;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32435"
    },
    {
        "index": 370,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1201"
    },
    {
        "index": 371,
        "code": "static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[2], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * Length is the number of bytes.\n\t */\n\tlength = hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n\t\t/*\n\t\t * Write all bytes in a single I2C transaction. If the target\n\t\t * device is an EEPROM, it is your responsibility to not cross\n\t\t * a page boundary. No write delay upon completion, take this\n\t\t * into account if linking commands.\n\t\t */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\t/*\n\t\t * Repeated addressing - perform <length> separate\n\t\t * write transactions of one byte each\n\t\t */\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34835"
    },
    {
        "index": 372,
        "code": "diff_redraw(\n    int\t\tdofold)\t    // also recompute the folds\n{\n    win_T\t*wp;\n    win_T\t*wp_other = NULL;\n    int\t\tused_max_fill_other = FALSE;\n    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_p_diff)\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING\n\t    if (dofold && foldmethodIsDiff(wp))\n\t\tfoldUpdateAll(wp);\n#endif\n\t    // A change may have made filler lines invalid, need to take care\n\t    // of that for other windows.\n\t    n = diff_check(wp, wp->w_topline);\n\t    if ((wp != curwin && wp->w_topfill > 0) || n > 0)\n\t    {\n\t\tif (wp->w_topfill > n)\n\t\t    wp->w_topfill = (n < 0 ? 0 : n);\n\t\telse if (n > 0 && n > wp->w_topfill)\n\t\t{\n\t\t    wp->w_topfill = n;\n\t\t    if (wp == curwin)\n\t\t\tused_max_fill_curwin = TRUE;\n\t\t    else if (wp_other != NULL)\n\t\t\tused_max_fill_other = TRUE;\n\t\t}\n\t\tcheck_topfill(wp, FALSE);\n\t    }\n\t}\n\n    if (wp_other != NULL && curwin->w_p_scb)\n    {\n\tif (used_max_fill_curwin)\n\t    // The current window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(wp_other, curwin);\n\telse if (used_max_fill_other)\n\t    // The other window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(curwin, wp_other);\n    }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2208"
    },
    {
        "index": 373,
        "code": "RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tif (!bin->entry_table) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1297"
    },
    {
        "index": 374,
        "code": "PJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t   pjsip_dialog *dlg )\n{\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n\n    /* For all dialogs, local tag (inc hash) must has been initialized. */\n    PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&\n\t\t     dlg->local.tag_hval != 0, PJ_EBUG);\n\n    /* For UAS dialog, remote tag (inc hash) must have been initialized. */\n    //PJ_ASSERT_RETURN(dlg->role==PJSIP_ROLE_UAC ||\n    //\t\t     (dlg->role==PJSIP_ROLE_UAS && dlg->remote.info->tag.slen\n    //\t\t      && dlg->remote.tag_hval != 0), PJ_EBUG);\n\n    /* Lock the user agent. */\n    pj_mutex_lock(mod_ua.mutex);\n\n    /* For UAC, check if there is existing dialog in the same set. */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower( mod_ua.dlg_table,\n                                     dlg->local.info->tag.ptr, \n\t\t\t             (unsigned)dlg->local.info->tag.slen,\n\t\t\t             &dlg->local.tag_hval);\n\n\tif (dlg_set) {\n\t    /* This is NOT the first dialog in the dialog set. \n\t     * Just add this dialog in the list.\n\t     */\n\t    pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t} else {\n\t    /* This is the first dialog in the dialog set. \n\t     * Create the dialog set and add this dialog to it.\n\t     */\n\t    dlg_set = alloc_dlgset_node();\n\t    pj_list_init(&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\t    dlg->dlg_set = dlg_set;\n\n\t    /* Register the dialog set in the hash table. */\n\t    pj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t\t         dlg->local.info->tag.ptr,\n                                 (unsigned)dlg->local.info->tag.slen,\n\t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                                 dlg_set);\n\t}\n\n    } else {\n\t/* For UAS, create the dialog set with a single dialog as member. */\n\tstruct dlg_set *dlg_set;\n\n\tdlg_set = alloc_dlgset_node();\n\tpj_list_init(&dlg_set->dlg_list);\n\tpj_list_push_back(&dlg_set->dlg_list, dlg);\n\n\tdlg->dlg_set = dlg_set;\n\n\tpj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t             dlg->local.info->tag.ptr,\n                             (unsigned)dlg->local.info->tag.slen,\n\t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n    }\n\n    /* Unlock user agent. */\n    pj_mutex_unlock(mod_ua.mutex);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23608"
    },
    {
        "index": 375,
        "code": "int qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\n{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tsize_t size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb)) {\n\t\t\tqrtr_port_put(ipc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3743"
    },
    {
        "index": 376,
        "code": "static Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int newlen, argc, istart, n, rhowmany, ilen, curlen;\n    Jsi_Value *va, *start, *howmany;\n    Jsi_Obj *nobj, *obj = _this->d.obj;\n    \n    start = Jsi_ValueArrayIndex(interp, args, 0);\n    howmany = Jsi_ValueArrayIndex(interp, args, 1);\n    argc = Jsi_ValueGetLength(interp, args);\n    istart = 0;\n    ilen = (argc>=2 ? argc - 2 : 0);\n    n = Jsi_ObjGetLength(interp, obj);\n    curlen = n;\n    \n    if (!start) {\n        goto bail2;\n    }\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_ObjSetLength(interp, nobj, 0);\n    \n    /* Determine start index. */\n    Jsi_Number nstart;\n    if (Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            istart=0;\n    }\n      \n    Jsi_Number nhow;\n    rhowmany = n-istart;\n    if (howmany && Jsi_GetNumberFromValue(interp, howmany, &nhow) == JSI_OK) {\n        rhowmany = (int)nhow;\n        if (rhowmany >= (n-istart))\n            rhowmany = n-istart;\n        if (rhowmany < 0)\n            rhowmany = (n-istart);\n        if (rhowmany<0)\n            goto bail;\n    }\n    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    Jsi_ObjArraySizer(interp, nobj, rhowmany);\n\n    /* Move elements to return object. */\n    int i, j, m;\n    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    Jsi_ObjSetLength(interp, nobj, m);\n    \n    /* Shift remaining down. */\n    for (; rhowmany && i<curlen; i++)\n    {\n        obj->arr[i-rhowmany] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    curlen -= j;\n    /* Add elements. */\n    newlen = curlen + argc - (argc>=2?2:1);\n    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_ERROR;\n    }\n    if (ilen>0) {\n        for (i = curlen-1; i>=istart; i--) {\n            obj->arr[i+ilen] = obj->arr[i];\n            obj->arr[i] = NULL;\n        }\n        for (m=istart, i = 2; i<argc; m++,i++) {\n            va = Jsi_ValueArrayIndex(interp, args, i);\n            if (!va) continue;\n            obj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, obj->arr+m, va);\n        }\n    }\n    Jsi_ObjSetLength(interp, obj, newlen);\nbail:    \n    return JSI_OK;\n     \n            \nbail2:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 377,
        "code": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\n\trose_start_t3timer(sk);\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2318"
    },
    {
        "index": 378,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length)\n{\n    pjmedia_rtcp_common *hdr;\n    unsigned len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    len = 12;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB PLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 379,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_BIN_JAVA_ATTR_TYPE attr_type, ut32 pos) {\n\t/*\n\tSearch through the Attribute list for the given type starting at position pos.\n\trvalue: NULL or the first occurrence of attr_type after pos\n\t*/\n\tRBinJavaAttrInfo *attr = NULL, *item;\n\tRListIter *iter;\n\tut32 i = 0;\n\tif (field) {\n\t\tr_list_foreach (field->attributes, iter, item) {\n\t\t\t// Note the increment happens after the comparison\n\t\t\tif ((i++) >= pos) {\n\t\t\t\tif (item && (item->type == attr_type)) {\n\t\t\t\t\tattr = item;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1451"
    },
    {
        "index": 380,
        "code": "GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples)\n{\n\tu32 i, k;\n\tu32 *newSizes;\n\tif (!stsz /*|| !size */ || !sampleNumber) return GF_BAD_PARAM;\n\n\tif (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM;\n\n\tif (!nb_pack_samples) nb_pack_samples = 1;\n\telse if (nb_pack_samples>1)\n\t\tsize /= nb_pack_samples;\n\n\t//all samples have the same size\n\tif (stsz->sizes == NULL) {\n\t\t//1 first sample added in NON COMPACT MODE\n\t\tif (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) {\n\t\t\tstsz->sampleCount = nb_pack_samples;\n\t\t\tstsz->sampleSize = size;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//2- sample has the same size\n\t\tif (stsz->sampleSize == size) {\n\t\t\tstsz->sampleCount += nb_pack_samples;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (nb_pack_samples>1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Inserting packed samples with different sizes is not yet supported\\n\" ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\t//3- no, need to alloc a size table\n\t\tstsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1));\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tstsz->alloc_size = stsz->sampleCount + 1;\n\n\t\tk = 0;\n\t\tfor (i = 0 ; i < stsz->sampleCount; i++) {\n\t\t\tif (i + 1 == sampleNumber) {\n\t\t\t\tstsz->sizes[i + k] = size;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tstsz->sizes[i+k] = stsz->sampleSize;\n\t\t}\n\t\t//this if we append a new sample\n\t\tif (stsz->sampleCount + 1 == sampleNumber) {\n\t\t\tstsz->sizes[stsz->sampleCount] = size;\n\t\t}\n\t\tstsz->sampleSize = 0;\n\t\tstsz->sampleCount++;\n\t\treturn GF_OK;\n\t}\n\n\n\t/*append*/\n\tif (stsz->sampleCount + 1 == sampleNumber) {\n\t\tif (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount;\n\t\tif (stsz->sampleCount == stsz->alloc_size) {\n\t\t\tALLOC_INC(stsz->alloc_size);\n\t\t\tstsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) );\n\t\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) );\n\t\t}\n\t\tstsz->sizes[stsz->sampleCount] = size;\n\t} else {\n\t\tnewSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) );\n\t\tif (!newSizes) return GF_OUT_OF_MEM;\n\t\tk = 0;\n\t\tfor (i = 0; i < stsz->sampleCount; i++) {\n\t\t\tif (i + 1 == sampleNumber) {\n\t\t\t\tnewSizes[i + k] = size;\n\t\t\t\tk = 1;\n\t\t\t}\n\t\t\tnewSizes[i + k] = stsz->sizes[i];\n\t\t}\n\t\tgf_free(stsz->sizes);\n\t\tstsz->sizes = newSizes;\n\t\tstsz->alloc_size = 1 + stsz->sampleCount;\n\t}\n\tstsz->sampleCount++;\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 381,
        "code": "int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t     struct ndpi_flow_struct *flow, uint32_t quic_version) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  union ja3_info ja3;\n  u_int8_t invalid_ja3 = 0;\n  u_int16_t tls_version, ja3_str_len;\n  char ja3_str[JA3_STR_LEN];\n  ndpi_MD5_CTX ctx;\n  u_char md5_hash[16];\n  int i;\n  u_int16_t total_len;\n  u_int8_t handshake_type;\n  char buffer[64] = { '\\0' };\n  int is_quic = (quic_version != 0);\n  int is_dtls = packet->udp && (!is_quic);\n\n#ifdef DEBUG_TLS\n  printf(\"TLS %s() called\\n\", __FUNCTION__);\n#endif\n\n  memset(&ja3, 0, sizeof(ja3));\n\n  handshake_type = packet->payload[0];\n  total_len = (packet->payload[1] << 16) +  (packet->payload[2] << 8) + packet->payload[3];\n\n  if((total_len > packet->payload_packet_len) || (packet->payload[1] != 0x0))\n    return(0); /* Not found */\n\n  total_len = packet->payload_packet_len;\n\n  /* At least \"magic\" 3 bytes, null for string end, otherwise no need to waste cpu cycles */\n  if(total_len > 4) {\n    u_int16_t base_offset    = (!is_dtls) ? 38 : 46;\n    u_int16_t version_offset = (!is_dtls) ? 4 : 12;\n    u_int16_t offset = (!is_dtls) ? 38 : 46, extension_len, j;\n    u_int8_t  session_id_len =  0;\n\n    if((base_offset >= total_len) ||\n       (version_offset + 1) >= total_len)\n      return 0; /* Not found */\n\n    session_id_len = packet->payload[base_offset];\n\n#ifdef DEBUG_TLS\n    printf(\"TLS [len: %u][handshake_type: %02X]\\n\", packet->payload_packet_len, handshake_type);\n#endif\n\n    tls_version = ntohs(*((u_int16_t*)&packet->payload[version_offset]));\n\n    if(handshake_type == 0x02 /* Server Hello */) {\n      int i, rc;\n\n      ja3.server.tls_handshake_version = tls_version;\n\n#ifdef DEBUG_TLS\n      printf(\"TLS Server Hello [version: 0x%04X]\\n\", tls_version);\n#endif\n\n      /*\n\tThe server hello decides about the TLS version of this flow\n\thttps://networkengineering.stackexchange.com/questions/55752/why-does-wireshark-show-version-tls-1-2-here-instead-of-tls-1-3\n      */\n      if(packet->udp)\n\toffset += session_id_len + 1;\n      else {\n\tif(tls_version < 0x7F15 /* TLS 1.3 lacks of session id */)\n\t  offset += session_id_len+1;\n      }\n\n      if((offset+3) > packet->payload_packet_len)\n\treturn(0); /* Not found */\n\n      ja3.server.num_cipher = 1, ja3.server.cipher[0] = ntohs(*((u_int16_t*)&packet->payload[offset]));\n      if((flow->protos.tls_quic_stun.tls_quic.server_unsafe_cipher = ndpi_is_safe_ssl_cipher(ja3.server.cipher[0])) == 1)\n\tndpi_set_risk(flow, NDPI_TLS_WEAK_CIPHER);\n\n      flow->protos.tls_quic_stun.tls_quic.server_cipher = ja3.server.cipher[0];\n\n#ifdef DEBUG_TLS\n      printf(\"TLS [server][session_id_len: %u][cipher: %04X]\\n\", session_id_len, ja3.server.cipher[0]);\n#endif\n\n      offset += 2 + 1;\n\n      if((offset + 1) < packet->payload_packet_len) /* +1 because we are goint to read 2 bytes */\n\textension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n      else\n\textension_len = 0;\n\n#ifdef DEBUG_TLS\n      printf(\"TLS [server][extension_len: %u]\\n\", extension_len);\n#endif\n      offset += 2;\n\n      for(i=0; i<extension_len; ) {\n\tu_int16_t extension_id, extension_len;\n\n\tif((offset+4) > packet->payload_packet_len) break;\n\n\textension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));\n\textension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));\n\n\tif(ja3.server.num_tls_extension < MAX_NUM_JA3)\n\t  ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;\n\n#ifdef DEBUG_TLS\n\tprintf(\"TLS [server][extension_id: %u/0x%04X][len: %u]\\n\",\n\t       extension_id, extension_id, extension_len);\n#endif\n\n\tif(extension_id == 43 /* supported versions */) {\n\t  if(extension_len >= 2) {\n\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));\n\n#ifdef DEBUG_TLS\n\t    printf(\"TLS [server] [TLS version: 0x%04X]\\n\", tls_version);\n#endif\n\n\t    flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;\n\t  }\n\t} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */) {\n\t  u_int16_t s_offset = offset+4;\n\t  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t  char alpn_str[256];\n\t  u_int8_t alpn_str_len = 0, i;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n#endif\n\t  s_offset += 2;\n\t  tot_alpn_len += s_offset;\n\n\t  while(s_offset < tot_alpn_len && s_offset < total_len) {\n\t    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n\n\t    if((s_offset + alpn_len) <= tot_alpn_len) {\n#ifdef DEBUG_TLS\n\t      printf(\"Server TLS [ALPN: %u]\\n\", alpn_len);\n#endif\n\n\t      if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n\t        if(alpn_str_len > 0) {\n\t          alpn_str[alpn_str_len] = ',';\n\t          alpn_str_len++;\n\t        }\n\n\t        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n\t        {\n\t          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n\t        }\n\n\t        s_offset += alpn_len, alpn_str_len += alpn_len;;\n\t      } else {\n\t        ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n\t        break;\n\t      }\n\t    } else {\n\t      ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n\t      break;\n\t    }\n\t  } /* while */\n\n\t  alpn_str[alpn_str_len] = '\\0';\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n#endif\n\t  if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n\t    flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n\n\t  if(flow->protos.tls_quic_stun.tls_quic.alpn != NULL)\n\t    tlsCheckUncommonALPN(flow);\n\n\t  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), \"%s\", alpn_str);\n\n\t  /* Replace , with - as in JA3 */\n\t  for(i=0; ja3.server.alpn[i] != '\\0'; i++)\n\t    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';\n\t} else if(extension_id == 11 /* ec_point_formats groups */) {\n\t  u_int16_t s_offset = offset+4 + 1;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n#endif\n\t  if((s_offset+extension_len-1) <= total_len) {\n\t    for(i=0; i<extension_len-1; i++) {\n\t      u_int8_t s_group = packet->payload[s_offset+i];\n\n#ifdef DEBUG_TLS\n\t      printf(\"Server TLS [EllipticCurveFormat: %u]\\n\", s_group);\n#endif\n\n\t      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)\n\t\tja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;\n\t      else {\n\t\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\tprintf(\"Server TLS Invalid num elliptic %u\\n\", ja3.server.num_elliptic_curve_point_format);\n#endif\n\t      }\n\t    }\n\t  } else {\n\t    invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t    printf(\"Server TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n#endif\n\t  }\n\t}\n\n\ti += 4 + extension_len, offset += 4 + extension_len;\n      } /* for */\n\n      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), \"%u,\", ja3.server.tls_handshake_version);\n\n      for(i=0; i<ja3.server.num_cipher; i++) {\n\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.cipher[i]);\n\n\tif(rc <= 0) break; else ja3_str_len += rc;\n      }\n\n      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n      if(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;\n\n      /* ********** */\n\n      for(i=0; i<ja3.server.num_tls_extension; i++) {\n\tint rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.tls_extension[i]);\n\n\tif(rc <= 0) break; else ja3_str_len += rc;\n      }\n\n      if(ndpi_struct->enable_ja3_plus) {\n\tfor(i=0; i<ja3.server.num_elliptic_curve_point_format; i++) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t(i > 0) ? \"-\" : \"\", ja3.server.elliptic_curve_point_format[i]);\n\t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t}\n\n\tif(ja3.server.alpn[0] != '\\0') {\n\t  rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",%s\", ja3.server.alpn);\n\t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\t}\n\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3+] Server: %s \\n\", ja3_str);\n#endif\n      } else {\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Server: %s \\n\", ja3_str);\n#endif\n      }\n\n      ndpi_MD5Init(&ctx);\n      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n      ndpi_MD5Final(md5_hash, &ctx);\n\n      for(i=0, j=0; i<16; i++) {\n\tint rc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_server[j],\n\t\t\t  sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_server)-j, \"%02x\", md5_hash[i]);\n\tif(rc <= 0) break; else j += rc;\n      }\n\n#ifdef DEBUG_TLS\n      printf(\"[JA3] Server: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_server);\n#endif\n    } else if(handshake_type == 0x01 /* Client Hello */) {\n      u_int16_t cipher_len, cipher_offset;\n      u_int8_t cookie_len = 0;\n\n      flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.client.tls_handshake_version = tls_version;\n      if(flow->protos.tls_quic_stun.tls_quic.ssl_version < 0x0302) /* TLSv1.1 */\n\tndpi_set_risk(flow, NDPI_TLS_OBSOLETE_VERSION);\n\n      if((session_id_len+base_offset+3) > packet->payload_packet_len)\n\treturn(0); /* Not found */\n\n      if(!is_dtls) {\n\tcipher_len = packet->payload[session_id_len+base_offset+2] + (packet->payload[session_id_len+base_offset+1] << 8);\n\tcipher_offset = base_offset + session_id_len + 3;\n      } else {\n\tcookie_len = packet->payload[base_offset+session_id_len+1];\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Client: DTLS cookie len %d\\n\", cookie_len);\n#endif\n\tif((session_id_len+base_offset+cookie_len+4) > packet->payload_packet_len)\n\t  return(0); /* Not found */\n\tcipher_len = ntohs(*((u_int16_t*)&packet->payload[base_offset+session_id_len+cookie_len+2]));\n\tcipher_offset = base_offset + session_id_len + cookie_len + 4;\n      }\n\n#ifdef DEBUG_TLS\n      printf(\"Client TLS [client cipher_len: %u][tls_version: 0x%04X]\\n\", cipher_len, tls_version);\n#endif\n\n      if((cipher_offset+cipher_len) <= total_len) {\n\tu_int8_t safari_ciphers = 0, chrome_ciphers = 0;\n\n\tfor(i=0; i<cipher_len;) {\n\t  u_int16_t *id = (u_int16_t*)&packet->payload[cipher_offset+i];\n\n#ifdef DEBUG_TLS\n\t  printf(\"Client TLS [cipher suite: %u/0x%04X] [%d/%u]\\n\", ntohs(*id), ntohs(*id), i, cipher_len);\n#endif\n\t  if((*id == 0) || (packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1])) {\n\t    u_int16_t cipher_id = ntohs(*id);\n\t    /*\n\t      Skip GREASE [https://tools.ietf.org/id/draft-ietf-tls-grease-01.html]\n\t      https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967\n\t    */\n\n\t    if(ja3.client.num_cipher < MAX_NUM_JA3)\n\t      ja3.client.cipher[ja3.client.num_cipher++] = cipher_id;\n\t    else {\n\t      invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS Invalid cipher %u\\n\", ja3.client.num_cipher);\n#endif\n\t    }\n\n\t    switch(cipher_id) {\n\t    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:\n\t      safari_ciphers++;\n\t      break;\n\n\t    case TLS_CIPHER_GREASE_RESERVED_0:\n\t    case TLS_AES_128_GCM_SHA256:\n\t    case TLS_AES_256_GCM_SHA384:\n\t    case TLS_CHACHA20_POLY1305_SHA256:\n\t      chrome_ciphers++;\n\t      break;\n\n\t    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:\n\t    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:\n\t    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_128_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_256_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_RSA_WITH_AES_256_GCM_SHA384:\n\t      safari_ciphers++, chrome_ciphers++;\n\t      break;\n\t    }\n\t  }\n\n\t  i += 2;\n\t} /* for */\n\n\tif(chrome_ciphers == 13)\n\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 1;\n\telse if(safari_ciphers == 12)\n\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 1;\n      } else {\n\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\tprintf(\"Client TLS Invalid len %u vs %u\\n\", (cipher_offset+cipher_len), total_len);\n#endif\n      }\n\n      offset = base_offset + session_id_len + cookie_len + cipher_len + 2;\n      offset += (!is_dtls) ? 1 : 2;\n\n      if(offset < total_len) {\n\tu_int16_t compression_len;\n\tu_int16_t extensions_len;\n\n\tcompression_len = packet->payload[offset];\n\toffset++;\n\n#ifdef DEBUG_TLS\n\tprintf(\"Client TLS [compression_len: %u]\\n\", compression_len);\n#endif\n\n\t// offset += compression_len + 3;\n\toffset += compression_len;\n\n\tif(offset+1 < total_len) {\n\t  extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n\t  offset += 2;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Client TLS [extensions_len: %u]\\n\", extensions_len);\n#endif\n\n\t  if((extensions_len+offset) <= total_len) {\n\t    /* Move to the first extension\n\t       Type is u_int to avoid possible overflow on extension_len addition */\n\t    u_int extension_offset = 0;\n\t    u_int32_t j;\n\n\t    while(extension_offset < extensions_len &&\n\t\t  offset+extension_offset+4 <= total_len) {\n\t      u_int16_t extension_id, extension_len, extn_off = offset+extension_offset;\n\n\n\t      extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n\t      extension_offset += 2;\n\n\t      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n\t      extension_offset += 2;\n\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS [extension_id: %u][extension_len: %u]\\n\", extension_id, extension_len);\n#endif\n\n\t      if((extension_id == 0) || (packet->payload[extn_off] != packet->payload[extn_off+1])) {\n\t\t/* Skip GREASE */\n\n\t\tif(ja3.client.num_tls_extension < MAX_NUM_JA3)\n\t\t  ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;\n\t\telse {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid extensions %u\\n\", ja3.client.num_tls_extension);\n#endif\n\t\t}\n\t      }\n\n\t      if(extension_id == 0 /* server name */) {\n\t\tu_int16_t len;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"[TLS] Extensions: found server name\\n\");\n#endif\n\t\tif((offset+extension_offset+4) < packet->payload_packet_len) {\n\n\t\t  len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];\n\t\t  len = (u_int)ndpi_min(len, sizeof(buffer)-1);\n\n\t\t  if((offset+extension_offset+5+len) <= packet->payload_packet_len) {\n\t\t    strncpy(buffer, (char*)&packet->payload[offset+extension_offset+5], len);\n\t\t    buffer[len] = '\\0';\n\n\t\t    cleanupServerName(buffer, sizeof(buffer));\n\n\t\t    snprintf(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,\n\t\t\t     sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),\n\t\t\t     \"%s\", buffer);\n#ifdef DEBUG_TLS\n\t\t    printf(\"[TLS] SNI: [%s]\\n\", buffer);\n#endif\n\t\t    if(!is_quic) {\n\t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, buffer, strlen(buffer)))\n\t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n\t\t    } else {\n\t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, buffer, strlen(buffer)))\n\t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n\t\t    }\n\n\t\t    if(ndpi_check_dga_name(ndpi_struct, flow,\n\t\t\t\t\t   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, 1)) {\n\t\t      char *sni = flow->protos.tls_quic_stun.tls_quic.client_requested_server_name;\n\t\t      int len = strlen(sni);\n\n#ifdef DEBUG_TLS\n\t\t      printf(\"[TLS] SNI: (DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n#endif\n\n\t\t      if((len >= 4)\n\t\t         /* Check if it ends in .com or .net */\n\t\t         && ((strcmp(&sni[len-4], \".com\") == 0) || (strcmp(&sni[len-4], \".net\") == 0))\n\t\t         && (strncmp(sni, \"www.\", 4) == 0)) /* Not starting with www.... */\n\t\t        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS);\n\t\t    } else {\n#ifdef DEBUG_TLS\n\t\t      printf(\"[TLS] SNI: (NO DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n#endif\n\t\t    }\n\t\t  } else {\n#ifdef DEBUG_TLS\n\t\t    printf(\"[TLS] Extensions server len too short: %u vs %u\\n\",\n\t\t\t   offset+extension_offset+5+len,\n\t\t\t   packet->payload_packet_len);\n#endif\n\t\t  }\n\t\t}\n\t      } else if(extension_id == 10 /* supported groups */) {\n\t\tu_int16_t s_offset = offset+extension_offset + 2;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [EllipticCurveGroups: len=%u]\\n\", extension_len);\n#endif\n\n\t\tif((s_offset+extension_len-2) <= total_len) {\n\t\t  for(i=0; i<extension_len-2;) {\n\t\t    u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [EllipticCurve: %u/0x%04X]\\n\", s_group, s_group);\n#endif\n\t\t    if((s_group == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {\n\t\t      /* Skip GREASE */\n\t\t      if(ja3.client.num_elliptic_curve < MAX_NUM_JA3)\n\t\t\tja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;\n\t\t      else {\n\t\t\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t\tprintf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve);\n#endif\n\t\t      }\n\t\t    }\n\n\t\t    i += 2;\n\t\t  }\n\t\t} else {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", (s_offset+extension_len-1), total_len);\n#endif\n\t\t}\n\t      } else if(extension_id == 11 /* ec_point_formats groups */) {\n\t\tu_int16_t s_offset = offset+extension_offset + 1;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n#endif\n\t\tif((s_offset+extension_len-1) <= total_len) {\n\t\t  for(i=0; i<extension_len-1; i++) {\n\t\t    u_int8_t s_group = packet->payload[s_offset+i];\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [EllipticCurveFormat: %u]\\n\", s_group);\n#endif\n\n\t\t    if(ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)\n\t\t      ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;\n\t\t    else {\n\t\t      invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t      printf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve_point_format);\n#endif\n\t\t    }\n\t\t  }\n\t\t} else {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n#endif\n\t\t}\n\t      } else if(extension_id == 13 /* signature algorithms */) {\n\t\tu_int16_t s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0;\n\t\tu_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\\n\", extension_len, tot_signature_algorithms_len);\n#endif\n\n\t\ts_offset += 2;\n\t\ttot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);\n\n#ifdef TLS_HANDLE_SIGNATURE_ALGORITMS\n\t\tflow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);\n\n\t\tmemcpy(flow->protos.tls_quic_stun.tls_quic.client_signature_algorithms,\n\t\t       &packet->payload[s_offset], 2 /* 16 bit */*flow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms);\n#endif\n\n\t\tfor(i=0; i<tot_signature_algorithms_len; i++) {\n\t\t  int rc = snprintf(&ja3.client.signature_algorithms[i*2], sizeof(ja3.client.signature_algorithms)-i*2, \"%02X\", packet->payload[s_offset+i]);\n\n\t\t  if(rc < 0) break;\n\t\t}\n\n\t\tfor(i=0; i<tot_signature_algorithms_len; i+=2) {\n\t\t  u_int16_t cipher_id = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n\n\t\t  // printf(\"=>> %04X\\n\", cipher_id);\n\n\t\t  switch(cipher_id) {\n\t\t  case ECDSA_SECP521R1_SHA512:\n\t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls = 1;\n\t\t    break;\n\n\t\t  case ECDSA_SECP256R1_SHA256:\n\t\t  case ECDSA_SECP384R1_SHA384:\n\t\t  case RSA_PKCS1_SHA256:\n\t\t  case RSA_PKCS1_SHA384:\n\t\t  case RSA_PKCS1_SHA512:\n\t\t  case RSA_PSS_RSAE_SHA256:\n\t\t  case RSA_PSS_RSAE_SHA384:\n\t\t  case RSA_PSS_RSAE_SHA512:\n\t\t    chrome_signature_algorithms++, safari_signature_algorithms++;\n\t\t    break;\n\t\t  }\n\t\t}\n\n\t\tif(flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls)\n\t\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0,\n\t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n\n\t\tif(safari_signature_algorithms != 8)\n\t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0;\n\n\t\tif(chrome_signature_algorithms != 8)\n\t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n\n\t\tja3.client.signature_algorithms[i*2] = '\\0';\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: %s]\\n\", ja3.client.signature_algorithms);\n#endif\n\t      } else if(extension_id == 16 /* application_layer_protocol_negotiation */) {\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tu_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\tchar alpn_str[256];\n\t\tu_int8_t alpn_str_len = 0, i;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n#endif\n\t\ts_offset += 2;\n\t\ttot_alpn_len += s_offset;\n\n\t\twhile(s_offset < tot_alpn_len && s_offset < total_len) {\n\t\t  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n\n\t\t  if((s_offset + alpn_len) <= tot_alpn_len &&\n\t\t     (s_offset + alpn_len) <= total_len) {\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [ALPN: %u]\\n\", alpn_len);\n#endif\n\n\t\t    if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n\t\t      if(alpn_str_len > 0) {\n\t\t\talpn_str[alpn_str_len] = ',';\n\t\t\talpn_str_len++;\n\t\t      }\n\n\t\t      for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n\t\t\talpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n\n\t\t      s_offset += alpn_len, alpn_str_len += alpn_len;;\n\t\t    } else\n\t\t      break;\n\t\t  } else\n\t\t    break;\n\t\t} /* while */\n\n\t\talpn_str[alpn_str_len] = '\\0';\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n#endif\n\t\tif(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n\t\t  flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n\n\t\tsnprintf(ja3.client.alpn, sizeof(ja3.client.alpn), \"%s\", alpn_str);\n\n\t\t/* Replace , with - as in JA3 */\n\t\tfor(i=0; ja3.client.alpn[i] != '\\0'; i++)\n\t\t  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';\n\n\t      } else if(extension_id == 43 /* supported versions */) {\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tu_int8_t version_len = packet->payload[s_offset];\n\t\tchar version_str[256];\n\t\tu_int8_t version_str_len = 0;\n\t\tversion_str[0] = 0;\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [TLS version len: %u]\\n\", version_len);\n#endif\n\n\t\tif(version_len == (extension_len-1)) {\n\t\t  u_int8_t j;\n\t\t  u_int16_t supported_versions_offset = 0;\n\n\t\t  s_offset++;\n\n\t\t  // careful not to overflow and loop forever with u_int8_t\n\t\t  for(j=0; j+1<version_len; j += 2) {\n\t\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));\n\t\t    u_int8_t unknown_tls_version;\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [TLS version: %s/0x%04X]\\n\",\n\t\t\t   ndpi_ssl_version2str(flow, tls_version, &unknown_tls_version), tls_version);\n#endif\n\n\t\t    if((version_str_len+8) < sizeof(version_str)) {\n\t\t      int rc = snprintf(&version_str[version_str_len],\n\t\t\t\t\tsizeof(version_str) - version_str_len, \"%s%s\",\n\t\t\t\t\t(version_str_len > 0) ? \",\" : \"\",\n\t\t\t\t\tndpi_ssl_version2str(flow, tls_version, &unknown_tls_version));\n\t\t      if(rc <= 0)\n\t\t\tbreak;\n\t\t      else\n\t\t\tversion_str_len += rc;\n\n\t\t      rc = snprintf(&ja3.client.supported_versions[supported_versions_offset],\n\t\t\t\t    sizeof(ja3.client.supported_versions)-supported_versions_offset,\n\t\t\t\t    \"%s%04X\", (j > 0) ? \"-\" : \"\", tls_version);\n\n\t\t      if(rc > 0)\n\t\t\tsupported_versions_offset += rc;\n\t\t    }\n\t\t  }\n\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS [SUPPORTED_VERSIONS: %s]\\n\", ja3.client.supported_versions);\n#endif\n\n\t\t  if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions == NULL)\n\t\t    flow->protos.tls_quic_stun.tls_quic.tls_supported_versions = ndpi_strdup(version_str);\n\t\t}\n\t      } else if(extension_id == 65486 /* encrypted server name */) {\n\t\t/*\n\t\t   - https://tools.ietf.org/html/draft-ietf-tls-esni-06\n\t\t   - https://blog.cloudflare.com/encrypted-sni/\n\t\t*/\n\t\tu_int16_t e_offset = offset+extension_offset;\n\t\tu_int16_t initial_offset = e_offset;\n\t\tu_int16_t e_sni_len, cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n\n\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.cipher_suite = cipher_suite;\n\n\t\te_offset += 2; /* Cipher suite len */\n\n\t\t/* Key Share Entry */\n\t\te_offset += 2; /* Group */\n\t\te_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */\n\n\t\tif((e_offset+4) < packet->payload_packet_len) {\n\t\t  /* Record Digest */\n\t\t  e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */\n\n\t\t  if((e_offset+4) < packet->payload_packet_len) {\n\t\t    e_sni_len = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n\t\t    e_offset += 2;\n\n\t\t    if((e_offset+e_sni_len-extension_len-initial_offset) >= 0 &&\n\t\t        e_offset+e_sni_len < packet->payload_packet_len) {\n#ifdef DEBUG_ENCRYPTED_SNI\n\t\t      printf(\"Client TLS [Encrypted Server Name len: %u]\\n\", e_sni_len);\n#endif\n\n\t\t      if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) {\n\t\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni = (char*)ndpi_malloc(e_sni_len*2+1);\n\n\t\t\tif(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni) {\n\t\t\t  u_int16_t i, off;\n\n\t\t\t  for(i=e_offset, off=0; i<(e_offset+e_sni_len); i++) {\n\t\t\t    int rc = sprintf(&flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off], \"%02X\", packet->payload[i] & 0XFF);\n\n\t\t\t    if(rc <= 0) {\n\t\t\t      flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off] = '\\0';\n\t\t\t      break;\n\t\t\t    } else\n\t\t\t      off += rc;\n\t\t\t  }\n\t\t\t}\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t      } else if(extension_id == 65445 || /* QUIC transport parameters (drafts version) */\n\t\t        extension_id == 57) { /* QUIC transport parameters (final version) */\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tuint16_t final_offset;\n\t\tint using_var_int = is_version_with_var_int_transport_params(quic_version);\n\n\t\tif(!using_var_int) {\n\t\t  if(s_offset+1 >= total_len) {\n\t\t    final_offset = 0; /* Force skipping extension */\n\t\t  } else {\n\t\t    u_int16_t seq_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\t    s_offset += 2;\n\t            final_offset = MIN(total_len, s_offset + seq_len);\n\t\t  }\n\t\t} else {\n\t          final_offset = MIN(total_len, s_offset + extension_len);\n\t\t}\n\n\t\twhile(s_offset < final_offset) {\n\t\t  u_int64_t param_type, param_len;\n\n                  if(!using_var_int) {\n\t\t    if(s_offset+3 >= final_offset)\n\t\t      break;\n\t\t    param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\t    param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset + 2]));\n\t\t    s_offset += 4;\n\t\t  } else {\n\t\t    if(s_offset >= final_offset ||\n\t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n\t\t      break;\n\t\t    s_offset += quic_len(&packet->payload[s_offset], &param_type);\n\n\t\t    if(s_offset >= final_offset ||\n\t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n\t\t      break;\n\t\t    s_offset += quic_len(&packet->payload[s_offset], &param_len);\n\t\t  }\n\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS [QUIC TP: Param 0x%x Len %d]\\n\", (int)param_type, (int)param_len);\n#endif\n\t\t  if(s_offset+param_len > final_offset)\n\t\t    break;\n\n\t\t  if(param_type==0x3129) {\n#ifdef DEBUG_TLS\n\t\t      printf(\"UA [%.*s]\\n\", (int)param_len, &packet->payload[s_offset]);\n#endif\n\t\t      http_process_user_agent(ndpi_struct, flow,\n\t\t\t\t\t      &packet->payload[s_offset], param_len);\n\t\t      break;\n\t\t  }\n\t\t  s_offset += param_len;\n\t\t}\n\t      }\n\n\t      extension_offset += extension_len; /* Move to the next extension */\n\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS [extension_offset/len: %u/%u]\\n\", extension_offset, extension_len);\n#endif\n\t    } /* while */\n\n\t    if(!invalid_ja3) {\n\t      int rc;\n\n\t    compute_ja3c:\n\t      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), \"%u,\", ja3.client.tls_handshake_version);\n\n\t      for(i=0; i<ja3.client.num_cipher; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.cipher[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      /* ********** */\n\n\t      for(i=0; i<ja3.client.num_tls_extension; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.tls_extension[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      /* ********** */\n\n\t      for(i=0; i<ja3.client.num_elliptic_curve; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      for(i=0; i<ja3.client.num_elliptic_curve_point_format; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve_point_format[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      if(ndpi_struct->enable_ja3_plus) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,\n\t\t\t      \",%s,%s,%s\", ja3.client.signature_algorithms, ja3.client.supported_versions, ja3.client.alpn);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\t      }\n\n#ifdef DEBUG_JA3C\n\t      printf(\"[JA3+] Client: %s \\n\", ja3_str);\n#endif\n\n\t      ndpi_MD5Init(&ctx);\n\t      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n\t      ndpi_MD5Final(md5_hash, &ctx);\n\n\t      for(i=0, j=0; i<16; i++) {\n\t\trc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_client[j],\n\t\t\t      sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_client)-j, \"%02x\",\n\t\t\t      md5_hash[i]);\n\t\tif(rc > 0) j += rc; else break;\n\t      }\n\n#ifdef DEBUG_JA3C\n\t      printf(\"[JA3] Client: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_client);\n#endif\n\n\t      if(ndpi_struct->malicious_ja3_automa.ac_automa != NULL) {\n\t\tu_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_ja3_automa.ac_automa,\n\t\t\t\t\t\t  flow->protos.tls_quic_stun.tls_quic.ja3_client);\n\n\t\tif(rc1 > 0)\n\t\t  ndpi_set_risk(flow, NDPI_MALICIOUS_JA3);\n\t      }\n\t    }\n\n\t    /* Before returning to the caller we need to make a final check */\n\t    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0303) /* >= TLSv1.2 */\n\t       && (flow->protos.tls_quic_stun.tls_quic.alpn == NULL) /* No ALPN */) {\n\t      ndpi_set_risk(flow, NDPI_TLS_NOT_CARRYING_HTTPS);\n\t    }\n\n\t    /* Suspicious Domain Fronting:\n\t       https://github.com/SixGenInc/Noctilucent/blob/master/docs/ */\n\t    if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni &&\n\t       flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {\n\t      ndpi_set_risk(flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE);\n\t    }\n\n\t    /* Add check for missing SNI */\n\t    if((flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == 0)\n\t       && (flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0302) /* TLSv1.1 */\n\t       && (flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) /* No ESNI */\n\t       ) {\n\t      /* This is a bit suspicious */\n\t      ndpi_set_risk(flow, NDPI_TLS_MISSING_SNI);\n\t    }\n\n\t    return(2 /* Client Certificate */);\n\t  } else {\n#ifdef DEBUG_TLS\n\t    printf(\"[TLS] Client: too short [%u vs %u]\\n\",\n\t\t   (extensions_len+offset), total_len);\n#endif\n\t  }\n\t} else if(offset == total_len) {\n\t  /* TLS does not have extensions etc */\n\t  goto compute_ja3c;\n\t}\n      } else {\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Client: invalid length detected\\n\");\n#endif\n      }\n    }\n  }\n\n  return(0); /* Not found */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36082"
    },
    {
        "index": 382,
        "code": "static SDL_Surface* Create_Surface_Shaded(int width, int height, SDL_Color fg, SDL_Color bg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    Uint8 bg_alpha = bg.a;\n\n    /* Create a surface with memory:\n     * - pitch is rounded to alignment\n     * - adress is aligned\n     */\n    void *pixels, *ptr;\n    /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        /* Overflow... */\n        return NULL;\n    }\n\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* address is aligned */\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n\n    /* Let SDL handle the memory allocation */\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n\n    /* Initialize with background to 0 */\n    SDL_memset(pixels, 0, height * pitch);\n\n    /* Underline/Strikethrough color style */\n    *color = NUM_GRAYS - 1;\n\n    /* Support alpha blending */\n    if (fg.a != SDL_ALPHA_OPAQUE || bg.a != SDL_ALPHA_OPAQUE) {\n        SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n\n        /* Would disturb alpha palette */\n        if (bg.a == SDL_ALPHA_OPAQUE) {\n            bg.a = 0;\n        }\n    }\n\n    /* Fill the palette with NUM_GRAYS levels of shading from bg to fg */\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        int rdiff  = fg.r - bg.r;\n        int gdiff  = fg.g - bg.g;\n        int bdiff  = fg.b - bg.b;\n        int adiff  = fg.a - bg.a;\n        int sign_r = (rdiff >= 0) ? 1 : 255;\n        int sign_g = (gdiff >= 0) ? 1 : 255;\n        int sign_b = (bdiff >= 0) ? 1 : 255;\n        int sign_a = (adiff >= 0) ? 1 : 255;\n        int i;\n\n        for (i = 0; i < NUM_GRAYS; ++i) {\n            /* Compute color[i] = (i * color_diff / 255) */\n            int tmp_r = i * rdiff;\n            int tmp_g = i * gdiff;\n            int tmp_b = i * bdiff;\n            int tmp_a = i * adiff;\n            palette->colors[i].r = (Uint8)(bg.r + DIVIDE_BY_255_SIGNED(tmp_r, sign_r));\n            palette->colors[i].g = (Uint8)(bg.g + DIVIDE_BY_255_SIGNED(tmp_g, sign_g));\n            palette->colors[i].b = (Uint8)(bg.b + DIVIDE_BY_255_SIGNED(tmp_b, sign_b));\n            palette->colors[i].a = (Uint8)(bg.a + DIVIDE_BY_255_SIGNED(tmp_a, sign_a));\n        }\n\n        /* Make sure background has the correct alpha value */\n        palette->colors[0].a = bg_alpha;\n    }\n\n    return textbuf;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27470"
    },
    {
        "index": 383,
        "code": "MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute value beginning */\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            /* now go forward */\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1907"
    },
    {
        "index": 384,
        "code": "  explicit QuantizedResizeBilinearOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"align_corners\", &align_corners_));\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"half_pixel_centers\", &half_pixel_centers_));\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29537"
    },
    {
        "index": 385,
        "code": "bool logToUSDT(const Array& bt) {\n  std::lock_guard<std::mutex> lock(usdt_mutex);\n\n  memset(&bt_slab, 0, sizeof(bt_slab));\n\n  int i = 0;\n  IterateVNoInc(\n    bt.get(),\n    [&](TypedValue tv) -> bool {\n\n      if (i >= strobelight::kMaxStackframes) {\n        return true;\n      }\n\n      assertx(isArrayLikeType(type(tv)));\n      ArrayData* bt_frame = val(tv).parr;\n      strobelight::backtrace_frame_t* frame = &bt_slab.frames[i];\n\n      auto const line = bt_frame->get(s_line.get());\n      if (line.is_init()) {\n        assertx(isIntType(type(line)));\n        frame->line = val(line).num;\n      }\n\n      auto const file_name = bt_frame->get(s_file.get());\n      if (file_name.is_init()) {\n        assertx(isStringType(type(file_name)));\n        strncpy(frame->file_name,\n                val(file_name).pstr->data(),\n                std::min(val(file_name).pstr->size(), strobelight::kFileNameMax));\n        frame->file_name[strobelight::kFileNameMax - 1] = '\\0';\n      }\n\n      auto const class_name = bt_frame->get(s_class.get());\n      if (class_name.is_init()) {\n        assertx(isStringType(type(class_name)));\n        strncpy(frame->class_name,\n                val(class_name).pstr->data(),\n                std::min(val(class_name).pstr->size(), strobelight::kClassNameMax));\n        frame->class_name[strobelight::kClassNameMax - 1] = '\\0';\n      }\n\n      auto const function_name = bt_frame->get(s_function.get());\n      if (function_name.is_init()) {\n        assertx(isStringType(type(function_name)));\n        strncpy(frame->function,\n                val(function_name).pstr->data(),\n                std::min(val(function_name).pstr->size(),\n                         strobelight::kFunctionMax));\n        frame->function[strobelight::kFunctionMax - 1] = '\\0';\n      }\n\n      i++;\n      return false;\n    }\n  );\n  bt_slab.len = i;\n\n  // Allow BPF to read the now-formatted stacktrace\n  FOLLY_SDT_WITH_SEMAPHORE(hhvm, hhvm_stack, &bt_slab);\n\n  return true;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 386,
        "code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1276"
    },
    {
        "index": 387,
        "code": "MOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    uint32_t *infl_groups = NULL;\n    size_t infl_count = mobi_get_indxentry_tagarray(&infl_groups, orth_entry, INDX_TAGARR_ORTH_INFL);\n    \n    if (infl_count == 0 || !infl_groups) {\n        return MOBI_SUCCESS;\n    }    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform%s value=\\\"%s\\\"/>\";\n    char name_attr[INDX_INFLBUF_SIZEMAX + 1];\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (infl->cncx_record == NULL) {\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    for (size_t i = 0; i < infl_count; i++) {\n        size_t offset = infl_groups[i];\n        if (offset >= infl->entries_count) {\n            debug_print(\"%s\\n\", \"Invalid entry offset\");\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t *groups;\n        size_t group_cnt = mobi_get_indxentry_tagarray(&groups, &infl->entries[offset], INDX_TAGARR_INFL_GROUPS);\n        uint32_t *parts;\n        size_t part_cnt = mobi_get_indxentry_tagarray(&parts, &infl->entries[offset], INDX_TAGARR_INFL_PARTS_V2);\n        if (group_cnt != part_cnt) {\n            return MOBI_DATA_CORRUPT;\n        }\n        for (size_t j = 0; j < part_cnt; j++) {\n            name_attr[0] = '\\0';\n            char *group_name = mobi_get_cncx_string(infl->cncx_record, groups[j]);\n            if (group_name == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (strlen(group_name)) {\n                snprintf(name_attr, INDX_INFLBUF_SIZEMAX, \" name=\\\"%s\\\"\", group_name);\n            }\n            free(group_name);\n            \n            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];\n            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);\n            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;\n            memcpy(decoded, label, label_length);\n            int decoded_length = (int) label_length;\n            MOBI_RET ret = mobi_decode_infl(decoded, &decoded_length, rule);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            if (decoded_length == 0) {\n                continue;\n            }\n            int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, name_attr, decoded);\n            if (n > INDX_INFLBUF_SIZEMAX) {\n                debug_print(\"Skipping truncated tag: %s\\n\", infl_tag);\n                continue;\n            }\n            outlen += strlen(infl_tag);\n            if (outlen > INDX_INFLTAG_SIZEMAX) {\n                debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n                return MOBI_ERROR;\n            }\n            strcat(outstring, infl_tag);\n        }\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1534"
    },
    {
        "index": 388,
        "code": "irc_nick_set_mode (struct t_irc_server *server, struct t_irc_channel *channel,\n                   struct t_irc_nick *nick, int set, char mode)\n{\n    int index;\n    const char *prefix_chars;\n\n    index = irc_server_get_prefix_mode_index (server, mode);\n    if (index < 0)\n        return;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* set flag */\n    prefix_chars = irc_server_get_prefix_chars (server);\n    irc_nick_set_prefix (server, nick, set, prefix_chars[index]);\n\n    /* add nick in nicklist */\n    irc_nick_nicklist_add (server, channel, nick);\n\n    if (irc_server_strcasecmp (server, nick->name, server->nick) == 0)\n    {\n        weechat_bar_item_update (\"input_prompt\");\n        weechat_bar_item_update (\"irc_nick\");\n        weechat_bar_item_update (\"irc_nick_host\");\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-9760"
    },
    {
        "index": 389,
        "code": "nv_diffgetput(int put, long count)\n{\n    exarg_T\tea;\n    char_u\tbuf[30];\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf))\n    {\n\tvim_beep(BO_OPER);\n\treturn;\n    }\n#endif\n    if (count == 0)\n\tea.arg = (char_u *)\"\";\n    else\n    {\n\tvim_snprintf((char *)buf, 30, \"%ld\", count);\n\tea.arg = buf;\n    }\n    if (put)\n\tea.cmdidx = CMD_diffput;\n    else\n\tea.cmdidx = CMD_diffget;\n    ea.addr_count = 0;\n    ea.line1 = curwin->w_cursor.lnum;\n    ea.line2 = curwin->w_cursor.lnum;\n    ex_diffgetput(&ea);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2289"
    },
    {
        "index": 390,
        "code": "static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tif (!sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\tsdump->indent++;\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"<node>\");\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</node>\");\n\t\t\t\t\t\tsdump->indent--;\n\t\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (field.far_ptr) {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tif (field.far_ptr)\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t} else if (field.far_ptr) {\n\t\t\t\t\tgf_dump_vrml_simple_field(sdump, field, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else if (field.far_ptr) {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" [\");\n\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\twhile (l) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, l->node, 1, NULL);\n\t\t\t\t\t\tl = l->next;\n\t\t\t\t\t}\n\t\t\t\t\tsdump->indent--;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2549"
    },
    {
        "index": 391,
        "code": "static INLINE BOOL RLEDECOMPRESS(const BYTE* pbSrcBuffer, UINT32 cbSrcBuffer, BYTE* pbDestBuffer,\n                                 UINT32 rowDelta, UINT32 width, UINT32 height)\n{\n\tconst BYTE* pbSrc = pbSrcBuffer;\n\tconst BYTE* pbEnd;\n\tconst BYTE* pbDestEnd;\n\tBYTE* pbDest = pbDestBuffer;\n\tPIXEL temp;\n\tPIXEL fgPel = WHITE_PIXEL;\n\tBOOL fInsertFgPel = FALSE;\n\tBOOL fFirstLine = TRUE;\n\tBYTE bitmask;\n\tPIXEL pixelA, pixelB;\n\tUINT32 runLength;\n\tUINT32 code;\n\tUINT32 advance;\n\tRLEEXTRA\n\n\tif ((rowDelta == 0) || (rowDelta < width))\n\t\treturn FALSE;\n\n\tif (!pbSrcBuffer || !pbDestBuffer)\n\t\treturn FALSE;\n\n\tpbEnd = pbSrcBuffer + cbSrcBuffer;\n\tpbDestEnd = pbDestBuffer + rowDelta * height;\n\n\twhile (pbSrc < pbEnd)\n\t{\n\t\t/* Watch out for the end of the first scanline. */\n\t\tif (fFirstLine)\n\t\t{\n\t\t\tif ((UINT32)(pbDest - pbDestBuffer) >= rowDelta)\n\t\t\t{\n\t\t\t\tfFirstLine = FALSE;\n\t\t\t\tfInsertFgPel = FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t   Extract the compression order code ID from the compression\n\t\t   order header.\n\t\t*/\n\t\tcode = ExtractCodeId(*pbSrc);\n\n\t\t/* Handle Background Run Orders. */\n\t\tif (code == REGULAR_BG_RUN || code == MEGA_MEGA_BG_RUN)\n\t\t{\n\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\tif (fFirstLine)\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength = runLength - 1;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength--;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* A follow-on background run order will need a foreground pel inserted. */\n\t\t\tfInsertFgPel = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* For any of the other run-types a follow-on background run\n\t\t    order does not need a foreground pel inserted. */\n\t\tfInsertFgPel = FALSE;\n\n\t\tswitch (code)\n\t\t{\n\t\t\t/* Handle Foreground Run Orders. */\n\t\t\tcase REGULAR_FG_RUN:\n\t\t\tcase MEGA_MEGA_FG_RUN:\n\t\t\tcase LITE_SET_FG_FG_RUN:\n\t\t\tcase MEGA_MEGA_SET_FG_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Dithered Run Orders. */\n\t\t\tcase LITE_DITHERED_RUN:\n\t\t\tcase MEGA_MEGA_DITHERED_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\tSRCREADPIXEL(pixelB, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength * 2))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelB);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Color Run Orders. */\n\t\t\tcase REGULAR_COLOR_RUN:\n\t\t\tcase MEGA_MEGA_COLOR_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Foreground/Background Image Orders. */\n\t\t\tcase REGULAR_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_FGBG_IMAGE:\n\t\t\tcase LITE_SET_FG_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_SET_FGBG_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (runLength > 0)\n\t\t\t\t{\n\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\t\tif (fFirstLine)\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Color Image Orders. */\n\t\t\tcase REGULAR_COLOR_IMAGE:\n\t\t\tcase MEGA_MEGA_COLOR_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tSRCREADPIXEL(temp, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Special Order 1. */\n\t\t\tcase SPECIAL_FGBG_1:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Special Order 2. */\n\t\t\tcase SPECIAL_FGBG_2:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\t/* Handle White Order. */\n\t\t\tcase SPECIAL_WHITE:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, WHITE_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\t/* Handle Black Order. */\n\t\t\tcase SPECIAL_BLACK:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-4033"
    },
    {
        "index": 392,
        "code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  // Scale up our output bit depth to the nearest factor of 8\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n\n  process( res, layers, x, y, w, h, rawtile.data );\n\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n\n  return rawtile;\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 393,
        "code": "void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,\n                                       char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n                                       uint8_t ind) {\n\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    uint32_t enc_len;\n    int status;\n\n    CHECK_STATE(encrypted_skey);\n    CHECK_STATE(result_str);\n    CHECK_STATE(s_shareG2);\n    CHECK_STATE(pub_keyB);\n\n    LOG_DEBUG(__FUNCTION__);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);\n\n    trustedGenerateEcdsaKeyAES(&status, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);\n\n    CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");\n\n    status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    skey[ECDSA_SKEY_LEN - 1] = 0;\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedGetEncryptedSecretShareAES) with status %d\");\n\n    *dec_len = enc_len;\n\n    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n    status = gen_session_key(skey, pub_keyB, common_key);\n\n    CHECK_STATUS(\"gen_session_key failed\")\n\n    SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);\n\n    status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);\n    CHECK_STATUS(\"calc secret share failed\")\n\n\n    status = calc_secret_shareG2(s_share, s_shareG2);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);\n    status=xor_encrypt(common_key, s_share, cypher);\n\n    CHECK_STATUS(\"xor_encrypt failed\")\n\n    strncpy(result_str, cypher, strlen(cypher));\n    strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));\n    strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 394,
        "code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-37706"
    },
    {
        "index": 395,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45934"
    },
    {
        "index": 396,
        "code": "static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\n\tif (vps_id >= 16) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \"base_layer_internal_flag\");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \"base_layer_available_flag\");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers_minus1\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \"temporal_id_nesting\");\n\tgf_bs_read_int_log(bs, 16, \"vps_reserved_ffff_16bits\");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"vps_sub_layer_ordering_info_present_flag\");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_dec_pic_buffering_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_num_reorder_pics\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_latency_increase_plus1\", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \"max_layer_id\");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \"num_layer_sets_minus1\") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"layer_id_included_flag\", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"vps_timing_info_present_flag\")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \"vps_num_units_in_tick\");\n\t\tgf_bs_read_int_log(bs, 32, \"vps_time_scale\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_poc_proportional_to_timing_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"vps_num_ticks_poc_diff_one_minus1\");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \"vps_num_hrd_parameters\");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \"hrd_layer_set_idx\", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \"cprms_present_flag\");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \"vps_extension_flag\");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_extension2_flag\")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 397,
        "code": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch (IHDR)\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch (BPCC)\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tif (!dec->image->cmprof_) {\n\t\t\tjas_iccprof_destroy(iccprof);\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tif (!pclrd->numlutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tif (!lutents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#else\n\t\t\t\t/* suppress -Wunused-but-set-variable */\n\t\t\t\t(void)cdefd;\n#endif\n\t\t\t} else {\n\t\t\t\tjas_eprintf(\"error: invalid MTYP in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Ensure that the number of channels being used by the decoder\n\t  matches the number of image components. */\n\tif (dec->numchans != jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: mismatch in number of components (%d != %d)\\n\",\n\t\t  dec->numchans, jas_image_numcmpts(dec->image));\n\t\tgoto error;\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-26926"
    },
    {
        "index": 398,
        "code": "void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,\n                            uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,\n                            uint32_t *enc_bls_key_len) {\n\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(s_shares);\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(encr_bls_key);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t sum;\n    mpz_init(sum);\n    mpz_set_ui(sum, 0);\n\n    mpz_t q;\n    mpz_init(q);\n    mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);\n\n    mpz_t bls_key;\n    mpz_init(bls_key);\n\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);\n    CHECK_STATUS2(\"aes decrypt failed with status %d\");\n\n    skey[ECDSA_SKEY_LEN - 1] = 0;\n\n    int num_shares = strlen(s_shares) / 192;\n\n    for (int i = 0; i < num_shares; i++) { SAFE_CHAR_BUF(encr_sshare, 65);\n        strncpy(encr_sshare, s_shares + 192 * i, 64);\n        encr_sshare[64] = 0;\n\n        SAFE_CHAR_BUF(s_share, 193);\n        strncpy(s_share, s_shares + 192 * i, 192);\n        s_share[192] = 0;\n\n        SAFE_CHAR_BUF(common_key, 65);\n\n        status = session_key_recover(skey, s_share, common_key);\n\n        CHECK_STATUS(\"session_key_recover failed\");\n\n        common_key[64] = 0;\n\n        SAFE_CHAR_BUF(decr_sshare, 65);\n\n        status = xor_decrypt(common_key, encr_sshare, decr_sshare);\n        CHECK_STATUS(\"xor_decrypt failed\");\n\n        decr_sshare[64] = 0;\n\n        mpz_t decr_secret_share;\n        mpz_init(decr_secret_share);\n        if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {\n            *errStatus = 111;\n            snprintf(errString, BUF_LEN, \"invalid decrypted secret share\");\n            LOG_ERROR(errString);\n\n            mpz_clear(decr_secret_share);\n            goto clean;\n        }\n\n        mpz_addmul_ui(sum, decr_secret_share, 1);\n        mpz_clear(decr_secret_share);\n    }\n\n\n    mpz_mod(bls_key, sum, q);\n\n    SAFE_CHAR_BUF(key_share, BLS_KEY_LENGTH);\n\n    SAFE_CHAR_BUF(arr_skey_str, BUF_LEN);\n\n    mpz_get_str(arr_skey_str, 16, bls_key);\n    int n_zeroes = 64 - strlen(arr_skey_str);\n    for (int i = 0; i < n_zeroes; i++) {\n        key_share[i] = '0';\n    }\n    strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);\n    key_share[BLS_KEY_LENGTH - 1] = 0;\n\n    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);\n\n    CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");\n\n    *enc_bls_key_len = strlen(key_share) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(bls_key);\n    mpz_clear(sum);\n    mpz_clear(q);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 399,
        "code": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t}\n\telse {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-40568"
    },
    {
        "index": 400,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 401,
        "code": "static Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0)\n        Jsi_ObjSetLength(interp, obj, 0);\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n            \n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 402,
        "code": "int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\n\t/* this is non-NULL only with TCP/UDP Encapsulation */\n\tif (x->encap) {\n\t\tint err = esp_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27666"
    },
    {
        "index": 403,
        "code": "static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1587"
    },
    {
        "index": 404,
        "code": "  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    // TODO(zongheng): we will call Reorder() below, which will modify\n    // in-place the underlying indices and values buffers.  To avoid\n    // surprises of this kernel being stateful, we work around the above by\n    // making deep copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\n    // Compute strides, and use it to convert coords to flat index.  The\n    // coordinates returned by .group() have the same ndims as group_by_dims.\n    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n      output_strides.back() = 1;\n      for (int d = output_strides.size() - 2; d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                                     ArraySlice<int64> strides) -> int64 {\n      if (strides.empty()) {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(), strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size(); ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n    // g.group() provides the coordinates of a particular reduced value.\n    sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37635"
    },
    {
        "index": 405,
        "code": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXME: this needs the console lock extending */\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\n\t/* explicitly blank/unblank the screen if switching modes */\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3753"
    },
    {
        "index": 406,
        "code": "set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> guard(globalMutex);\n\n  string pipePath = endpoint.name();\n  if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {\n    throw runtime_error(\"Tried to listen twice on the same path\");\n  }\n\n  sockaddr_un local;\n\n  int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(fd);\n  initServerSocket(fd);\n  local.sun_family = AF_UNIX; /* local is declared before socket() ^ */\n  strcpy(local.sun_path, pipePath.c_str());\n  unlink(local.sun_path);\n\n  FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));\n  ::listen(fd, 5);\n#ifndef WIN32\n  FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));\n#endif\n\n  pipeServerSockets[pipePath] = set<int>({fd});\n  return pipeServerSockets[pipePath];\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 407,
        "code": "static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1052"
    },
    {
        "index": 408,
        "code": "static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segments_enabled_flag\");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \"num_extra_slice_header_bits\");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \"sign_data_hiding_flag\");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"cabac_init_present_flag\");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active\");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active\");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \"pic_init_qp_minus26\");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \"constrained_intra_pred_flag\");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"transform_skip_enabled_flag\");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"cu_qp_delta_enabled_flag\")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \"diff_cu_qp_delta_depth\");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \"pic_cb_qp_offset\");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \"pic_cr_qp_offset\");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"slice_chroma_qp_offsets_present_flag\");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"weighted_bipred_flag\");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \"transquant_bypass_enable_flag\");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"tiles_enabled_flag\");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_tile_columns_minus1\");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_tile_rows_minus1\");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_spacing_flag\");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \"column_width_minus1\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \"row_height_minus1\", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_tiles_enabled_flag\");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_slices_enabled_flag\");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\"))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_enabled_flag\");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \"pic_disable_deblocking_filter_flag\"))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \"beta_offset_div2\");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \"tc_offset_div2\");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"pic_scaling_list_data_present_flag\"))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \"lists_modification_present_flag\");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \"log2_parallel_merge_level_minus2\");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"slice_segment_header_extension_present_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 409,
        "code": "temac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct temac_local *lp = netdev_priv(ndev);\n\tstruct cdmac_bd *cur_p;\n\tdma_addr_t tail_p, skb_dma_addr;\n\tint ii;\n\tunsigned long num_frag;\n\tskb_frag_t *frag;\n\n\tnum_frag = skb_shinfo(skb)->nr_frags;\n\tfrag = &skb_shinfo(skb)->frags[0];\n\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\n\tif (temac_check_tx_bd_space(lp, num_frag + 1)) {\n\t\tif (netif_queue_stopped(ndev))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_stop_queue(ndev);\n\n\t\t/* Matches barrier in temac_start_xmit_done */\n\t\tsmp_mb();\n\n\t\t/* Space might have just been freed - check again */\n\t\tif (temac_check_tx_bd_space(lp, num_frag))\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_wake_queue(ndev);\n\t}\n\n\tcur_p->app0 = 0;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tunsigned int csum_start_off = skb_checksum_start_offset(skb);\n\t\tunsigned int csum_index_off = csum_start_off + skb->csum_offset;\n\n\t\tcur_p->app0 |= cpu_to_be32(0x000001); /* TX Checksum Enabled */\n\t\tcur_p->app1 = cpu_to_be32((csum_start_off << 16)\n\t\t\t\t\t  | csum_index_off);\n\t\tcur_p->app2 = 0;  /* initial checksum seed */\n\t}\n\n\tcur_p->app0 |= cpu_to_be32(STS_CTRL_APP0_SOP);\n\tskb_dma_addr = dma_map_single(ndev->dev.parent, skb->data,\n\t\t\t\t      skb_headlen(skb), DMA_TO_DEVICE);\n\tcur_p->len = cpu_to_be32(skb_headlen(skb));\n\tif (WARN_ON_ONCE(dma_mapping_error(ndev->dev.parent, skb_dma_addr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tndev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tcur_p->phys = cpu_to_be32(skb_dma_addr);\n\n\tfor (ii = 0; ii < num_frag; ii++) {\n\t\tif (++lp->tx_bd_tail >= lp->tx_bd_num)\n\t\t\tlp->tx_bd_tail = 0;\n\n\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\tskb_dma_addr = dma_map_single(ndev->dev.parent,\n\t\t\t\t\t      skb_frag_address(frag),\n\t\t\t\t\t      skb_frag_size(frag),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ndev->dev.parent, skb_dma_addr)) {\n\t\t\tif (--lp->tx_bd_tail < 0)\n\t\t\t\tlp->tx_bd_tail = lp->tx_bd_num - 1;\n\t\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\t\twhile (--ii >= 0) {\n\t\t\t\t--frag;\n\t\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t\t be32_to_cpu(cur_p->phys),\n\t\t\t\t\t\t skb_frag_size(frag),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tif (--lp->tx_bd_tail < 0)\n\t\t\t\t\tlp->tx_bd_tail = lp->tx_bd_num - 1;\n\t\t\t\tcur_p = &lp->tx_bd_v[lp->tx_bd_tail];\n\t\t\t}\n\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t be32_to_cpu(cur_p->phys),\n\t\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tndev->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tcur_p->phys = cpu_to_be32(skb_dma_addr);\n\t\tcur_p->len = cpu_to_be32(skb_frag_size(frag));\n\t\tcur_p->app0 = 0;\n\t\tfrag++;\n\t}\n\tcur_p->app0 |= cpu_to_be32(STS_CTRL_APP0_EOP);\n\n\t/* Mark last fragment with skb address, so it can be consumed\n\t * in temac_start_xmit_done()\n\t */\n\tptr_to_txbd((void *)skb, cur_p);\n\n\ttail_p = lp->tx_bd_p + sizeof(*lp->tx_bd_v) * lp->tx_bd_tail;\n\tlp->tx_bd_tail++;\n\tif (lp->tx_bd_tail >= lp->tx_bd_num)\n\t\tlp->tx_bd_tail = 0;\n\n\tskb_tx_timestamp(skb);\n\n\t/* Kick off the transfer */\n\twmb();\n\tlp->dma_out(lp, TX_TAILDESC_PTR, tail_p); /* DMA start */\n\n\treturn NETDEV_TX_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-38207"
    },
    {
        "index": 410,
        "code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we don't know what's a URN yet\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32137"
    },
    {
        "index": 411,
        "code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0676"
    },
    {
        "index": 412,
        "code": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2345"
    },
    {
        "index": 413,
        "code": "process_options(argc, argv)\nint argc;\nchar *argv[];\n{\n    int i, l;\n\n    /*\n     * Process options.\n     */\n    while (argc > 1 && argv[1][0] == '-') {\n        argv++;\n        argc--;\n        l = (int) strlen(*argv);\n        /* must supply at least 4 chars to match \"-XXXgraphics\" */\n        if (l < 4)\n            l = 4;\n\n        switch (argv[0][1]) {\n        case 'D':\n        case 'd':\n            if ((argv[0][1] == 'D' && !argv[0][2])\n                || !strcmpi(*argv, \"-debug\")) {\n                wizard = TRUE, discover = FALSE;\n            } else if (!strncmpi(*argv, \"-DECgraphics\", l)) {\n                load_symset(\"DECGraphics\", PRIMARY);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %s\", *argv);\n            }\n            break;\n        case 'X':\n\n            discover = TRUE, wizard = FALSE;\n            break;\n#ifdef NEWS\n        case 'n':\n            iflags.news = FALSE;\n            break;\n#endif\n        case 'u':\n            if (argv[0][2]) {\n                (void) strncpy(plname, argv[0] + 2, sizeof plname - 1);\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                (void) strncpy(plname, argv[0], sizeof plname - 1);\n            } else {\n                raw_print(\"Player name expected after -u\");\n            }\n            break;\n        case 'I':\n        case 'i':\n            if (!strncmpi(*argv, \"-IBMgraphics\", l)) {\n                load_symset(\"IBMGraphics\", PRIMARY);\n                load_symset(\"RogueIBM\", ROGUESET);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %s\", *argv);\n            }\n            break;\n        case 'p': /* profession (role) */\n            if (argv[0][2]) {\n                if ((i = str2role(&argv[0][2])) >= 0)\n                    flags.initrole = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2role(argv[0])) >= 0)\n                    flags.initrole = i;\n            }\n            break;\n        case 'r': /* race */\n            if (argv[0][2]) {\n                if ((i = str2race(&argv[0][2])) >= 0)\n                    flags.initrace = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2race(argv[0])) >= 0)\n                    flags.initrace = i;\n            }\n            break;\n        case 'w': /* windowtype */\n            config_error_init(FALSE, \"command line\", FALSE);\n            choose_windows(&argv[0][2]);\n            config_error_done();\n            break;\n        case '@':\n            flags.randomall = 1;\n            break;\n        default:\n            if ((i = str2role(&argv[0][1])) >= 0) {\n                flags.initrole = i;\n                break;\n            }\n            /* else raw_printf(\"Unknown option: %s\", *argv); */\n        }\n    }\n\n#ifdef SYSCF\n    if (argc > 1)\n        raw_printf(\"MAXPLAYERS are set in sysconf file.\\n\");\n#else\n    /* XXX This is deprecated in favor of SYSCF with MAXPLAYERS */\n    if (argc > 1)\n        locknum = atoi(argv[1]);\n#endif\n#ifdef MAX_NR_OF_PLAYERS\n    /* limit to compile-time limit */\n    if (!locknum || locknum > MAX_NR_OF_PLAYERS)\n        locknum = MAX_NR_OF_PLAYERS;\n#endif\n#ifdef SYSCF\n    /* let syscf override compile-time limit */\n    if (!locknum || (sysopt.maxplayers && locknum > sysopt.maxplayers))\n        locknum = sysopt.maxplayers;\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5210"
    },
    {
        "index": 414,
        "code": "static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\n\tif (vps_id >= 16) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \"base_layer_internal_flag\");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \"base_layer_available_flag\");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers_minus1\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \"temporal_id_nesting\");\n\tgf_bs_read_int_log(bs, 16, \"vps_reserved_ffff_16bits\");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \"vps_sub_layer_ordering_info_present_flag\");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_dec_pic_buffering_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_num_reorder_pics\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"vps_max_latency_increase_plus1\", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \"max_layer_id\");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \"num_layer_sets_minus1\") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"layer_id_included_flag\", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"vps_timing_info_present_flag\")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \"vps_num_units_in_tick\");\n\t\tgf_bs_read_int_log(bs, 32, \"vps_time_scale\");\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_poc_proportional_to_timing_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"vps_num_ticks_poc_diff_one_minus1\");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \"vps_num_hrd_parameters\");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \"hrd_layer_set_idx\", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \"cprms_present_flag\");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \"vps_extension_flag\");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \"vps_extension2_flag\")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 415,
        "code": "int main(int    argc,\n         char **argv)\n{\nl_int32       w, h;\nPIX          *pixs, *pixg, *pixim, *pixgm, *pixmi, *pix1, *pix2;\nPIX          *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\nPIXA         *pixa;\nL_REGPARAMS  *rp;\n\n    if (regTestSetup(argc, argv, &rp))\n        return 1;\n\n    lept_mkdir(\"lept/adapt\");  // REMOVE?\n\n    pixs = pixRead(\"wet-day.jpg\");\n    pixa = pixaCreate(0);\n    pixg = pixConvertRGBToGray(pixs, 0.33, 0.34, 0.33);\n    pixaAddPix(pixa, pixs, L_INSERT);\n    pixaAddPix(pixa, pixg, L_INSERT);\n    pixGetDimensions(pixs, &w, &h, NULL);\n\n        /* Process in grayscale */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundGrayMap(pixg, pixim, SIZE_X, SIZE_Y,\n                            BINTHRESH, MINCOUNT, &pixgm);\n    fprintf(stderr, \"Time for gray adaptmap gen: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixgm, IFF_PNG);  /* 0 */\n    pixaAddPix(pixa, pixgm, L_INSERT);\n\n    startTimer();\n    pixmi = pixGetInvBackgroundMap(pixgm, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for gray inv map generation: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmi, IFF_PNG);  /* 1 */\n    pixaAddPix(pixa, pixmi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundGrayMap(pixg, pixmi, SIZE_X, SIZE_Y);\n    fprintf(stderr, \"Time to apply gray inv map: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 2 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 3 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Process in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundRGBMap(pixs, pixim, NULL, SIZE_X, SIZE_Y,\n                           BINTHRESH, MINCOUNT,\n                           &pixmr, &pixmg, &pixmb);\n    fprintf(stderr, \"Time for color adaptmap gen: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmr, IFF_PNG);  /* 4 */\n    regTestWritePixAndCheck(rp, pixmg, IFF_PNG);  /* 5 */\n    regTestWritePixAndCheck(rp, pixmb, IFF_PNG);  /* 6 */\n    pixaAddPix(pixa, pixmr, L_INSERT);\n    pixaAddPix(pixa, pixmg, L_INSERT);\n    pixaAddPix(pixa, pixmb, L_INSERT);\n\n    startTimer();\n    pixmri = pixGetInvBackgroundMap(pixmr, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmgi = pixGetInvBackgroundMap(pixmg, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmbi = pixGetInvBackgroundMap(pixmb, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for color inv map generation: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmri, IFF_PNG);  /* 7 */\n    regTestWritePixAndCheck(rp, pixmgi, IFF_PNG);  /* 8 */\n    regTestWritePixAndCheck(rp, pixmbi, IFF_PNG);  /* 9 */\n    pixaAddPix(pixa, pixmri, L_INSERT);\n    pixaAddPix(pixa, pixmgi, L_INSERT);\n    pixaAddPix(pixa, pixmbi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                       SIZE_X, SIZE_Y);\n    fprintf(stderr, \"Time to apply color inv maps: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 10 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 11 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Process at higher level in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pix1 = pixBackgroundNorm(pixs, pixim, NULL, 5, 10, BINTHRESH, 20,\n                             BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for bg normalization: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 12 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 13 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Display results */\n    pix1 = pixaDisplayTiledAndScaled(pixa, 32, 400, 4, 0, 20, 2);\n    pixWrite(\"/tmp/lept/adapt/results.jpg\", pix1, IFF_JFIF_JPEG);\n    pixDisplayWithTitle(pix1, 100, 0, NULL, rp->display);\n    pixDestroy(&pix1);\n    pixaDestroy(&pixa);\n\n    return regTestCleanup(rp);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36279"
    },
    {
        "index": 416,
        "code": "void fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\t\t\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29368"
    },
    {
        "index": 417,
        "code": "static pyc_object *get_small_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut8 n = 0;\n\n\tn = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_SMALL_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0523"
    },
    {
        "index": 418,
        "code": "R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {\n\tut64 size = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *se;\n\tif (sf) {\n\t\t// sf->tag = buffer[offset];\n\t\tsize += 1;\n\t\tswitch (sf->type) {\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t\t// Nothing to read\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// sf->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->local_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\t// sf->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown type\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 419,
        "code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2061"
    },
    {
        "index": 420,
        "code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1620"
    },
    {
        "index": 421,
        "code": "TypedValue HHVM_FUNCTION(substr_compare,\n                         const String& main_str,\n                         const String& str,\n                         int offset,\n                         int length /* = INT_MAX */,\n                         bool case_insensitivity /* = false */) {\n  int s1_len = main_str.size();\n  int s2_len = str.size();\n\n  if (length <= 0) {\n    raise_warning(\"The length must be greater than zero\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (offset < 0) {\n    offset = s1_len + offset;\n    if (offset < 0) offset = 0;\n  }\n\n  if (offset >= s1_len) {\n    raise_warning(\"The start position cannot exceed initial string length\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  int cmp_len = s1_len - offset;\n  if (cmp_len < s2_len) cmp_len = s2_len;\n  if (cmp_len > length) cmp_len = length;\n\n  const char *s1 = main_str.data();\n  if (case_insensitivity) {\n    return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len));\n  }\n  return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len));\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 422,
        "code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    return qftf_list;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2982"
    },
    {
        "index": 423,
        "code": "static bool php_openssl_validate_iv(\n    String piv,\n    int iv_required_len,\n    String& out,\n    EVP_CIPHER_CTX* cipher_ctx,\n    const php_openssl_cipher_mode* mode) {\n  if (cipher_ctx == nullptr || mode == nullptr) {\n    return false;\n  }\n\n  /* Best case scenario, user behaved */\n  if (piv.size() == iv_required_len) {\n    out = std::move(piv);\n    return true;\n  }\n\n  if (mode->is_aead) {\n    if (EVP_CIPHER_CTX_ctrl(\n            cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) {\n      raise_warning(\n          \"Setting of IV length for AEAD mode failed, the expected length is \"\n          \"%d bytes\",\n          iv_required_len);\n      return false;\n    }\n    out = std::move(piv);\n    return true;\n  }\n\n  String s = String(iv_required_len, ReserveString);\n  char* iv_new = s.mutableData();\n  memset(iv_new, 0, iv_required_len);\n\n  if (piv.size() <= 0) {\n    /* BC behavior */\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  if (piv.size() < iv_required_len) {\n    raise_warning(\"IV passed is only %d bytes long, cipher \"\n                  \"expects an IV of precisely %d bytes, padding with \\\\0\",\n                  piv.size(), iv_required_len);\n    memcpy(iv_new, piv.data(), piv.size());\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  raise_warning(\"IV passed is %d bytes long which is longer than the %d \"\n                \"expected by selected cipher, truncating\", piv.size(),\n                iv_required_len);\n  memcpy(iv_new, piv.data(), iv_required_len);\n  s.setSize(iv_required_len);\n  out = std::move(s);\n  return true;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 424,
        "code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-30292"
    },
    {
        "index": 425,
        "code": "shared_ptr <vector<uint8_t>> check_and_set_SEK(const string &SEK) {\n\n    vector<char> decr_key(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n    int err_status = 0;\n\n    auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);\n\n    uint32_t l = 0;\n\n    sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,\n                                               SEK.c_str());\n\n    encrypted_SEK->resize(l);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n    validate_SEK();\n\n    return encrypted_SEK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 426,
        "code": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-44109"
    },
    {
        "index": 427,
        "code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\n\treturn alloc_vring_queue(dev, vring_idx);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3839"
    },
    {
        "index": 428,
        "code": "void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,\n                                  int level, int prev_idx, int* src_data_ptr,\n                                  T* dest_data) {\n  if (level == indices.size()) {\n    int orig_rank = dense_shape_.size();\n    std::vector<int> orig_idx;\n    orig_idx.resize(orig_rank);\n    int i = 0;\n    for (; i < orig_idx.size(); i++) {\n      int orig_dim = traversal_order_[i];\n      orig_idx[orig_dim] = indices[i];\n    }\n\n    for (; i < indices.size(); i++) {\n      const int block_idx = traversal_order_[i] - orig_rank;\n      const int orig_dim = block_map_[block_idx];\n      orig_idx[orig_dim] =\n          orig_idx[orig_dim] * block_size_[block_idx] + indices[i];\n    }\n\n    dest_data[GetFlattenedIndex(orig_idx, dense_shape_)] =\n        src_data[*src_data_ptr];\n\n    *src_data_ptr = *src_data_ptr + 1;\n    return;\n  }\n\n  const int metadata_idx = 2 * level;\n  const int shape_of_level = dim_metadata_[metadata_idx][0];\n  if (format_[level] == kTfLiteDimDense) {\n    for (int i = 0; i < shape_of_level; i++) {\n      indices[level] = i;\n      Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,\n               src_data_ptr, dest_data);\n    }\n  } else {\n    const auto& array_segments = dim_metadata_[metadata_idx];\n    const auto& array_indices = dim_metadata_[metadata_idx + 1];\n    for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];\n         i++) {\n      indices[level] = array_indices[i];\n      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23560"
    },
    {
        "index": 429,
        "code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\t// Set cbc_block to the initialization vector, and if\n\t\t// not zero, write it to the output stream.\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                // Initialize vector with zeroes; zero vector was not\n                // written to the beginning of the input file.\n                initializeVector();\n            }\n            else\n\t    {\n\t\t// Take the first block of input as the initialization\n\t\t// vector.  There's nothing to write at this time.\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36978"
    },
    {
        "index": 430,
        "code": "size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    /* FIXME: this function could be replaced by mobi_find_attrvalue()? */\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    /* FIXME: search may start inside tag, so it is a safer option */\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            /* found match */\n            size_t offset = size - length;\n            if (last_border == '>') {\n                /* We are in tag contents */\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            /* previous character should be white space or opening tag */\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            /* now go forward */\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            /* return offset to the beginning of the attribute value string */\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1907"
    },
    {
        "index": 431,
        "code": "static MagickRealType ApplyEvaluateOperator(RandomInfo *random_info,\n  const Quantum pixel,const MagickEvaluateOperator op,\n  const MagickRealType value)\n{\n  MagickRealType\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(MagickRealType) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a\n        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale*\n        pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        ImpulseNoise,value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(MagickRealType) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(MagickRealType) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 :\n        QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange :\n        pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-27764"
    },
    {
        "index": 432,
        "code": "_dwarf_internal_get_pubnames_like_data(Dwarf_Debug dbg,\n    const char *secname,\n    Dwarf_Small * section_data_ptr,\n    Dwarf_Unsigned section_length,\n    Dwarf_Global ** globals,\n    Dwarf_Signed * return_count,\n    Dwarf_Error * error,\n    int context_DLA_code,\n    int global_DLA_code,\n    int length_err_num,\n    int version_err_num)\n{\n    Dwarf_Small *pubnames_like_ptr = 0;\n    Dwarf_Off pubnames_section_offset = 0;\n    Dwarf_Small *section_end_ptr = section_data_ptr +section_length;\n\n    /*  Points to the context for the current set of global names, and\n        contains information to identify the compilation-unit that the\n        set refers to. */\n    Dwarf_Global_Context pubnames_context = 0;\n    Dwarf_Bool           pubnames_context_on_list = FALSE;\n\n    Dwarf_Unsigned version = 0;\n\n    /*  Offset from the start of compilation-unit for the current\n        global. */\n    Dwarf_Off die_offset_in_cu = 0;\n\n    Dwarf_Unsigned global_count = 0;\n\n    /*  Used to chain the Dwarf_Global_s structs for\n        creating contiguous list of pointers to the structs. */\n    Dwarf_Chain head_chain = 0;\n    Dwarf_Chain *plast_chain = &head_chain;\n\n    /* Points to contiguous block of Dwarf_Global to be returned. */\n    Dwarf_Global *ret_globals = 0;\n    int mres = 0;\n\n    /* Temporary counter. */\n    Dwarf_Unsigned i = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling for pubnames-like data Dwarf_Debug \"\n            \"either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    /* We will eventually need the .debug_info data. Load it now. */\n    if (!dbg->de_debug_info.dss_data) {\n        int res = _dwarf_load_debug_info(dbg, error);\n\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    if (section_data_ptr == NULL) {\n        return DW_DLV_NO_ENTRY;\n    }\n    pubnames_like_ptr = section_data_ptr;\n    do {\n        Dwarf_Unsigned length = 0;\n        int local_extension_size = 0;\n        int local_length_size = 0;\n\n        /*  Some compilers emit padding at the end of each cu's area.\n            pubnames_ptr_past_end_cu records the true area end for the\n            pubnames(like) content of a cu.\n            Essentially the length in the header and the 0\n            terminator of the data are redundant information. The\n            dwarf2/3 spec does not mention what to do if the length is\n            past the 0 terminator. So we take any bytes left\n            after the 0 as padding and ignore them. */\n        Dwarf_Small *pubnames_ptr_past_end_cu = 0;\n\n        pubnames_context_on_list = FALSE;\n        pubnames_context = (Dwarf_Global_Context)\n            _dwarf_get_alloc(dbg, context_DLA_code, 1);\n        if (pubnames_context == NULL) {\n            dealloc_globals_chain(dbg,head_chain);\n            _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n            return DW_DLV_ERROR;\n        }\n        /*  ========pubnames_context not recorded anywhere yet. */\n        /*  READ_AREA_LENGTH updates pubnames_like_ptr for consumed\n            bytes. */\n        if ((pubnames_like_ptr + DWARF_32BIT_SIZE +\n            DWARF_HALF_SIZE + DWARF_32BIT_SIZE) >\n            /* A minimum size needed */\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                DWARF_32BIT_SIZE + DWARF_HALF_SIZE + DWARF_32BIT_SIZE,\n                secname,\n                \"header-record\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_area_length_ck_wrapper(dbg,\n            &length,&pubnames_like_ptr,&local_length_size,\n            &local_extension_size,section_length,section_end_ptr,\n            error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_context->pu_alloc_type = context_DLA_code;\n        pubnames_context->pu_length_size = local_length_size;\n        pubnames_context->pu_length = length;\n        pubnames_context->pu_extension_size = local_extension_size;\n        pubnames_context->pu_dbg = dbg;\n        pubnames_context->pu_pub_offset = pubnames_section_offset;\n        pubnames_ptr_past_end_cu = pubnames_like_ptr + length;\n        pubnames_context->pu_pub_entries_end_ptr =\n            pubnames_ptr_past_end_cu;\n\n        if ((pubnames_like_ptr + (DWARF_HALF_SIZE) ) >\n            /* A minimum size needed */\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                DWARF_HALF_SIZE,\n                secname,\"version-number\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &version,pubnames_like_ptr,DWARF_HALF_SIZE,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_context->pu_version = version;\n        pubnames_like_ptr += DWARF_HALF_SIZE;\n        /* ASSERT: DW_PUBNAMES_VERSION2 == DW_PUBTYPES_VERSION2 */\n        if (version != DW_PUBNAMES_VERSION2) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, version_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* Offset of CU header in debug section. */\n        if ((pubnames_like_ptr + 3*pubnames_context->pu_length_size)>\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                3*pubnames_context->pu_length_size,\n                secname,\n                \"header/DIE offsets\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &pubnames_context->pu_offset_of_cu_header,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n\n        FIX_UP_OFFSET_IRIX_BUG(dbg,\n            pubnames_context->pu_offset_of_cu_header,\n            \"pubnames cu header offset\");\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &pubnames_context->pu_info_length,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n\n        if (pubnames_like_ptr > (section_data_ptr + section_length)) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, length_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* ====begin pubname  */\n        /*  Read initial offset (of DIE within CU) of a pubname, final\n            entry is not a pair, just a zero offset. */\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &die_offset_in_cu,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            pubnames_context->pu_pub_entries_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n        FIX_UP_OFFSET_IRIX_BUG(dbg,\n            die_offset_in_cu, \"offset of die in cu\");\n        if (pubnames_like_ptr > (section_data_ptr + section_length)) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, length_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* Loop thru pairs. DIE off with CU followed by string. */\n        if (!die_offset_in_cu) {\n            if (dbg->de_return_empty_pubnames) {\n                int res = 0;\n\n                /*  Here we have a pubnames CU with no actual\n                    entries so we fake up an entry to hold the\n                    header data.  There are no 'pairs' here,\n                    just the end of list zero value.  We do this\n                    only if de_return_empty_pubnames is set\n                    so that we by default return exactly the same\n                    data this always returned, yet dwarfdump can\n                    request the empty-cu records get created\n                    to test that feature.\n                    see dwarf_get_globals_header()  */\n                res = _dwarf_make_global_add_to_chain(dbg,\n                    global_DLA_code,\n                    pubnames_context,\n                    die_offset_in_cu,\n                    /*  It is a fake global, so empty name */\n                    (unsigned char *)\"\",\n                    &global_count,\n                    &pubnames_context_on_list,\n                    &plast_chain,\n                    error);\n                if (res != DW_DLV_OK) {\n                    dealloc_globals_chain(dbg,head_chain);\n                    if (!pubnames_context_on_list) {\n                        dwarf_dealloc(dbg,pubnames_context,\n                            context_DLA_code);\n                    }\n                    return res;\n                }\n                /*  ========pubnames_context recorded in chain. */\n            } else {\n                /*  The section is empty.\n                    Nowhere to record pubnames_context); */\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n                pubnames_context = 0;\n                continue;\n            }\n        }\n        while (die_offset_in_cu) {\n            int res = 0;\n            unsigned char *glname = 0;\n\n            /*  non-zero die_offset_in_cu already read, so\n                pubnames_like_ptr points to a string.  */\n            res = _dwarf_check_string_valid(dbg,section_data_ptr,\n                pubnames_like_ptr,\n                pubnames_context->pu_pub_entries_end_ptr,\n                DW_DLE_STRING_OFF_END_PUBNAMES_LIKE,error);\n            if (res != DW_DLV_OK) {\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return res;\n            }\n            glname = (unsigned char *)pubnames_like_ptr;\n            pubnames_like_ptr = pubnames_like_ptr +\n                strlen((char *) pubnames_like_ptr) + 1;\n            /*  Already read offset and verified string, glname\n                now points to the string. */\n            res = _dwarf_make_global_add_to_chain(dbg,\n                global_DLA_code,\n                pubnames_context,\n                die_offset_in_cu,\n                glname,\n                &global_count,\n                &pubnames_context_on_list,\n                &plast_chain,\n                error);\n            if (res != DW_DLV_OK) {\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return res;\n            }\n            /*  ========pubnames_context recorded in chain. */\n            /*  Ensure room for a next entry  to exist. */\n            if ((pubnames_like_ptr +\n                pubnames_context->pu_length_size ) >\n                section_end_ptr) {\n                pubnames_error_length(dbg,error,\n                    2*pubnames_context->pu_length_size,\n                    secname,\n                    \"global record offset\");\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return DW_DLV_ERROR;\n            }\n            /* Read die offset for the *next* entry */\n            mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n                &die_offset_in_cu,\n                pubnames_like_ptr,\n                pubnames_context->pu_length_size,\n                pubnames_context->pu_pub_entries_end_ptr,\n                error);\n            if (mres != DW_DLV_OK) {\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                dealloc_globals_chain(dbg,head_chain);\n                return mres;\n            }\n            pubnames_like_ptr += pubnames_context->pu_length_size;\n            FIX_UP_OFFSET_IRIX_BUG(dbg,\n                die_offset_in_cu, \"offset of next die in cu\");\n            if (pubnames_like_ptr >\n                (section_data_ptr + section_length)) {\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                dealloc_globals_chain(dbg,head_chain);\n                _dwarf_error(dbg, error, length_err_num);\n                return DW_DLV_ERROR;\n            }\n        }\n        /* ASSERT: die_offset_in_cu == 0 */\n        if (pubnames_like_ptr > pubnames_ptr_past_end_cu) {\n            /* This is some kind of error. This simply cannot happen.\n            The encoding is wrong or the length in the header for\n            this cu's contribution is wrong. */\n            _dwarf_error(dbg, error, length_err_num);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            dealloc_globals_chain(dbg,head_chain);\n            return DW_DLV_ERROR;\n        }\n        /*  If there is some kind of padding at the end of\n            the section,\n            as emitted by some compilers, skip over that padding and\n            simply ignore the bytes thus passed-over.  With most\n            compilers, pubnames_like_ptr ==\n            pubnames_ptr_past_end_cu at this point */\n        {\n            Dwarf_Unsigned increment =\n                pubnames_context->pu_length_size +\n                pubnames_context->pu_length +\n                pubnames_context->pu_extension_size;\n            pubnames_section_offset += increment;\n        }\n        pubnames_like_ptr = pubnames_ptr_past_end_cu;\n    } while (pubnames_like_ptr < section_end_ptr);\n\n    /* Points to contiguous block of Dwarf_Global. */\n    ret_globals = (Dwarf_Global *)\n        _dwarf_get_alloc(dbg, DW_DLA_LIST, global_count);\n    if (ret_globals == NULL) {\n        if (!pubnames_context_on_list) {\n            dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n        }\n        dealloc_globals_chain(dbg,head_chain);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    /*  Store pointers to Dwarf_Global_s structs in contiguous block,\n        and deallocate the chain.  This ignores the various\n        headers */\n    {\n        Dwarf_Chain curr_chain = 0;\n        curr_chain = head_chain;\n        for (i = 0; i < global_count; i++) {\n            Dwarf_Chain prev = 0;\n\n            *(ret_globals + i) = curr_chain->ch_item;\n            prev = curr_chain;\n            curr_chain = curr_chain->ch_next;\n            prev->ch_item = 0; /* Not actually necessary. */\n            dwarf_dealloc(dbg, prev, DW_DLA_CHAIN);\n        }\n    }\n    *globals = ret_globals;\n    *return_count = (Dwarf_Signed) global_count;\n    return DW_DLV_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-32200"
    },
    {
        "index": 433,
        "code": "static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tgf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tgf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 434,
        "code": "nv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (text_locked())\n    {\n\tclearopbeep(cap->oap);\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1897"
    },
    {
        "index": 435,
        "code": "process_options(argc, argv)\nint argc;\nchar *argv[];\n{\n    int i, l;\n\n    /*\n     * Process options.\n     */\n    while (argc > 1 && argv[1][0] == '-') {\n        argv++;\n        argc--;\n        l = (int) strlen(*argv);\n        /* must supply at least 4 chars to match \"-XXXgraphics\" */\n        if (l < 4)\n            l = 4;\n\n        switch (argv[0][1]) {\n        case 'D':\n        case 'd':\n            if ((argv[0][1] == 'D' && !argv[0][2])\n                || !strcmpi(*argv, \"-debug\")) {\n                wizard = TRUE, discover = FALSE;\n            } else if (!strncmpi(*argv, \"-DECgraphics\", l)) {\n                load_symset(\"DECGraphics\", PRIMARY);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %s\", *argv);\n            }\n            break;\n        case 'X':\n\n            discover = TRUE, wizard = FALSE;\n            break;\n#ifdef NEWS\n        case 'n':\n            iflags.news = FALSE;\n            break;\n#endif\n        case 'u':\n            if (argv[0][2]) {\n                (void) strncpy(plname, argv[0] + 2, sizeof plname - 1);\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                (void) strncpy(plname, argv[0], sizeof plname - 1);\n            } else {\n                raw_print(\"Player name expected after -u\");\n            }\n            break;\n        case 'I':\n        case 'i':\n            if (!strncmpi(*argv, \"-IBMgraphics\", l)) {\n                load_symset(\"IBMGraphics\", PRIMARY);\n                load_symset(\"RogueIBM\", ROGUESET);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %s\", *argv);\n            }\n            break;\n        case 'p': /* profession (role) */\n            if (argv[0][2]) {\n                if ((i = str2role(&argv[0][2])) >= 0)\n                    flags.initrole = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2role(argv[0])) >= 0)\n                    flags.initrole = i;\n            }\n            break;\n        case 'r': /* race */\n            if (argv[0][2]) {\n                if ((i = str2race(&argv[0][2])) >= 0)\n                    flags.initrace = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2race(argv[0])) >= 0)\n                    flags.initrace = i;\n            }\n            break;\n        case 'w': /* windowtype */\n            config_error_init(FALSE, \"command line\", FALSE);\n            choose_windows(&argv[0][2]);\n            config_error_done();\n            break;\n        case '@':\n            flags.randomall = 1;\n            break;\n        default:\n            if ((i = str2role(&argv[0][1])) >= 0) {\n                flags.initrole = i;\n                break;\n            }\n            /* else raw_printf(\"Unknown option: %s\", *argv); */\n        }\n    }\n\n#ifdef SYSCF\n    if (argc > 1)\n        raw_printf(\"MAXPLAYERS are set in sysconf file.\\n\");\n#else\n    /* XXX This is deprecated in favor of SYSCF with MAXPLAYERS */\n    if (argc > 1)\n        locknum = atoi(argv[1]);\n#endif\n#ifdef MAX_NR_OF_PLAYERS\n    /* limit to compile-time limit */\n    if (!locknum || locknum > MAX_NR_OF_PLAYERS)\n        locknum = MAX_NR_OF_PLAYERS;\n#endif\n#ifdef SYSCF\n    /* let syscf override compile-time limit */\n    if (!locknum || (sysopt.maxplayers && locknum > sysopt.maxplayers))\n        locknum = sysopt.maxplayers;\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5209"
    },
    {
        "index": 436,
        "code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n\n    return nDecryptResult == 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-6018"
    },
    {
        "index": 437,
        "code": "IdKeyPair UserTerminalRouter::acceptNewConnection() {\n  LOG(INFO) << \"Listening to id/key FIFO\";\n  int terminalFd = socketHandler->accept(serverFd);\n  if (terminalFd < 0) {\n    if (GetErrno() != EAGAIN && GetErrno() != EWOULDBLOCK) {\n      FATAL_FAIL(-1);  // STFATAL with the error\n    } else {\n      return IdKeyPair({\"\", \"\"});  // Nothing to accept this time\n    }\n  }\n\n  LOG(INFO) << \"Connected\";\n\n  try {\n    Packet packet;\n    if (!socketHandler->readPacket(terminalFd, &packet)) {\n      STFATAL << \"Missing user info packet\";\n    }\n    if (packet.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) {\n      STFATAL << \"Got an invalid packet header: \" << int(packet.getHeader());\n    }\n    TerminalUserInfo tui = stringToProto<TerminalUserInfo>(packet.getPayload());\n    tui.set_fd(terminalFd);\n    idInfoMap[tui.id()] = tui;\n    return IdKeyPair({tui.id(), tui.passkey()});\n  } catch (const std::runtime_error &re) {\n    STFATAL << \"Router can't talk to terminal: \" << re.what();\n  }\n\n  STFATAL << \"Should never get here\";\n  return IdKeyPair({\"\", \"\"});\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 438,
        "code": "void IOBuf::allocExtBuffer(\n    std::size_t minCapacity,\n    uint8_t** bufReturn,\n    SharedInfo** infoReturn,\n    std::size_t* capacityReturn) {\n  size_t mallocSize = goodExtBufferSize(minCapacity);\n  auto buf = static_cast<uint8_t*>(checkedMalloc(mallocSize));\n  initExtBuffer(buf, mallocSize, infoReturn, capacityReturn);\n\n  // the userData and the freeFn are nullptr here\n  // just store the mallocSize in userData\n  (*infoReturn)->userData = reinterpret_cast<void*>(mallocSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(buf, mallocSize);\n  }\n\n  *bufReturn = buf;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-24036"
    },
    {
        "index": 439,
        "code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\n\treturn alloc_vring_queue(dev, vring_idx);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3839"
    },
    {
        "index": 440,
        "code": "main(argc, argv)\nint argc;\nchar *argv[];\n{\n    register int fd;\n#ifdef CHDIR\n    register char *dir;\n#endif\n    boolean exact_username;\n    boolean resuming = FALSE; /* assume new game */\n    boolean plsel_once = FALSE;\n\n    sys_early_init();\n\n#if defined(__APPLE__)\n    {\n/* special hack to change working directory to a resource fork when\n   running from finder --sam */\n#define MAC_PATH_VALUE \".app/Contents/MacOS/\"\n        char mac_cwd[1024], *mac_exe = argv[0], *mac_tmp;\n        int arg0_len = strlen(mac_exe), mac_tmp_len, mac_lhs_len = 0;\n        getcwd(mac_cwd, 1024);\n        if (mac_exe[0] == '/' && !strcmp(mac_cwd, \"/\")) {\n            if ((mac_exe = strrchr(mac_exe, '/')))\n                mac_exe++;\n            else\n                mac_exe = argv[0];\n            mac_tmp_len = (strlen(mac_exe) * 2) + strlen(MAC_PATH_VALUE);\n            if (mac_tmp_len <= arg0_len) {\n                mac_tmp = malloc(mac_tmp_len + 1);\n                sprintf(mac_tmp, \"%s%s%s\", mac_exe, MAC_PATH_VALUE, mac_exe);\n                if (!strcmp(argv[0] + (arg0_len - mac_tmp_len), mac_tmp)) {\n                    mac_lhs_len =\n                        (arg0_len - mac_tmp_len) + strlen(mac_exe) + 5;\n                    if (mac_lhs_len > mac_tmp_len - 1)\n                        mac_tmp = realloc(mac_tmp, mac_lhs_len);\n                    strncpy(mac_tmp, argv[0], mac_lhs_len);\n                    mac_tmp[mac_lhs_len] = '\\0';\n                    chdir(mac_tmp);\n                }\n                free(mac_tmp);\n            }\n        }\n    }\n#endif\n\n    hname = argv[0];\n    hackpid = getpid();\n    (void) umask(0777 & ~FCMASK);\n\n    choose_windows(DEFAULT_WINDOW_SYS);\n\n#ifdef CHDIR /* otherwise no chdir() */\n    /*\n     * See if we must change directory to the playground.\n     * (Perhaps hack runs suid and playground is inaccessible\n     *  for the player.)\n     * The environment variable HACKDIR is overridden by a\n     *  -d command line option (must be the first option given).\n     */\n    dir = nh_getenv(\"NETHACKDIR\");\n    if (!dir)\n        dir = nh_getenv(\"HACKDIR\");\n\n    if (argc > 1) {\n        if (argcheck(argc, argv, ARG_VERSION) == 2)\n            exit(EXIT_SUCCESS);\n\n        if (argcheck(argc, argv, ARG_SHOWPATHS) == 2) {\n#ifdef CHDIR\n            chdirx((char *) 0, 0);\n#endif\n            iflags.initoptions_noterminate = TRUE;\n            initoptions();\n            iflags.initoptions_noterminate = FALSE;\n            reveal_paths();\n            exit(EXIT_SUCCESS);\n        }\n        if (argcheck(argc, argv, ARG_DEBUG) == 1) {\n            argc--;\n            argv++;\n        }\n        if (argc > 1 && !strncmp(argv[1], \"-d\", 2) && argv[1][2] != 'e') {\n            /* avoid matching \"-dec\" for DECgraphics; since the man page\n             * says -d directory, hope nobody's using -desomething_else\n             */\n            argc--;\n            argv++;\n            dir = argv[0] + 2;\n            if (*dir == '=' || *dir == ':')\n                dir++;\n            if (!*dir && argc > 1) {\n                argc--;\n                argv++;\n                dir = argv[0];\n            }\n            if (!*dir)\n                error(\"Flag -d must be followed by a directory name.\");\n        }\n    }\n#endif /* CHDIR */\n\n    if (argc > 1) {\n        /*\n         * Now we know the directory containing 'record' and\n         * may do a prscore().  Exclude `-style' - it's a Qt option.\n         */\n        if (!strncmp(argv[1], \"-s\", 2) && strncmp(argv[1], \"-style\", 6)) {\n#ifdef CHDIR\n            chdirx(dir, 0);\n#endif\n#ifdef SYSCF\n            initoptions();\n#endif\n#ifdef PANICTRACE\n            ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n            panictrace_setsignals(TRUE);\n#endif\n#endif\n            prscore(argc, argv);\n            /* FIXME: shouldn't this be using nh_terminate() to free\n               up any memory allocated by initoptions() */\n            exit(EXIT_SUCCESS);\n        }\n    } /* argc > 1 */\n\n/*\n * Change directories before we initialize the window system so\n * we can find the tile file.\n */\n#ifdef CHDIR\n    chdirx(dir, 1);\n#endif\n\n#ifdef _M_UNIX\n    check_sco_console();\n#endif\n#ifdef __linux__\n    check_linux_console();\n#endif\n    initoptions();\n#ifdef PANICTRACE\n    ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n    panictrace_setsignals(TRUE);\n#endif\n#endif\n    exact_username = whoami();\n\n    /*\n     * It seems you really want to play.\n     */\n    u.uhp = 1; /* prevent RIP on early quits */\n    program_state.preserve_locks = 1;\n#ifndef NO_SIGNAL\n    sethanguphandler((SIG_RET_TYPE) hangup);\n#endif\n\n    process_options(argc, argv); /* command line options */\n#ifdef WINCHAIN\n    commit_windowchain();\n#endif\n    init_nhwindows(&argc, argv); /* now we can set up window system */\n#ifdef _M_UNIX\n    init_sco_cons();\n#endif\n#ifdef __linux__\n    init_linux_cons();\n#endif\n\n#ifdef DEF_PAGER\n    if (!(catmore = nh_getenv(\"HACKPAGER\"))\n        && !(catmore = nh_getenv(\"PAGER\")))\n        catmore = DEF_PAGER;\n#endif\n#ifdef MAIL\n    getmailstatus();\n#endif\n\n    /* wizard mode access is deferred until here */\n    set_playmode(); /* sets plname to \"wizard\" for wizard mode */\n    if (exact_username) {\n        /*\n         * FIXME: this no longer works, ever since 3.3.0\n         * when plnamesuffix() was changed to find\n         * Name-Role-Race-Gender-Alignment.  It removes\n         * all dashes rather than just the last one,\n         * regardless of whether whatever follows each\n         * dash matches role, race, gender, or alignment.\n         */\n        /* guard against user names with hyphens in them */\n        int len = (int) strlen(plname);\n        /* append the current role, if any, so that last dash is ours */\n        if (++len < (int) sizeof plname)\n            (void) strncat(strcat(plname, \"-\"), pl_character,\n                           sizeof plname - len - 1);\n    }\n    /* strip role,race,&c suffix; calls askname() if plname[] is empty\n       or holds a generic user name like \"player\" or \"games\" */\n    plnamesuffix();\n\n    if (wizard) {\n        /* use character name rather than lock letter for file names */\n        locknum = 0;\n    } else {\n        /* suppress interrupts while processing lock file */\n        (void) signal(SIGQUIT, SIG_IGN);\n        (void) signal(SIGINT, SIG_IGN);\n    }\n\n    dlb_init(); /* must be before newgame() */\n\n    /*\n     * Initialize the vision system.  This must be before mklev() on a\n     * new game or before a level restore on a saved game.\n     */\n    vision_init();\n\n    display_gamewindows();\n\n    /*\n     * First, try to find and restore a save file for specified character.\n     * We'll return here if new game player_selection() renames the hero.\n     */\n attempt_restore:\n\n    /*\n     * getlock() complains and quits if there is already a game\n     * in progress for current character name (when locknum == 0)\n     * or if there are too many active games (when locknum > 0).\n     * When proceeding, it creates an empty <lockname>.0 file to\n     * designate the current game.\n     * getlock() constructs <lockname> based on the character\n     * name (for !locknum) or on first available of alock, block,\n     * clock, &c not currently in use in the playground directory\n     * (for locknum > 0).\n     */\n    if (*plname) {\n        getlock();\n        program_state.preserve_locks = 0; /* after getlock() */\n    }\n\n    if (*plname && (fd = restore_saved_game()) >= 0) {\n        const char *fq_save = fqname(SAVEF, SAVEPREFIX, 1);\n\n        (void) chmod(fq_save, 0); /* disallow parallel restores */\n#ifndef NO_SIGNAL\n        (void) signal(SIGINT, (SIG_RET_TYPE) done1);\n#endif\n#ifdef NEWS\n        if (iflags.news) {\n            display_file(NEWS, FALSE);\n            iflags.news = FALSE; /* in case dorecover() fails */\n        }\n#endif\n        pline(\"Restoring save file...\");\n        mark_synch(); /* flush output */\n        if (dorecover(fd)) {\n            resuming = TRUE; /* not starting new game */\n            wd_message();\n            if (discover || wizard) {\n                /* this seems like a candidate for paranoid_confirmation... */\n                if (yn(\"Do you want to keep the save file?\") == 'n') {\n                    (void) delete_savefile();\n                } else {\n                    (void) chmod(fq_save, FCMASK); /* back to readable */\n                    nh_compress(fq_save);\n                }\n            }\n        }\n    }\n\n    if (!resuming) {\n        boolean neednewlock = (!*plname);\n        /* new game:  start by choosing role, race, etc;\n           player might change the hero's name while doing that,\n           in which case we try to restore under the new name\n           and skip selection this time if that didn't succeed */\n        if (!iflags.renameinprogress || iflags.defer_plname || neednewlock) {\n            if (!plsel_once)\n                player_selection();\n            plsel_once = TRUE;\n            if (neednewlock && *plname)\n                goto attempt_restore;\n            if (iflags.renameinprogress) {\n                /* player has renamed the hero while selecting role;\n                   if locking alphabetically, the existing lock file\n                   can still be used; otherwise, discard current one\n                   and create another for the new character name */\n                if (!locknum) {\n                    delete_levelfile(0); /* remove empty lock file */\n                    getlock();\n                }\n                goto attempt_restore;\n            }\n        }\n        newgame();\n        wd_message();\n    }\n\n    /* moveloop() never returns but isn't flagged NORETURN */\n    moveloop(resuming);\n\n    exit(EXIT_SUCCESS);\n    /*NOTREACHED*/\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5210"
    },
    {
        "index": 441,
        "code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n\n    int width = fixed_length / sizeof(T);\n\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n\n    if (flat_in.size() == 0) {  // Empty input\n      return;\n    }\n\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n\n    // Forcibly clear memory - we're going to copy variable length strings in,\n    // and need to ensure that if we don't write to byte N when we copy, that\n    // we're not getting random data.\n    memset(out_data, 0, fixed_length * flat_in.size());\n\n    // If the data is already in the host's byte order, or if the width of the\n    // output type is a single byte (meaning the ordering doesn't matter), we\n    // can copy the memory directly.\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      // Otherwise, the data is not in the host's byte order, and rather than a\n      // direct copy, we need to reverse the byte ordering of each element.\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29614"
    },
    {
        "index": 442,
        "code": "host_name_lookup(void)\n{\nint old_pool, rc;\nint sep = 0;\nuschar *save_hostname;\nuschar **aliases;\nuschar *ordername;\nconst uschar *list = host_lookup_order;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\n\nsender_host_dnssec = host_lookup_deferred = host_lookup_failed = FALSE;\n\nHDEBUG(D_host_lookup)\n  debug_printf(\"looking up host name for %s\\n\", sender_host_address);\n\n/* For testing the case when a lookup does not complete, we have a special\nreserved IP address. */\n\nif (f.running_in_test_harness &&\n    Ustrcmp(sender_host_address, \"99.99.99.99\") == 0)\n  {\n  HDEBUG(D_host_lookup)\n    debug_printf(\"Test harness: host name lookup returns DEFER\\n\");\n  host_lookup_deferred = TRUE;\n  return DEFER;\n  }\n\n/* Do lookups directly in the DNS or via gethostbyaddr() (or equivalent), in\nthe order specified by the host_lookup_order option. */\n\nwhile ((ordername = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  if (strcmpic(ordername, US\"bydns\") == 0)\n    {\n    uschar * name = dns_build_reverse(sender_host_address);\n\n    dns_init(FALSE, FALSE, FALSE);    /* dnssec ctrl by dns_dnssec_ok glbl */\n    rc = dns_lookup_timerwrap(dnsa, name, T_PTR, NULL);\n\n    /* The first record we come across is used for the name; others are\n    considered to be aliases. We have to scan twice, in order to find out the\n    number of aliases. However, if all the names are empty, we will behave as\n    if failure. (PTR records that yield empty names have been encountered in\n    the DNS.) */\n\n    if (rc == DNS_SUCCEED)\n      {\n      uschar **aptr = NULL;\n      int ssize = 264;\n      int count = 0;\n      int old_pool = store_pool;\n\n      sender_host_dnssec = dns_is_secure(dnsa);\n      DEBUG(D_dns)\n        debug_printf(\"Reverse DNS security status: %s\\n\",\n            sender_host_dnssec ? \"DNSSEC verified (AD)\" : \"unverified\");\n\n      store_pool = POOL_PERM;        /* Save names in permanent storage */\n\n      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n           rr;\n           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)\n\tcount++;\n\n      /* Get store for the list of aliases. For compatibility with\n      gethostbyaddr, we make an empty list if there are none. */\n\n      aptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n\n      /* Re-scan and extract the names */\n\n      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n           rr;\n           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)\n        {\n        uschar * s = store_get(ssize, TRUE);\t/* names are tainted */\n\n        /* If an overlong response was received, the data will have been\n        truncated and dn_expand may fail. */\n\n        if (dn_expand(dnsa->answer, dnsa->answer + dnsa->answerlen,\n             US (rr->data), (DN_EXPAND_ARG4_TYPE)(s), ssize) < 0)\n          {\n          log_write(0, LOG_MAIN, \"host name alias list truncated for %s\",\n            sender_host_address);\n          break;\n          }\n\n        store_release_above(s + Ustrlen(s) + 1);\n        if (!s[0])\n          {\n          HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an \"\n            \"empty name: treated as non-existent host name\\n\");\n          continue;\n          }\n        if (!sender_host_name) sender_host_name = s;\n\telse *aptr++ = s;\n        while (*s) { *s = tolower(*s); s++; }\n        }\n\n      *aptr = NULL;            /* End of alias list */\n      store_pool = old_pool;   /* Reset store pool */\n\n      /* If we've found a name, break out of the \"order\" loop */\n\n      if (sender_host_name) break;\n      }\n\n    /* If the DNS lookup deferred, we must also defer. */\n\n    if (rc == DNS_AGAIN)\n      {\n      HDEBUG(D_host_lookup)\n        debug_printf(\"IP address PTR lookup gave temporary error\\n\");\n      host_lookup_deferred = TRUE;\n      return DEFER;\n      }\n    }\n\n  /* Do a lookup using gethostbyaddr() - or equivalent */\n\n  else if (strcmpic(ordername, US\"byaddr\") == 0)\n    {\n    HDEBUG(D_host_lookup)\n      debug_printf(\"IP address lookup using gethostbyaddr()\\n\");\n    rc = host_name_lookup_byaddr();\n    if (rc == DEFER)\n      {\n      host_lookup_deferred = TRUE;\n      return rc;                       /* Can't carry on */\n      }\n    if (rc == OK) break;               /* Found a name */\n    }\n  }      /* Loop for bydns/byaddr scanning */\n\n/* If we have failed to find a name, return FAIL and log when required.\nNB host_lookup_msg must be in permanent store.  */\n\nif (!sender_host_name)\n  {\n  if (host_checking || !f.log_testing_mode)\n    log_write(L_host_lookup_failed, LOG_MAIN, \"no host name found for IP \"\n      \"address %s\", sender_host_address);\n  host_lookup_msg = US\" (failed to find host name from IP address)\";\n  host_lookup_failed = TRUE;\n  return FAIL;\n  }\n\nHDEBUG(D_host_lookup)\n  {\n  uschar **aliases = sender_host_aliases;\n  debug_printf(\"IP address lookup yielded \\\"%s\\\"\\n\", sender_host_name);\n  while (*aliases != NULL) debug_printf(\"  alias \\\"%s\\\"\\n\", *aliases++);\n  }\n\n/* We need to verify that a forward lookup on the name we found does indeed\ncorrespond to the address. This is for security: in principle a malefactor who\nhappened to own a reverse zone could set it to point to any names at all.\n\nThis code was present in versions of Exim before 3.20. At that point I took it\nout because I thought that gethostbyaddr() did the check anyway. It turns out\nthat this isn't always the case, so it's coming back in at 4.01. This version\nis actually better, because it also checks aliases.\n\nThe code was made more robust at release 4.21. Prior to that, it accepted all\nthe names if any of them had the correct IP address. Now the code checks all\nthe names, and accepts only those that have the correct IP address. */\n\nsave_hostname = sender_host_name;   /* Save for error messages */\naliases = sender_host_aliases;\nfor (uschar * hname = sender_host_name; hname; hname = *aliases++)\n  {\n  int rc;\n  BOOL ok = FALSE;\n  host_item h = { .next = NULL, .name = hname, .mx = MX_NONE, .address = NULL };\n  dnssec_domains d =\n    { .request = sender_host_dnssec ? US\"*\" : NULL, .require = NULL };\n\n  if (  (rc = host_find_bydns(&h, NULL, HOST_FIND_BY_A | HOST_FIND_BY_AAAA,\n\t  NULL, NULL, NULL, &d, NULL, NULL)) == HOST_FOUND\n     || rc == HOST_FOUND_LOCAL\n     )\n    {\n    HDEBUG(D_host_lookup) debug_printf(\"checking addresses for %s\\n\", hname);\n\n    /* If the forward lookup was not secure we cancel the is-secure variable */\n\n    DEBUG(D_dns) debug_printf(\"Forward DNS security status: %s\\n\",\n\t  h.dnssec == DS_YES ? \"DNSSEC verified (AD)\" : \"unverified\");\n    if (h.dnssec != DS_YES) sender_host_dnssec = FALSE;\n\n    for (host_item * hh = &h; hh; hh = hh->next)\n      if (host_is_in_net(hh->address, sender_host_address, 0))\n        {\n        HDEBUG(D_host_lookup) debug_printf(\"  %s OK\\n\", hh->address);\n        ok = TRUE;\n        break;\n        }\n      else\n        HDEBUG(D_host_lookup) debug_printf(\"  %s\\n\", hh->address);\n\n    if (!ok) HDEBUG(D_host_lookup)\n      debug_printf(\"no IP address for %s matched %s\\n\", hname,\n        sender_host_address);\n    }\n  else if (rc == HOST_FIND_AGAIN)\n    {\n    HDEBUG(D_host_lookup) debug_printf(\"temporary error for host name lookup\\n\");\n    host_lookup_deferred = TRUE;\n    sender_host_name = NULL;\n    return DEFER;\n    }\n  else\n    HDEBUG(D_host_lookup) debug_printf(\"no IP addresses found for %s\\n\", hname);\n\n  /* If this name is no good, and it's the sender name, set it null pro tem;\n  if it's an alias, just remove it from the list. */\n\n  if (!ok)\n    {\n    if (hname == sender_host_name) sender_host_name = NULL; else\n      {\n      uschar **a;                              /* Don't amalgamate - some */\n      a = --aliases;                           /* compilers grumble */\n      while (*a != NULL) { *a = a[1]; a++; }\n      }\n    }\n  }\n\n/* If sender_host_name == NULL, it means we didn't like the name. Replace\nit with the first alias, if there is one. */\n\nif (sender_host_name == NULL && *sender_host_aliases != NULL)\n  sender_host_name = *sender_host_aliases++;\n\n/* If we now have a main name, all is well. */\n\nif (sender_host_name != NULL) return OK;\n\n/* We have failed to find an address that matches. */\n\nHDEBUG(D_host_lookup)\n  debug_printf(\"%s does not match any IP address for %s\\n\",\n    sender_host_address, save_hostname);\n\n/* This message must be in permanent store */\n\nold_pool = store_pool;\nstore_pool = POOL_PERM;\nhost_lookup_msg = string_sprintf(\" (%s does not match any IP address for %s)\",\n  sender_host_address, save_hostname);\nstore_pool = old_pool;\nhost_lookup_failed = TRUE;\nreturn FAIL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-37452"
    },
    {
        "index": 443,
        "code": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29340"
    },
    {
        "index": 444,
        "code": "static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 255) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 445,
        "code": "regtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    vim_free(reg_prev_sub);\n    if (newsub != source)\t// newsub was allocated, just keep it\n\treg_prev_sub = newsub;\n    else\t\t\t// no ~ found, need to save newsub\n\treg_prev_sub = vim_strsave(newsub);\n    return newsub;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2345"
    },
    {
        "index": 446,
        "code": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-40568"
    },
    {
        "index": 447,
        "code": "str2special(\n    char_u\t**sp,\n    int\t\tfrom)\t// TRUE for lhs of mapping\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\n\t*sp = str;\n\t// Try to un-escape a multi-byte character after modifiers.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    // Since 'special' is TRUE the multi-byte character 'c' will be\n\t    // processed by get_special_key_name()\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    // illegal byte\n\t    *sp = str + 1;\n    }\n    else\n\t// single-byte character or illegal byte\n\t*sp = str + 1;\n\n    // Make special keys and C0 control characters in <> form, also <M-Space>.\n    // Use <Space> only for lhs of a mapping.\n    if (special || c < ' ' || (from && c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2257"
    },
    {
        "index": 448,
        "code": "static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 255) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 449,
        "code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23560"
    },
    {
        "index": 450,
        "code": "static void test_reply_reader(void) {\n    redisReader *reader;\n    void *reply, *root;\n    int ret;\n    int i;\n\n    test(\"Error handling in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    /* when the reply already contains multiple items, they must be free'd\n     * on an error. valgrind will bark when this doesn't happen. */\n    test(\"Memory cleanup in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*2\\r\\n\",4);\n    redisReaderFeed(reader,(char*)\"$5\\r\\nhello\\r\\n\",11);\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    reader = redisReaderCreate();\n    test(\"Can handle arbitrarily nested multi-bulks: \");\n    for (i = 0; i < 128; i++) {\n        redisReaderFeed(reader,(char*)\"*1\\r\\n\", 4);\n    }\n    redisReaderFeed(reader,(char*)\"$6\\r\\nLOLWUT\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    root = reply; /* Keep track of the root reply */\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 1);\n\n    test(\"Can parse arbitrarily nested multi-bulks correctly: \");\n    while(i--) {\n        assert(reply != NULL && ((redisReply*)reply)->type == REDIS_REPLY_ARRAY);\n        reply = ((redisReply*)reply)->element[0];\n    }\n    test_cond(((redisReply*)reply)->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->str, \"LOLWUT\", 6));\n    freeReplyObject(root);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775807\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MAX);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when > LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775808\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775808\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MIN);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when < LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775809\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when array < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*-2\\r\\n+asdf\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$-2\\r\\nasdf\\r\\n\",11);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Can configure maximum multi-bulk elements: \");\n    reader = redisReaderCreate();\n    reader->maxelements = 1024;\n    redisReaderFeed(reader, \"*1025\\r\\n\", 7);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr, \"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n#if LLONG_MAX > SIZE_MAX\n    test(\"Set error when array > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*9223372036854775807\\r\\n+asdf\\r\\n\",29);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$9223372036854775807\\r\\nasdf\\r\\n\",28);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n#endif\n\n    test(\"Works with NULL functions for reply: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\\n\",5);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Works when a single newline (\\\\r\\\\n) covers two calls to feed: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_OK && reply == NULL);\n    redisReaderFeed(reader,(char*)\"\\n\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Don't reset state after protocol error: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"x\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_ERR);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR && reply == NULL);\n    redisReaderFree(reader);\n\n    /* Regression test for issue #45 on GitHub. */\n    test(\"Don't do empty allocation for empty multi bulk: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*0\\r\\n\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 verbatim strings (GitHub issue #802) */\n    test(\"Can parse RESP3 verbatim strings: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"=10\\r\\ntxt:LOLWUT\\r\\n\",17);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_VERB &&\n         !memcmp(((redisReply*)reply)->str,\"LOLWUT\", 6));\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 push messages (Github issue #815) */\n    test(\"Can parse RESP3 push messages: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\">2\\r\\n$6\\r\\nLOLWUT\\r\\n:42\\r\\n\",21);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&\n        ((redisReply*)reply)->elements == 2 &&\n        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->element[0]->str,\"LOLWUT\",6) &&\n        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n        ((redisReply*)reply)->element[1]->integer == 42);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-32765"
    },
    {
        "index": 451,
        "code": "bool CSteamNetworkConnectionBase::ProcessPlainTextDataChunk( int usecTimeSinceLast, RecvPacketContext_t &ctx )\n{\n\t#define DECODE_ERROR( ... ) do { \\\n\t\tConnectionState_ProblemDetectedLocally( k_ESteamNetConnectionEnd_Misc_InternalError, __VA_ARGS__ ); \\\n\t\treturn false; } while(false)\n\n\t#define EXPECT_BYTES(n,pszWhatFor) \\\n\t\tdo { \\\n\t\t\tif ( pDecode + (n) > pEnd ) \\\n\t\t\t\tDECODE_ERROR( \"SNP decode overrun, %d bytes for %s\", (n), pszWhatFor ); \\\n\t\t} while (false)\n\n\t#define READ_8BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(1,pszWhatFor); var = *(uint8 *)pDecode; pDecode += 1; } while(false)\n\n\t#define READ_16BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(2,pszWhatFor); var = LittleWord(*(uint16 *)pDecode); pDecode += 2; } while(false)\n\n\t#define READ_24BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(3,pszWhatFor); \\\n\t\t\tvar = *(uint8 *)pDecode; pDecode += 1; \\\n\t\t\tvar |= uint32( LittleWord(*(uint16 *)pDecode) ) << 8U; pDecode += 2; \\\n\t\t} while(false)\n\n\t#define READ_32BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(4,pszWhatFor); var = LittleDWord(*(uint32 *)pDecode); pDecode += 4; } while(false)\n\n\t#define READ_48BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(6,pszWhatFor); \\\n\t\t\tvar = LittleWord( *(uint16 *)pDecode ); pDecode += 2; \\\n\t\t\tvar |= uint64( LittleDWord(*(uint32 *)pDecode) ) << 16U; pDecode += 4; \\\n\t\t} while(false)\n\n\t#define READ_64BITU( var, pszWhatFor ) \\\n\t\tdo { EXPECT_BYTES(8,pszWhatFor); var = LittleQWord(*(uint64 *)pDecode); pDecode += 8; } while(false)\n\n\t#define READ_VARINT( var, pszWhatFor ) \\\n\t\tdo { pDecode = DeserializeVarInt( pDecode, pEnd, var ); if ( !pDecode ) { DECODE_ERROR( \"SNP data chunk decode overflow, varint for %s\", pszWhatFor ); } } while(false)\n\n\t#define READ_SEGMENT_DATA_SIZE( is_reliable ) \\\n\t\tint cbSegmentSize; \\\n\t\t{ \\\n\t\t\tint sizeFlags = nFrameType & 7; \\\n\t\t\tif ( sizeFlags <= 4 ) \\\n\t\t\t{ \\\n\t\t\t\tuint8 lowerSizeBits; \\\n\t\t\t\tREAD_8BITU( lowerSizeBits, #is_reliable \" size lower bits\" ); \\\n\t\t\t\tcbSegmentSize = (sizeFlags<<8) + lowerSizeBits; \\\n\t\t\t\tif ( pDecode + cbSegmentSize > pEnd ) \\\n\t\t\t\t{ \\\n\t\t\t\t\tDECODE_ERROR( \"SNP decode overrun %d bytes for %s segment data.\", cbSegmentSize, #is_reliable ); \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t\telse if ( sizeFlags == 7 ) \\\n\t\t\t{ \\\n\t\t\t\tcbSegmentSize = pEnd - pDecode; \\\n\t\t\t} \\\n\t\t\telse \\\n\t\t\t{ \\\n\t\t\t\tDECODE_ERROR( \"Invalid SNP frame lead byte 0x%02x. (size bits)\", nFrameType ); \\\n\t\t\t} \\\n\t\t} \\\n\t\tconst uint8 *pSegmentData = pDecode; \\\n\t\tpDecode += cbSegmentSize;\n\n\t// Make sure we have initialized the connection\n\tAssert( BStateIsActive() );\n\n\tconst SteamNetworkingMicroseconds usecNow = ctx.m_usecNow;\n\tconst int64 nPktNum = ctx.m_nPktNum;\n\tbool bInhibitMarkReceived = false;\n\n\tconst int nLogLevelPacketDecode = m_connectionConfig.m_LogLevel_PacketDecode.Get();\n\tSpewVerboseGroup( nLogLevelPacketDecode, \"[%s] decode pkt %lld\\n\", GetDescription(), (long long)nPktNum );\n\n\t// Decode frames until we get to the end of the payload\n\tconst byte *pDecode = (const byte *)ctx.m_pPlainText;\n\tconst byte *pEnd = pDecode + ctx.m_cbPlainText;\n\tint64 nCurMsgNum = 0;\n\tint64 nDecodeReliablePos = 0;\n\twhile ( pDecode < pEnd )\n\t{\n\n\t\tuint8 nFrameType = *pDecode;\n\t\t++pDecode;\n\t\tif ( ( nFrameType & 0xc0 ) == 0x00 )\n\t\t{\n\n\t\t\t//\n\t\t\t// Unreliable segment\n\t\t\t//\n\n\t\t\t// Decode message number\n\t\t\tif ( nCurMsgNum == 0 )\n\t\t\t{\n\t\t\t\t// First unreliable frame.  Message number is absolute, but only bottom N bits are sent\n\t\t\t\tstatic const char szUnreliableMsgNumOffset[] = \"unreliable msgnum\";\n\t\t\t\tint64 nLowerBits, nMask;\n\t\t\t\tif ( nFrameType & 0x10 )\n\t\t\t\t{\n\t\t\t\t\tREAD_32BITU( nLowerBits, szUnreliableMsgNumOffset );\n\t\t\t\t\tnMask = 0xffffffff;\n\t\t\t\t\tnCurMsgNum = NearestWithSameLowerBits( (int32)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREAD_16BITU( nLowerBits, szUnreliableMsgNumOffset );\n\t\t\t\t\tnMask = 0xffff;\n\t\t\t\t\tnCurMsgNum = NearestWithSameLowerBits( (int16)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\t\t\t\tAssert( ( nCurMsgNum & nMask ) == nLowerBits );\n\n\t\t\t\tif ( nCurMsgNum <= 0 )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode unreliable msgnum underflow.  %llx mod %llx, highest seen %llx\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\t\t\t\tif ( std::abs( nCurMsgNum - m_receiverState.m_nHighestSeenMsgNum ) > (nMask>>2) )\n\t\t\t\t{\n\t\t\t\t\t// We really should never get close to this boundary.\n\t\t\t\t\tSpewWarningRateLimited( usecNow, \"Sender sent abs unreliable message number using %llx mod %llx, highest seen %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_receiverState.m_nHighestSeenMsgNum );\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( nFrameType & 0x10 )\n\t\t\t\t{\n\t\t\t\t\tuint64 nMsgNumOffset;\n\t\t\t\t\tREAD_VARINT( nMsgNumOffset, \"unreliable msgnum offset\" );\n\t\t\t\t\tnCurMsgNum += nMsgNumOffset;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++nCurMsgNum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( nCurMsgNum > m_receiverState.m_nHighestSeenMsgNum )\n\t\t\t\tm_receiverState.m_nHighestSeenMsgNum = nCurMsgNum;\n\n\t\t\t//\n\t\t\t// Decode segment offset in message\n\t\t\t//\n\t\t\tuint32 nOffset = 0;\n\t\t\tif ( nFrameType & 0x08 )\n\t\t\t\tREAD_VARINT( nOffset, \"unreliable data offset\" );\n\n\t\t\t//\n\t\t\t// Decode size, locate segment data\n\t\t\t//\n\t\t\tREAD_SEGMENT_DATA_SIZE( unreliable )\n\t\t\tAssert( cbSegmentSize > 0 ); // !TEST! Bogus assert, zero byte messages are OK.  Remove after testing\n\n\t\t\t// Receive the segment\n\t\t\tbool bLastSegmentInMessage = ( nFrameType & 0x20 ) != 0;\n\t\t\tSNP_ReceiveUnreliableSegment( nCurMsgNum, nOffset, pSegmentData, cbSegmentSize, bLastSegmentInMessage, usecNow );\n\t\t}\n\t\telse if ( ( nFrameType & 0xe0 ) == 0x40 )\n\t\t{\n\n\t\t\t//\n\t\t\t// Reliable segment\n\t\t\t//\n\n\t\t\t// First reliable segment?\n\t\t\tif ( nDecodeReliablePos == 0 )\n\t\t\t{\n\n\t\t\t\t// Stream position is absolute.  How many bits?\n\t\t\t\tstatic const char szFirstReliableStreamPos[] = \"first reliable streampos\";\n\t\t\t\tint64 nOffset, nMask;\n\t\t\t\tswitch ( nFrameType & (3<<3) )\n\t\t\t\t{\n\t\t\t\t\tcase 0<<3: READ_24BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<24)-1; break;\n\t\t\t\t\tcase 1<<3: READ_32BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<32)-1; break;\n\t\t\t\t\tcase 2<<3: READ_48BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<48)-1; break;\n\t\t\t\t\tdefault: DECODE_ERROR( \"Reserved reliable stream pos size\" );\n\t\t\t\t}\n\n\t\t\t\t// What do we expect to receive next?\n\t\t\t\tint64 nExpectNextStreamPos = m_receiverState.m_nReliableStreamPos + len( m_receiverState.m_bufReliableStream );\n\n\t\t\t\t// Find the stream offset closest to that\n\t\t\t\tnDecodeReliablePos = ( nExpectNextStreamPos & ~nMask ) + nOffset;\n\t\t\t\tif ( nDecodeReliablePos + (nMask>>1) < nExpectNextStreamPos )\n\t\t\t\t{\n\t\t\t\t\tnDecodeReliablePos += nMask+1;\n\t\t\t\t\tAssert( ( nDecodeReliablePos & nMask ) == nOffset );\n\t\t\t\t\tAssert( nExpectNextStreamPos < nDecodeReliablePos );\n\t\t\t\t\tAssert( nExpectNextStreamPos + (nMask>>1) >= nDecodeReliablePos );\n\t\t\t\t}\n\t\t\t\tif ( nDecodeReliablePos <= 0 )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode first reliable stream pos underflow.  %llx mod %llx, expected next %llx\",\n\t\t\t\t\t\t(unsigned long long)nOffset, (unsigned long long)( nMask+1 ), (unsigned long long)nExpectNextStreamPos );\n\t\t\t\t}\n\t\t\t\tif ( std::abs( nDecodeReliablePos - nExpectNextStreamPos ) > (nMask>>2) )\n\t\t\t\t{\n\t\t\t\t\t// We really should never get close to this boundary.\n\t\t\t\t\tSpewWarningRateLimited( usecNow, \"Sender sent reliable stream pos using %llx mod %llx, expected next %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)nOffset, (unsigned long long)( nMask+1 ), (unsigned long long)nExpectNextStreamPos );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Subsequent reliable message encode the position as an offset from previous.\n\t\t\t\tstatic const char szOtherReliableStreamPos[] = \"reliable streampos offset\";\n\t\t\t\tint64 nOffset;\n\t\t\t\tswitch ( nFrameType & (3<<3) )\n\t\t\t\t{\n\t\t\t\t\tcase 0<<3: nOffset = 0; break;\n\t\t\t\t\tcase 1<<3: READ_8BITU( nOffset, szOtherReliableStreamPos ); break;\n\t\t\t\t\tcase 2<<3: READ_16BITU( nOffset, szOtherReliableStreamPos ); break;\n\t\t\t\t\tdefault: READ_32BITU( nOffset, szOtherReliableStreamPos ); break;\n\t\t\t\t}\n\t\t\t\tnDecodeReliablePos += nOffset;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Decode size, locate segment data\n\t\t\t//\n\t\t\tREAD_SEGMENT_DATA_SIZE( reliable )\n\n\t\t\t// Ingest the segment.\n\t\t\tif ( !SNP_ReceiveReliableSegment( nPktNum, nDecodeReliablePos, pSegmentData, cbSegmentSize, usecNow ) )\n\t\t\t{\n\t\t\t\tif ( !BStateIsActive() )\n\t\t\t\t\treturn false; // we decided to nuke the connection - abort packet processing\n\n\t\t\t\t// We're not able to ingest this reliable segment at the moment,\n\t\t\t\t// but we didn't terminate the connection.  So do not ack this packet\n\t\t\t\t// to the peer.  We need them to retransmit\n\t\t\t\tbInhibitMarkReceived = true;\n\t\t\t}\n\n\t\t\t// Advance pointer for the next reliable segment, if any.\n\t\t\tnDecodeReliablePos += cbSegmentSize;\n\n\t\t\t// Decoding rules state that if we have established a message number,\n\t\t\t// (from an earlier unreliable message), then we advance it.\n\t\t\tif ( nCurMsgNum > 0 ) \n\t\t\t\t++nCurMsgNum;\n\t\t}\n\t\telse if ( ( nFrameType & 0xfc ) == 0x80 )\n\t\t{\n\t\t\t//\n\t\t\t// Stop waiting\n\t\t\t//\n\n\t\t\tint64 nOffset = 0;\n\t\t\tstatic const char szStopWaitingOffset[] = \"stop_waiting offset\";\n\t\t\tswitch ( nFrameType & 3 )\n\t\t\t{\n\t\t\t\tcase 0: READ_8BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t\tcase 1: READ_16BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t\tcase 2: READ_24BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t\tcase 3: READ_64BITU( nOffset, szStopWaitingOffset ); break;\n\t\t\t}\n\t\t\tif ( nOffset >= nPktNum )\n\t\t\t{\n\t\t\t\tDECODE_ERROR( \"stop_waiting pktNum %llu offset %llu\", nPktNum, nOffset );\n\t\t\t}\n\t\t\t++nOffset;\n\t\t\tint64 nMinPktNumToSendAcks = nPktNum-nOffset;\n\t\t\tif ( nMinPktNumToSendAcks == m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t\tcontinue;\n\t\t\tif ( nMinPktNumToSendAcks < m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t{\n\t\t\t\t// Sender must never reduce this number!  Check for bugs or bogus sender\n\t\t\t\tif ( nPktNum >= m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP stop waiting reduced %lld (pkt %lld) -> %lld (pkt %lld)\",\n\t\t\t\t\t\t(long long)m_receiverState.m_nMinPktNumToSendAcks,\n\t\t\t\t\t\t(long long)m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks,\n\t\t\t\t\t\t(long long)nMinPktNumToSendAcks,\n\t\t\t\t\t\t(long long)nPktNum\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld stop waiting: %lld (was %lld)\",\n\t\t\t\tGetDescription(),\n\t\t\t\t(long long)nPktNum,\n\t\t\t\t(long long)nMinPktNumToSendAcks, (long long)m_receiverState.m_nMinPktNumToSendAcks );\n\t\t\tm_receiverState.m_nMinPktNumToSendAcks = nMinPktNumToSendAcks;\n\t\t\tm_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks = nPktNum;\n\n\t\t\t// Trim from the front of the packet gap list,\n\t\t\t// we can stop reporting these losses to the sender\n\t\t\tauto h = m_receiverState.m_mapPacketGaps.begin();\n\t\t\twhile ( h->first <= m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t{\n\t\t\t\tif ( h->second.m_nEnd > m_receiverState.m_nMinPktNumToSendAcks )\n\t\t\t\t{\n\t\t\t\t\t// Ug.  You're not supposed to modify the key in a map.\n\t\t\t\t\t// I suppose that's legit, since you could violate the ordering.\n\t\t\t\t\t// but in this case I know that this change is OK.\n\t\t\t\t\tconst_cast<int64 &>( h->first ) = m_receiverState.m_nMinPktNumToSendAcks;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Were we pending an ack on this?\n\t\t\t\tif ( m_receiverState.m_itPendingAck == h )\n\t\t\t\t\t++m_receiverState.m_itPendingAck;\n\n\t\t\t\t// Were we pending a nack on this?\n\t\t\t\tif ( m_receiverState.m_itPendingNack == h )\n\t\t\t\t{\n\t\t\t\t\t// I am not sure this is even possible.\n\t\t\t\t\tAssertMsg( false, \"Expiring packet gap, which had pending NACK\" );\n\n\t\t\t\t\t// But just in case, this would be the proper action\n\t\t\t\t\t++m_receiverState.m_itPendingNack;\n\t\t\t\t}\n\n\t\t\t\t// Packet loss is in the past.  Forget about it and move on\n\t\t\t\th = m_receiverState.m_mapPacketGaps.erase(h);\n\t\t\t}\n\t\t}\n\t\telse if ( ( nFrameType & 0xf0 ) == 0x90 )\n\t\t{\n\n\t\t\t//\n\t\t\t// Ack\n\t\t\t//\n\n\t\t\t#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA > 0\n\t\t\t\tm_senderState.DebugCheckInFlightPacketMap();\n\t\t\t\t#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA == 1\n\t\t\t\tif ( ( nPktNum & 255 ) == 0 ) // only do it periodically\n\t\t\t\t#endif\n\t\t\t\t{\n\t\t\t\t\tm_senderState.DebugCheckInFlightPacketMap();\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t// Parse latest received sequence number\n\t\t\tint64 nLatestRecvSeqNum;\n\t\t\t{\n\t\t\t\tstatic const char szAckLatestPktNum[] = \"ack latest pktnum\";\n\t\t\t\tint64 nLowerBits, nMask;\n\t\t\t\tif ( nFrameType & 0x40 )\n\t\t\t\t{\n\t\t\t\t\tREAD_32BITU( nLowerBits, szAckLatestPktNum );\n\t\t\t\t\tnMask = 0xffffffff;\n\t\t\t\t\tnLatestRecvSeqNum = NearestWithSameLowerBits( (int32)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREAD_16BITU( nLowerBits, szAckLatestPktNum );\n\t\t\t\t\tnMask = 0xffff;\n\t\t\t\t\tnLatestRecvSeqNum = NearestWithSameLowerBits( (int16)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\tAssert( ( nLatestRecvSeqNum & nMask ) == nLowerBits );\n\n\t\t\t\t// Find the message number that is closes to \n\t\t\t\tif ( nLatestRecvSeqNum < 0 )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode ack latest pktnum underflow.  %llx mod %llx, next send %llx\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\tif ( std::abs( nLatestRecvSeqNum - m_statsEndToEnd.m_nNextSendSequenceNumber ) > (nMask>>2) )\n\t\t\t\t{\n\t\t\t\t\t// We really should never get close to this boundary.\n\t\t\t\t\tSpewWarningRateLimited( usecNow, \"Sender sent abs latest recv pkt number using %llx mod %llx, next send %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber );\n\t\t\t\t}\n\t\t\t\tif ( nLatestRecvSeqNum >= m_statsEndToEnd.m_nNextSendSequenceNumber )\n\t\t\t\t{\n\t\t\t\t\tDECODE_ERROR( \"SNP decode ack latest pktnum %lld (%llx mod %llx), but next outoing packet is %lld (%llx).\",\n\t\t\t\t\t\t(long long)nLatestRecvSeqNum, (unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ),\n\t\t\t\t\t\t(long long)m_statsEndToEnd.m_nNextSendSequenceNumber, (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld latest recv %lld\\n\",\n\t\t\t\tGetDescription(),\n\t\t\t\t(long long)nPktNum, (long long)nLatestRecvSeqNum\n\t\t\t);\n\n\t\t\t// Locate our bookkeeping for this packet, or the latest one before it\n\t\t\t// Remember, we have a sentinel with a low, invalid packet number\n\t\t\tAssert( !m_senderState.m_mapInFlightPacketsByPktNum.empty() );\n\t\t\tauto inFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.upper_bound( nLatestRecvSeqNum );\n\t\t\t--inFlightPkt;\n\t\t\tAssert( inFlightPkt->first <= nLatestRecvSeqNum );\n\n\t\t\t// Parse out delay, and process the ping\n\t\t\t{\n\t\t\t\tuint16 nPackedDelay;\n\t\t\t\tREAD_16BITU( nPackedDelay, \"ack delay\" );\n\t\t\t\tif ( nPackedDelay != 0xffff && inFlightPkt->first == nLatestRecvSeqNum && inFlightPkt->second.m_pTransport == ctx.m_pTransport )\n\t\t\t\t{\n\t\t\t\t\tSteamNetworkingMicroseconds usecDelay = SteamNetworkingMicroseconds( nPackedDelay ) << k_nAckDelayPrecisionShift;\n\t\t\t\t\tSteamNetworkingMicroseconds usecElapsed = usecNow - inFlightPkt->second.m_usecWhenSent;\n\t\t\t\t\tAssert( usecElapsed >= 0 );\n\n\t\t\t\t\t// Account for their reported delay, and calculate ping, in MS\n\t\t\t\t\tint msPing = ( usecElapsed - usecDelay ) / 1000;\n\n\t\t\t\t\t// Does this seem bogus?  (We allow a small amount of slop.)\n\t\t\t\t\t// NOTE: A malicious sender could lie about this delay, tricking us\n\t\t\t\t\t// into thinking that the real network latency is low, they are just\n\t\t\t\t\t// delaying their replies.  This actually matters, since the ping time\n\t\t\t\t\t// is an input into the rate calculation.  So we might need to\n\t\t\t\t\t// occasionally send pings that require an immediately reply, and\n\t\t\t\t\t// if those ping times seem way out of whack with the ones where they are\n\t\t\t\t\t// allowed to send a delay, take action against them.\n\t\t\t\t\tif ( msPing < -1 || msPing > 2000 )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Either they are lying or some weird timer stuff is happening.\n\t\t\t\t\t\t// Either way, discard it.\n\n\t\t\t\t\t\tSpewMsgGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %lluusec INVALID ping %lldusec\\n\",\n\t\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t\t(long long)nPktNum, (long long)nLatestRecvSeqNum,\n\t\t\t\t\t\t\t(unsigned long long)usecDelay,\n\t\t\t\t\t\t\t(long long)usecElapsed\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Clamp, if we have slop\n\t\t\t\t\t\tif ( msPing < 0 )\n\t\t\t\t\t\t\tmsPing = 0;\n\t\t\t\t\t\tProcessSNPPing( msPing, ctx );\n\n\t\t\t\t\t\t// Spew\n\t\t\t\t\t\tSpewVerboseGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %.1fms elapsed %.1fms ping %dms\\n\",\n\t\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t\t(long long)nPktNum, (long long)nLatestRecvSeqNum,\n\t\t\t\t\t\t\t(float)(usecDelay * 1e-3 ),\n\t\t\t\t\t\t\t(float)(usecElapsed * 1e-3 ),\n\t\t\t\t\t\t\tmsPing\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Parse number of blocks\n\t\t\tint nBlocks = nFrameType&7;\n\t\t\tif ( nBlocks == 7 )\n\t\t\t\tREAD_8BITU( nBlocks, \"ack num blocks\" );\n\n\t\t\t// If they actually sent us any blocks, that means they are fragmented.\n\t\t\t// We should make sure and tell them to stop sending us these nacks\n\t\t\t// and move forward.\n\t\t\tif ( nBlocks > 0 )\n\t\t\t{\n\t\t\t\t// Decrease flush delay the more blocks they send us.\n\t\t\t\t// FIXME - This is not an optimal way to do this.  Forcing us to\n\t\t\t\t// ack everything is not what we want to do.  Instead, we should\n\t\t\t\t// use a separate timer for when we need to flush out a stop_waiting\n\t\t\t\t// packet!\n\t\t\t\tSteamNetworkingMicroseconds usecDelay = 250*1000 / nBlocks;\n\t\t\t\tQueueFlushAllAcks( usecNow + usecDelay );\n\t\t\t}\n\n\t\t\t// Process ack blocks, working backwards from the latest received sequence number.\n\t\t\t// Note that we have to parse all this stuff out, even if it's old news (packets older\n\t\t\t// than the stop_aiting value we sent), because we need to do that to get to the rest\n\t\t\t// of the packet.\n\t\t\tbool bAckedReliableRange = false;\n\t\t\tint64 nPktNumAckEnd = nLatestRecvSeqNum+1;\n\t\t\twhile ( nBlocks >= 0 )\n\t\t\t{\n\n\t\t\t\t// Parse out number of acks/nacks.\n\t\t\t\t// Have we parsed all the real blocks?\n\t\t\t\tint64 nPktNumAckBegin, nPktNumNackBegin;\n\t\t\t\tif ( nBlocks == 0 )\n\t\t\t\t{\n\t\t\t\t\t// Implicit block.  Everything earlier between the last\n\t\t\t\t\t// NACK and the stop_waiting value is implicitly acked!\n\t\t\t\t\tif ( nPktNumAckEnd <= m_senderState.m_nMinPktWaitingOnAck )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tnPktNumAckBegin = m_senderState.m_nMinPktWaitingOnAck;\n\t\t\t\t\tnPktNumNackBegin = nPktNumAckBegin;\n\t\t\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld ack last block ack begin %lld\\n\",\n\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t(long long)nPktNum, (long long)nPktNumAckBegin );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuint8 nBlockHeader;\n\t\t\t\t\tREAD_8BITU( nBlockHeader, \"ack block header\" );\n\n\t\t\t\t\t// Ack count?\n\t\t\t\t\tint64 numAcks = ( nBlockHeader>> 4 ) & 7;\n\t\t\t\t\tif ( nBlockHeader & 0x80 )\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 nUpperBits;\n\t\t\t\t\t\tREAD_VARINT( nUpperBits, \"ack count upper bits\" );\n\t\t\t\t\t\tif ( nUpperBits > 100000 )\n\t\t\t\t\t\t\tDECODE_ERROR( \"Ack count of %llu<<3 is crazy\", (unsigned long long)nUpperBits );\n\t\t\t\t\t\tnumAcks |= nUpperBits<<3;\n\t\t\t\t\t}\n\t\t\t\t\tnPktNumAckBegin = nPktNumAckEnd - numAcks;\n\t\t\t\t\tif ( nPktNumAckBegin < 0 )\n\t\t\t\t\t\tDECODE_ERROR( \"Ack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckEnd, (long long)numAcks );\n\n\t\t\t\t\t// Extended nack count?\n\t\t\t\t\tint64 numNacks = nBlockHeader & 7;\n\t\t\t\t\tif ( nBlockHeader & 0x08)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 nUpperBits;\n\t\t\t\t\t\tREAD_VARINT( nUpperBits, \"nack count upper bits\" );\n\t\t\t\t\t\tif ( nUpperBits > 100000 )\n\t\t\t\t\t\t\tDECODE_ERROR( \"Nack count of %llu<<3 is crazy\", nUpperBits );\n\t\t\t\t\t\tnumNacks |= nUpperBits<<3;\n\t\t\t\t\t}\n\t\t\t\t\tnPktNumNackBegin = nPktNumAckBegin - numNacks;\n\t\t\t\t\tif ( nPktNumNackBegin < 0 )\n\t\t\t\t\t\tDECODE_ERROR( \"Nack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckBegin, (long long)numAcks );\n\n\t\t\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld nack [%lld,%lld) ack [%lld,%lld)\\n\",\n\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t(long long)nPktNum,\n\t\t\t\t\t\t(long long)nPktNumNackBegin, (long long)( nPktNumNackBegin + numNacks ),\n\t\t\t\t\t\t(long long)nPktNumAckBegin, (long long)( nPktNumAckBegin + numAcks )\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Process acks first.\n\t\t\t\tAssert( nPktNumAckBegin >= 0 );\n\t\t\t\twhile ( inFlightPkt->first >= nPktNumAckBegin )\n\t\t\t\t{\n\t\t\t\t\tAssert( inFlightPkt->first < nPktNumAckEnd );\n\n\t\t\t\t\t// Scan reliable segments, and see if any are marked for retry or are in flight\n\t\t\t\t\tfor ( const SNPRange_t &relRange: inFlightPkt->second.m_vecReliableSegments )\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// If range is present, it should be in only one of these two tables.\n\t\t\t\t\t\tif ( m_senderState.m_listInFlightReliableRange.erase( relRange ) == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( m_senderState.m_listReadyRetryReliableRange.erase( relRange ) > 0 )\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t// When we put stuff into the reliable retry list, we mark it as pending again.\n\t\t\t\t\t\t\t\t// But now it's acked, so it's no longer pending, even though we didn't send it.\n\t\t\t\t\t\t\t\tm_senderState.m_cbPendingReliable -= int( relRange.length() );\n\t\t\t\t\t\t\t\tAssert( m_senderState.m_cbPendingReliable >= 0 );\n\n\t\t\t\t\t\t\t\tbAckedReliableRange = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbAckedReliableRange = true;\n\t\t\t\t\t\t\tAssert( m_senderState.m_listReadyRetryReliableRange.count( relRange ) == 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if this was the next packet we were going to timeout, then advance\n\t\t\t\t\t// pointer.  This guy didn't timeout.\n\t\t\t\t\tif ( inFlightPkt == m_senderState.m_itNextInFlightPacketToTimeout )\n\t\t\t\t\t\t++m_senderState.m_itNextInFlightPacketToTimeout;\n\n\t\t\t\t\t// No need to track this anymore, remove from our table\n\t\t\t\t\tinFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.erase( inFlightPkt );\n\t\t\t\t\t--inFlightPkt;\n\t\t\t\t\tm_senderState.MaybeCheckInFlightPacketMap();\n\t\t\t\t}\n\n\t\t\t\t// Ack of in-flight end-to-end stats?\n\t\t\t\tif ( nPktNumAckBegin <= m_statsEndToEnd.m_pktNumInFlight && m_statsEndToEnd.m_pktNumInFlight < nPktNumAckEnd )\n\t\t\t\t\tm_statsEndToEnd.InFlightPktAck( usecNow );\n\n\t\t\t\t// Process nacks.\n\t\t\t\tAssert( nPktNumNackBegin >= 0 );\n\t\t\t\twhile ( inFlightPkt->first >= nPktNumNackBegin )\n\t\t\t\t{\n\t\t\t\t\tAssert( inFlightPkt->first < nPktNumAckEnd );\n\t\t\t\t\tSNP_SenderProcessPacketNack( inFlightPkt->first, inFlightPkt->second, \"NACK\" );\n\n\t\t\t\t\t// We'll keep the record on hand, though, in case an ACK comes in\n\t\t\t\t\t--inFlightPkt;\n\t\t\t\t}\n\n\t\t\t\t// Continue on to the the next older block\n\t\t\t\tnPktNumAckEnd = nPktNumNackBegin;\n\t\t\t\t--nBlocks;\n\t\t\t}\n\n\t\t\t// Should we check for discarding reliable messages we are keeping around in case\n\t\t\t// of retransmission, since we know now that they were delivered?\n\t\t\tif ( bAckedReliableRange )\n\t\t\t{\n\t\t\t\tm_senderState.RemoveAckedReliableMessageFromUnackedList();\n\n\t\t\t\t// Spew where we think the peer is decoding the reliable stream\n\t\t\t\tif ( nLogLevelPacketDecode >= k_ESteamNetworkingSocketsDebugOutputType_Debug )\n\t\t\t\t{\n\n\t\t\t\t\tint64 nPeerReliablePos = m_senderState.m_nReliableStreamPos;\n\t\t\t\t\tif ( !m_senderState.m_listInFlightReliableRange.empty() )\n\t\t\t\t\t\tnPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listInFlightReliableRange.begin()->first.m_nBegin );\n\t\t\t\t\tif ( !m_senderState.m_listReadyRetryReliableRange.empty() )\n\t\t\t\t\t\tnPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listReadyRetryReliableRange.begin()->first.m_nBegin );\n\n\t\t\t\t\tSpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld peer reliable pos = %lld\\n\",\n\t\t\t\t\t\tGetDescription(),\n\t\t\t\t\t\t(long long)nPktNum, (long long)nPeerReliablePos );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if any of this was new info, then advance our stop_waiting value.\n\t\t\tif ( nLatestRecvSeqNum > m_senderState.m_nMinPktWaitingOnAck )\n\t\t\t{\n\t\t\t\tSpewVerboseGroup( nLogLevelPacketDecode, \"[%s]   updating min_waiting_on_ack %lld -> %lld\\n\",\n\t\t\t\t\tGetDescription(),\n\t\t\t\t\t(long long)m_senderState.m_nMinPktWaitingOnAck, (long long)nLatestRecvSeqNum );\n\t\t\t\tm_senderState.m_nMinPktWaitingOnAck = nLatestRecvSeqNum;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDECODE_ERROR( \"Invalid SNP frame lead byte 0x%02x\", nFrameType );\n\t\t}\n\t}\n\n\t// Should we record that we received it?\n\tif ( bInhibitMarkReceived )\n\t{\n\t\t// Something really odd.  High packet loss / fragmentation.\n\t\t// Potentially the peer is being abusive and we need\n\t\t// to protect ourselves.\n\t\t//\n\t\t// Act as if the packet was dropped.  This will cause the\n\t\t// peer's sender logic to interpret this as additional packet\n\t\t// loss and back off.  That's a feature, not a bug.\n\t}\n\telse\n\t{\n\n\t\t// Update structures needed to populate our ACKs.\n\t\t// If we received reliable data now, then schedule an ack\n\t\tbool bScheduleAck = nDecodeReliablePos > 0;\n\t\tSNP_RecordReceivedPktNum( nPktNum, usecNow, bScheduleAck );\n\t}\n\n\t// Track end-to-end flow.  Even if we decided to tell our peer that\n\t// we did not receive this, we want our own stats to reflect\n\t// that we did.  (And we want to be able to quickly reject a\n\t// packet with this same number.)\n\t//\n\t// Also, note that order of operations is important.  This call must\n\t// happen after the SNP_RecordReceivedPktNum call above\n\tm_statsEndToEnd.TrackProcessSequencedPacket( nPktNum, usecNow, usecTimeSinceLast );\n\n\t// Packet can be processed further\n\treturn true;\n\n\t// Make sure these don't get used beyond where we intended them to get used\n\t#undef DECODE_ERROR\n\t#undef EXPECT_BYTES\n\t#undef READ_8BITU\n\t#undef READ_16BITU\n\t#undef READ_24BITU\n\t#undef READ_32BITU\n\t#undef READ_64BITU\n\t#undef READ_VARINT\n\t#undef READ_SEGMENT_DATA_SIZE\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-6016"
    },
    {
        "index": 452,
        "code": "static Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = Jsi_ObjGetLength(interp, obj);\n    assert(n <= obj->arrCnt);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 453,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    OP_REQUIRES(context, shape.NumElements() != 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n\n    bool is_1d = shape.NumElements() == 1;\n    auto shape_vector = shape.flat<int64_t>();\n    int num_batches = is_1d ? 1 : shape_vector(0);\n    int num_values = values.NumElements();\n\n    for (int b = 0; b < shape_vector.size(); b++) {\n      OP_REQUIRES(context, shape_vector(b) >= 0,\n                  errors::InvalidArgument(\n                      \"Elements in dense_shape must be >= 0. Instead got:\",\n                      shape.DebugString()));\n    }\n\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", num_values,\n                    \" values, indices shape: \", indices.shape().DebugString()));\n\n    const auto indices_values = indices.matrix<int64_t>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    OP_REQUIRES(context, num_values <= indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"The first dimension of indices must be equal to or \"\n                    \"greather than number of values. ( \",\n                    indices.shape().dim_size(0), \" vs. \", num_values, \" )\"));\n    OP_REQUIRES(context, indices.shape().dim_size(1) > 0,\n                errors::InvalidArgument(\"The second dimension of indices must \"\n                                        \"be greater than 0. Received: \",\n                                        indices.shape().dim_size(1)));\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch >= num_batches) {\n        OP_REQUIRES(context, batch < num_batches,\n                    errors::InvalidArgument(\n                        \"Indices value along the first dimension must be \",\n                        \"lower than the first index of the shape.\", \"Got \",\n                        batch, \" as batch and \", num_batches,\n                        \" as the first dimension of the shape.\"));\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21740"
    },
    {
        "index": 454,
        "code": "njs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    capability = pargs->capability;\n\n    array = pargs->args.data;\n    njs_set_undefined(&array->start[index]);\n\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1,\n                            &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    on_rejected = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n\n    on_rejected->u.native = njs_promise_any_reject_element_functions;\n    on_rejected->args_count = 1;\n\n    context = on_rejected->context;\n\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n\n    (*pargs->remaining)++;\n\n    arguments[0] = capability->resolve;\n    njs_set_function(&arguments[1], on_rejected);\n\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-32414"
    },
    {
        "index": 455,
        "code": "void LineBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n\n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            if (*m_pppImage[i]) {\n              FetchRegion(bx,*m_pppImage[i],dst);\n            } else {\n              memset(dst,0,sizeof(dst));\n            }\n            up->DefineRegion(bx,by,dst);\n          }\n          Next8Lines(i);\n        }\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else if (*m_pppImage[i]) {\n                FetchRegion(x,*m_pppImage[i],m_ppCTemp[i]);\n              } else {\n                memset(m_ppCTemp[0],0,sizeof(LONG) * 64);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Next8Lines(i);\n        }\n      }\n    }\n  } else { // direct case, no upsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            FetchRegion(x,*m_pppImage[i],dst);\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Next8Lines(i);\n      }\n    }\n  }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-32202"
    },
    {
        "index": 456,
        "code": "start_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  int c;\n  unsigned int w, h, maxval;\n  boolean need_iobuffer, use_raw_buffer, need_rescale;\n\n  if (getc(source->pub.input_file) != 'P')\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  c = getc(source->pub.input_file); /* subformat discriminator character */\n\n  /* detect unsupported variants (ie, PBM) before trying to read header */\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n  case '3':                     /* it's a text-format PPM file */\n  case '5':                     /* it's a raw-format PGM file */\n  case '6':                     /* it's a raw-format PPM file */\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_NOT);\n    break;\n  }\n\n  /* fetch the remaining header info */\n  w = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  h = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  maxval = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */\n  cinfo->image_width = (JDIMENSION)w;\n  cinfo->image_height = (JDIMENSION)h;\n  source->maxval = maxval;\n\n  /* initialize flags to most common settings */\n  need_iobuffer = TRUE;         /* do we need an I/O buffer? */\n  use_raw_buffer = FALSE;       /* do we map input buffer onto I/O buffer? */\n  need_rescale = TRUE;          /* do we need a rescale array? */\n\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM_TEXT, w, h);\n    if (cinfo->in_color_space == JCS_GRAYSCALE)\n      source->pub.get_pixel_rows = get_text_gray_row;\n    else if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_gray_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_gray_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '3':                     /* it's a text-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM_TEXT, w, h);\n    if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_rgb_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '5':                     /* it's a raw-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM, w, h);\n    if (maxval > 255) {\n      source->pub.get_pixel_rows = get_word_gray_row;\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n               cinfo->in_color_space == JCS_GRAYSCALE) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_scaled_gray_row;\n      else if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_gray_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_gray_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n\n  case '6':                     /* it's a raw-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM, w, h);\n    if (maxval > 255) {\n      source->pub.get_pixel_rows = get_word_rgb_row;\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n               (cinfo->in_color_space == JCS_EXT_RGB ||\n                cinfo->in_color_space == JCS_RGB)) {\n#else\n               cinfo->in_color_space == JCS_EXT_RGB) {\n#endif\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_rgb_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n  }\n\n  if (IsExtRGB(cinfo->in_color_space))\n    cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n  else if (cinfo->in_color_space == JCS_GRAYSCALE)\n    cinfo->input_components = 1;\n  else if (cinfo->in_color_space == JCS_CMYK)\n    cinfo->input_components = 4;\n\n  /* Allocate space for I/O buffer: 1 or 3 bytes or words/pixel. */\n  if (need_iobuffer) {\n    if (c == '6')\n      source->buffer_width = (size_t)w * 3 *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    else\n      source->buffer_width = (size_t)w *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  source->buffer_width);\n  }\n\n  /* Create compressor input buffer. */\n  if (use_raw_buffer) {\n    /* For unscaled raw-input case, we can just map it onto the I/O buffer. */\n    /* Synthesize a JSAMPARRAY pointer structure */\n    source->pixrow = (JSAMPROW)source->iobuffer;\n    source->pub.buffer = &source->pixrow;\n    source->pub.buffer_height = 1;\n  } else {\n    /* Need to translate anyway, so make a separate sample buffer. */\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)w * cinfo->input_components, (JDIMENSION)1);\n    source->pub.buffer_height = 1;\n  }\n\n  /* Compute the rescaling array if required. */\n  if (need_rescale) {\n    long val, half_maxval;\n\n    /* On 16-bit-int machines we have to be careful of maxval = 65535 */\n    source->rescale = (JSAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  (size_t)(((long)MAX(maxval, 255) + 1L) *\n                                           sizeof(JSAMPLE)));\n    half_maxval = maxval / 2;\n    for (val = 0; val <= (long)maxval; val++) {\n      /* The multiplication here must be done in 32 bits to avoid overflow */\n      source->rescale[val] = (JSAMPLE)((val * MAXJSAMPLE + half_maxval) /\n                                        maxval);\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-46822"
    },
    {
        "index": 457,
        "code": "njs_array_prototype_concat(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    double       idx;\n    int64_t      k, len, length;\n    njs_int_t    ret;\n    njs_uint_t   i;\n    njs_value_t  this, retval, *e;\n    njs_array_t  *array, *keys;\n\n    ret = njs_value_to_object(vm, &args[0]);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    array = njs_array_alloc(vm, 0, 0, NJS_ARRAY_SPARE);\n    if (njs_slow_path(array == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_set_array(&this, array);\n\n    len = 0;\n    length = 0;\n\n    for (i = 0; i < nargs; i++) {\n        e = njs_argument(args, i);\n\n        ret = njs_is_concat_spreadable(vm, e);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n\n        if (ret == NJS_OK) {\n            ret = njs_object_length(vm, e, &len);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return ret;\n            }\n\n            if (njs_slow_path((length + len) > NJS_MAX_LENGTH)) {\n                njs_type_error(vm, \"Invalid length\");\n                return NJS_ERROR;\n            }\n\n            if (njs_is_fast_array(e) || njs_fast_object(len)) {\n                for (k = 0; k < len; k++, length++) {\n                    ret = njs_value_property_i64(vm, e, k, &retval);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        if (ret == NJS_ERROR) {\n                            return NJS_ERROR;\n                        }\n\n                        njs_set_invalid(&retval);\n                    }\n\n                    ret = njs_array_add(vm, array, &retval);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        return NJS_ERROR;\n                    }\n                }\n\n                continue;\n            }\n\n            keys = njs_array_indices(vm, e);\n            if (njs_slow_path(keys == NULL)) {\n                return NJS_ERROR;\n            }\n\n            for (k = 0; k < keys->length; k++) {\n                ret = njs_value_property(vm, e, &keys->start[k], &retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n\n                if (ret == NJS_OK) {\n                    idx = njs_string_to_index(&keys->start[k]) + length;\n\n                    ret = njs_value_property_i64_set(vm, &this, idx, &retval);\n                    if (njs_slow_path(ret == NJS_ERROR)) {\n                        njs_array_destroy(vm, keys);\n                        return ret;\n                    }\n                }\n            }\n\n            njs_array_destroy(vm, keys);\n\n            length += len;\n\n            continue;\n        }\n\n        if (njs_slow_path((length + len) >= NJS_MAX_LENGTH)) {\n            njs_type_error(vm, \"Invalid length\");\n            return NJS_ERROR;\n        }\n\n        ret = njs_value_property_i64_set(vm, &this, length, e);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n\n        length++;\n    }\n\n    ret = njs_object_length_set(vm, &this, length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NJS_ERROR;\n    }\n\n    vm->retval = this;\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27008"
    },
    {
        "index": 458,
        "code": "PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n\n    switch (msg_type) {\n    case PJSTUN_BINDING_REQUEST:\n    case PJSTUN_BINDING_RESPONSE:\n    case PJSTUN_BINDING_ERROR_RESPONSE:\n    case PJSTUN_SHARED_SECRET_REQUEST:\n    case PJSTUN_SHARED_SECRET_RESPONSE:\n    case PJSTUN_SHARED_SECRET_ERROR_RESPONSE:\n\tbreak;\n    default:\n\tPJ_LOG(4,(THIS_FILE, \"Error: unknown msg type %d\", msg_type));\n\treturn PJLIB_UTIL_ESTUNINMSGTYPE;\n    }\n\n    msg_len = pj_ntohs(msg->hdr->length);\n    if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n\tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\", \n\t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n\treturn PJLIB_UTIL_ESTUNINMSGLEN;\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n\tlen = (len + 3) & ~3;\n\n\tif (msg_len < len) {\n\t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\", \n\t\t\t\t msg->attr_count));\n\t    return PJLIB_UTIL_ESTUNINATTRLEN;\n\t}\n\n\tattr_type = pj_ntohs((*attr)->type);\n\tif (attr_type > PJSTUN_ATTR_REFLECTED_FROM &&\n\t    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR)\n\t{\n\t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n\t\t\t\t \"Attribute was ignored.\",\n\t\t\t\t attr_type, msg->attr_count));\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-31031"
    },
    {
        "index": 459,
        "code": "bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                        socklen_t input_len, struct sockaddr *output,\n                        socklen_t *output_len,\n                        void (*abort_handler)(const char *)) {\n  if (!input || !output || !output_len || input_len == 0) {\n    output = nullptr;\n    return false;\n  }\n\n  int16_t klinux_family = input->klinux_sa_family;\n  if (klinux_family == kLinux_AF_UNIX) {\n    struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n        const_cast<struct klinux_sockaddr_un *>(\n            reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n\n    struct sockaddr_un sockaddr_un_out;\n    sockaddr_un_out.sun_family = AF_UNIX;\n    InitializeToZeroArray(sockaddr_un_out.sun_path);\n    ReinterpretCopyArray(\n        sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n        std::min(sizeof(sockaddr_un_out.sun_path),\n                 sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n    CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET) {\n    struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n        const_cast<struct klinux_sockaddr_in *>(\n            reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n\n    struct sockaddr_in sockaddr_in_out;\n    sockaddr_in_out.sin_family = AF_INET;\n    sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n    InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n    ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                          &klinux_sockaddr_in_in->klinux_sin_addr);\n    InitializeToZeroArray(sockaddr_in_out.sin_zero);\n    ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                         klinux_sockaddr_in_in->klinux_sin_zero);\n    CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET6) {\n    struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n        const_cast<struct klinux_sockaddr_in6 *>(\n            reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n\n    struct sockaddr_in6 sockaddr_in6_out;\n    sockaddr_in6_out.sin6_family = AF_INET6;\n    sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n    sockaddr_in6_out.sin6_flowinfo =\n        klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n    sockaddr_in6_out.sin6_scope_id =\n        klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n    InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n    ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                          &klinux_sockaddr_in6_in->klinux_sin6_addr);\n    CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                 output_len);\n  } else if (klinux_family == kLinux_AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message = absl::StrCat(\n          \"Type conversion error - Unsupported AF family: \", klinux_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8938"
    },
    {
        "index": 460,
        "code": "static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-33362"
    },
    {
        "index": 461,
        "code": "void ACSequentialScan::DecodeBlock(LONG *block,\n                                   LONG &prevdc,LONG &prevdiff,\n                                   UBYTE small,UBYTE large,UBYTE kx,UBYTE dc,UBYTE ac)\n{\n  // DC coding\n  if (m_ucScanStart == 0 && m_bResidual == false) {\n    LONG diff;\n    struct QMContextSet::DCContextZeroSet &cz = m_Context[dc].Classify(prevdiff,small,large);\n    // Check whether the difference is nonzero.\n    if (m_Coder.Get(cz.S0)) {\n      LONG sz;\n      bool sign = m_Coder.Get(cz.SS); // sign coding, is true for negative.\n      //\n      //\n      // Positive and negative are encoded in different contexts.\n      // Decode the magnitude cathegory.\n      if (m_Coder.Get((sign)?(cz.SN):(cz.SP))) {\n        int  i = 0;\n        LONG m = 2;\n        \n        while(m_Coder.Get(m_Context[dc].DCMagnitude.X[i])) {\n          m <<= 1;\n          i++;\n          if (m == 0) \n            JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                      \"QMDecoder is out of sync\");\n        }\n        //\n        // Get the MSB to decode.\n        m >>= 1;\n        sz  = m;\n        //\n        // Refinement coding of remaining bits.\n        while((m >>= 1)) {\n          if (m_Coder.Get(m_Context[dc].DCMagnitude.M[i])) {\n            sz |= m;\n          }\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done, finally, include the sign and the offset.\n      if (sign) {\n        diff = -sz - 1;\n      } else {\n        diff = sz + 1;\n      }\n    } else {\n      // Difference is zero.\n      diff = 0;\n    }\n\n    prevdiff = diff;\n    if (m_bDifferential) {\n      prevdc   = diff;\n    } else {\n      prevdc  += diff;\n    }\n    block[0] = prevdc << m_ucLowBit; // point transformation\n  }\n\n  if (m_ucScanStop) {\n    // AC coding. No block skipping used here.\n    int k = (m_ucScanStart)?(m_ucScanStart):((m_bResidual)?0:1);\n    //\n    // EOB decoding.\n    while(k <= m_ucScanStop && !m_Coder.Get(m_Context[ac].ACZero[k-1].SE)) {\n      LONG sz;\n      bool sign;\n      //\n      // Not yet EOB. Run coding in S0: Skip over zeros.\n      while(!m_Coder.Get(m_Context[ac].ACZero[k-1].S0)) {\n        k++;\n        if (k > m_ucScanStop)\n          JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                    \"QMDecoder is out of sync\");\n      }\n      //\n      // Now decode the sign of the coefficient.\n      // This happens in the uniform context.\n      sign = m_Coder.Get(m_Context[ac].Uniform);\n      //\n      // Decode the magnitude.\n      if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n        // X1 coding, identical to SN and SP.\n        if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n          int  i = 0;\n          LONG m = 4;\n          struct QMContextSet::ACContextMagnitudeSet &acm = (k > kx)?(m_Context[ac].ACMagnitudeHigh):(m_Context[ac].ACMagnitudeLow);\n          \n          while(m_Coder.Get(acm.X[i])) {\n            m <<= 1;\n            i++;\n            if (m == 0)\n              JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                        \"QMDecoder is out of sync\");\n          }\n          //\n          // Get the MSB to decode\n          m >>= 1;\n          sz  = m;\n          //\n          // Proceed to refinement.\n          while((m >>= 1)) {\n            if (m_Coder.Get(acm.M[i])) {\n              sz |= m;\n            }\n          }\n        } else {\n          sz = 1;\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done. Finally, include sign and offset.\n      sz++;\n      if (sign) \n        sz = -sz;\n      block[DCT::ScanOrder[k]] = sz << m_ucLowBit;\n      //\n      // Proceed to the next block.\n      k++;\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-31620"
    },
    {
        "index": 462,
        "code": "  void Compute(tensorflow::OpKernelContext* context) override {\n    for (int ngram_width : ngram_widths_) {\n      OP_REQUIRES(\n          context, ngram_width > 0,\n          errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n    }\n\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    if (splits_vec_size > 0) {\n      int prev_split = splits_vec(0);\n      OP_REQUIRES(context, prev_split == 0,\n                  errors::InvalidArgument(\"First split value must be 0, got \",\n                                          prev_split));\n      for (int i = 1; i < splits_vec_size; ++i) {\n        bool valid_splits = splits_vec(i) >= prev_split;\n        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n        OP_REQUIRES(context, valid_splits,\n                    errors::InvalidArgument(\n                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n                        prev_split, \", \", input_data_size, \"]\"));\n        prev_split = splits_vec(i);\n      }\n      OP_REQUIRES(context, prev_split == input_data_size,\n                  errors::InvalidArgument(\n                      \"Last split value must be data size. Expected \",\n                      input_data_size, \", got \", prev_split));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-21733"
    },
    {
        "index": 463,
        "code": "void SPECTRA::run( Session* session, const std::string& argument ){\n\n  /* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  */\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n  int resolution, tile, x, y;\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n  // Make sure our x,y coordinates are within the tile dimensions\n  if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||\n      y < 0 || y >= (int)(*session->image)->getTileHeight() ){\n    throw invalid_argument( \"SPECTRA :: Error: x,y coordinates outside of tile boundaries\" );\n  }\n  \n\n  TileManager tilemanager( session->tileCache, *session->image, session->watermark, session->jpeg, session->logfile, session->loglevel );\n\n  // Use our horizontal views function to get a list of available spectral images\n  list <int> views = (*session->image)->getHorizontalViewsList();\n  list <int> :: const_iterator i;\n\n  // Our list of spectral reflectance values for the requested point\n  list <float> spectrum;\n\n\n#ifndef DEBUG\n  // Output our HTTP header\n  stringstream header;\n  header << session->response->createHTTPHeader( \"xml\", (*session->image)->getTimestamp() );\n  session->out->putStr( (const char*) header.str().c_str(), header.tellp() );\n  session->out->flush();\n#endif\n\n  session->out->putS( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" );\n  session->out->putS( \"<spectra>\\n\" );\n  session->out->flush();\n\n  for( i = views.begin(); i != views.end(); i++ ){\n\n    int n = *i;\n\n    RawTile rawtile = tilemanager.getTile( resolution, tile, n, session->view->yangle, session->view->getLayers(), UNCOMPRESSED );\n\n    // Make sure our x,y coordinates are within the tile dimensions\n    if( x >= (int)rawtile.width || y >= (int)rawtile.height ){\n      if( session->loglevel >= 1 ){\n\t(*session->logfile) << \"SPECTRA :: Error: x,y coordinates outside of tile boundaries\" << endl;\n      }\n      break;\n    }\n\n\n    unsigned int tw = (*session->image)->getTileWidth();\n    unsigned int index = y*tw + x;\n\n    void *ptr;\n    float reflectance = 0.0;\n\n    if( session->loglevel >= 5 ) (*session->logfile) << \"SPECTRA :: \" << rawtile.bpc << \" bits per channel data\" << endl;\n\n    // Handle depending on bit depth\n    if( rawtile.bpc == 8 ){\n      ptr = (unsigned char*) (rawtile.data);\n      reflectance = static_cast<float>((float)((unsigned char*)ptr)[index]) / 255.0;\n    }\n    else if( rawtile.bpc == 16 ){\n      ptr = (unsigned short*) (rawtile.data);\n      reflectance = static_cast<float>((float)((unsigned short*)ptr)[index]) / 65535.0;\n    }\n    else if( rawtile.bpc == 32 ){\n      if( rawtile.sampleType == FIXEDPOINT ) {\n        ptr = (unsigned int*) rawtile.data;\n        reflectance = static_cast<float>((float)((unsigned int*)ptr)[index]);\n      }\n      else {\n        ptr = (float*) rawtile.data;\n        reflectance = static_cast<float>((float)((float*)ptr)[index]);\n      }\n    }\n\n    spectrum.push_front( reflectance );\n\n    string metadata = (*session->image)->getMetadata( \"subject\" );\n\n    char tmp[1024];\n    snprintf( tmp, 1024, \"\\t<point>\\n\\t\\t<wavelength>%d</wavelength>\\n\\t\\t<reflectance>%f</reflectance>\\n\\t</point>\\n\", n, reflectance );\n    session->out->putS( tmp );\n    session->out->flush();\n\n    if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA :: Band: \" << n << \", reflectance: \" << reflectance << endl;\n  }\n\n\n  session->out->putS( \"</spectra>\" );\n\n  if( session->out->flush() == -1 ) {\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"SPECTRA :: Error flushing XML\" << endl;\n    }\n  }\n\n\n  // Inform our response object that we have sent something to the client\n  session->response->setImageSent();\n\n  // Total SPECTRA response time\n  if( session->loglevel >= 2 ){\n    *(session->logfile) << \"SPECTRA :: Total command time \" << command_timer.getTime() << \" microseconds\" << endl;\n  }\n\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-46389"
    },
    {
        "index": 464,
        "code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41211"
    },
    {
        "index": 465,
        "code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   // original size\n    size_t dsize;                  // decoded size\n    unsigned char *buf = 0;\n\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\n\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36430"
    },
    {
        "index": 466,
        "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 467,
        "code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n\n    return 1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36278"
    },
    {
        "index": 468,
        "code": "njs_async_function_frame_invoke(njs_vm_t *vm, njs_value_t *retval)\n{\n    njs_int_t                 ret;\n    njs_value_t               ctor;\n    njs_native_frame_t        *frame;\n    njs_promise_capability_t  *capability;\n\n    frame = vm->top_frame;\n    frame->retval = retval;\n\n    njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);\n\n    capability = njs_promise_new_capability(vm, &ctor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n\n    frame->function->context = capability;\n\n    ret = njs_function_lambda_call(vm);\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&capability->resolve),\n                                &njs_value_undefined, retval, 1, &vm->retval);\n\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n\n        ret = njs_function_call(vm, njs_function(&capability->reject),\n                                &njs_value_undefined, &vm->retval, 1,\n                                &vm->retval);\n    }\n\n    *retval = capability->promise;\n\n    return ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-25139"
    },
    {
        "index": 469,
        "code": "do_arg_all(\n    int\tcount,\n    int\tforceit,\t\t// hide buffers in current windows\n    int keep_tabs)\t\t// keep current tabs, for \":tab drop file\"\n{\n    int\t\ti;\n    win_T\t*wp, *wpnext;\n    char_u\t*opened;\t// Array of weight for which args are open:\n\t\t\t\t//  0: not opened\n\t\t\t\t//  1: opened in other tab\n\t\t\t\t//  2: opened in curtab\n\t\t\t\t//  3: opened in curtab and curwin\n\t\t\t\t//\n    int\t\topened_len;\t// length of opened[]\n    int\t\tuse_firstwin = FALSE;\t// use first window for arglist\n    int\t\ttab_drop_empty_window = FALSE;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    alist_T\t*alist;\t\t// argument list to be used\n    buf_T\t*buf;\n    tabpage_T\t*tpnext;\n    int\t\thad_tab = cmdmod.cmod_tab;\n    win_T\t*old_curwin, *last_curwin;\n    tabpage_T\t*old_curtab, *last_curtab;\n    win_T\t*new_curwin = NULL;\n    tabpage_T\t*new_curtab = NULL;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn;\n    }\n#endif\n    if (ARGCOUNT <= 0)\n    {\n\t// Don't give an error message.  We don't want it when the \":all\"\n\t// command is in the .vimrc.\n\treturn;\n    }\n    setpcmark();\n\n    opened_len = ARGCOUNT;\n    opened = alloc_clear(opened_len);\n    if (opened == NULL)\n\treturn;\n\n    // Autocommands may do anything to the argument list.  Make sure it's not\n    // freed while we are working here by \"locking\" it.  We still have to\n    // watch out for its size to be changed.\n    alist = curwin->w_alist;\n    ++alist->al_refcount;\n\n    old_curwin = curwin;\n    old_curtab = curtab;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    // Try closing all windows that are not in the argument list.\n    // Also close windows that are not full width;\n    // When 'hidden' or \"forceit\" set the buffer becomes hidden.\n    // Windows that have a changed buffer and can't be hidden won't be closed.\n    // When the \":tab\" modifier was used do this for all tab pages.\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    buf = wp->w_buffer;\n\t    if (buf->b_ffname == NULL\n\t\t    || (!keep_tabs && (buf->b_nwindows > 1\n\t\t\t    || wp->w_width != Columns)))\n\t\ti = opened_len;\n\t    else\n\t    {\n\t\t// check if the buffer in this window is in the arglist\n\t\tfor (i = 0; i < opened_len; ++i)\n\t\t{\n\t\t    if (i < alist->al_ga.ga_len\n\t\t\t    && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum\n\t\t\t\t|| fullpathcmp(alist_name(&AARGLIST(alist)[i]),\n\t\t\t\t\tbuf->b_ffname, TRUE, TRUE) & FPC_SAME))\n\t\t    {\n\t\t\tint weight = 1;\n\n\t\t\tif (old_curtab == curtab)\n\t\t\t{\n\t\t\t    ++weight;\n\t\t\t    if (old_curwin == wp)\n\t\t\t\t++weight;\n\t\t\t}\n\n\t\t\tif (weight > (int)opened[i])\n\t\t\t{\n\t\t\t    opened[i] = (char_u)weight;\n\t\t\t    if (i == 0)\n\t\t\t    {\n\t\t\t\tif (new_curwin != NULL)\n\t\t\t\t    new_curwin->w_arg_idx = opened_len;\n\t\t\t\tnew_curwin = wp;\n\t\t\t\tnew_curtab = curtab;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (keep_tabs)\n\t\t\t    i = opened_len;\n\n\t\t\tif (wp->w_alist != alist)\n\t\t\t{\n\t\t\t    // Use the current argument list for all windows\n\t\t\t    // containing a file from it.\n\t\t\t    alist_unlink(wp->w_alist);\n\t\t\t    wp->w_alist = alist;\n\t\t\t    ++wp->w_alist->al_refcount;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    wp->w_arg_idx = i;\n\n\t    if (i == opened_len && !keep_tabs)// close this window\n\t    {\n\t\tif (buf_hide(buf) || forceit || buf->b_nwindows > 1\n\t\t\t\t\t\t\t|| !bufIsChanged(buf))\n\t\t{\n\t\t    // If the buffer was changed, and we would like to hide it,\n\t\t    // try autowriting.\n\t\t    if (!buf_hide(buf) && buf->b_nwindows <= 1\n\t\t\t\t\t\t\t && bufIsChanged(buf))\n\t\t    {\n\t\t\tbufref_T    bufref;\n\n\t\t\tset_bufref(&bufref, buf);\n\n\t\t\t(void)autowrite(buf, FALSE);\n\n\t\t\t// check if autocommands removed the window\n\t\t\tif (!win_valid(wp) || !bufref_valid(&bufref))\n\t\t\t{\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t    // don't close last window\n\t\t    if (ONE_WINDOW\n\t\t\t    && (first_tabpage->tp_next == NULL || !had_tab))\n\t\t\tuse_firstwin = TRUE;\n\t\t    else\n\t\t    {\n\t\t\twin_close(wp, !buf_hide(buf) && !bufIsChanged(buf));\n\n\t\t\t// check if autocommands removed the next window\n\t\t\tif (!win_valid(wpnext))\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\n\t// check if autocommands removed the next tab page\n\tif (!valid_tabpage(tpnext))\n\t    tpnext = first_tabpage;\t// start all over...\n\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    // Open a window for files in the argument list that don't have one.\n    // ARGCOUNT may change while doing this, because of autocommands.\n    if (count > opened_len || count <= 0)\n\tcount = opened_len;\n\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    ++autocmd_no_leave;\n    last_curwin = curwin;\n    last_curtab = curtab;\n    win_enter(lastwin, FALSE);\n    // \":tab drop file\" should re-use an empty window to avoid \"--remote-tab\"\n    // leaving an empty tab page when executed locally.\n    if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1\n\t\t\t    && curbuf->b_ffname == NULL && !curbuf->b_changed)\n    {\n\tuse_firstwin = TRUE;\n\ttab_drop_empty_window = TRUE;\n    }\n\n    for (i = 0; i < count && !got_int; ++i)\n    {\n\tif (alist == &global_alist && i == global_alist.al_ga.ga_len - 1)\n\t    arg_had_last = TRUE;\n\tif (opened[i] > 0)\n\t{\n\t    // Move the already present window to below the current window\n\t    if (curwin->w_arg_idx != i)\n\t    {\n\t\tFOR_ALL_WINDOWS(wpnext)\n\t\t{\n\t\t    if (wpnext->w_arg_idx == i)\n\t\t    {\n\t\t\tif (keep_tabs)\n\t\t\t{\n\t\t\t    new_curwin = wpnext;\n\t\t\t    new_curtab = curtab;\n\t\t\t}\n\t\t\telse if (wpnext->w_frame->fr_parent\n\t\t\t\t\t\t != curwin->w_frame->fr_parent)\n\t\t\t{\n\t\t\t    emsg(_(\"E249: window layout changed unexpectedly\"));\n\t\t\t    i = count;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse\n\t\t\t    win_move_after(wpnext, curwin);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (split_ret == OK)\n\t{\n\t    // trigger events for tab drop\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t--autocmd_no_enter;\n\t    if (!use_firstwin)\t\t// split current window\n\t    {\n\t\tp_ea_save = p_ea;\n\t\tp_ea = TRUE;\t\t// use space from all windows\n\t\tsplit_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t\tp_ea = p_ea_save;\n\t\tif (split_ret == FAIL)\n\t\t    continue;\n\t    }\n\t    else    // first window: do autocmd for leaving this buffer\n\t\t--autocmd_no_leave;\n\n\t    // edit file \"i\"\n\t    curwin->w_arg_idx = i;\n\t    if (i == 0)\n\t    {\n\t\tnew_curwin = curwin;\n\t\tnew_curtab = curtab;\n\t    }\n\t    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL,\n\t\t      ECMD_ONE,\n\t\t      ((buf_hide(curwin->w_buffer)\n\t\t\t   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)\n\t\t\t\t\t\t       + ECMD_OLDBUF, curwin);\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t++autocmd_no_enter;\n\t    if (use_firstwin)\n\t\t++autocmd_no_leave;\n\t    use_firstwin = FALSE;\n\t}\n\tui_breakcheck();\n\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n\n    // Remove the \"lock\" on the argument list.\n    alist_unlink(alist);\n\n    --autocmd_no_enter;\n\n    // restore last referenced tabpage's curwin\n    if (last_curtab != new_curtab)\n    {\n\tif (valid_tabpage(last_curtab))\n\t    goto_tabpage_tp(last_curtab, TRUE, TRUE);\n\tif (win_valid(last_curwin))\n\t    win_enter(last_curwin, FALSE);\n    }\n    // to window with first arg\n    if (valid_tabpage(new_curtab))\n\tgoto_tabpage_tp(new_curtab, TRUE, TRUE);\n    if (win_valid(new_curwin))\n\twin_enter(new_curwin, FALSE);\n\n    --autocmd_no_leave;\n    vim_free(opened);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-4166"
    },
    {
        "index": 470,
        "code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-24370"
    },
    {
        "index": 471,
        "code": "vector <string> genECDSAKey() {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint32_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());\n\n    vector <string> keys(3);\n\n    vector<char> hexEncrKey(BUF_LEN * 2, 0);\n\n    carray2Hex(encr_pr_key.data(), enc_len, hexEncrKey.data(),\n               BUF_LEN * 2);\n    keys.at(0) = hexEncrKey.data();\n    keys.at(1) = string(pub_key_x.data()) + string(pub_key_y.data());\n\n    vector<unsigned char> randBuffer(32, 0);\n    fillRandomBuffer(randBuffer);\n\n    vector<char> rand_str(BUF_LEN, 0);\n\n    carray2Hex(randBuffer.data(), 32, rand_str.data(), BUF_LEN);\n\n    keys.at(2) = rand_str.data();\n\n    CHECK_STATE(keys.at(2).size() == 64);\n\n    return keys;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 472,
        "code": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    /* Stop recursion: The inner Arrays are written */\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    /* Recurse to the next dimension */\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36429"
    },
    {
        "index": 473,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        regs[a] = mrb_hash_get(mrb, va, vb);\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      regs[a] = mrb_vm_const_get(mrb, syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      regs[a] = mrb_hash_get(mrb, kdict, k);\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      size_t len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_assert(mrb_hash_p(hash));\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0614"
    },
    {
        "index": 475,
        "code": "static void rose_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\t/* Magic here: If we listen() and a new link dies before it\n\t\t   is accepted() it isn't 'dead' so doesn't get removed. */\n\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\trose_destroy_socket(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase ROSE_STATE_3:\n\t\t/*\n\t\t * Check for the state of the receive buffer.\n\t\t */\n\t\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\n\t\t    (rose->condition & ROSE_COND_OWN_RX_BUSY)) {\n\t\t\trose->condition &= ~ROSE_COND_OWN_RX_BUSY;\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose->vl         = rose->vr;\n\t\t\trose_write_internal(sk, ROSE_RR);\n\t\t\trose_stop_timer(sk);\t/* HB */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\trose_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2318"
    },
    {
        "index": 476,
        "code": "ALWAYS_INLINE String serialize_impl(const Variant& value,\n                                    const SerializeOptions& opts) {\n  switch (value.getType()) {\n    case KindOfClass:\n    case KindOfLazyClass:\n    case KindOfPersistentString:\n    case KindOfString: {\n      auto const str =\n        isStringType(value.getType()) ? value.getStringData() :\n        isClassType(value.getType()) ? classToStringHelper(value.toClassVal()) :\n        lazyClassToStringHelper(value.toLazyClassVal());\n      auto const size = str->size();\n      if (size >= RuntimeOption::MaxSerializedStringSize) {\n        throw Exception(\"Size of serialized string (%d) exceeds max\", size);\n      }\n      StringBuffer sb;\n      sb.append(\"s:\");\n      sb.append(size);\n      sb.append(\":\\\"\");\n      sb.append(str->data(), size);\n      sb.append(\"\\\";\");\n      return sb.detach();\n    }\n    case KindOfResource:\n      return s_Res;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfFunc:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfDouble:\n    case KindOfObject:\n    case KindOfClsMeth:\n    case KindOfRClsMeth:\n    case KindOfRFunc:\n    case KindOfRecord:\n      break;\n  }\n  VariableSerializer vs(VariableSerializer::Type::Serialize);\n  if (opts.keepDVArrays)        vs.keepDVArrays();\n  if (opts.forcePHPArrays)      vs.setForcePHPArrays();\n  if (opts.warnOnHackArrays)    vs.setHackWarn();\n  if (opts.warnOnPHPArrays)     vs.setPHPWarn();\n  if (opts.ignoreLateInit)      vs.setIgnoreLateInit();\n  if (opts.serializeProvenanceAndLegacy) vs.setSerializeProvenanceAndLegacy();\n  // Keep the count so recursive calls to serialize() embed references properly.\n  return vs.serialize(value, true, true);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 477,
        "code": "Status Examples::Initialize(OpKernelContext* const context,\n                            const ModelWeights& weights,\n                            const int num_sparse_features,\n                            const int num_sparse_features_with_values,\n                            const int num_dense_features) {\n  num_features_ = num_sparse_features + num_dense_features;\n\n  OpInputList sparse_example_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_example_indices\",\n                                         &sparse_example_indices_inputs));\n  if (sparse_example_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_example_indices but got \",\n        sparse_example_indices_inputs.size());\n  OpInputList sparse_feature_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_indices\",\n                                         &sparse_feature_indices_inputs));\n  if (sparse_feature_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_feature_indices but got \",\n        sparse_feature_indices_inputs.size());\n  OpInputList sparse_feature_values_inputs;\n  if (num_sparse_features_with_values > 0) {\n    TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_values\",\n                                           &sparse_feature_values_inputs));\n    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)\n      return errors::InvalidArgument(\n          \"Expected \", num_sparse_features_with_values,\n          \" tensors in sparse_feature_values but got \",\n          sparse_feature_values_inputs.size());\n  }\n\n  const Tensor* example_weights_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_weights\", &example_weights_t));\n  auto example_weights = example_weights_t->flat<float>();\n\n  if (example_weights.size() >= std::numeric_limits<int>::max()) {\n    return errors::InvalidArgument(strings::Printf(\n        \"Too many examples in a mini-batch: %zu > %d\", example_weights.size(),\n        std::numeric_limits<int>::max()));\n  }\n\n  // The static_cast here is safe since num_examples can be at max an int.\n  const int num_examples = static_cast<int>(example_weights.size());\n  const Tensor* example_labels_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_labels\", &example_labels_t));\n  auto example_labels = example_labels_t->flat<float>();\n\n  OpInputList dense_features_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_features\", &dense_features_inputs));\n\n  examples_.clear();\n  examples_.resize(num_examples);\n  probabilities_.resize(num_examples);\n  sampled_index_.resize(num_examples);\n  sampled_count_.resize(num_examples);\n  for (int example_id = 0; example_id < num_examples; ++example_id) {\n    Example* const example = &examples_[example_id];\n    example->sparse_features_.resize(num_sparse_features);\n    example->dense_vectors_.resize(num_dense_features);\n    example->example_weight_ = example_weights(example_id);\n    example->example_label_ = example_labels(example_id);\n  }\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(\n      worker_threads, num_examples, num_sparse_features, weights,\n      sparse_example_indices_inputs, sparse_feature_indices_inputs,\n      sparse_feature_values_inputs, &examples_));\n  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(\n      worker_threads, num_examples, num_dense_features, weights,\n      dense_features_inputs, &examples_));\n  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(\n      worker_threads, num_examples, num_sparse_features, num_dense_features,\n      &examples_));\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37672"
    },
    {
        "index": 478,
        "code": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >= 32) {\n\t\treturn -1;\n\t}\n\tif (sps_id < 0) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 479,
        "code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    return IsSwitch(*input_node);\n  }\n  return false;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-23589"
    },
    {
        "index": 480,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n#if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n#endif\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#ifdef MRB_USE_BIGINT\n#define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n#else\n#define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n#endif\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1427"
    },
    {
        "index": 481,
        "code": "void print_summary(const MOBIData *m) {\n    char *title = mobi_meta_get_title(m);\n    if (title) {\n        printf(\"Title: %s\\n\", title);\n        free(title);\n    }\n    char *author = mobi_meta_get_author(m);\n    if (author) {\n        printf(\"Author: %s\\n\", author);\n        free(author);\n    }\n    char *contributor = mobi_meta_get_contributor(m);\n    uint32_t major = 0, minor = 0, build = 0;\n    bool is_calibre = false;\n    if (contributor) {\n        const char *calibre_contributor = \"calibre (\";\n        if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) {\n            is_calibre = true;\n            sscanf(contributor, \"calibre (%u.%u.%u)\", &major, &minor, &build);\n        } else {\n            printf(\"Contributor: %s\\n\", contributor);\n        }\n        free(contributor);\n    }\n    char *subject = mobi_meta_get_subject(m);\n    if (subject) {\n        printf(\"Subject: %s\\n\", subject);\n        free(subject);\n    }\n    char *publisher = mobi_meta_get_publisher(m);\n    if (publisher) {\n        printf(\"Publisher: %s\\n\", publisher);\n        free(publisher);\n    }\n    char *date = mobi_meta_get_publishdate(m);\n    if (date) {\n        printf(\"Publishing date: %s\\n\", date);\n        free(date);\n    }\n    char *description = mobi_meta_get_description(m);\n    if (description) {\n        printf(\"Description: %s\\n\", description);\n        free(description);\n    }\n    char *review = mobi_meta_get_review(m);\n    if (review) {\n        printf(\"Review: %s\\n\", review);\n        free(review);\n    }\n    char *imprint = mobi_meta_get_imprint(m);\n    if (imprint) {\n        printf(\"Imprint: %s\\n\", imprint);\n        free(imprint);\n    }\n    char *copyright = mobi_meta_get_copyright(m);\n    if (copyright) {\n        printf(\"Copyright: %s\\n\", copyright);\n        free(copyright);\n    }\n    char *isbn = mobi_meta_get_isbn(m);\n    if (isbn) {\n        printf(\"ISBN: %s\\n\", isbn);\n        free(isbn);\n    }\n    char *asin = mobi_meta_get_asin(m);\n    if (asin) {\n        printf(\"ASIN: %s\\n\", asin);\n        free(asin);\n    }\n    char *language = mobi_meta_get_language(m);\n    if (language) {\n        printf(\"Language: %s\", language);\n        free(language);\n        if (m->mh && m->mh->text_encoding) {\n            uint32_t encoding = *m->mh->text_encoding;\n            if (encoding == MOBI_CP1252) {\n                printf(\" (cp1252)\");\n            } else if (encoding == MOBI_UTF8) {\n                printf(\" (utf8)\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_dictionary(m)) {\n        printf(\"Dictionary\");\n        if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang &&\n            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {\n            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);\n            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);\n            printf(\": %s => %s\", locale_in, locale_out);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"__\\n\");\n    if (strcmp(m->ph->type, \"TEXt\") == 0) {\n        if (strcmp(m->ph->creator, \"TlDc\") == 0) {\n            printf(\"TealDoc\\n\");\n        } else {\n            printf(\"PalmDoc\\n\");\n        }\n    } else {\n        printf(\"Mobi version: %zu\", mobi_get_fileversion(m));\n        if (mobi_is_hybrid(m)) {\n            size_t version = mobi_get_fileversion(m->next);\n            if (version != MOBI_NOTSET) {\n                printf(\" (hybrid with version %zu)\", version);\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_replica(m)) {\n        printf(\"Print Replica\\n\");\n    }\n    if (mobi_is_encrypted(m)) {\n        printf(\"Document is encrypted\\n\");\n    }\n    if (is_calibre) {\n        printf(\"Creator software: calibre %u.%u.%u\\n\", major, minor, build);\n    } else {\n        MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT);\n        if (exth) {\n            printf(\"Creator software: \");\n            uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size);\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR);\n            if (exth) {\n                major = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR);\n            if (exth) {\n                minor = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD);\n            if (exth) {\n                build = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV);\n            if (major == 2 && minor == 9 && build == 0 && exth) {\n                char *rev = mobi_decode_exthstring(m, exth->data, exth->size);\n                if (rev) {\n                    if (strcmp(rev, \"0730-890adc2\") == 0) {\n                        is_calibre = true;\n                    }\n                    free(rev);\n                }\n            }\n            switch (creator) {\n                case 0:\n                    printf(\"mobipocket reader %u.%u.%u\", major, minor, build);\n                    break;\n                case 1:\n                case 101:\n                    printf(\"mobigen %u.%u.%u\", major, minor, build);\n                    break;\n                case 2:\n                    printf(\"mobipocket creator %u.%u.%u\", major, minor, build);\n                    break;\n                case 200:\n                    printf(\"kindlegen %u.%u.%u (windows)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 201:\n                    printf(\"kindlegen %u.%u.%u (linux)\", major, minor, build);\n                    if ((major == 1 && minor == 2 && build == 33307) ||\n                        (major == 2 && minor == 0 && build == 101) ||\n                        is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 202:\n                    printf(\"kindlegen %u.%u.%u (mac)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                default:\n                    printf(\"unknown\");\n                    break;\n            }\n            printf(\"\\n\");\n        }\n    }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2279"
    },
    {
        "index": 482,
        "code": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-44109"
    },
    {
        "index": 483,
        "code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    // Written using Wikipedia:\n    // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Miller%E2%80%93Rabin_test\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        // r \u2212 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; // \"composite\"\n    }\n\n    return true; // \"probably prime\"\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-27343"
    },
    {
        "index": 484,
        "code": "  void Compute(tensorflow::OpKernelContext* context) override {\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    for (int i = 0; i < splits_vec_size; ++i) {\n      bool valid_splits = splits_vec(i) >= 0;\n      valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n      OP_REQUIRES(\n          context, valid_splits,\n          errors::InvalidArgument(\"Invalid split value \", splits_vec(i),\n                                  \", must be in [0,\", input_data_size, \"]\"));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29542"
    },
    {
        "index": 485,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45932"
    },
    {
        "index": 487,
        "code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  // Now look in prototypes\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n\n  /* Check for builtins via separate function\n   * This way we save on RAM for built-ins because everything comes out of program code */\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n\n  /* We didn't get here if we found a child in the object itself, so\n   * if we're here then we probably have the wrong name - so for example\n   * with `a.b = c;` could end up setting `a.prototype.b` (bug #360)\n   *\n   * Also we might have got a built-in, which wouldn't have a name on it\n   * anyway - so in both cases, strip the name if it is there, and create\n   * a new name that references the object we actually requested the\n   * member from..\n   */\n  if (child && returnName) {\n    // Get rid of existing name\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    // create a new name\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n\n  // If not found and is the prototype, create it\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      // prototype is supposed to be an object\n      JsVar *proto = jsvNewObject();\n      // make sure it has a 'constructor' variable that points to the object it was part of\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n\n  return child;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-25044"
    },
    {
        "index": 488,
        "code": "static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->emsgs) {\n\t\t\t\tgf_isom_box_array_del(mov->emsgs);\n\t\t\t\tmov->emsgs = NULL;\n\t\t\t}\n#endif\n\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(mov->moof ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tif (trak) {\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\t\tcase GF_ISOM_BOX_TYPE_EMSG:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tif (!mov->emsgs) mov->emsgs = gf_list_new();\n\t\t\t\tgf_list_add(mov->emsgs, a);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_MFRA:\n\t\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\t\t//only keep for dump mode, otherwise we ignore these boxes and we don't want to carry them over in non-fragmented file\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\ttotSize += a->size;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29340"
    },
    {
        "index": 489,
        "code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37651"
    },
    {
        "index": 490,
        "code": "f_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\ttv = &list->lv_u.mat.lv_last->li_tv;\n\t\tactual = get_vim_var_str(VV_ERRMSG);\n\t\texpected = tv_get_string_buf_chk(tv, buf);\n\t\tif (!pattern_match(expected, actual, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    expected_str = expected;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2817"
    },
    {
        "index": 491,
        "code": "int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    int emulation_type, void *insn, int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt;\n\n\tif (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))\n\t\treturn 1;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\twrite_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tkvm_clear_exception_queue(vcpu);\n\n\t\tr = x86_decode_emulated_instruction(vcpu, emulation_type,\n\t\t\t\t\t\t    insn, insn_len);\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif ((emulation_type & EMULTYPE_TRAP_UD) ||\n\t\t\t    (emulation_type & EMULTYPE_TRAP_UD_FORCED)) {\n\t\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (reexecute_instruction(vcpu, cr2_or_gpa,\n\t\t\t\t\t\t  write_fault_to_spt,\n\t\t\t\t\t\t  emulation_type))\n\t\t\t\treturn 1;\n\t\t\tif (ctxt->have_exception) {\n\t\t\t\t/*\n\t\t\t\t * #UD should result in just EMULATION_FAILED, and trap-like\n\t\t\t\t * exception should not be encountered during decode.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||\n\t\t\t\t\t     exception_type(ctxt->exception.vector) == EXCPT_TRAP);\n\t\t\t\tinject_emulated_exception(vcpu);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t\t}\n\t}\n\n\tif ((emulation_type & EMULTYPE_VMWARE_GP) &&\n\t    !is_vmware_backdoor_opcode(ctxt)) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for\n\t * use *only* by vendor callbacks for kvm_skip_emulated_instruction().\n\t * The caller is responsible for updating interruptibility state and\n\t * injecting single-step #DBs.\n\t */\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tctxt->eip = (u32)ctxt->_eip;\n\t\telse\n\t\t\tctxt->eip = ctxt->_eip;\n\n\t\tif (emulation_type & EMULTYPE_COMPLETE_USER_EXIT) {\n\t\t\tr = 1;\n\t\t\tgoto writeback;\n\t\t}\n\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn 1;\n\t}\n\n\tif (retry_instruction(ctxt, cr2_or_gpa, emulation_type))\n\t\treturn 1;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tif (emulation_type & EMULTYPE_PF) {\n\t\t/* Save the faulting GPA (cr2) in the address field */\n\t\tctxt->exception.address = cr2_or_gpa;\n\n\t\t/* With shadow page tables, cr2 contains a GVA or nGPA. */\n\t\tif (vcpu->arch.mmu->root_role.direct) {\n\t\t\tctxt->gpa_available = true;\n\t\t\tctxt->gpa_val = cr2_or_gpa;\n\t\t}\n\t} else {\n\t\t/* Sanitize the address out of an abundance of paranoia. */\n\t\tctxt->exception.address = 0;\n\t}\n\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn 1;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn 1;\n\n\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = 1;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = 0;\n\t} else if (vcpu->mmio_needed) {\n\t\t++vcpu->stat.mmio_exits;\n\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = 0;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (vcpu->arch.complete_userspace_io) {\n\t\twriteback = false;\n\t\tr = 0;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = 1;\n\nwriteback:\n\tif (writeback) {\n\t\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {\n\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\t\t\tif (ctxt->is_branch)\n\t\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\t\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\t\tif (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))\n\t\t\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\t\t\tstatic_call_cond(kvm_x86_update_emulated_instruction)(vcpu);\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\t\t}\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1852"
    },
    {
        "index": 492,
        "code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32055"
    },
    {
        "index": 493,
        "code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  // If we don't have rank information on the input or value information on\n  // perm we can't return any shape information, otherwise we have enough\n  // information to at least find the rank of the output.\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n\n  // Find our value of the rank.\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    // A permutation array containing a single element is ambiguous. It could\n    // indicate either a scalar or a 1-dimensional array, both of which the\n    // transpose op returns unchanged.\n    c->set_output(0, input);\n    return Status::OK();\n  }\n\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  // Ensure that perm is a vector and has rank elements.\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n\n  // If we know the rank of the input and the value of perm, we can return\n  // all shape information, otherwise we can only return rank information,\n  // but no information for the dimensions.\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41216"
    },
    {
        "index": 494,
        "code": "log_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 495,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n                    \"Matrix size incompatible: a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice, float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor> a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_) {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value) {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n                        a_float->flat<float>().data(), a.NumElements());\n        left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value) {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n                        b_float->flat<float>().data(), b.NumElements());\n        right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>()) =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n      std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n      // TODO(agarwal): avoid transposing the matrix here and directly handle\n      // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1), right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output) {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n                                right->matrix<TL>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    } else {\n      DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                                right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41219"
    },
    {
        "index": 496,
        "code": "static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segments_enabled_flag\");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \"num_extra_slice_header_bits\");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \"sign_data_hiding_flag\");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"cabac_init_present_flag\");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active\");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active\");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \"pic_init_qp_minus26\");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \"constrained_intra_pred_flag\");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"transform_skip_enabled_flag\");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"cu_qp_delta_enabled_flag\")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \"diff_cu_qp_delta_depth\");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \"pic_cb_qp_offset\");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \"pic_cr_qp_offset\");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"slice_chroma_qp_offsets_present_flag\");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"weighted_bipred_flag\");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \"transquant_bypass_enable_flag\");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"tiles_enabled_flag\");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_tile_columns_minus1\");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_tile_rows_minus1\");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \"uniform_spacing_flag\");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \"column_width_minus1\", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \"row_height_minus1\", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_tiles_enabled_flag\");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \"loop_filter_across_slices_enabled_flag\");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\"))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_enabled_flag\");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \"pic_disable_deblocking_filter_flag\"))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \"beta_offset_div2\");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \"tc_offset_div2\");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \"pic_scaling_list_data_present_flag\"))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \"lists_modification_present_flag\");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \"log2_parallel_merge_level_minus2\");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"slice_segment_header_extension_present_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 497,
        "code": "void Scan::CreateParser(void)\n{\n  ScanType type = m_pFrame->ScanTypeOf();\n  //\n  assert(m_pParser == NULL);\n  //\n  switch(type) {\n  case Baseline:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,\n                                                     false,false,false,true);\n    break;\n  case Sequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits);\n    break;\n  case DifferentialSequential:\n    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                     m_ucScanStart,m_ucScanStop,\n                                                     m_ucLowBit + m_ucHiddenBits,\n                                                     m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Lossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,m_ucScanStart,\n                                                   m_ucLowBit + m_ucHiddenBits);\n    break;\n  case DifferentialLossless:\n    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,0,\n                                                   m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,m_ucScanStart,\n                                                     m_ucLowBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialLossless:\n    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,0,\n                                                     m_ucLowBit + m_ucHiddenBits,true);\n    break;\n  case ACSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    break;\n  case ACDifferentialSequential:\n    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    break;\n  case Progressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ResidualProgressive:\n    if (m_ucHighBit == 0) { \n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    } else { \n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,\n                                                       true,true);\n    }\n    break;\n  case DifferentialProgressive:\n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    } else { \n      // Even though the specs do not mention this, it makes perfect sense that the\n      // refinement scan is a regular refinement scan without modification.\n      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this,\n                                                       m_ucScanStart,m_ucScanStop,\n                                                       m_ucLowBit + m_ucHiddenBits,\n                                                       m_ucHighBit + m_ucHiddenBits,true);\n    }\n    break;\n  case ACProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits);\n    }\n    break;\n  case ACDifferentialProgressive: \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         true);\n    }\n    break;\n  case ACResidualProgressive:  \n    if (m_ucHighBit == 0) { // The first scan is parsed off by the regular parser.\n      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    } else { \n      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this,\n                                                         m_ucScanStart,m_ucScanStop,\n                                                         m_ucLowBit + m_ucHiddenBits,\n                                                         m_ucHighBit + m_ucHiddenBits,\n                                                         false,true);\n    }\n    break;\n  case Residual:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               true,true);\n    break;\n  case ACResidual:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 true,true);  \n    break;\n  case ResidualDCT:\n    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this,\n                                               m_ucScanStart,m_ucScanStop,\n                                               m_ucLowBit + m_ucHiddenBits,\n                                               m_ucHighBit + m_ucHiddenBits,\n                                               false,false,true);\n    break; \n  case ACResidualDCT:\n    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this,\n                                                 m_ucScanStart,m_ucScanStop,\n                                                 m_ucLowBit + m_ucHiddenBits,\n                                                 m_ucHighBit + m_ucHiddenBits,\n                                                 false,false,true);\n    break;\n  case JPEG_LS:\n    // Depends on the interleaving\n    switch(m_ucScanStop) {\n    case 0:\n      if (m_ucCount != 1)\n        JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n                  \"invalid codestream, found a single comonent scan containing more than one component\");\n      m_pParser = new(m_pEnviron) class SingleComponentLSScan(m_pFrame,this,\n                                                              m_ucScanStart, // NEAR\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits); \n      break;\n    case 1:\n      m_pParser = new(m_pEnviron) class LineInterleavedLSScan(m_pFrame,this,\n                                                              m_ucScanStart,\n                                                              m_ucMappingTable,\n                                                              m_ucLowBit + m_ucHiddenBits);\n      break;\n    case 2:\n      m_pParser = new(m_pEnviron) class SampleInterleavedLSScan(m_pFrame,this,\n                                                                m_ucScanStart,\n                                                                m_ucMappingTable,\n                                                                m_ucLowBit + m_ucHiddenBits);\n      break;\n    }\n    break;\n  default:\n    JPG_THROW(NOT_IMPLEMENTED,\"Scan::CreateParser\",\n              \"sorry, the coding mode in the codestream is currently not supported\");\n  }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-32201"
    },
    {
        "index": 498,
        "code": "compile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    char_u\t*line_to_free = NULL;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tvim_free(line_to_free);\n\t\tline_to_free = line;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon || !(*cmd == '\\''\n\t\t       || (cmd[0] == cmd[1] && (*cmd == '+' || *cmd == '-')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &line_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    vim_free(line_to_free);\n    free_imported(&cctx);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0128"
    },
    {
        "index": 499,
        "code": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * Setup a pipe to send logs to the parent. This should happen\n\t * first, because bail will use that pipe.\n\t */\n\tsetup_logpipe();\n\n\t/*\n\t * Get the init pipe fd from the environment. The init pipe is used to\n\t * read the bootstrap data and tell the parent what the new pids are\n\t * after the setup is done.\n\t */\n\tpipenum = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (pipenum < 0) {\n\t\t/* We are not a runc init. Just return to go runtime. */\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/*\n\t * Inform the parent we're past initial setup.\n\t * For the other side of this, see initWaiter.\n\t */\n\tif (write(pipenum, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(DEBUG, \"=> nsexec container setup\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\twrite_log(DEBUG, \"set process as non-dumpable\");\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tcurrent_stage = setjmp(env);\n\tswitch (current_stage) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: STAGE_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase STAGE_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t stage1_pid = -1, stage2_pid = -1;\n\t\t\tbool stage1_complete, stage2_complete;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-0\");\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\twrite_log(DEBUG, \"spawn stage-1\");\n\t\t\tstage1_pid = clone_parent(&env, STAGE_CHILD);\n\t\t\tif (stage1_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children. We only\n\t\t\t * return once both the child and grandchild are ready.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"-> stage-1 synchronisation loop\");\n\t\t\tstage1_complete = false;\n\t\t\twhile (!stage1_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(stage1_pid, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* Get the stage-2 pid. */\n\t\t\t\t\tif (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send both the stage-1 and stage-2 pids back to runc.\n\t\t\t\t\t * runc needs the stage-2 to continue process management,\n\t\t\t\t\t * but because stage-1 was spawned with CLONE_PARENT we\n\t\t\t\t\t * cannot reap it within stage-0 and thus we need to ask\n\t\t\t\t\t * runc to reap the zombie for us.\n\t\t\t\t\t */\n\t\t\t\t\twrite_log(DEBUG, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  stage1_pid, stage2_pid);\n\t\t\t\t\tlen =\n\t\t\t\t\t    dprintf(pipenum, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", stage1_pid,\n\t\t\t\t\t\t    stage2_pid);\n\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 complete\");\n\t\t\t\t\tstage1_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* Now sync with grandchild. */\n\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(DEBUG, \"-> stage-2 synchronisation loop\");\n\t\t\tstage2_complete = false;\n\t\t\twhile (!stage2_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\twrite_log(DEBUG, \"signalling stage-2 to run\");\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-2 complete\");\n\t\t\t\t\tstage2_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all of\n\t\t *          the requested namespaces. If we've been asked to CLONE_NEWUSER,\n\t\t *          we will ask our parent (stage 0) to set up our user mappings\n\t\t *          for us. Then, we create a new child (stage 2: STAGE_INIT) for\n\t\t *          PID namespace. We then send the child's PID to our parent\n\t\t *          (stage 0).\n\t\t */\n\tcase STAGE_CHILD:{\n\t\t\tpid_t stage2_pid = -1;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tif (close(sync_child_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-1\");\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: STAGE_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\twrite_log(DEBUG, \"unshare user namespace\");\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We need to set ourselves as dumpable temporarily so that the\n\t\t\t\t * parent process can write to our procfs files.\n\t\t\t\t */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal stage-0 to do the mapping for\n\t\t\t\t * us.\n\t\t\t\t */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\n\t\t\t\t/* Revert temporary re-dumpable setting. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"spawn stage-2\");\n\t\t\tstage2_pid = clone_parent(&env, STAGE_INIT);\n\t\t\tif (stage2_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\twrite_log(DEBUG, \"request stage-0 to forward stage-2 pid (%d)\", stage2_pid);\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: STAGE_INIT] is doing the rest of the work. */\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase STAGE_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tif (close(sync_grandchild_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-2\");\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\twrite_log(DEBUG, \"<= nsexec container setup\");\n\t\t\twrite_log(DEBUG, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", current_stage);\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-43784"
    },
    {
        "index": 500,
        "code": "bool MemFile::seek(int64_t offset, int whence /* = SEEK_SET */) {\n  assertx(m_len != -1);\n  if (whence == SEEK_CUR) {\n    if (offset > 0 && offset < bufferedLen()) {\n      setReadPosition(getReadPosition() + offset);\n      setPosition(getPosition() + offset);\n      return true;\n    }\n    offset += getPosition();\n    whence = SEEK_SET;\n  }\n\n  // invalidate the current buffer\n  setWritePosition(0);\n  setReadPosition(0);\n  if (whence == SEEK_SET) {\n    m_cursor = offset;\n  } else {\n    assertx(whence == SEEK_END);\n    m_cursor = m_len + offset;\n  }\n  setPosition(m_cursor);\n  return true;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 501,
        "code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    /* We memory copy to the pixel map so the endianness is preserved */\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-33657"
    },
    {
        "index": 502,
        "code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-32765"
    },
    {
        "index": 503,
        "code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41556"
    },
    {
        "index": 504,
        "code": "goto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 505,
        "code": "static int exif_scan_thumbnail(image_info_type *ImageInfo) {\n  unsigned char c, *data = (unsigned char*)ImageInfo->Thumbnail.data;\n  int n, marker;\n  size_t length=2, pos=0;\n  jpeg_sof_info sof_info;\n\n  if (!data || ImageInfo->Thumbnail.size < 4) {\n    return 0; /* nothing to do here */\n  }\n  if (memcmp(data, \"\\xFF\\xD8\\xFF\", 3)) {\n    if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {\n      raise_warning(\"Thumbnail is not a JPEG image\");\n    }\n    return 0;\n  }\n  for (;;) {\n    pos += length;\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    c = data[pos++];\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    if (c != 0xFF) {\n      return 0;\n    }\n    n = 8;\n    while ((c = data[pos++]) == 0xFF && n--) {\n      if (pos+3>=ImageInfo->Thumbnail.size)\n        return 0;\n      /* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n    }\n    if (c == 0xFF)\n      return 0;\n    marker = c;\n    length = php_jpg_get16(data+pos);\n    if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {\n      return 0;\n    }\n    switch (marker) {\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        /* handle SOFn block */\n        if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {\n          /* exif_process_SOFn needs 8 bytes */\n          return 0;\n        }\n        exif_process_SOFn(data+pos, marker, &sof_info);\n        ImageInfo->Thumbnail.height   = sof_info.height;\n        ImageInfo->Thumbnail.width    = sof_info.width;\n        return 1;\n\n      case M_SOS:\n      case M_EOI:\n        raise_warning(\"Could not compute size of thumbnail\");\n        return 0;\n        break;\n\n      default:\n        /* just skip */\n        break;\n    }\n  }\n\n  raise_warning(\"Could not compute size of thumbnail\");\n  return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 507,
        "code": "irc_mode_channel_update (struct t_irc_server *server,\n                         struct t_irc_channel *channel,\n                         char set_flag,\n                         char chanmode,\n                         const char *argument)\n{\n    char *pos_args, *str_modes, **argv, *pos, *ptr_arg;\n    char *new_modes, *new_args, str_mode[2], *str_temp;\n    int argc, current_arg, chanmode_found, length;\n\n    if (!channel->modes)\n        channel->modes = strdup (\"+\");\n    if (!channel->modes)\n        return;\n\n    argc = 0;\n    argv = NULL;\n    pos_args = strchr (channel->modes, ' ');\n    if (pos_args)\n    {\n        str_modes = weechat_strndup (channel->modes, pos_args - channel->modes);\n        if (!str_modes)\n            return;\n        pos_args++;\n        while (pos_args[0] == ' ')\n            pos_args++;\n        argv = weechat_string_split (pos_args, \" \", NULL,\n                                     WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                     | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                     | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                     0, &argc);\n    }\n    else\n    {\n        str_modes = strdup (channel->modes);\n        if (!str_modes)\n            return;\n    }\n\n    new_modes = malloc (strlen (channel->modes) + 1 + 1);\n    new_args = malloc (((pos_args) ? strlen (pos_args) : 0)\n                       + ((argument) ? 1 + strlen (argument) : 0) + 1);\n    if (new_modes && new_args)\n    {\n        new_modes[0] = '\\0';\n        new_args[0] = '\\0';\n\n        /* loop on current modes and build \"new_modes\" + \"new_args\" */\n        current_arg = 0;\n        chanmode_found = 0;\n        pos = str_modes;\n        while (pos && pos[0])\n        {\n            if ((pos[0] == '+') || (pos[0] == '-'))\n            {\n                str_mode[0] = pos[0];\n                str_mode[1] = '\\0';\n                strcat (new_modes, str_mode);\n            }\n            else\n            {\n                ptr_arg = NULL;\n                switch (irc_mode_get_chanmode_type (server, pos[0]))\n                {\n                    case 'A': /* always argument */\n                    case 'B': /* always argument */\n                    case 'C': /* argument if set */\n                        ptr_arg = (current_arg < argc) ?\n                            argv[current_arg] : NULL;\n                        break;\n                    case 'D': /* no argument */\n                        break;\n                }\n                if (ptr_arg)\n                    current_arg++;\n                if (pos[0] == chanmode)\n                {\n                    chanmode_found = 1;\n                    if (set_flag == '+')\n                    {\n                        str_mode[0] = pos[0];\n                        str_mode[1] = '\\0';\n                        strcat (new_modes, str_mode);\n                        if (argument)\n                        {\n                            if (new_args[0])\n                                strcat (new_args, \" \");\n                            strcat (new_args, argument);\n                        }\n                    }\n                }\n                else\n                {\n                    str_mode[0] = pos[0];\n                    str_mode[1] = '\\0';\n                    strcat (new_modes, str_mode);\n                    if (ptr_arg)\n                    {\n                        if (new_args[0])\n                            strcat (new_args, \" \");\n                        strcat (new_args, ptr_arg);\n                    }\n                }\n            }\n            pos++;\n        }\n        if (!chanmode_found)\n        {\n            /*\n             * chanmode was not in channel modes: if set_flag is '+', add\n             * it to channel modes\n             */\n            if (set_flag == '+')\n            {\n                if (argument)\n                {\n                    /* add mode with argument at the end of modes */\n                    str_mode[0] = chanmode;\n                    str_mode[1] = '\\0';\n                    strcat (new_modes, str_mode);\n                    if (new_args[0])\n                        strcat (new_args, \" \");\n                    strcat (new_args, argument);\n                }\n                else\n                {\n                    /* add mode without argument at the beginning of modes */\n                    pos = new_modes;\n                    while (pos[0] == '+')\n                        pos++;\n                    memmove (pos + 1, pos, strlen (pos) + 1);\n                    pos[0] = chanmode;\n                }\n            }\n        }\n        if (new_args[0])\n        {\n            length = strlen (new_modes) + 1 + strlen (new_args) + 1;\n            str_temp = malloc (length);\n            if (str_temp)\n            {\n                snprintf (str_temp, length, \"%s %s\", new_modes, new_args);\n                if (channel->modes)\n                    free (channel->modes);\n                channel->modes = str_temp;\n            }\n        }\n        else\n        {\n            if (channel->modes)\n                free (channel->modes);\n            channel->modes = strdup (new_modes);\n        }\n    }\n\n    if (new_modes)\n        free (new_modes);\n    if (new_args)\n        free (new_args);\n    if (str_modes)\n        free (str_modes);\n    if (argv)\n        weechat_string_free_split (argv);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8955"
    },
    {
        "index": 508,
        "code": "njs_function_frame_invoke(njs_vm_t *vm, njs_value_t *retval)\n{\n    njs_native_frame_t  *frame;\n\n    frame = vm->top_frame;\n    frame->retval = retval;\n\n    if (njs_function_object_type(vm, frame->function)\n        == NJS_OBJ_TYPE_ASYNC_FUNCTION)\n    {\n        return njs_async_function_frame_invoke(vm, retval);\n    }\n\n    if (frame->native) {\n        return njs_function_native_call(vm);\n\n    } else {\n        return njs_function_lambda_call(vm);\n    }\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-25139"
    },
    {
        "index": 509,
        "code": "static bool is_vmware_backdoor_opcode(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->opcode_len) {\n\tcase 1:\n\t\tswitch (ctxt->b) {\n\t\tcase 0xe4:\t/* IN */\n\t\tcase 0xe5:\n\t\tcase 0xec:\n\t\tcase 0xed:\n\t\tcase 0xe6:\t/* OUT */\n\t\tcase 0xe7:\n\t\tcase 0xee:\n\t\tcase 0xef:\n\t\tcase 0x6c:\t/* INS */\n\t\tcase 0x6d:\n\t\tcase 0x6e:\t/* OUTS */\n\t\tcase 0x6f:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (ctxt->b) {\n\t\tcase 0x33:\t/* RDPMC */\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1852"
    },
    {
        "index": 511,
        "code": "R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaElementValuePair *evp = NULL;\n\tif (!annotation) {\n\t\t// TODO eprintf invalid annotation\n\t\treturn;\n\t}\n\tprintf (\"  Annotation Type Index: 0x%02x\\n\", annotation->type_idx);\n\tprintf (\"  Annotation Number of EV Pairs: 0x%04x\\n\", annotation->num_element_value_pairs);\n\tprintf (\"  Annotation EV Pair Values:\\n\");\n\tif (annotation->element_value_pairs) {\n\t\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, evp) {\n\t\t\tr_bin_java_print_element_pair_summary (evp);\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 512,
        "code": "int flag2str_sh(int flag, char *flag_str) {\n    if (flag & 0x1)\n        flag_str[2] = 'W';\n    if (flag >> 1 & 0x1)\n        flag_str[1] = 'A';\n    if (flag >> 2 & 0x1)\n        flag_str[0] = 'E';\n    \n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21711"
    },
    {
        "index": 513,
        "code": "static SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n\n    /* Background color */\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n\n    /* Underline/Strikethrough color style */\n    *color = bgcolor | (fg.a << 24);\n\n    /* Create the target surface if required */\n    if (width != 0) {\n        /* Create a surface with memory:\n         * - pitch is rounded to alignment\n         * - adress is aligned\n         */\n        Sint64 size;\n        void *pixels, *ptr;\n        /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n        Sint64 pitch = (width + alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            /* Overflow... */\n            return NULL;\n        }\n\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n\n        /* address is aligned */\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n\n        /* Let SDL handle the memory allocation */\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n\n        /* Initialize with fg and 0 alpha */\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n\n        /* Support alpha blending */\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n\n    return textbuf;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27470"
    },
    {
        "index": 514,
        "code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  // Swap data begins 164 chars into data buffer:\n  // offset = deposit function hash + address + address + uint256\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    // String length must be < 255 characters\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-31616"
    },
    {
        "index": 515,
        "code": "static int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                           size_t *out_len, const unsigned char *key,\n                           size_t key_len)\n{\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    ASN1_OBJECT *crypt_params_obj = (pkey_nid == NID_id_GostR3410_2001 || pkey_nid == NID_id_GostR3410_2001DH) ?\n        OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet) :\n        OBJ_nid2obj(NID_id_tc26_gost_28147_param_Z);\n    const struct gost_cipher_info *param =\n        get_encryption_params(crypt_params_obj);\n    unsigned char ukm[8], shared_key[32], crypted_key[44];\n    int ret = 0;\n    int key_is_ephemeral = 1;\n    gost_ctx cctx;\n    EVP_PKEY *sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (data->shared_ukm_size) {\n        memcpy(ukm, data->shared_ukm, 8);\n    } else {\n        if (RAND_bytes(ukm, 8) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_RNG_ERROR);\n            return 0;\n        }\n    }\n    if (!param)\n        goto err;\n    /* Check for private key in the peer_key of context */\n    if (sec_key) {\n        key_is_ephemeral = 0;\n        if (!gost_get0_priv_key(sec_key)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_NO_PRIVATE_PART_OF_NON_EPHEMERAL_KEYPAIR);\n            goto err;\n        }\n    } else {\n        key_is_ephemeral = 1;\n        if (out) {\n            sec_key = EVP_PKEY_new();\n            if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n                || !EVP_PKEY_copy_parameters(sec_key, pubk)\n                || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n                GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                        GOST_R_ERROR_COMPUTING_SHARED_KEY);\n                goto err;\n            }\n        }\n    }\n    if (out) {\n        int dgst_nid = NID_undef;\n        EVP_PKEY_get_default_digest_nid(pubk, &dgst_nid);\n        if (dgst_nid == NID_id_GostR3411_2012_512)\n            dgst_nid = NID_id_GostR3411_2012_256;\n\n        if (!VKO_compute_key(shared_key,\n                             EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                             EVP_PKEY_get0(sec_key), ukm, 8, dgst_nid)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_ERROR_COMPUTING_SHARED_KEY);\n            goto err;\n        }\n        gost_init(&cctx, param->sblock);\n        keyWrapCryptoPro(&cctx, shared_key, ukm, key, crypted_key);\n    }\n    gkt = GOST_KEY_TRANSPORT_new();\n    if (!gkt) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_agreement_info->eph_iv, ukm, 8)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_info->imit, crypted_key + 40, 4)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set\n        (gkt->key_info->encrypted_key, crypted_key + 8, 32)) {\n        goto err;\n    }\n    if (key_is_ephemeral) {\n        if (!X509_PUBKEY_set\n            (&gkt->key_agreement_info->ephem_key, out ? sec_key : pubk)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n            goto err;\n        }\n    }\n    ASN1_OBJECT_free(gkt->key_agreement_info->cipher);\n    gkt->key_agreement_info->cipher = OBJ_nid2obj(param->nid);\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    if (!key_is_ephemeral) {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt, out ? &out : NULL)) > 0)\n        ret = 1;\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n err:\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29242"
    },
    {
        "index": 516,
        "code": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24764"
    },
    {
        "index": 517,
        "code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3888"
    },
    {
        "index": 518,
        "code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        // out of memory\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 519,
        "code": "void RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \"elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37639"
    },
    {
        "index": 520,
        "code": "  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n\n    const Tensor* stats_summary_indices_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary_indices\",\n                                           &stats_summary_indices_t));\n    const auto stats_summary_indices = stats_summary_indices_t->matrix<int32>();\n    const int32_t num_sparse_entries = stats_summary_indices_t->dim_size(0);\n\n    const Tensor* stats_summary_values_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary_values\",\n                                           &stats_summary_values_t));\n    const auto stats_summary_values = stats_summary_values_t->vec<float>();\n\n    const Tensor* stats_summary_shape_t;\n    OP_REQUIRES_OK(\n        context, context->input(\"stats_summary_shape\", &stats_summary_shape_t));\n    const auto stats_summary_shape = stats_summary_shape_t->vec<int32>();\n    const int32_t num_buckets = stats_summary_shape(2) - 1;\n    const int32_t stats_dims = stats_summary_shape(3);\n\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<float> output_left_node_contribs;\n    std::vector<float> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    FeatureMap f_map;\n\n    int32_t previous_node_id = -1;\n    for (int idx = 0; idx < num_sparse_entries; ++idx) {\n      int32_t node_id = stats_summary_indices(idx, 0);\n      if (node_id != previous_node_id) {\n        process_node(f_map, &output_node_ids, &output_gains,\n                     &output_feature_dimensions, &output_thresholds,\n                     &output_left_node_contribs, &output_right_node_contribs,\n                     &output_split_types, previous_node_id, min_node_weight, l1,\n                     l2, num_buckets);\n        f_map.clear();\n      }\n      previous_node_id = node_id;\n      DCHECK_LE(node_id_first, node_id);\n      DCHECK_LT(node_id, node_id_last);\n      const int32_t feature_dim = stats_summary_indices(idx, 1);\n      const int32_t bucket_id = stats_summary_indices(idx, 2);\n      const int32_t stat_dim = stats_summary_indices(idx, 3);\n      std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(\n          FeatureMapIterator::value_type(feature_dim, BucketMap()));\n      auto& b_map = f_insert_result.first->second;\n      std::pair<BucketMapIterator, bool> const& b_insert_result =\n          b_map.insert(BucketMapIterator::value_type(\n              bucket_id, std::vector<float>(stats_dims)));\n      auto& stats = b_insert_result.first->second;\n      stats[stat_dim] = stats_summary_values(idx);\n    }  // for node_id\n    // process the last node id\n    process_node(f_map, &output_node_ids, &output_gains,\n                 &output_feature_dimensions, &output_thresholds,\n                 &output_left_node_contribs, &output_right_node_contribs,\n                 &output_split_types, previous_node_id, min_node_weight, l1, l2,\n                 num_buckets);\n\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"left_node_contribs\", {num_nodes, 1},\n                                          &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"right_node_contribs\", {num_nodes, 1},\n                                          &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      // TODO(crawles): change this for multi-class.\n      output_left_node_contribs_matrix(i, 0) = output_left_node_contribs[i];\n      output_right_node_contribs_matrix(i, 0) = output_right_node_contribs[i];\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37664"
    },
    {
        "index": 521,
        "code": "void trustedSetSEK(int *errStatus, char *errString, uint8_t *encrypted_sek) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n    CHECK_STATE(encrypted_sek);\n    SAFE_CHAR_BUF(aes_key_hex, BUF_LEN);\n\n    uint32_t dec_len = BUF_LEN;\n\n    sgx_status_t status = sgx_unseal_data(\n            (const sgx_sealed_data_t *) encrypted_sek, NULL, 0,\n            (uint8_t *)aes_key_hex, &dec_len);\n\n    if (status == 0x3001) {\n        LOG_ERROR(\"Could not decrypt LevelDB storage! \\n\"\n                  \"If you upgraded sgxwallet software or if you are restoring from backup, please run sgxwallet with -b flag  and \"\n                  \"pass your backup key.\");\n    }\n\n    CHECK_STATUS2(\"sgx unseal SEK failed with status %d\");\n\n    uint64_t len;\n\n\n    hex2carray(aes_key_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 522,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check that offset is less than packet size */\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21722"
    },
    {
        "index": 523,
        "code": "static int pkey_GOST_ECcp_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                           size_t *key_len, const unsigned char *in,\n                           size_t in_len)\n{\n    const unsigned char *p = in;\n    EVP_PKEY *priv = EVP_PKEY_CTX_get0_pkey(pctx);\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    int ret = 0;\n    unsigned char wrappedKey[44];\n    unsigned char sharedKey[32];\n    gost_ctx ctx;\n    const struct gost_cipher_info *param = NULL;\n    EVP_PKEY *eph_key = NULL, *peerkey = NULL;\n    int dgst_nid = NID_undef;\n\n    if (!key) {\n        *key_len = 32;\n        return 1;\n    }\n    gkt = d2i_GOST_KEY_TRANSPORT(NULL, (const unsigned char **)&p, in_len);\n    if (!gkt) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    /* If key transport structure contains public key, use it */\n    eph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);\n    if (eph_key) {\n        if (EVP_PKEY_derive_set_peer(pctx, eph_key) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                    GOST_R_INCOMPATIBLE_PEER_KEY);\n            goto err;\n        }\n    } else {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    peerkey = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!peerkey) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_NO_PEER_KEY);\n        goto err;\n    }\n\n    param = get_encryption_params(gkt->key_agreement_info->cipher);\n    if (!param) {\n        goto err;\n    }\n\n    gost_init(&ctx, param->sblock);\n    OPENSSL_assert(gkt->key_agreement_info->eph_iv->length == 8);\n    memcpy(wrappedKey, gkt->key_agreement_info->eph_iv->data, 8);\n    OPENSSL_assert(gkt->key_info->encrypted_key->length == 32);\n    memcpy(wrappedKey + 8, gkt->key_info->encrypted_key->data, 32);\n    OPENSSL_assert(gkt->key_info->imit->length == 4);\n    memcpy(wrappedKey + 40, gkt->key_info->imit->data, 4);\n\n    EVP_PKEY_get_default_digest_nid(priv, &dgst_nid);\n    if (dgst_nid == NID_id_GostR3411_2012_512)\n        dgst_nid = NID_id_GostR3411_2012_256;\n\n    if (!VKO_compute_key(sharedKey,\n                         EC_KEY_get0_public_key(EVP_PKEY_get0(peerkey)),\n                         EVP_PKEY_get0(priv), wrappedKey, 8, dgst_nid)) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n    }\n    if (!keyUnwrapCryptoPro(&ctx, sharedKey, wrappedKey, key)) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(sharedKey, sizeof(sharedKey));\n    EVP_PKEY_free(eph_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29242"
    },
    {
        "index": 524,
        "code": "#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\n\n\n\n/* The application writer has already defined the array used for the RTOS\n\n* heap - probably so it can be placed in a special segment or address. */\n\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\n\n#else\n\n    PRIVILEGED_DATA static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\n\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\n\n\n\n/* Define the linked list structure.  This is used to link free blocks in order\n\n * of their memory address. */\n\ntypedef struct A_BLOCK_LINK\n\n{\n\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\n\n    size_t xBlockSize;                     /*<< The size of the free block. */\n\n} BlockLink_t;\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\n/*\n\n * Inserts a block of memory that is being freed into the correct position in\n\n * the list of free memory blocks.  The block being freed will be merged with\n\n * the block in front it and/or the block behind it if the memory blocks are\n\n * adjacent to each other.\n\n */\n\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n\n * Called automatically to setup the required heap structures the first time\n\n * pvPortMalloc() is called.\n\n */\n\nstatic void prvHeapInit( void ) PRIVILEGED_FUNCTION;\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\n/* The size of the structure placed at the beginning of each allocated memory\n\n * block must by correctly byte aligned. */\n\nstatic const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\n\n\n\n/* Create a couple of list links to mark the start and end of the list. */\n\nPRIVILEGED_DATA static BlockLink_t xStart, * pxEnd = NULL;\n\n\n\n/* Keeps track of the number of calls to allocate and free memory as well as the\n\n * number of free bytes remaining, but says nothing about fragmentation. */\n\nPRIVILEGED_DATA static size_t xFreeBytesRemaining = 0U;\n\nPRIVILEGED_DATA static size_t xMinimumEverFreeBytesRemaining = 0U;\n\nPRIVILEGED_DATA static size_t xNumberOfSuccessfulAllocations = 0;\n\nPRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;\n\n\n\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\n\n * member of an BlockLink_t structure is set then the block belongs to the\n\n * application.  When the bit is free the block is still part of the free heap\n\n * space. */\n\nPRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\nvoid * pvPortMalloc( size_t xWantedSize )\n\n{\n\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n\n    void * pvReturn = NULL;\n\n\n\n    vTaskSuspendAll();\n\n    {\n\n        /* If this is the first call to malloc then the heap will require\n\n         * initialisation to setup the list of free blocks. */\n\n        if( pxEnd == NULL )\n\n        {\n\n            prvHeapInit();\n\n        }\n\n        else\n\n        {\n\n            mtCOVERAGE_TEST_MARKER();\n\n        }\n\n\n\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32020"
    },
    {
        "index": 525,
        "code": "static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tgf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tgf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 526,
        "code": "int64 CSteamNetworkConnectionBase::SNP_SendMessage( CSteamNetworkingMessage *pSendMessage, SteamNetworkingMicroseconds usecNow, bool *pbThinkImmediately )\n{\n\tint cbData = (int)pSendMessage->m_cbSize;\n\n\t// Assume we won't want to wake up immediately\n\tif ( pbThinkImmediately )\n\t\t*pbThinkImmediately = false;\n\n\t// Check if we're full\n\tif ( m_senderState.PendingBytesTotal() + cbData > m_connectionConfig.m_SendBufferSize.Get() )\n\t{\n\t\tSpewWarningRateLimited( usecNow, \"Connection already has %u bytes pending, cannot queue any more messages\\n\", m_senderState.PendingBytesTotal() );\n\t\tpSendMessage->Release();\n\t\treturn -k_EResultLimitExceeded; \n\t}\n\n\t// Check if they try to send a really large message\n\tif ( cbData > k_cbMaxUnreliableMsgSize && !( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )  )\n\t{\n\t\tSpewWarningRateLimited( usecNow, \"Trying to send a very large (%d bytes) unreliable message.  Sending as reliable instead.\\n\", cbData );\n\t\tpSendMessage->m_nFlags |= k_nSteamNetworkingSend_Reliable;\n\t}\n\n\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoDelay )\n\t{\n\t\t// FIXME - need to check how much data is currently pending, and return\n\t\t// k_EResultIgnored if we think it's going to be a while before this\n\t\t// packet goes on the wire.\n\t}\n\n\t// First, accumulate tokens, and also limit to reasonable burst\n\t// if we weren't already waiting to send\n\tSNP_ClampSendRate();\n\tSNP_TokenBucket_Accumulate( usecNow );\n\n\t// Assign a message number\n\tpSendMessage->m_nMessageNumber = ++m_senderState.m_nLastSentMsgNum;\n\n\t// Reliable, or unreliable?\n\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )\n\t{\n\t\tpSendMessage->SNPSend_SetReliableStreamPos( m_senderState.m_nReliableStreamPos );\n\n\t\t// Generate the header\n\t\tbyte *hdr = pSendMessage->SNPSend_ReliableHeader();\n\t\thdr[0] = 0;\n\t\tbyte *hdrEnd = hdr+1;\n\t\tint64 nMsgNumGap = pSendMessage->m_nMessageNumber - m_senderState.m_nLastSendMsgNumReliable;\n\t\tAssert( nMsgNumGap >= 1 );\n\t\tif ( nMsgNumGap > 1 )\n\t\t{\n\t\t\thdrEnd = SerializeVarInt( hdrEnd, (uint64)nMsgNumGap );\n\t\t\thdr[0] |= 0x40;\n\t\t}\n\t\tif ( cbData < 0x20 )\n\t\t{\n\t\t\thdr[0] |= (byte)cbData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thdr[0] |= (byte)( 0x20 | ( cbData & 0x1f ) );\n\t\t\thdrEnd = SerializeVarInt( hdrEnd, cbData>>5U );\n\t\t}\n\t\tpSendMessage->m_cbSNPSendReliableHeader = hdrEnd - hdr;\n\n\t\t// Grow the total size of the message by the header\n\t\tpSendMessage->m_cbSize += pSendMessage->m_cbSNPSendReliableHeader;\n\n\t\t// Advance stream pointer\n\t\tm_senderState.m_nReliableStreamPos += pSendMessage->m_cbSize;\n\n\t\t// Update stats\n\t\t++m_senderState.m_nMessagesSentReliable;\n\t\tm_senderState.m_cbPendingReliable += pSendMessage->m_cbSize;\n\n\t\t// Remember last sent reliable message number, so we can know how to\n\t\t// encode the next one\n\t\tm_senderState.m_nLastSendMsgNumReliable = pSendMessage->m_nMessageNumber;\n\n\t\tAssert( pSendMessage->SNPSend_IsReliable() );\n\t}\n\telse\n\t{\n\t\tpSendMessage->SNPSend_SetReliableStreamPos( 0 );\n\t\tpSendMessage->m_cbSNPSendReliableHeader = 0;\n\n\t\t++m_senderState.m_nMessagesSentUnreliable;\n\t\tm_senderState.m_cbPendingUnreliable += pSendMessage->m_cbSize;\n\n\t\tAssert( !pSendMessage->SNPSend_IsReliable() );\n\t}\n\n\t// Add to pending list\n\tm_senderState.m_messagesQueued.push_back( pSendMessage );\n\tSpewVerboseGroup( m_connectionConfig.m_LogLevel_Message.Get(), \"[%s] SendMessage %s: MsgNum=%lld sz=%d\\n\",\n\t\t\t\t GetDescription(),\n\t\t\t\t pSendMessage->SNPSend_IsReliable() ? \"RELIABLE\" : \"UNRELIABLE\",\n\t\t\t\t (long long)pSendMessage->m_nMessageNumber,\n\t\t\t\t pSendMessage->m_cbSize );\n\n\t// Use Nagle?\n\t// We always set the Nagle timer, even if we immediately clear it.  This makes our clearing code simpler,\n\t// since we can always safely assume that once we find a message with the nagle timer cleared, all messages\n\t// queued earlier than this also have it cleared.\n\t// FIXME - Don't think this works if the configuration value is changing.  Since changing the\n\t// config value could violate the assumption that nagle times are increasing.  Probably not worth\n\t// fixing.\n\tpSendMessage->SNPSend_SetUsecNagle( usecNow + m_connectionConfig.m_NagleTime.Get() );\n\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoNagle )\n\t\tm_senderState.ClearNagleTimers();\n\n\t// Save the message number.  The code below might end up deleting the message we just queued\n\tint64 result = pSendMessage->m_nMessageNumber;\n\n\t// Schedule wakeup at the appropriate time.  (E.g. right now, if we're ready to send, \n\t// or at the Nagle time, if Nagle is active.)\n\t//\n\t// NOTE: Right now we might not actually be capable of sending end to end data.\n\t// But that case is relatievly rare, and nothing will break if we try to right now.\n\t// On the other hand, just asking the question involved a virtual function call,\n\t// and it will return success most of the time, so let's not make the check here.\n\tif ( GetState() == k_ESteamNetworkingConnectionState_Connected )\n\t{\n\t\tSteamNetworkingMicroseconds usecNextThink = SNP_GetNextThinkTime( usecNow );\n\n\t\t// Ready to send now?\n\t\tif ( usecNextThink > usecNow )\n\t\t{\n\n\t\t\t// We are rate limiting.  Spew about it?\n\t\t\tif ( m_senderState.m_messagesQueued.m_pFirst->SNPSend_UsecNagle() == 0 )\n\t\t\t{\n\t\t\t\tSpewVerbose( \"[%s] RATELIM QueueTime is %.1fms, SendRate=%.1fk, BytesQueued=%d\\n\", \n\t\t\t\t\tGetDescription(),\n\t\t\t\t\tm_senderState.CalcTimeUntilNextSend() * 1e-3,\n\t\t\t\t\tm_senderState.m_n_x * ( 1.0/1024.0),\n\t\t\t\t\tm_senderState.PendingBytesTotal()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Set a wakeup call.\n\t\t\tEnsureMinThinkTime( usecNextThink );\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\t// We're ready to send right now.  Check if we should!\n\t\t\tif ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_UseCurrentThread )\n\t\t\t{\n\n\t\t\t\t// We should send in this thread, before the API entry point\n\t\t\t\t// that the app used returns.  Is the caller gonna handle this?\n\t\t\t\tif ( pbThinkImmediately )\n\t\t\t\t{\n\t\t\t\t\t// Caller says they will handle it\n\t\t\t\t\t*pbThinkImmediately = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Caller wants us to just do it here.\n\t\t\t\t\tCheckConnectionStateAndSetNextThinkTime( usecNow );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Wake up the service thread ASAP to send this in the background thread\n\t\t\t\tSetNextThinkTimeASAP();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-6016"
    },
    {
        "index": 527,
        "code": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0523"
    },
    {
        "index": 528,
        "code": "skip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.\n\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2889"
    },
    {
        "index": 529,
        "code": "static __cold void io_flush_timeouts(struct io_ring_ctx *ctx)\n\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since seq can easily wrap around over time, subtract\n\t\t * the last seq at which timeouts were flushed before comparing.\n\t\t * Assuming not more than 2^31-1 events have happened since,\n\t\t * these subtractions won't have wrapped, so we can check if\n\t\t * target is in [last_seq, current_seq] by comparing the two.\n\t\t */\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-29582"
    },
    {
        "index": 530,
        "code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n\n    native = &frame->native;\n\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n\n    function = active->function;\n\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n\n\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n\n    /* Move all arguments. */\n\n    p = native->arguments;\n    local = native->local + function->args_offset;\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n\n        *local++ = p++;\n    }\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-27007"
    },
    {
        "index": 531,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 532,
        "code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21730"
    },
    {
        "index": 533,
        "code": "static int pkey_gost2018_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                          size_t *key_len, const unsigned char *in,\n                          size_t in_len)\n{\n    const unsigned char *p = in;\n    struct gost_pmeth_data *data;\n    EVP_PKEY *priv;\n    PSKeyTransport_gost *pst = NULL;\n    int ret = 0;\n    unsigned char expkeys[64];\n    EVP_PKEY *eph_key = NULL;\n    int pkey_nid;\n    int mac_nid = NID_undef;\n    int iv_len = 0;\n\n    if (!(data = EVP_PKEY_CTX_get_data(pctx)) ||\n        !(priv = EVP_PKEY_CTX_get0_pkey(pctx))) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n    pkey_nid = EVP_PKEY_base_id(priv);\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    if (!key) {\n        *key_len = 32;\n        return 1;\n    }\n\n    pst = d2i_PSKeyTransport_gost(NULL, (const unsigned char **)&p, in_len);\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    eph_key = X509_PUBKEY_get(pst->ephem_key);\n/*\n * TODO beldmit\n   1.  Checks the next three conditions fulfilling and terminates the\n   connection with fatal error if not.\n\n   o  Q_eph is on the same curve as server public key;\n\n   o  Q_eph is not equal to zero point;\n\n   o  q * Q_eph is not equal to zero point.\n*/\n    if (eph_key == NULL) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n               GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n  \n    if (data->shared_ukm_size == 0 && pst->ukm != NULL) {\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_SET_IV,\n        ASN1_STRING_length(pst->ukm), (void *)ASN1_STRING_get0_data(pst->ukm)) < 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_UKM_NOT_SET);\n            goto err;\n        }\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(eph_key)),\n                 EVP_PKEY_get0(priv), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kimp15(ASN1_STRING_get0_data(pst->psexp),\n                    ASN1_STRING_length(pst->psexp), data->cipher_nid,\n                    expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24,\n                    iv_len, key) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_CANNOT_UNPACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    EVP_PKEY_free(eph_key);\n    PSKeyTransport_gost_free(pst);\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29242"
    },
    {
        "index": 534,
        "code": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24754"
    },
    {
        "index": 535,
        "code": "RList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {\n\tRList *imports = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tut16 off = bin->ne_header->ImportNameTable + bin->header_offset + 1;\n\tint i;\n\tfor (i = 0; i < bin->ne_header->ModRefs; i++) {\n\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\tif (!imp) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tr_bin_import_free (imp);\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\timp->name = name;\n\t\timp->ordinal = i + 1;\n\t\tr_list_append (imports, imp);\n\t\toff += sz;\n\t}\n\tbin->imports = imports;\n\treturn imports;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1283"
    },
    {
        "index": 536,
        "code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-28805"
    },
    {
        "index": 537,
        "code": "GF_Err flac_dmx_process(GF_Filter *filter)\n{\n\tGF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *output;\n\tu8 *start;\n\tBool final_flush=GF_FALSE;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\tFLACHeader hdr;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tflac_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->flac_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t\tfinal_flush = GF_TRUE;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->flac_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tu8 *data = (u8 *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->flac_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->flac_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->flac_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->flac_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->flac_buffer_size + pck_size > ctx->flac_buffer_alloc) {\n\t\t\tctx->flac_buffer_alloc = ctx->flac_buffer_size + pck_size;\n\t\t\tctx->flac_buffer = gf_realloc(ctx->flac_buffer, ctx->flac_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->flac_buffer + ctx->flac_buffer_size, data, pck_size);\n\t\tctx->flac_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->flac_buffer_size;\n\tstart = ctx->flac_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain>2) {\n\t\tu32 next_frame=0, nb_samp;\n\t\tu32 cur_size = remain-2;\n\t\tu8 *cur_buf = start+2;\n\t\tu8 *hdr_start = NULL;\n\n\t\tif (final_flush) {\n\t\t\tnext_frame = remain;\n\t\t} else {\n\t\t\twhile (cur_size) {\n\t\t\t\t//wait till we have a frame header\n\t\t\t\thdr_start = memchr(cur_buf, 0xFF, cur_size);\n\t\t\t\tif (!hdr_start) break;\n\t\t\t\tnext_frame = (u32) (hdr_start-start);\n\t\t\t\tif (next_frame == remain)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif ((hdr_start[1]&0xFC) == 0xF8) {\n\t\t\t\t\tif (flac_parse_header(ctx, hdr_start, (u32) remain - next_frame, &hdr))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_buf = hdr_start+1;\n\t\t\t\tcur_size = (u32) (cur_buf - start);\n\t\t\t\tassert(cur_size<=remain);\n\t\t\t\tcur_size = remain - cur_size;\n\t\t\t\thdr_start = NULL;\n\t\t\t}\n\t\t\tif (!hdr_start) break;\n\t\t\tif (next_frame == remain)\n\t\t\t\tbreak;\n\t\t}\n\n\n\t\tif (!ctx->initialized) {\n\t\t\tu32 size = next_frame;\n\t\t\tu32 dsi_end = 0;\n\t\t\t//we have a header\n\t\t\tgf_bs_reassign_buffer(ctx->bs, ctx->flac_buffer, size);\n\t\t\tu32 magic = gf_bs_read_u32(ctx->bs);\n\t\t\tif (magic != GF_4CC('f','L','a','C')) {\n\n\t\t\t}\n\t\t\twhile (gf_bs_available(ctx->bs)) {\n\t\t\t\tBool last = gf_bs_read_int(ctx->bs, 1);\n\t\t\t\tu32 type = gf_bs_read_int(ctx->bs, 7);\n\t\t\t\tu32 len = gf_bs_read_int(ctx->bs, 24);\n\n\t\t\t\tif (type==0) {\n\t\t\t\t\tu16 min_block_size = gf_bs_read_u16(ctx->bs);\n\t\t\t\t\tu16 max_block_size = gf_bs_read_u16(ctx->bs);\n\t\t\t\t\t/*u32 min_frame_size = */gf_bs_read_u24(ctx->bs);\n\t\t\t\t\t/*u32 max_frame_size = */gf_bs_read_u24(ctx->bs);\n\t\t\t\t\tctx->sample_rate = gf_bs_read_int(ctx->bs, 20);\n\t\t\t\t\tctx->nb_channels = 1 + gf_bs_read_int(ctx->bs, 3);\n\t\t\t\t\tctx->bits_per_sample = 1 + gf_bs_read_int(ctx->bs, 5);\n\t\t\t\t\tif (min_block_size==max_block_size) ctx->block_size = min_block_size;\n\t\t\t\t\telse ctx->block_size = 0;\n\n\t\t\t\t\tctx->duration.num = gf_bs_read_long_int(ctx->bs, 36);\n\t\t\t\t\tctx->duration.den = ctx->sample_rate;\n\t\t\t\t\t//ignore the rest\n\t\t\t\t\tgf_bs_skip_bytes(ctx->bs, 16);\n\t\t\t\t\tdsi_end = (u32) gf_bs_get_position(ctx->bs);\n\n\t\t\t\t} else {\n\t\t\t\t\t//ignore the rest for now\n\t\t\t\t\t//TODO: expose metadata, pictures and co\n\t\t\t\t\tgf_bs_skip_bytes(ctx->bs, len);\n\t\t\t\t}\n\t\t\t\tif (last) break;\n\t\t\t}\n\t\t\tflac_dmx_check_pid(filter, ctx, ctx->flac_buffer+4, dsi_end-4);\n\t\t\tremain -= size;\n\t\t\tstart += size;\n\t\t\tctx->initialized = GF_TRUE;\n\t\t\tif (!ctx->is_playing) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//we have a next frame, check we are synchronize\n\t\tif ((start[0] != 0xFF) && ((start[1]&0xFC) != 0xF8)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[FLACDmx] invalid frame, droping %d bytes and resyncing\\n\", next_frame));\n\t\t\tstart += next_frame;\n\t\t\tremain -= next_frame;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflac_parse_header(ctx,start, next_frame, &hdr);\n\t\tif (hdr.sample_rate != ctx->sample_rate) {\n\t\t\tctx->sample_rate = hdr.sample_rate;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n\t\t}\n\n\t\tnb_samp = hdr.block_size;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sample_rate);\n\t\t\tif (ctx->cts + nb_samp >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + nb_samp ) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, next_frame, &output);\n\t\t\tmemcpy(output, start, next_frame);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (!ctx->timescale || (ctx->timescale==ctx->sample_rate) )\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, nb_samp);\n\t\t\telse {\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (nb_samp * ctx->timescale) / ctx->sample_rate);\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset);\n\t\t\t}\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tflac_dmx_update_cts(ctx, nb_samp);\n\n\t\tassert (start[0] == 0xFF);\n\t\tassert((start[1]&0xFC) == 0xF8);\n\n\t\tstart += next_frame;\n\t\tassert(remain >= next_frame);\n\t\tremain -= next_frame;\n\n\t}\n\n\tif (!pck) {\n\t\tctx->flac_buffer_size = 0;\n\t\treturn flac_dmx_process(filter);\n\t} else {\n\t\tif (remain < ctx->flac_buffer_size) {\n\t\t\tmemmove(ctx->flac_buffer, start, remain);\n\t\t}\n\t\tctx->flac_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29279"
    },
    {
        "index": 538,
        "code": "readSampleCountForLineBlock(InputStreamMutex* streamData,\n                            DeepScanLineInputFile::Data* data,\n                            int lineBlockId)\n{\n    streamData->is->seekg(data->lineOffsets[lineBlockId]);\n\n    if (isMultiPart(data->version))\n    {\n        int partNumber;\n        OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, partNumber);\n\n        if (partNumber != data->partNumber)\n            throw IEX_NAMESPACE::ArgExc(\"Unexpected part number.\");\n    }\n\n    int minY;\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, minY);\n\n    //\n    // Check the correctness of minY.\n    //\n\n    if (minY != data->minY + lineBlockId * data->linesInBuffer)\n        throw IEX_NAMESPACE::ArgExc(\"Unexpected data block y coordinate.\");\n\n    int maxY;\n    maxY = min(minY + data->linesInBuffer - 1, data->maxY);\n\n    uint64_t sampleCountTableDataSize;\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, sampleCountTableDataSize);\n\n    \n    \n    if(sampleCountTableDataSize>static_cast<uint64_t>(data->maxSampleCountTableSize))\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Bad sampleCountTableDataSize read from chunk \"<< lineBlockId << \": expected \" << data->maxSampleCountTableSize << \" or less, got \"<< sampleCountTableDataSize);\n    }\n    \n    uint64_t packedDataSize;\n    uint64_t unpackedDataSize;\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, packedDataSize);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, unpackedDataSize);\n\n    \n    \n    //\n    // We make a check on the data size requirements here.\n    // Whilst we wish to store 64bit sizes on disk, not all the compressors\n    // have been made to work with such data sizes and are still limited to\n    // using signed 32 bit (int) for the data size. As such, this version\n    // insists that we validate that the data size does not exceed the data\n    // type max limit.\n    // @TODO refactor the compressor code to ensure full 64-bit support.\n    //\n\n    int compressorMaxDataSize = std::numeric_limits<int>::max();\n    if (sampleCountTableDataSize > uint64_t(compressorMaxDataSize))\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"This version of the library does not \"\n              << \"support the allocation of data with size  > \"\n              << compressorMaxDataSize\n              << \" file table size    :\" << sampleCountTableDataSize << \".\\n\");\n    }\n    streamData->is->read(data->sampleCountTableBuffer, static_cast<int>(sampleCountTableDataSize));\n    \n    const char* readPtr;\n\n    //\n    // If the sample count table is compressed, we'll uncompress it.\n    //\n\n\n    if (sampleCountTableDataSize < static_cast<uint64_t>(data->maxSampleCountTableSize))\n    {\n        if(!data->sampleCountTableComp)\n        {\n            THROW(IEX_NAMESPACE::ArgExc,\"Deep scanline data corrupt at chunk \" << lineBlockId << \" (sampleCountTableDataSize error)\");\n        }\n        data->sampleCountTableComp->uncompress(data->sampleCountTableBuffer,\n                                               static_cast<int>(sampleCountTableDataSize),\n                                               minY,\n                                               readPtr);\n    }\n    else readPtr = data->sampleCountTableBuffer;\n\n    char* base = data->sampleCountSliceBase;\n    int xStride = data->sampleCountXStride;\n    int yStride = data->sampleCountYStride;\n\n    // total number of samples in block: used to check samplecount table doesn't\n    // reference more data than exists\n    \n    size_t cumulative_total_samples=0;\n    \n    for (int y = minY; y <= maxY; y++)\n    {\n        int yInDataWindow = y - data->minY;\n        data->lineSampleCount[yInDataWindow] = 0;\n\n        int lastAccumulatedCount = 0;\n        for (int x = data->minX; x <= data->maxX; x++)\n        {\n            int accumulatedCount, count;\n\n            //\n            // Read the sample count for pixel (x, y).\n            //\n\n            Xdr::read <CharPtrIO> (readPtr, accumulatedCount);\n            \n            // sample count table should always contain monotonically\n            // increasing values.\n            if (accumulatedCount < lastAccumulatedCount)\n            {\n                THROW(IEX_NAMESPACE::ArgExc,\"Deep scanline sampleCount data corrupt at chunk \" << lineBlockId << \" (negative sample count detected)\");\n            }\n\n            count = accumulatedCount - lastAccumulatedCount;\n            lastAccumulatedCount = accumulatedCount;\n\n            //\n            // Store the data in both internal and external data structure.\n            //\n\n            data->sampleCount[yInDataWindow][x - data->minX] = count;\n            data->lineSampleCount[yInDataWindow] += count;\n            sampleCount(base, xStride, yStride, x, y) = count;\n        }\n        cumulative_total_samples+=data->lineSampleCount[yInDataWindow];\n        if(cumulative_total_samples*data->combinedSampleSize > unpackedDataSize)\n        {\n            THROW(IEX_NAMESPACE::ArgExc,\"Deep scanline sampleCount data corrupt at chunk \" << lineBlockId << \": pixel data only contains \" << unpackedDataSize \n            << \" bytes of data but table references at least \" << cumulative_total_samples*data->combinedSampleSize << \" bytes of sample data\" );            \n        }\n        data->gotSampleCount[y - data->minY] = true;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45942"
    },
    {
        "index": 539,
        "code": "static bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count;\n\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1052"
    },
    {
        "index": 540,
        "code": "load_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)\n{\n    XwdHeader *h = &loader->header;\n    XwdHeader in;\n    const guint32 *p = (const guint32 *) &in;\n\n    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))\n        return FALSE;\n\n    h->header_size = g_ntohl (*(p++));\n    h->file_version = g_ntohl (*(p++));\n    h->pixmap_format = g_ntohl (*(p++));\n    h->pixmap_depth = g_ntohl (*(p++));\n    h->pixmap_width = g_ntohl (*(p++));\n    h->pixmap_height = g_ntohl (*(p++));\n    h->x_offset = g_ntohl (*(p++));\n    h->byte_order = g_ntohl (*(p++));\n    h->bitmap_unit = g_ntohl (*(p++));\n    h->bitmap_bit_order = g_ntohl (*(p++));\n    h->bitmap_pad = g_ntohl (*(p++));\n    h->bits_per_pixel = g_ntohl (*(p++));\n    h->bytes_per_line = g_ntohl (*(p++));\n    h->visual_class = g_ntohl (*(p++));\n    h->red_mask = g_ntohl (*(p++));\n    h->green_mask = g_ntohl (*(p++));\n    h->blue_mask = g_ntohl (*(p++));\n    h->bits_per_rgb = g_ntohl (*(p++));\n    h->color_map_entries = g_ntohl (*(p++));\n    h->n_colors = g_ntohl (*(p++));\n    h->window_width = g_ntohl (*(p++));\n    h->window_height = g_ntohl (*(p++));\n    h->window_x = g_ntohl (*(p++));\n    h->window_y = g_ntohl (*(p++));\n    h->window_border_width = g_ntohl (*(p++));\n\n    /* Only support the most common/useful subset of XWD files out there;\n     * namely, that corresponding to screen dumps from modern X.Org servers. */\n\n    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));\n    ASSERT_HEADER (h->file_version == 7);\n    ASSERT_HEADER (h->pixmap_depth == 24);\n\n    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One\n     * of them is likely misunderstanding. Let's be lenient and accept either. */\n    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);\n\n    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));\n    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);\n\n    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);\n    if (!loader->file_data)\n        return FALSE;\n\n    ASSERT_HEADER (loader->file_data_len >= h->header_size\n                   + h->n_colors * sizeof (XwdColor)\n                   + h->pixmap_height * h->bytes_per_line);\n\n    loader->image_data = (const guint8 *) loader->file_data\n        + h->header_size + h->n_colors * sizeof (XwdColor);\n\n    return TRUE;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-2301"
    },
    {
        "index": 541,
        "code": "TEST(ValidationSubgraph, NameIsDetected) {\n  EXPECT_FALSE(IsValidationSubgraph(nullptr));\n  EXPECT_FALSE(IsValidationSubgraph(\"\"));\n  EXPECT_FALSE(IsValidationSubgraph(\"a name\"));\n  EXPECT_FALSE(IsValidationSubgraph(\"VALIDATIONfoo\"));\n  EXPECT_TRUE(IsValidationSubgraph(\"VALIDATION:\"));\n  EXPECT_TRUE(IsValidationSubgraph(\"VALIDATION:main\"));\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23559"
    },
    {
        "index": 542,
        "code": "static Jsi_RC SysRunModuleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args, 0),\n    *v2 = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *cp, *mod = NULL;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {}, nStr = {};\n    Jsi_Value *cmd = NULL;\n    Jsi_Value *vpargs, *vargs[2] = {};\n    uint i, n = 0, siz, anum = 0, acnt=0;\n    Jsi_Value **arr;\n    Jsi_Obj *obj;\n    const char *anam;\n    bool isMain = jsi_isMain(interp);\n    if (interp->isMain)\n        interp->isMain = 0;\n    \n    if (v2 && !Jsi_ValueIsObjType(interp, v2, JSI_OT_ARRAY))\n        return Jsi_LogError(\"arg 2: expected array|undefined\");\n    if (!v1 || Jsi_ValueIsNull(interp, v1)) {\n        mod = interp->framePtr->fileName;\n        if (mod) mod = Jsi_Strrchr(mod, '/');\n        if (!mod) return JSI_ERROR;\n        mod++;\n        cp = Jsi_Strrchr(mod, '.');\n        int len = (cp?(cp-mod):(int)Jsi_Strlen(mod));\n        mod = Jsi_DSAppendLen(&dStr, mod, len);\n    } else {\n        mod = Jsi_ValueString(interp, v1, NULL);\n        if (!mod) {\n            if (Jsi_ValueIsObjType(interp, v1, JSI_OT_FUNCTION))\n                cmd = v1;\n            else\n                return Jsi_LogError(\"arg 1: expected string|function|undefined\");\n        }\n    }\n    if (!v2 && isMain)\n        v2 = interp->args;\n\n    if (!cmd && mod) {\n        cmd = Jsi_NameLookup(interp, mod);\n        if (!cmd)\n            cmd = jsi_LoadFunction(interp, mod, NULL);\n    }\n    if (!cmd || !Jsi_ValueIsObjType(interp, cmd, JSI_OT_FUNCTION)) {\n        rc = Jsi_LogError(\"unknown command: %s\", (mod?mod:\"\"));\n        goto done;\n    }\n    \n    if (!v2) {\n        obj = Jsi_ObjNewArray(interp, NULL, 0, 0);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj=Jsi_ObjNew(interp));\n    } else {\n        arr = v2->d.obj->arr;\n        siz = v2->d.obj->arrCnt;\n        for (i=0; i<siz; i+=2) {\n            anam = Jsi_ValueToString(interp, arr[i], NULL);\n            if (i==0 && siz==1 && !Jsi_Strcmp(anam, \"-h\")) { anum=1; break; }\n            if (anam[0] != '-') break;\n            if (anam[0] == '-' && anam[1] == '-' && !anam[2]) {acnt++; break;}\n            anum += 2;\n        }\n        if (anum != 1 && (anum>siz)) {\n            if (anam)\n                interp->lastPushStr = (char*)anam;\n            rc = Jsi_LogError(\"missing argument\");\n            goto done;\n        }\n        obj = Jsi_ObjNewArray(interp, arr+anum+acnt, siz-anum-acnt, 0);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj=Jsi_ObjNew(interp));\n        bool isLong = 0;\n        for (i=0; i<anum; i+=2) {\n            int anLen;\n            const char *astr, *anam = Jsi_ValueToString(interp, arr[i], &anLen);\n            if (anum<=1 && !Jsi_Strcmp(anam,\"-h\") ) anam = \"help\";\n            else if (anam && anam[0] == '-') anam++;\n            else {\n                rc = Jsi_LogError(\"bad option: %d\", i);\n                goto done;\n            }\n                \n            Jsi_Value *aval;\n            if  (anum==1)\n                aval = Jsi_ValueNewBoolean(interp, isLong);\n            else {\n                bool bv;\n                Jsi_Number nv;\n                astr = Jsi_ValueToString(interp, arr[i+1], NULL);\n                if (Jsi_GetBool(interp, astr, &bv) == JSI_OK) aval = Jsi_ValueNewBoolean(interp, bv);\n                else if (Jsi_GetDouble(interp, astr, &nv) == JSI_OK) aval = Jsi_ValueNewNumber(interp, nv);\n                else if (!Jsi_Strcmp(astr, \"null\"))  aval = Jsi_ValueNewNull(interp);\n                else aval = arr[i+1];\n            }\n            Jsi_ObjInsert(interp, obj, anam, aval, 0);\n        }\n    }\n    \n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    \n    Jsi_IncrRefCount(interp, cmd);\n    Jsi_IncrRefCount(interp, vpargs);\n    for (i=0; i<n; i++)\n        Jsi_IncrRefCount(interp, vargs[i]);\n    rc = Jsi_FunctionInvoke(interp, cmd, vpargs, ret, NULL);\n    Jsi_DecrRefCount(interp, cmd);\n    for (i=0; i<n; i++)\n        Jsi_DecrRefCount(interp, vargs[i]);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc == JSI_OK && !Jsi_ValueIsUndef(interp, *ret) && isMain && funcPtr && funcPtr->callflags.bits.isdiscard) {\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_ValueGetDString(interp, *ret, &dStr, 0);\n        if (cp && (!(cp=Jsi_Strrchr(cp, '\\n')) || cp[1]))\n            Jsi_DSAppend(&dStr, \"\\n\", NULL);\n        Jsi_Puts(interp, jsi_Stdout, Jsi_DSValue(&dStr), -1);\n    }\n\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&nStr);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 543,
        "code": "compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2862"
    },
    {
        "index": 544,
        "code": "void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 545,
        "code": "void gen_SEK() {\n    vector<char> errMsg(1024, 0);\n    int err_status = 0;\n    vector <uint8_t> encrypted_SEK(1024, 0);\n    uint32_t enc_len = 0;\n\n    SAFE_CHAR_BUF(SEK, 65);\n\n    spdlog::info(\"Generating backup key. Will be stored in backup_key.txt ... \");\n\n    sgx_status_t status = trustedGenerateSEK(eid, &err_status, errMsg.data(), encrypted_SEK.data(), &enc_len, SEK);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n\n    if (strnlen(SEK, 33) != 32) {\n        throw SGXException(-1, \"strnlen(SEK,33) != 32\");\n    }\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_SEK.data(), enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    spdlog::info(string(\"Encrypted storage encryption key:\") + hexEncrKey.data());\n\n    ofstream sek_file(BACKUP_PATH);\n    sek_file.clear();\n\n    sek_file << SEK;\n\n\n    cout << \"ATTENTION! YOUR BACKUP KEY HAS BEEN WRITTEN INTO sgx_data/backup_key.txt \\n\" <<\n         \"PLEASE COPY IT TO THE SAFE PLACE AND THEN DELETE THE FILE MANUALLY BY RUNNING THE FOLLOWING COMMAND:\\n\" <<\n         \"apt-get install secure-delete && srm -vz sgx_data/backup_key.txt\" << endl;\n\n\n    if (!autoconfirm) {\n        string confirm_str = \"I confirm\";\n        string buffer;\n        do {\n            cout << \" DO YOU CONFIRM THAT YOU COPIED THE KEY? (if you confirm type - I confirm)\"\n                 << endl;\n            getline(cin, buffer);\n        } while (case_insensitive_match(confirm_str, buffer));\n    }\n\n\n    LevelDB::getLevelDb()->writeDataUnique(\"SEK\", hexEncrKey.data());\n\n    create_test_key();\n\n    validate_SEK();\n\n    shared_ptr <string> encrypted_SEK_ptr = LevelDB::getLevelDb()->readString(\"SEK\");\n\n    setSEK(encrypted_SEK_ptr);\n\n    validate_SEK();\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 546,
        "code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" // XXX\n\t\t\"=BP\tsrp\\n\" // XXX\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" // r14\n\t\t\"gpr\tacr\t.32\t60\t0\\n\" // r15\n\t\t\"gpr\tpc\t.32\t64\t0\\n\" // r16 // out of context\n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" // like rbp on x86 // out of context\n\t\t// GPR\n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\n\t\t// STACK POINTER\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t// ADD P REGISTERS\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1207"
    },
    {
        "index": 547,
        "code": "static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file)\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\telse\n\t\tkfree(twcb);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-21504"
    },
    {
        "index": 548,
        "code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8943"
    },
    {
        "index": 549,
        "code": "check_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_col();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1735"
    },
    {
        "index": 550,
        "code": "PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,\n\t\t\t\t\t    const pj_str_t *nonce,\n\t\t\t\t\t    const pj_str_t *nc,\n\t\t\t\t\t    const pj_str_t *cnonce,\n\t\t\t\t\t    const pj_str_t *qop,\n\t\t\t\t\t    const pj_str_t *uri,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pjsip_cred_info *cred_info,\n\t\t\t\t\t    const pj_str_t *method)\n{\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n\n    char ha1[PJSIP_SHA256STRLEN];\n    char ha2[PJSIP_SHA256STRLEN];\n    unsigned char digest[32];\n    SHA256_CTX pms;\n\n    pj_assert(result->slen >= PJSIP_SHA256STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD)\n    {\n\t/***\n\t *** ha1 = SHA256(username \":\" realm \":\" password)\n\t ***/\n\tSHA256_Init(&pms);\n\tSHA256_Update( &pms, cred_info->username.ptr,\n\t\t       cred_info->username.slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, realm->ptr, realm->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tSHA256_Final(digest, &pms);\n\n\tdigestNtoStr(digest, 32, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n    {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \" ha1=%.64s\", ha1));\n\n    /***\n     *** ha2 = SHA256(method \":\" req_uri)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, method->ptr, method->slen);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, uri->ptr, uri->slen);\n    SHA256_Final( digest, &pms);\n    digestNtoStr(digest, 32, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \" ha2=%.64s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, ha1, PJSIP_SHA256STRLEN);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, nc->ptr, nc->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cnonce->ptr, cnonce->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, qop->ptr, qop->slen);\n    }\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, ha2, PJSIP_SHA256STRLEN);\n\n    /* This is the final response digest. */\n    SHA256_Final(digest, &pms);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_SHA256STRLEN;\n    digestNtoStr(digest, 32, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \" digest=%.64s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(result);\n    PJ_UNUSED_ARG(nonce);\n    PJ_UNUSED_ARG(nc);\n    PJ_UNUSED_ARG(cnonce);\n    PJ_UNUSED_ARG(qop);\n    PJ_UNUSED_ARG(uri);\n    PJ_UNUSED_ARG(realm);\n    PJ_UNUSED_ARG(cred_info);\n    PJ_UNUSED_ARG(method);\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24754"
    },
    {
        "index": 551,
        "code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n            push();\n          }\n          else {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 14) {\n        n++;\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0525"
    },
    {
        "index": 552,
        "code": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-24122"
    },
    {
        "index": 554,
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    function = async->function;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    function->context = ctx->capability;\n    function->await = ctx;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n\n    function->context = NULL;\n    function->await = NULL;\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    vm->top_frame = top;\n    vm->active_frame = frame;\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n\n        njs_async_context_free(vm, ctx);\n\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n\n        value = &vm->retval;\n\n        goto failed;\n    }\n\n    return ret;\n\nfailed:\n\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n\n    njs_async_context_free(vm, ctx);\n\n    return NJS_ERROR;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-25139"
    },
    {
        "index": 555,
        "code": "unique_ptr<IOBuf> IOBuf::create(std::size_t capacity) {\n  // For smaller-sized buffers, allocate the IOBuf, SharedInfo, and the buffer\n  // all with a single allocation.\n  //\n  // We don't do this for larger buffers since it can be wasteful if the user\n  // needs to reallocate the buffer but keeps using the same IOBuf object.\n  // In this case we can't free the data space until the IOBuf is also\n  // destroyed.  Callers can explicitly call createCombined() or\n  // createSeparate() if they know their use case better, and know if they are\n  // likely to reallocate the buffer later.\n  if (capacity <= kDefaultCombinedBufSize) {\n    return createCombined(capacity);\n  }\n\n  // if we have nallocx, we want to allocate the capacity and the overhead in\n  // a single allocation only if we do not cross into the next allocation class\n  // for some buffer sizes, this can use about 25% extra memory\n  if (canNallocx()) {\n    auto mallocSize = goodMallocSize(capacity);\n    // round capacity to a multiple of 8\n    size_t minSize = ((capacity + 7) & ~7) + sizeof(SharedInfo);\n    // if we do not have space for the overhead, allocate the mem separateley\n    if (mallocSize < minSize) {\n      auto* buf = checkedMalloc(mallocSize);\n      return takeOwnership(SIZED_FREE, buf, mallocSize, 0, 0);\n    }\n  }\n\n  return createSeparate(capacity);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-24036"
    },
    {
        "index": 556,
        "code": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8940"
    },
    {
        "index": 557,
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n\n    value = args->value;\n    from = args->from;\n    to = args->to;\n\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n\n        from += 1;\n\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n\n                    entry = &prop;\n                }\n\n                ret = handler(vm, args, entry, from);\n            }\n\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n\n                return NJS_ERROR;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n\n            njs_set_object_value(&string_obj, object);\n\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n\n        if ((size_t) length == string_prop.size) {\n            /* Byte or ASCII string. */\n\n            p = string_prop.start + from;\n\n            i = from + 1;\n\n            while (i-- > to) {\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, p, 1, 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p = pos;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\n\nprocess_object:\n\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n\n        i = keys->length;\n\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n\n            if (idx < to || idx > from) {\n                continue;\n            }\n\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n\n        njs_array_destroy(vm, keys);\n\n        return NJS_OK;\n    }\n\n    i = from + 1;\n\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return NJS_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-31307"
    },
    {
        "index": 558,
        "code": "static int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q)\n{\n    if ( !bcf_hdr_nsamples(h) ) return 0;\n\n    static int extreme_val_warned = 0;\n    char *r, *t;\n    int j, l, m, g, overflow = 0;\n    khint_t k;\n    ks_tokaux_t aux1;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    kstring_t *mem = (kstring_t*)&h->mem;\n    fmt_aux_t fmt[MAX_N_FMT];\n    mem->l = 0;\n\n    char *end = s->s + s->l;\n    if ( q>=end )\n    {\n        hts_log_error(\"FORMAT column with no sample columns starting at %s:%\"PRIhts_pos\"\", bcf_seqname_safe(h,v), v->pos+1);\n        v->errcode |= BCF_ERR_NCOLS;\n        return -1;\n    }\n\n    v->n_fmt = 0;\n    if ( p[0]=='.' && p[1]==0 ) // FORMAT field is empty \".\"\n    {\n        v->n_sample = bcf_hdr_nsamples(h);\n        return 0;\n    }\n\n    // get format information from the dictionary\n    for (j = 0, t = kstrtok(p, \":\", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) {\n        if (j >= MAX_N_FMT) {\n            v->errcode |= BCF_ERR_LIMITS;\n            hts_log_error(\"FORMAT column at %s:%\"PRIhts_pos\" lists more identifiers than htslib can handle\",\n                bcf_seqname_safe(h,v), v->pos+1);\n            return -1;\n        }\n\n        *(char*)aux1.p = 0;\n        k = kh_get(vdict, d, t);\n        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) {\n            if ( t[0]=='.' && t[1]==0 )\n            {\n                hts_log_error(\"Invalid FORMAT tag name '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n            hts_log_warning(\"FORMAT '%s' at %s:%\"PRIhts_pos\" is not defined in the header, assuming Type=String\", t, bcf_seqname_safe(h,v), v->pos+1);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##FORMAT=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", t);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n\n            k = kh_get(vdict, d, t);\n            v->errcode = BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for FORMAT '%s' at %s:%\"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n        }\n        fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0;\n        fmt[j].key = kh_val(d, k).id;\n        fmt[j].is_gt = !strcmp(t, \"GT\");\n        fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT];\n        v->n_fmt++;\n    }\n    // compute max\n    int n_sample_ori = -1;\n    r = q + 1;  // r: position in the format string\n    l = 0, m = g = 1, v->n_sample = 0;  // m: max vector size, l: max field len, g: max number of alleles\n    while ( r<end )\n    {\n        // can we skip some samples?\n        if ( h->keep_samples )\n        {\n            n_sample_ori++;\n            if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n            {\n                while ( *r!='\\t' && r<end ) r++;\n                if ( *r=='\\t' ) { *r = 0; r++; }\n                continue;\n            }\n        }\n\n        // collect fmt stats: max vector size, length, number of alleles\n        j = 0;  // j-th format field\n        fmt_aux_t *f = fmt;\n        for (;;) {\n            switch (*r) {\n            case ',':\n                m++;\n                break;\n\n            case '|':\n            case '/':\n                if (f->is_gt) g++;\n                break;\n\n            case '\\t':\n                *r = 0; // fall through\n\n            case '\\0':\n            case ':':\n                if (f->max_m < m) f->max_m = m;\n                if (f->max_l < l) f->max_l = l;\n                if (f->is_gt && f->max_g < g) f->max_g = g;\n                l = 0, m = g = 1;\n                if ( *r==':' ) {\n                    j++; f++;\n                    if ( j>=v->n_fmt ) {\n                        hts_log_error(\"Incorrect number of FORMAT fields at %s:%\"PRIhts_pos\"\",\n                                      h->id[BCF_DT_CTG][v->rid].key, v->pos+1);\n                        v->errcode |= BCF_ERR_NCOLS;\n                        return -1;\n                    }\n                } else goto end_for;\n                break;\n            }\n            if ( r>=end ) break;\n            r++; l++;\n        }\n    end_for:\n        v->n_sample++;\n        if ( v->n_sample == bcf_hdr_nsamples(h) ) break;\n        r++;\n    }\n\n    // allocate memory for arrays\n    for (j = 0; j < v->n_fmt; ++j) {\n        fmt_aux_t *f = &fmt[j];\n        if ( !f->max_m ) f->max_m = 1;  // omitted trailing format field\n        if ((f->y>>4&0xf) == BCF_HT_STR) {\n            f->size = f->is_gt? f->max_g << 2 : f->max_l;\n        } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) {\n            f->size = f->max_m << 2;\n        } else\n        {\n            hts_log_error(\"The format type %d at %s:%\"PRIhts_pos\" is currently not supported\", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n        if (align_mem(mem) < 0) {\n            hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        f->offset = mem->l;\n\n        // Limit the total memory to ~2Gb per VCF row.  This should mean\n        // malformed VCF data is less likely to take excessive memory and/or\n        // time.\n        if (v->n_sample * (uint64_t)f->size > INT_MAX) {\n            hts_log_error(\"Excessive memory required by FORMAT fields at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) {\n            hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        mem->l += v->n_sample * f->size;\n    }\n    for (j = 0; j < v->n_fmt; ++j)\n        fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset;\n    // fill the sample fields; at beginning of the loop, t points to the first char of a format\n    n_sample_ori = -1;\n    t = q + 1; m = 0;   // m: sample id\n    while ( t<end )\n    {\n        // can we skip some samples?\n        if ( h->keep_samples )\n        {\n            n_sample_ori++;\n            if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n            {\n                while ( *t && t<end ) t++;\n                t++;\n                continue;\n            }\n        }\n        if ( m == bcf_hdr_nsamples(h) ) break;\n\n        j = 0; // j-th format field, m-th sample\n        while ( t < end )\n        {\n            fmt_aux_t *z = &fmt[j++];\n            if (!z->buf) {\n                hts_log_error(\"Memory allocation failure for FORMAT field type %d at %s:%\"PRIhts_pos,\n                              z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_LIMITS;\n                return -1;\n            }\n            if ((z->y>>4&0xf) == BCF_HT_STR) {\n                if (z->is_gt) { // genotypes\n                    int32_t is_phased = 0;\n                    uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m);\n                    uint32_t unreadable = 0;\n                    uint32_t max = 0;\n                    overflow = 0;\n                    for (l = 0;; ++t) {\n                        if (*t == '.') {\n                            ++t, x[l++] = is_phased;\n                        } else {\n                            char *tt = t;\n                            uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow);\n                            unreadable |= tt == t;\n                            if (max < val) max = val;\n                            x[l++] = (val + 1) << 1 | is_phased;\n                        }\n                        is_phased = (*t == '|');\n                        if (*t != '|' && *t != '/') break;\n                    }\n                    // Possibly check max against v->n_allele instead?\n                    if (overflow || max > (INT32_MAX >> 1) - 1) {\n                        hts_log_error(\"Couldn't read GT data: value too large at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                        return -1;\n                    }\n                    if (unreadable) {\n                        hts_log_error(\"Couldn't read GT data: value not a number or '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                        return -1;\n                    }\n                    if ( !l ) x[l++] = 0;   // An empty field, insert missing value\n                    for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                } else {\n                    char *x = (char*)z->buf + z->size * (size_t)m;\n                    for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t;\n                    for (; l < z->size; ++l) x[l] = 0;\n                }\n            } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                for (l = 0;; ++t) {\n                    if (*t == '.') {\n                        x[l++] = bcf_int32_missing, ++t; // ++t to skip \".\"\n                    } else {\n                        overflow = 0;\n                        char *te;\n                        long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                        if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )\n                        {\n                            if ( !extreme_val_warned )\n                            {\n                                hts_log_warning(\"Extreme FORMAT/%s value encountered and set to missing at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1);\n                                extreme_val_warned = 1;\n                            }\n                            tmp_val = bcf_int32_missing;\n                        }\n                        x[l++] = tmp_val;\n                        t = te;\n                    }\n                    if (*t != ',') break;\n                }\n                if ( !l ) x[l++] = bcf_int32_missing;\n                for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                float *x = (float*)(z->buf + z->size * (size_t)m);\n                for (l = 0;; ++t) {\n                    if (*t == '.' && !isdigit_c(t[1])) {\n                        bcf_float_set_missing(x[l++]), ++t; // ++t to skip \".\"\n                    } else {\n                        overflow = 0;\n                        char *te;\n                        float tmp_val = hts_str2dbl(t, &te, &overflow);\n                        if ( (te==t || overflow) && !extreme_val_warned )\n                        {\n                            hts_log_warning(\"Extreme FORMAT/%s value encountered at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1);\n                            extreme_val_warned = 1;\n                        }\n                        x[l++] = tmp_val;\n                        t = te;\n                    }\n                    if (*t != ',') break;\n                }\n                if ( !l ) bcf_float_set_missing(x[l++]);    // An empty field, insert missing value\n                for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n            } else {\n                hts_log_error(\"Unknown FORMAT field type %d at %s:%\"PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n\n            if (*t == '\\0') {\n                break;\n            }\n            else if (*t == ':') {\n                t++;\n            }\n            else {\n                char buffer[8];\n                hts_log_error(\"Invalid character %s in '%s' FORMAT field at %s:%\"PRIhts_pos\"\",\n                    hts_strprint(buffer, sizeof buffer, '\\'', t, 1),\n                    h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_CHAR;\n                return -1;\n            }\n        }\n\n        for (; j < v->n_fmt; ++j) { // fill end-of-vector values\n            fmt_aux_t *z = &fmt[j];\n            if ((z->y>>4&0xf) == BCF_HT_STR) {\n                if (z->is_gt) {\n                    int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                    if (z->size) x[0] = bcf_int32_missing;\n                    for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                } else {\n                    char *x = (char*)z->buf + z->size * (size_t)m;\n                    if ( z->size ) x[0] = '.';\n                    for (l = 1; l < z->size; ++l) x[l] = 0;\n                }\n            } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                x[0] = bcf_int32_missing;\n                for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                float *x = (float*)(z->buf + z->size * (size_t)m);\n                bcf_float_set_missing(x[0]);\n                for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n            }\n        }\n\n        m++; t++;\n    }\n\n    // write individual genotype information\n    kstring_t *str = &v->indiv;\n    int i;\n    if (v->n_sample > 0) {\n        for (i = 0; i < v->n_fmt; ++i) {\n            fmt_aux_t *z = &fmt[i];\n            bcf_enc_int1(str, z->key);\n            if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) {\n                bcf_enc_size(str, z->size, BCF_BT_CHAR);\n                kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str);\n            } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) {\n                bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2);\n            } else {\n                bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT);\n                if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample,\n                                          (float *) z->buf) != 0) {\n                    v->errcode |= BCF_ERR_LIMITS;\n                    hts_log_error(\"Out of memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                    return -1;\n                }\n            }\n        }\n    }\n\n    if ( v->n_sample!=bcf_hdr_nsamples(h) )\n    {\n        hts_log_error(\"Number of columns at %s:%\"PRIhts_pos\" does not match the number of samples (%d vs %d)\",\n            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));\n        v->errcode |= BCF_ERR_NCOLS;\n        return -1;\n    }\n    if ( v->indiv.l > 0xffffffff )\n    {\n        hts_log_error(\"The FORMAT at %s:%\"PRIhts_pos\" is too long\", bcf_seqname_safe(h,v), v->pos+1);\n        v->errcode |= BCF_ERR_LIMITS;\n\n        // Error recovery: return -1 if this is a critical error or 0 if we want to ignore the FORMAT and proceed\n        v->n_fmt = 0;\n        return -1;\n    }\n\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36403"
    },
    {
        "index": 559,
        "code": "static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n\n    /* Check and get BYE reason */\n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n\n    /* Just print RTCP BYE log */\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-43804"
    },
    {
        "index": 560,
        "code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-44109"
    },
    {
        "index": 561,
        "code": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0713"
    },
    {
        "index": 562,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);\n  int axis = params->axis;\n  int num_inputs = node->inputs->size;\n\n  // The number of dimensions of the input tensors must match, and all\n  // dimensions except 'axis' must be equal.\n  const TfLiteTensor* t0;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));\n  TfLiteType input_type = t0->type;\n  if (axis < 0) axis += t0->dims->size;\n  TF_LITE_ENSURE(context, axis >= 0);\n  TF_LITE_ENSURE(context, axis < t0->dims->size);\n\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||\n                     input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||\n                     input_type == kTfLiteBool);\n\n  // Output dimensions will match input dimensions, except 'axis', which\n  // will be the sum of inputs\n  int sum_axis = t0->dims->data[axis];\n  for (int i = 1; i < num_inputs; ++i) {\n    const TfLiteTensor* t;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n    TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);\n    TF_LITE_ENSURE_EQ(context, t->type, input_type);\n    for (int d = 0; d < t0->dims->size; ++d) {\n      if (d == axis) {\n        sum_axis += t->dims->data[axis];\n      } else {\n        TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);\n      }\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);\n  for (int d = 0; d < t0->dims->size; ++d) {\n    output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);\n\n  if (input_type == kTfLiteInt8) {\n    // Make sure there is no re-scaling needed for Int8 quantized kernel. This\n    // is a restriction we introduced to Int8 kernels.\n    VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);\n    for (int i = 0; i < node->inputs->size; ++i) {\n      const TfLiteTensor* t;\n      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n      TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);\n      TF_LITE_ENSURE_EQ(context, t->params.zero_point,\n                        output->params.zero_point);\n    }\n  }\n\n  if (input_type == kTfLiteInt16) {\n    // Make sure that all Int16 inputs have a null zero-point.\n    for (int i = 0; i < node->inputs->size; ++i) {\n      const TfLiteTensor* t = GetInput(context, node, i);\n      TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);\n    }\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-29601"
    },
    {
        "index": 563,
        "code": "static int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\t/* more than one clock specified is invalid, obviously */\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-29582"
    },
    {
        "index": 564,
        "code": "string encryptBLSKeyShare2Hex(int *errStatus, char *err_string, const char *_key) {\n    CHECK_STATE(errStatus);\n    CHECK_STATE(err_string);\n    CHECK_STATE(_key);\n    auto keyArray = make_shared<vector<char>>(BUF_LEN, 0);\n    auto encryptedKey = make_shared<vector<uint8_t>>(BUF_LEN, 0);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n    unsigned int encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);\n\n    carray2Hex(encryptedKey->data(), encryptedLen, resultBuf, 2 * BUF_LEN + 1);\n\n    return string(resultBuf);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 565,
        "code": "GF_Err flac_dmx_process(GF_Filter *filter)\n{\n\tGF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *output;\n\tu8 *start;\n\tBool final_flush=GF_FALSE;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\tFLACHeader hdr;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tflac_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->flac_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t\tfinal_flush = GF_TRUE;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->flac_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tu8 *data = (u8 *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->flac_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->flac_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->flac_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->flac_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->flac_buffer_size + pck_size > ctx->flac_buffer_alloc) {\n\t\t\tctx->flac_buffer_alloc = ctx->flac_buffer_size + pck_size;\n\t\t\tctx->flac_buffer = gf_realloc(ctx->flac_buffer, ctx->flac_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->flac_buffer + ctx->flac_buffer_size, data, pck_size);\n\t\tctx->flac_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->flac_buffer_size;\n\tstart = ctx->flac_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain>2) {\n\t\tu32 next_frame=0, nb_samp;\n\t\tu32 cur_size = remain-2;\n\t\tu8 *cur_buf = start+2;\n\t\tu8 *hdr_start = NULL;\n\n\t\tif (final_flush) {\n\t\t\tnext_frame = remain;\n\t\t} else {\n\t\t\twhile (cur_size) {\n\t\t\t\t//wait till we have a frame header\n\t\t\t\thdr_start = memchr(cur_buf, 0xFF, cur_size);\n\t\t\t\tif (!hdr_start) break;\n\t\t\t\tnext_frame = (u32) (hdr_start-start);\n\t\t\t\tif (next_frame == remain)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif ((hdr_start[1]&0xFC) == 0xF8) {\n\t\t\t\t\tif (flac_parse_header(ctx, hdr_start, (u32) remain - next_frame, &hdr))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_buf = hdr_start+1;\n\t\t\t\tcur_size = (u32) (cur_buf - start);\n\t\t\t\tassert(cur_size<=remain);\n\t\t\t\tcur_size = remain - cur_size;\n\t\t\t\thdr_start = NULL;\n\t\t\t}\n\t\t\tif (!hdr_start) break;\n\t\t\tif (next_frame == remain)\n\t\t\t\tbreak;\n\t\t}\n\n\n\t\tif (!ctx->initialized) {\n\t\t\tu32 size = next_frame;\n\t\t\tu32 dsi_end = 0;\n\t\t\t//we have a header\n\t\t\tgf_bs_reassign_buffer(ctx->bs, ctx->flac_buffer, size);\n\t\t\tu32 magic = gf_bs_read_u32(ctx->bs);\n\t\t\tif (magic != GF_4CC('f','L','a','C')) {\n\n\t\t\t}\n\t\t\twhile (gf_bs_available(ctx->bs)) {\n\t\t\t\tBool last = gf_bs_read_int(ctx->bs, 1);\n\t\t\t\tu32 type = gf_bs_read_int(ctx->bs, 7);\n\t\t\t\tu32 len = gf_bs_read_int(ctx->bs, 24);\n\n\t\t\t\tif (type==0) {\n\t\t\t\t\tu16 min_block_size = gf_bs_read_u16(ctx->bs);\n\t\t\t\t\tu16 max_block_size = gf_bs_read_u16(ctx->bs);\n\t\t\t\t\t/*u32 min_frame_size = */gf_bs_read_u24(ctx->bs);\n\t\t\t\t\t/*u32 max_frame_size = */gf_bs_read_u24(ctx->bs);\n\t\t\t\t\tctx->sample_rate = gf_bs_read_int(ctx->bs, 20);\n\t\t\t\t\tctx->nb_channels = 1 + gf_bs_read_int(ctx->bs, 3);\n\t\t\t\t\tctx->bits_per_sample = 1 + gf_bs_read_int(ctx->bs, 5);\n\t\t\t\t\tif (min_block_size==max_block_size) ctx->block_size = min_block_size;\n\t\t\t\t\telse ctx->block_size = 0;\n\n\t\t\t\t\tctx->duration.num = gf_bs_read_long_int(ctx->bs, 36);\n\t\t\t\t\tctx->duration.den = ctx->sample_rate;\n\t\t\t\t\t//ignore the rest\n\t\t\t\t\tgf_bs_skip_bytes(ctx->bs, 16);\n\t\t\t\t\tdsi_end = (u32) gf_bs_get_position(ctx->bs);\n\n\t\t\t\t} else {\n\t\t\t\t\t//ignore the rest for now\n\t\t\t\t\t//TODO: expose metadata, pictures and co\n\t\t\t\t\tgf_bs_skip_bytes(ctx->bs, len);\n\t\t\t\t}\n\t\t\t\tif (last) break;\n\t\t\t}\n\t\t\tflac_dmx_check_pid(filter, ctx, ctx->flac_buffer+4, dsi_end-4);\n\t\t\tremain -= size;\n\t\t\tstart += size;\n\t\t\tctx->initialized = GF_TRUE;\n\t\t\tif (!ctx->is_playing) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//we have a next frame, check we are synchronize\n\t\tif ((start[0] != 0xFF) && ((start[1]&0xFC) != 0xF8)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[FLACDmx] invalid frame, droping %d bytes and resyncing\\n\", next_frame));\n\t\t\tstart += next_frame;\n\t\t\tremain -= next_frame;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflac_parse_header(ctx,start, next_frame, &hdr);\n\t\tif (hdr.sample_rate != ctx->sample_rate) {\n\t\t\tctx->sample_rate = hdr.sample_rate;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n\t\t}\n\n\t\tnb_samp = hdr.block_size;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sample_rate);\n\t\t\tif (ctx->cts + nb_samp >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + nb_samp ) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, next_frame, &output);\n\t\t\tmemcpy(output, start, next_frame);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (!ctx->timescale || (ctx->timescale==ctx->sample_rate) )\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, nb_samp);\n\t\t\telse {\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (nb_samp * ctx->timescale) / ctx->sample_rate);\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset);\n\t\t\t}\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tflac_dmx_update_cts(ctx, nb_samp);\n\n\t\tassert (start[0] == 0xFF);\n\t\tassert((start[1]&0xFC) == 0xF8);\n\n\t\tstart += next_frame;\n\t\tassert(remain >= next_frame);\n\t\tremain -= next_frame;\n\n\t}\n\n\tif (!pck) {\n\t\tctx->flac_buffer_size = 0;\n\t\treturn flac_dmx_process(filter);\n\t} else {\n\t\tif (remain < ctx->flac_buffer_size) {\n\t\t\tmemmove(ctx->flac_buffer, start, remain);\n\t\t}\n\t\tctx->flac_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-29279"
    },
    {
        "index": 566,
        "code": "GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_packed_samples)\n{\n\tu32 i, j, sampNum;\n\tu64 *DTSs, curDTS;\n\tBool inserted;\n\tGF_SttsEntry *ent;\n\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\t//reset the reading cache when adding a sample\n\tstts->r_FirstSampleInEntry = 0;\n\n\t*sampleNumber = 0;\n\tif (!nb_packed_samples)\n\t\tnb_packed_samples=1;\n\n\t//if we don't have an entry, that's the first one...\n\tif (!stts->nb_entries) {\n\t\t//assert the first DTS is 0. If not, that will break the whole file\n\t\tif (DTS) return GF_BAD_PARAM;\n\t\tstts->alloc_size = 1;\n\t\tstts->nb_entries = 1;\n\t\tstts->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tstts->entries[0].sampleCount = nb_packed_samples;\n\t\tstts->entries[0].sampleDelta = (nb_packed_samples>1) ? 0 : LastAUDefDuration;\n\t\t(*sampleNumber) = 1;\n\t\tstts->w_currentSampleNum = nb_packed_samples;\n\t\treturn GF_OK;\n\t}\n\t//check the last DTS - we allow 0-duration samples (same DTS)\n\tif (DTS >= stts->w_LastDTS) {\n\t\tu32 nb_extra = 0;\n\t\tent = &stts->entries[stts->nb_entries-1];\n\t\tif (!ent->sampleDelta && (ent->sampleCount>1)) {\n\t\t\tent->sampleDelta = (u32) ( DTS / ent->sampleCount);\n\t\t\tstts->w_LastDTS = DTS - ent->sampleDelta;\n\t\t}\n\t\t//OK, we're adding at the end\n\t\tif ((DTS == stts->w_LastDTS + ent->sampleDelta)\n\t\t\t//for raw audio, consider (dts==last_dts) and (dts==last_dts+2*delta) as sample append to cope with\n\t\t\t//timescale vs samplerate precision\n\t\t\t|| ((nb_packed_samples>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))\n\t\t) {\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n\t\t\tent->sampleCount += nb_packed_samples;\n\t\t\tstts->w_currentSampleNum += nb_packed_samples;\n\t\t\tstts->w_LastDTS = DTS + ent->sampleDelta * (nb_packed_samples-1);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we need to split the entry\n\t\tif (ent->sampleCount == 1) {\n\t\t\t//FIXME - we need more tests with timed text\n#if 0\n\t\t\tif (stts->w_LastDTS)\n\t\t\t\tent->sampleDelta += (u32) (DTS - stts->w_LastDTS);\n\t\t\telse\n\t\t\t\tent->sampleDelta = (u32) DTS;\n#else\n\t\t\t//use this one and adjust...\n\t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n#endif\n\n\t\t\tent->sampleCount ++;\n\t\t\t//little opt, merge last entry with previous one if same delta\n\t\t\tif ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {\n\t\t\t\tstts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;\n\t\t\t\tstts->nb_entries--;\n\t\t\t}\n\t\t\tstts->w_currentSampleNum ++;\n\t\t\tstts->w_LastDTS = DTS;\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//we definitely need to split the entry ;)\n\t\tent->sampleCount --;\n\n\t\tif (nb_packed_samples>1)\n\t\t\tnb_extra = 1;\n\n\t\tif (stts->alloc_size <= stts->nb_entries + nb_extra) {\n\t\t\tALLOC_INC(stts->alloc_size);\n\t\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t\t}\n\n\t\tif (nb_extra)\n\t\t\tnb_extra = stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tent = &stts->entries[stts->nb_entries];\n\t\tstts->nb_entries++;\n\n\t\tif (nb_packed_samples==1) {\n\t\t\tent->sampleCount = 2;\n\t\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n\t\t\tstts->w_LastDTS = DTS;\n\t\t\t(*sampleNumber) = stts->w_currentSampleNum+1;\n\t\t\tstts->w_currentSampleNum += 1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tent->sampleCount = 1;\n\t\tent->sampleDelta = (u32) (DTS - stts->w_LastDTS);\n\n\t\tent = &stts->entries[stts->nb_entries];\n\t\tstts->nb_entries++;\n\n\t\tent->sampleCount = nb_packed_samples;\n\t\tent->sampleDelta = nb_extra;\n\t\tstts->w_LastDTS = DTS;\n\t\t(*sampleNumber) = stts->w_currentSampleNum + 1;\n\t\tstts->w_currentSampleNum += nb_packed_samples;\n\t\treturn GF_OK;\n\t}\n\n\n\t//unpack the DTSs and locate new sample...\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\tcurDTS = 0;\n\tsampNum = 0;\n\tent = NULL;\n\tinserted = 0;\n\tfor (i=0; i<stts->nb_entries; i++) {\n\t\tent = & stts->entries[i];\n\t\tfor (j = 0; j<ent->sampleCount; j++) {\n\t\t\tif (!inserted && (curDTS > DTS)) {\n\t\t\t\tDTSs[sampNum] = DTS;\n\t\t\t\tsampNum++;\n\t\t\t\t*sampleNumber = sampNum;\n\t\t\t\tinserted = 1;\n\t\t\t}\n\t\t\tDTSs[sampNum] = curDTS;\n\t\t\tcurDTS += ent->sampleDelta;\n\t\t\tsampNum ++;\n\t\t}\n\t}\n\tif (!inserted) {\n\t\tgf_free(DTSs);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t/*we will at most insert 3 new entries*/\n\tif (stts->nb_entries+3 >= stts->alloc_size) {\n\t\tstts->alloc_size += 3;\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );\n\t}\n\n\t/*repack the DTSs*/\n\tj=0;\n\tstts->nb_entries = 1;\n\tstts->entries[0].sampleCount = 1;\n\tstts->entries[0].sampleDelta = (u32) DTSs[1] /* - (DTS[0] which is 0)*/;\n\tfor (i=1; i<stbl->SampleSize->sampleCount+1; i++) {\n\t\tif (i == stbl->SampleSize->sampleCount) {\n\t\t\t//and by default, our last sample has the same delta as the prev\n\t\t\tstts->entries[j].sampleCount++;\n\t\t} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {\n\t\t\tstts->entries[j].sampleCount ++;\n\t\t} else {\n\t\t\tstts->nb_entries ++;\n\t\t\tj++;\n\t\t\tstts->entries[j].sampleCount = 1;\n\t\t\tstts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);\n\t\t}\n\t}\n\tgf_free(DTSs);\n\n\t//reset the cache to the end\n\tstts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 567,
        "code": "static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signalling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 568,
        "code": "RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\"entry%d\", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1283"
    },
    {
        "index": 569,
        "code": "trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,\n                           uint32_t enc_len,\n                           uint8_t *decrypted_dkg_secret) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(decrypted_dkg_secret);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, (char *) decrypted_dkg_secret,\n                             3072);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\")\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 570,
        "code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8936"
    },
    {
        "index": 571,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45937"
    },
    {
        "index": 572,
        "code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    \n    //\n    // count channels; build map between channels in frame buffer\n    // and channels in internal buffers\n    //\n    \n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    \n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n    \n  _Data->_outputFrameBuffer=fr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45942"
    },
    {
        "index": 573,
        "code": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-28194"
    },
    {
        "index": 574,
        "code": "de265_error video_usability_information::read(error_queue* errqueue, bitreader* br,\n                                              const seq_parameter_set* sps)\n{\n  int vlc;\n\n\n  // --- sample aspect ratio (SAR) ---\n\n  aspect_ratio_info_present_flag = get_bits(br, 1);\n  if (aspect_ratio_info_present_flag) {\n    int aspect_ratio_idc = get_bits(br, 8);\n    if (aspect_ratio_idc <= NUM_SAR_PRESETS) {\n      sar_width = sar_presets[aspect_ratio_idc][0];\n      sar_height = sar_presets[aspect_ratio_idc][1];\n    }\n    else if (aspect_ratio_idc == EXTENDED_SAR) {\n      sar_width = get_bits(br, 16);\n      sar_height = get_bits(br, 16);\n    }\n    else {\n      sar_width = 0;\n      sar_height = 0;\n    }\n  }\n  else {\n    sar_width = 0;\n    sar_height = 0;\n  }\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = get_bits(br, 1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = get_bits(br, 1);\n  }\n\n\n  // --- video signal type ---\n\n  { // defaults\n    video_format = VideoFormat_Unspecified;\n    video_full_range_flag = false;\n    colour_primaries = 2;\n    transfer_characteristics = 2;\n    matrix_coeffs = 2;\n  }\n\n  video_signal_type_present_flag = get_bits(br, 1);\n  if (video_signal_type_present_flag) {\n    int video_format_idc = get_bits(br, 3);\n    if (video_format_idc > 5) {\n      video_format_idc = VideoFormat_Unspecified;\n    }\n    video_format = (VideoFormat)video_format_idc;\n\n    video_full_range_flag = get_bits(br, 1);\n\n    colour_description_present_flag = get_bits(br, 1);\n    if (colour_description_present_flag) {\n      colour_primaries = get_bits(br, 8);\n      if (colour_primaries == 0 ||\n        colour_primaries == 3 ||\n        colour_primaries >= 11) {\n        colour_primaries = 2;\n      }\n\n      transfer_characteristics = get_bits(br, 8);\n      if (transfer_characteristics == 0 ||\n        transfer_characteristics == 3 ||\n        transfer_characteristics >= 18) {\n        transfer_characteristics = 2;\n      }\n\n      matrix_coeffs = get_bits(br, 8);\n      \n      if (matrix_coeffs >= 11) {\n        matrix_coeffs = 2;\n      }\n    }\n  }\n\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = get_bits(br, 1);\n  if (chroma_loc_info_present_flag) {\n    READ_VLC(chroma_sample_loc_type_top_field, uvlc);\n    READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);\n  }\n  else {\n    chroma_sample_loc_type_top_field = 0;\n    chroma_sample_loc_type_bottom_field = 0;\n  }\n\n  neutral_chroma_indication_flag = get_bits(br, 1);\n  field_seq_flag = get_bits(br, 1);\n  frame_field_info_present_flag = get_bits(br, 1);\n\n\n  // --- default display window ---\n\n  default_display_window_flag = get_bits(br, 1);\n  if (default_display_window_flag) {\n    READ_VLC(def_disp_win_left_offset, uvlc);\n    READ_VLC(def_disp_win_right_offset, uvlc);\n    READ_VLC(def_disp_win_top_offset, uvlc);\n    READ_VLC(def_disp_win_bottom_offset, uvlc);\n  }\n  else {\n    def_disp_win_left_offset = 0;\n    def_disp_win_right_offset = 0;\n    def_disp_win_top_offset = 0;\n    def_disp_win_bottom_offset = 0;\n  }\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = get_bits(br, 1);\n  if (vui_timing_info_present_flag) {\n    vui_num_units_in_tick = get_bits(br, 32);\n    vui_time_scale = get_bits(br, 32);\n\n    vui_poc_proportional_to_timing_flag = get_bits(br, 1);\n    if (vui_poc_proportional_to_timing_flag) {\n      READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);\n    }\n\n    // --- hrd parameters ---\n\n    vui_hrd_parameters_present_flag = get_bits(br, 1);\n    if (vui_hrd_parameters_present_flag) {\n      de265_error err;\n      err = hrd_parameters(errqueue, br, sps);\n    }\n  }\n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = get_bits(br,1);\n  if (bitstream_restriction_flag) {\n    tiles_fixed_structure_flag = get_bits(br,1);\n    motion_vectors_over_pic_boundaries_flag = get_bits(br,1);\n    restricted_ref_pic_lists_flag = get_bits(br,1);\n\n    READ_VLC(min_spatial_segmentation_idc, uvlc);\n    if (min_spatial_segmentation_idc > 4095) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      min_spatial_segmentation_idc = 0;\n    }\n\n    READ_VLC(max_bytes_per_pic_denom, uvlc);\n    if (max_bytes_per_pic_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bytes_per_pic_denom = 2;\n    }\n\n    READ_VLC(max_bits_per_min_cu_denom, uvlc);\n    if (max_bits_per_min_cu_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bits_per_min_cu_denom = 1;\n    }\n\n    READ_VLC(log2_max_mv_length_horizontal, uvlc);\n    if (log2_max_mv_length_horizontal > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_horizontal = 15;\n    }\n\n    READ_VLC(log2_max_mv_length_vertical, uvlc);\n    if (log2_max_mv_length_vertical > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_vertical = 15;\n    }\n  }\n  else {\n    tiles_fixed_structure_flag = false;\n    motion_vectors_over_pic_boundaries_flag = true;\n    restricted_ref_pic_lists_flag = false; // NOTE: default not specified in standard 2014/10\n\n    min_spatial_segmentation_idc = 0;\n    max_bytes_per_pic_denom   = 2;\n    max_bits_per_min_cu_denom = 1;\n    log2_max_mv_length_horizontal = 15;\n    log2_max_mv_length_vertical   = 15;\n  }\n\n  //vui_read = true;\n\n  return DE265_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1253"
    },
    {
        "index": 575,
        "code": "void jsvAddName(JsVar *parent, JsVar *namedChild) {\n  namedChild = jsvRef(namedChild); // ref here VERY important as adding to structure!\n  assert(jsvIsName(namedChild));\n\n  // update array length\n  if (jsvIsArray(parent) && jsvIsInt(namedChild)) {\n    JsVarInt index = namedChild->varData.integer;\n    if (index >= jsvGetArrayLength(parent)) {\n      jsvSetArrayLength(parent, index + 1, false);\n    }\n  }\n\n  if (jsvGetLastChild(parent)) { // we have children already\n    JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));\n    if (jsvIsArray(parent)) {\n      // we must insert in order - so step back until we get the right place\n      while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {\n        JsVarRef prev = jsvGetPrevSibling(insertAfter);\n        jsvUnLock(insertAfter);\n        insertAfter = jsvLockSafe(prev);\n      }\n    }\n\n    if (insertAfter) {\n      if (jsvGetNextSibling(insertAfter)) {\n        // great, we're in the middle...\n        JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n        jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));\n        jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));\n        jsvUnLock(insertBefore);\n      } else {\n        // We're at the end - just set up the parent\n        jsvSetLastChild(parent, jsvGetRef(namedChild));\n      }\n      jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));\n      jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));\n      jsvUnLock(insertAfter);\n    } else { // Insert right at the beginning of the array\n      // Link 2 children together\n      JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));\n      jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));\n      jsvUnLock(firstChild);\n\n      jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));\n      // finally set the new child as the first one\n      jsvSetFirstChild(parent, jsvGetRef(namedChild));\n    }\n  } else { // we have no children - just add it\n    JsVarRef r = jsvGetRef(namedChild);\n    jsvSetFirstChild(parent, r);\n    jsvSetLastChild(parent, r);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-25044"
    },
    {
        "index": 576,
        "code": "pixFillMapHoles(PIX     *pix,\n                l_int32  nx,\n                l_int32  ny,\n                l_int32  filltype)\n{\nl_int32   w, h, y, nmiss, goodcol, i, j, found, ival, valtest;\nl_uint32  val, lastval;\nNUMA     *na;  /* indicates if there is any data in the column */\nPIX      *pixt;\n\n    PROCNAME(\"pixFillMapHoles\");\n\n    if (!pix || pixGetDepth(pix) != 8)\n        return ERROR_INT(\"pix not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pix))\n        return ERROR_INT(\"pix is colormapped\", procName, 1);\n\n    /* ------------- Fill holes in the mapping image columns ----------- */\n    pixGetDimensions(pix, &w, &h, NULL);\n    na = numaCreate(0);  /* holds flag for which columns have data */\n    nmiss = 0;\n    valtest = (filltype == L_FILL_WHITE) ? 255 : 0;\n    for (j = 0; j < nx; j++) {  /* do it by columns */\n        found = FALSE;\n        for (i = 0; i < ny; i++) {\n            pixGetPixel(pix, j, i, &val);\n            if (val != valtest) {\n                y = i;\n                found = TRUE;\n                break;\n            }\n        }\n        if (found == FALSE) {\n            numaAddNumber(na, 0);  /* no data in the column */\n            nmiss++;\n        }\n        else {\n            numaAddNumber(na, 1);  /* data in the column */\n            for (i = y - 1; i >= 0; i--)  /* replicate upwards to top */\n                pixSetPixel(pix, j, i, val);\n            pixGetPixel(pix, j, 0, &lastval);\n            for (i = 1; i < h; i++) {  /* set going down to bottom */\n                pixGetPixel(pix, j, i, &val);\n                if (val == valtest)\n                    pixSetPixel(pix, j, i, lastval);\n                else\n                    lastval = val;\n            }\n        }\n    }\n    numaAddNumber(na, 0);  /* last column */\n\n    if (nmiss == nx) {  /* no data in any column! */\n        numaDestroy(&na);\n        L_WARNING(\"no bg found; no data in any column\\n\", procName);\n        return 1;\n    }\n\n    /* ---------- Fill in missing columns by replication ----------- */\n    if (nmiss > 0) {  /* replicate columns */\n        pixt = pixCopy(NULL, pix);\n            /* Find the first good column */\n        goodcol = 0;\n        for (j = 0; j < w; j++) {\n            numaGetIValue(na, j, &ival);\n            if (ival == 1) {\n                goodcol = j;\n                break;\n            }\n        }\n        if (goodcol > 0) {  /* copy cols backward */\n            for (j = goodcol - 1; j >= 0; j--) {\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pixt, j + 1, 0);\n                pixRasterop(pixt, j, 0, 1, h, PIX_SRC, pix, j, 0);\n            }\n        }\n        for (j = goodcol + 1; j < w; j++) {   /* copy cols forward */\n            numaGetIValue(na, j, &ival);\n            if (ival == 0) {\n                    /* Copy the column to the left of j */\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pixt, j - 1, 0);\n                pixRasterop(pixt, j, 0, 1, h, PIX_SRC, pix, j, 0);\n            }\n        }\n        pixDestroy(&pixt);\n    }\n    if (w > nx) {  /* replicate the last column */\n        for (i = 0; i < h; i++) {\n            pixGetPixel(pix, w - 2, i, &val);\n            pixSetPixel(pix, w - 1, i, val);\n        }\n    }\n\n    numaDestroy(&na);\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36279"
    },
    {
        "index": 577,
        "code": "static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n        uint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n        /* MSVC does not allow dynamic stack arrays */\n        uint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n\tint result = RLC_OK;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* DB = lHash | PS | 01 | D. */\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\t*p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len;\n\t\t\t\tbn_lsh(m, m, *p_len * 8);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0x01);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_ENC_FIN:\n\t\t\t\t/* EB = 00 | maskedSeed | maskedDB. */\n\t\t\t\trand_bytes(h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tbn_write_bin(mask, k_len - RLC_MD_LEN - 1, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tbn_read_bin(t, h1, RLC_MD_LEN);\n\t\t\t\tbn_lsh(t, t, 8 * (k_len - RLC_MD_LEN - 1));\n\t\t\t\tbn_add(t, t, m);\n\t\t\t\tbn_copy(m, t);\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (!bn_is_zero(t)) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\tbn_write_bin(mask, m_len, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tpad = 0;\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\tpad |= h1[i] - h2[i];\n\t\t\t\t}\n\t\t\t\tif (result == RLC_OK) {\n\t\t\t\t\tresult = (pad ? RLC_ERR : RLC_OK);\n\t\t\t\t}\n\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t*p_len = bn_size_bin(m);\n\t\t\t\t(*p_len)--;\n\t\t\t\tbn_rsh(t, m, *p_len * 8);\n\t\t\t\tif (bn_cmp_dig(t, 1) != RLC_EQ) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n\t\t\t\t*p_len = k_len - *p_len;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* M' = 00 00 00 00 00 00 00 00 | H(M). */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 64);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, RLC_MD_LEN * 8);\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_FIN:\n\t\t\t\tmemset(mask, 0, 8);\n\t\t\t\tbn_write_bin(mask + 8, RLC_MD_LEN, m);\n\t\t\t\tmd_map(h1, mask, RLC_MD_LEN + 8);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tt->dp[0] ^= 0x01;\n\t\t\t\t/* m_len is now the size in bits of the modulus. */\n\t\t\t\tbn_lsh(t, t, 8 * RLC_MD_LEN);\n\t\t\t\tbn_add(m, t, m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PSS);\n\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\tbn_set_bit(m, i, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tbn_mod_2b(t, m, 8);\n\t\t\t\tif (bn_cmp_dig(t, RSA_PSS) != RLC_EQ) {\n\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = m_len; i < 8 * k_len; i++) {\n\t\t\t\t\t\tif (bn_get_bit(m, i) != 0) {\n\t\t\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbn_rsh(m, m, 8);\n\t\t\t\t\tbn_mod_2b(t, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tbn_rsh(m, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm->dp[0] ^= 0x01;\n\t\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\t\tbn_set_bit(m, i - ((RLC_MD_LEN + 1) * 8), 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (!bn_is_zero(m)) {\n\t\t\t\t\t\tresult = RLC_ERR;\n\t\t\t\t\t}\n\t\t\t\t\tbn_read_bin(m, h2, RLC_MD_LEN);\n\t\t\t\t\t*p_len = k_len - RLC_MD_LEN;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n        RLC_FREE(mask);\n\n\treturn result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36316"
    },
    {
        "index": 578,
        "code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3751"
    },
    {
        "index": 579,
        "code": "nv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize(ml_get_curline());\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n#endif\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (text_locked())\n\t{\n\t    clearopbeep(cap->oap);\n\t    text_locked_msg();\n\t    break;\n\t}\n\n\tif (!checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1897"
    },
    {
        "index": 580,
        "code": "static inline int sane_kill(pid_t pid, int signum)\n{\n\tif (pid > 0)\n\t\treturn kill(pid, signum);\n\telse\n\t\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-43784"
    },
    {
        "index": 581,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= 12, PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-21722"
    },
    {
        "index": 582,
        "code": "bool hex2carray(const char *_hex, uint64_t *_bin_len,\n                 uint8_t *_bin, uint64_t _max_length) {\n\n\n    CHECK_STATE(_hex);\n    CHECK_STATE(_bin);\n    CHECK_STATE(_bin_len)\n\n\n    int len = strnlen(_hex, 2 * _max_length + 1);\n\n    CHECK_STATE(len != 2 * _max_length + 1);\n\n    CHECK_STATE(len <= 2 * _max_length );\n\n\n    if (len == 0 && len % 2 == 1)\n        return false;\n\n    *_bin_len = len / 2;\n\n    for (int i = 0; i < len / 2; i++) {\n        int high = char2int((char) _hex[i * 2]);\n        int low = char2int((char) _hex[i * 2 + 1]);\n\n        if (high < 0 || low < 0) {\n            return false;\n        }\n\n        _bin[i] = (unsigned char) (high * 16 + low);\n    }\n\n    return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 583,
        "code": "static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0523"
    },
    {
        "index": 584,
        "code": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[4] = { NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetEXIFProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetGPSProperties(tiff,image,exception);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->resolution.x-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->resolution.y-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace,exception);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                    exception);\n                }\n          }\n      }\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          buffer[MagickPathExtent];\n\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          Quantum\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (tiff_status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=2*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=TIFFTileSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=columns*sizeof(uint64);\n#else\n        extent+=columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                Quantum\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo * ) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n#if defined(TIFF_VERSION_BIG)\n        number_pixels+=image->columns*sizeof(uint64);\n#else\n        number_pixels+=image->columns*sizeof(uint32);\n#endif\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if (status != MagickFalse)\n    TIFFReadPhotoshopLayers(image_info,image,exception);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-3610"
    },
    {
        "index": 585,
        "code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; /* for environment */\n\tsize_t len;\n\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t/* for testing single CPU */\n\tcontrol->threads = PROCESSORS;\t/* get CPUs for LZMA */\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\n\t/* The first 5 bytes of the salt is the time in seconds.\n\t * The next 2 bytes encode how many times to hash the password.\n\t * The last 9 bytes are random data, making 16 bytes of salt */\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\t/* Workaround for CPUs no longer keeping up with Moore's law!\n\t * This way we keep the magic header format unchanged. */\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\n\t/* Get Temp Dir. Try variations on canonical unix environment variable */\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; /* need a trailing slash */\n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-28044"
    },
    {
        "index": 586,
        "code": "  void Compute(OpKernelContext* context) override {\n    const int64 axis_input = context->input(0).scalar<int64>()();\n    const Tensor& input_indices = context->input(1);\n    const Tensor& input_values = context->input(2);\n    const Tensor& input_shape = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values.shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape.shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape.shape().DebugString()));\n\n    const int64 input_rank = input_shape.vec<int64>().size();\n    const int64 axis = (axis_input < 0) ? input_rank + axis_input : axis_input;\n\n    OP_REQUIRES(\n        context, axis >= 0 && axis < input_rank,\n        errors::InvalidArgument(\"Input axis should be in range [\", -input_rank,\n                                \", \", input_rank, \"), got \", axis_input));\n\n    OP_REQUIRES(context,\n                num_split_ >= 1 && num_split_ <= input_shape.vec<int64>()(axis),\n                errors::InvalidArgument(\"Input num_split should be between 1 \"\n                                        \"and the splitting dimension size (\",\n                                        input_shape.vec<int64>()(axis),\n                                        \"), got \", num_split_));\n\n    sparse::SparseTensor sparse_tensor;\n    OP_REQUIRES_OK(context,\n                   sparse::SparseTensor::Create(\n                       input_indices, input_values,\n                       TensorShape(input_shape.vec<int64>()), &sparse_tensor));\n\n    std::vector<sparse::SparseTensor> outputs;\n    OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(\n                                sparse_tensor, axis, num_split_, &outputs));\n\n    for (int slice_index = 0; slice_index < num_split_; ++slice_index) {\n      context->set_output(slice_index, outputs[slice_index].indices());\n      context->set_output(slice_index + num_split_,\n                          outputs[slice_index].values());\n      Tensor* shape = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  slice_index + 2 * num_split_,\n                                  {outputs[slice_index].dims()}, &shape));\n      auto output_shape = outputs[slice_index].shape();\n      for (int dim = 0; dim < outputs[slice_index].dims(); ++dim) {\n        shape->vec<int64>()(dim) = output_shape[dim];\n      }\n    }\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-29584"
    },
    {
        "index": 587,
        "code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36978"
    },
    {
        "index": 588,
        "code": "int main(int argc, char **argv, char **envp)\n{\n    // dynamically load shared library\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36979"
    },
    {
        "index": 589,
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-27666"
    },
    {
        "index": 591,
        "code": "int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n    uint64_t len = strlen(message) + 1;\n\n    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n        LOG_ERROR(\"Output buffer too small\");\n        return -3;\n    }\n\n    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n\n    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n    return status;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 592,
        "code": "int PipeSocketHandler::connect(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);\n\n  string pipePath = endpoint.name();\n  sockaddr_un remote;\n\n  int sockFd = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(sockFd);\n  initSocket(sockFd);\n  remote.sun_family = AF_UNIX;\n  strcpy(remote.sun_path, pipePath.c_str());\n\n  VLOG(3) << \"Connecting to \" << endpoint << \" with fd \" << sockFd;\n  int result =\n      ::connect(sockFd, (struct sockaddr*)&remote, sizeof(sockaddr_un));\n  auto localErrno = GetErrno();\n  if (result < 0 && localErrno != EINPROGRESS) {\n    VLOG(3) << \"Connection result: \" << result << \" (\" << strerror(localErrno)\n            << \")\";\n#ifdef WIN32\n    ::shutdown(sockFd, SD_BOTH);\n#else\n    ::shutdown(sockFd, SHUT_RDWR);\n#endif\n#ifdef _MSC_VER\n    FATAL_FAIL(::closesocket(sockFd));\n#else\n    FATAL_FAIL(::close(sockFd));\n#endif\n    sockFd = -1;\n    SetErrno(localErrno);\n    return sockFd;\n  }\n\n  fd_set fdset;\n  FD_ZERO(&fdset);\n  FD_SET(sockFd, &fdset);\n  timeval tv;\n  tv.tv_sec = 3; /* 3 second timeout */\n  tv.tv_usec = 0;\n  VLOG(4) << \"Before selecting sockFd\";\n  select(sockFd + 1, NULL, &fdset, NULL, &tv);\n\n  if (FD_ISSET(sockFd, &fdset)) {\n    VLOG(4) << \"sockFd \" << sockFd << \" is selected\";\n    int so_error;\n    socklen_t len = sizeof so_error;\n\n    FATAL_FAIL(\n        ::getsockopt(sockFd, SOL_SOCKET, SO_ERROR, (char*)&so_error, &len));\n\n    if (so_error == 0) {\n      LOG(INFO) << \"Connected to endpoint \" << endpoint;\n      // Initialize the socket again once it's blocking to make sure timeouts\n      // are set\n      initSocket(sockFd);\n\n      // if we get here, we must have connected successfully\n    } else {\n      LOG(INFO) << \"Error connecting to \" << endpoint << \": \" << so_error << \" \"\n                << strerror(so_error);\n#ifdef _MSC_VER\n      FATAL_FAIL(::closesocket(sockFd));\n#else\n      FATAL_FAIL(::close(sockFd));\n#endif\n      sockFd = -1;\n    }\n  } else {\n    auto localErrno = GetErrno();\n    LOG(INFO) << \"Error connecting to \" << endpoint << \": \" << localErrno << \" \"\n              << strerror(localErrno);\n#ifdef _MSC_VER\n    FATAL_FAIL(::closesocket(sockFd));\n#else\n    FATAL_FAIL(::close(sockFd));\n#endif\n    sockFd = -1;\n  }\n\n  LOG(INFO) << sockFd << \" is a good socket\";\n  if (sockFd >= 0) {\n    addToActiveSockets(sockFd);\n  }\n  return sockFd;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24949"
    },
    {
        "index": 593,
        "code": "static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tint opsize = -1;\n\top->type = -1;\n\topsize = 2;\n\tswitch (buf[0]) {\n\tcase 0x3f:\n\tcase 0x4f:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\topsize = 4;\n\t\tbreak;\n\tcase 0x6f:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\topsize = 6;\n\t\tbreak;\n\tcase 0x7f:\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\tif (len > 5) {\n\t\t\top->ptr = buf[2];\n\t\t\top->ptr |= buf[3]<<8;\n\t\t\top->ptr |= buf[4]<<16;\n\t\t\top->ptr |= ((ut32)(0xff&buf[5]))<<24;\n\t\t\top->ptr += addr;\n\t\t\topsize = 6;\n\t\t} else {\n\t\t\t// error\n\t\t\top->ptr = UT64_MAX;\n\t\t}\n\t\tbreak;\n\tcase 0xbf: // bsr\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\tif (len > 5) {\n\t\t\tst32 delta = buf[2];\n\t\t\tdelta |= buf[3]<<8;\n\t\t\tdelta |= buf[4]<<16;\n\t\t\tdelta |= buf[5]<<24;\n\t\t\top->jump = addr + delta;\n\t\t} else {\n\t\t\top->jump = UT64_MAX;\n\t\t}\n\t\top->fail = addr + 6;\n\t\topsize = 6;\n\t\tbreak;\n\tcase 0x00:\n\t\tif (buf[1] == 0x00) {\n\t\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\t{\n\t\t\t\tst8 delta = buf[0];\n\t\t\t\top->jump = addr + delta;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 0xf0:\n\t\tif (buf[1]==0xb9) {\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswitch (buf[1]) {\n\t\tcase 0x00:\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP; // BCC\n\t\t\tbreak;\n\t\tcase 0xf3:\n\t\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\t\tbreak;\n\t\tcase 0x96: // move.d r, r\n\t\t\tif (buf[0] >=0xc0) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t\t} else {\n\t\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\tcase 0x0b:\n\t\tcase 0x72:\n\t\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tif (buf[0] == 0xb0) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\tcase 0x02:\n\t\tcase 0xc2:\n\t\tcase 0xf5:\n\t\tcase 0x91:\n\t\tcase 0x41:\n\t\tcase 0x61:\n\t\tcase 0x65:\n\t\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\t\tbreak;\n\t\tcase 0x12:\n\t\tcase 0xf6:\n\t\tcase 0xe2:\n\t\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\t\tbreak;\n\t\tcase 0x82: // moveq i, r\n\t\tcase 0xba: // move.d [r], r\n\t\tcase 0xeb: // move.d r, [r]\n\t\tcase 0xc6: // move.d r, r\n\t\tcase 0x92: // moveq i, r\n\t\tcase 0x9b: // move.d i, r\n\t\tcase 0xbe: // move [sp+], srp\n\t\tcase 0x06:\n\t\tcase 0x26:\n\t\tcase 0xfb:\n\t\tcase 0x9a:\n\t\tcase 0xb2:\n\t\tcase 0xda:\n\t\tcase 0x2b:\n\t\tcase 0x6f:\n\t\tcase 0xa2:\n\t\tcase 0x2f:\n\t\tcase 0x8b:\n\t\tcase 0x1b:\n\t\tcase 0xaa:\n\t\tcase 0xa6:\n\t\tcase 0xb6:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tbreak;\n\t\tcase 0xe0:\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\t{\n\t\t\t\tst8 delta = buf[0];\n\t\t\t\top->jump = addr + delta;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\tcase 0x30:\n\t\tcase 0x20:\n\t\tcase 0x2d:\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t\top->jump = addr + buf[0];\n\t\t\top->fail = addr + 2; // delay slot here?\n\t\t\tbreak;\n\t\tcase 0xbf:\n\t\t\top->type = R_ANAL_OP_TYPE_CALL; // bsr\n\t\t\tbreak;\n\t\tcase 0xb9:\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP; // jsr reg\n\t\t\tbreak;\n\t\t}\n\t}\n#if 0\n\tswitch (*buf) {\n\tcase 0x3f: // adds.w N, R\n\t\topsize = 4;\n\tcase 0x01:\n\tcase 0x53: // addi, acr.w, r3, acr\n\tcase 0x04:\n\tcase 0x61:\n\tcase 0x62:\n\tcase 0x63:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase 0x88:\n\tcase 0x84:\n\tcase 0x81:\n\tcase 0x8c:\n\tcase 0xad:\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase 0x7f: // lapc <addr>, <reg>\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\tbreak;\n\tcase 0xcf:\n\tcase 0xbe:\n\tcase 0x60:\n\tcase 0x6f:\n\tcase 0x6a: // move.d reg, reg\n\tcase 0x7e:\n\tcase 0xfe:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase 0x00:\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t// jsr acr\n\t\tbreak;\n\tcase 0xff:\n\t\topsize = 6;\n\tcase 0x14:\n\tcase 0x0e:\n\tcase 0x1a:\n\tcase 0x9c:\n\tcase 0x6d: // bne\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t// jsr acr\n\t\tbreak;\n\tcase 0xbf:\n\t\topsize = 6;\n\tcase 0xb1:\n\tcase 0xb2:\n\tcase 0xb3:\n\tcase 0xb4:\n\tcase 0xb5:\n\tcase 0xb6:\n\tcase 0xb7:\n\tcase 0xb8:\n\tcase 0xb9:\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t// jsr acr\n\t\tbreak;\n\tcase 0x8f: // test.b [acr]\n\tcase 0xc0:\n\tcase 0xe1:\n\tcase 0xaa:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tdefault:\n\t\tswitch (*w) {\n\t\tcase 0xb0b9: //// jsr r0\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t\tbreak;\n\t\tcase 0xb005:\n\t\tcase 0x05b0:\n\t\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\t\tbreak;\n\t\tcase 0xf0b9:\n\t\tcase 0xb9f0:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\top->size = opsize;\n\t//op->delay = 1;\n\treturn opsize;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1207"
    },
    {
        "index": 594,
        "code": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        // out of memory\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 595,
        "code": "static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 596,
        "code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-8944"
    },
    {
        "index": 597,
        "code": "u_undo_end(\n    int\t\tdid_undo,\t// just did an undo\n    int\t\tabsolute)\t// used \":undo N\"\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t// For \":undo N\" we prefer a \"after #N\" message.\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tadd_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n\n    smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0368"
    },
    {
        "index": 598,
        "code": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    \n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    \n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 599,
        "code": "check_termcode(\n    int\t\tmax_offset,\n    char_u\t*buf,\n    int\t\tbufsize,\n    int\t\t*buflen)\n{\n    char_u\t*tp;\n    char_u\t*p;\n    int\t\tslen = 0;\t// init for GCC\n    int\t\tmodslen;\n    int\t\tlen;\n    int\t\tretval = 0;\n    int\t\toffset;\n    char_u\tkey_name[2];\n    int\t\tmodifiers;\n    char_u\t*modifiers_start = NULL;\n    int\t\tkey;\n    int\t\tnew_slen;   // Length of what will replace the termcode\n    char_u\tstring[MAX_KEY_CODE_LEN + 1];\n    int\t\ti, j;\n    int\t\tidx = 0;\n    int\t\tcpo_koffset;\n\n    cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);\n\n    /*\n     * Speed up the checks for terminal codes by gathering all first bytes\n     * used in termleader[].  Often this is just a single <Esc>.\n     */\n    if (need_gather)\n\tgather_termleader();\n\n    /*\n     * Check at several positions in typebuf.tb_buf[], to catch something like\n     * \"x<Up>\" that can be mapped. Stop at max_offset, because characters\n     * after that cannot be used for mapping, and with @r commands\n     * typebuf.tb_buf[] can become very long.\n     * This is used often, KEEP IT FAST!\n     */\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (buf == NULL)\n\t{\n\t    if (offset >= typebuf.tb_len)\n\t\tbreak;\n\t    tp = typebuf.tb_buf + typebuf.tb_off + offset;\n\t    len = typebuf.tb_len - offset;\t// length of the input\n\t}\n\telse\n\t{\n\t    if (offset >= *buflen)\n\t\tbreak;\n\t    tp = buf + offset;\n\t    len = *buflen - offset;\n\t}\n\n\t/*\n\t * Don't check characters after K_SPECIAL, those are already\n\t * translated terminal chars (avoid translating ~@^Hx).\n\t */\n\tif (*tp == K_SPECIAL)\n\t{\n\t    offset += 2;\t// there are always 2 extra characters\n\t    continue;\n\t}\n\n\t/*\n\t * Skip this position if the character does not appear as the first\n\t * character in term_strings. This speeds up a lot, since most\n\t * termcodes start with the same character (ESC or CSI).\n\t */\n\ti = *tp;\n\tfor (p = termleader; *p && *p != i; ++p)\n\t    ;\n\tif (*p == NUL)\n\t    continue;\n\n\t/*\n\t * Skip this position if p_ek is not set and tp[0] is an ESC and we\n\t * are in Insert mode.\n\t */\n\tif (*tp == ESC && !p_ek && (State & MODE_INSERT))\n\t    continue;\n\n\tkey_name[0] = NUL;\t// no key name found yet\n\tkey_name[1] = NUL;\t// no key name found yet\n\tmodifiers = 0;\t\t// no modifiers yet\n\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    /*\n\t     * GUI special key codes are all of the form [CSI xx].\n\t     */\n\t    if (*tp == CSI)\t    // Special key from GUI\n\t    {\n\t\tif (len < 3)\n\t\t    return -1;\t    // Shouldn't happen\n\t\tslen = 3;\n\t\tkey_name[0] = tp[1];\n\t\tkey_name[1] = tp[2];\n\t    }\n\t}\n\telse\n#endif // FEAT_GUI\n\t{\n\t    int  mouse_index_found = -1;\n\n\t    for (idx = 0; idx < tc_len; ++idx)\n\t    {\n\t\t/*\n\t\t * Ignore the entry if we are not at the start of\n\t\t * typebuf.tb_buf[]\n\t\t * and there are not enough characters to make a match.\n\t\t * But only when the 'K' flag is in 'cpoptions'.\n\t\t */\n\t\tslen = termcodes[idx].len;\n\t\tmodifiers_start = NULL;\n\t\tif (cpo_koffset && offset && len < slen)\n\t\t    continue;\n\t\tif (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t     (size_t)(slen > len ? len : slen)) == 0)\n\t\t{\n\t\t    int\t    looks_like_mouse_start = FALSE;\n\n\t\t    if (len < slen)\t\t// got a partial sequence\n\t\t\treturn -1;\t\t// need to get more chars\n\n\t\t    /*\n\t\t     * When found a keypad key, check if there is another key\n\t\t     * that matches and use that one.  This makes <Home> to be\n\t\t     * found instead of <kHome> when they produce the same\n\t\t     * key code.\n\t\t     */\n\t\t    if (termcodes[idx].name[0] == 'K'\n\t\t\t\t       && VIM_ISDIGIT(termcodes[idx].name[1]))\n\t\t    {\n\t\t\tfor (j = idx + 1; j < tc_len; ++j)\n\t\t\t    if (termcodes[j].len == slen &&\n\t\t\t\t    STRNCMP(termcodes[idx].code,\n\t\t\t\t\t    termcodes[j].code, slen) == 0)\n\t\t\t    {\n\t\t\t\tidx = j;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\n\t\t    if (slen == 2 && len > 2\n\t\t\t    && termcodes[idx].code[0] == ESC\n\t\t\t    && termcodes[idx].code[1] == '[')\n\t\t    {\n\t\t\t// The mouse termcode \"ESC [\" is also the prefix of\n\t\t\t// \"ESC [ I\" (focus gained) and other keys.  Check some\n\t\t\t// more bytes to find out.\n\t\t\tif (!isdigit(tp[2]))\n\t\t\t{\n\t\t\t    // ESC [ without number following: Only use it when\n\t\t\t    // there is no other match.\n\t\t\t    looks_like_mouse_start = TRUE;\n\t\t\t}\n\t\t\telse if (termcodes[idx].name[0] == KS_DEC_MOUSE)\n\t\t\t{\n\t\t\t    char_u  *nr = tp + 2;\n\t\t\t    int\t    count = 0;\n\n\t\t\t    // If a digit is following it could be a key with\n\t\t\t    // modifier, e.g., ESC [ 1;2P.  Can be confused\n\t\t\t    // with DEC_MOUSE, which requires four numbers\n\t\t\t    // following.  If not then it can't be a DEC_MOUSE\n\t\t\t    // code.\n\t\t\t    for (;;)\n\t\t\t    {\n\t\t\t\t++count;\n\t\t\t\t(void)getdigits(&nr);\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t\tif (*nr != ';')\n\t\t\t\t    break;\n\t\t\t\t++nr;\n\t\t\t\tif (nr >= tp + len)\n\t\t\t\t    return -1;\t// partial sequence\n\t\t\t    }\n\t\t\t    if (count < 4)\n\t\t\t\tcontinue;\t// no match\n\t\t\t}\n\t\t    }\n\t\t    if (looks_like_mouse_start)\n\t\t    {\n\t\t\t// Only use it when there is no other match.\n\t\t\tif (mouse_index_found < 0)\n\t\t\t    mouse_index_found = idx;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Check for code with modifier, like xterm uses:\n\t\t * <Esc>[123;*X  (modslen == slen - 3)\n\t\t * <Esc>[@;*X    (matches <Esc>[X and <Esc>[1;9X )\n\t\t * Also <Esc>O*X and <M-O>*X (modslen == slen - 2).\n\t\t * When there is a modifier the * matches a number.\n\t\t * When there is no modifier the ;* or * is omitted.\n\t\t */\n\t\tif (termcodes[idx].modlen > 0 && mouse_index_found < 0)\n\t\t{\n\t\t    int at_code;\n\n\t\t    modslen = termcodes[idx].modlen;\n\t\t    if (cpo_koffset && offset && len < modslen)\n\t\t\tcontinue;\n\t\t    at_code = termcodes[idx].code[modslen] == '@';\n\t\t    if (STRNCMP(termcodes[idx].code, tp,\n\t\t\t\t(size_t)(modslen > len ? len : modslen)) == 0)\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\tif (len <= modslen)\t// got a partial sequence\n\t\t\t    return -1;\t\t// need to get more chars\n\n\t\t\tif (tp[modslen] == termcodes[idx].code[slen - 1])\n\t\t\t    // no modifiers\n\t\t\t    slen = modslen + 1;\n\t\t\telse if (tp[modslen] != ';' && modslen == slen - 3)\n\t\t\t    // no match for \"code;*X\" with \"code;\"\n\t\t\t    continue;\n\t\t\telse if (at_code && tp[modslen] != '1')\n\t\t\t    // no match for \"<Esc>[@\" with \"<Esc>[1\"\n\t\t\t    continue;\n\t\t\telse\n\t\t\t{\n\t\t\t    // Skip over the digits, the final char must\n\t\t\t    // follow. URXVT can use a negative value, thus\n\t\t\t    // also accept '-'.\n\t\t\t    for (j = slen - 2; j < len && (isdigit(tp[j])\n\t\t\t\t       || tp[j] == '-' || tp[j] == ';'); ++j)\n\t\t\t\t;\n\t\t\t    ++j;\n\t\t\t    if (len < j)\t// got a partial sequence\n\t\t\t\treturn -1;\t// need to get more chars\n\t\t\t    if (tp[j - 1] != termcodes[idx].code[slen - 1])\n\t\t\t\tcontinue;\t// no match\n\n\t\t\t    modifiers_start = tp + slen - 2;\n\n\t\t\t    // Match!  Convert modifier bits.\n\t\t\t    n = atoi((char *)modifiers_start);\n\t\t\t    modifiers |= decode_modifiers(n);\n\n\t\t\t    slen = j;\n\t\t\t}\n\t\t\tkey_name[0] = termcodes[idx].name[0];\n\t\t\tkey_name[1] = termcodes[idx].name[1];\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (idx == tc_len && mouse_index_found >= 0)\n\t    {\n\t\tkey_name[0] = termcodes[mouse_index_found].name[0];\n\t\tkey_name[1] = termcodes[mouse_index_found].name[1];\n\t    }\n\t}\n\n#ifdef FEAT_TERMRESPONSE\n\tif (key_name[0] == NUL\n\t    // Mouse codes of DEC and pterm start with <ESC>[.  When\n\t    // detecting the start of these mouse codes they might as well be\n\t    // another key code or terminal response.\n# ifdef FEAT_MOUSE_DEC\n\t    || key_name[0] == KS_DEC_MOUSE\n# endif\n# ifdef FEAT_MOUSE_PTERM\n\t    || key_name[0] == KS_PTERM_MOUSE\n# endif\n\t   )\n\t{\n\t    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;\n\n\t    /*\n\t     * Check for responses from the terminal starting with {lead}:\n\t     * \"<Esc>[\" or CSI followed by [0-9>?]\n\t     *\n\t     * - Xterm version string: {lead}>{x};{vers};{y}c\n\t     *   Also eat other possible responses to t_RV, rxvt returns\n\t     *   \"{lead}?1;2c\".\n\t     *\n\t     * - Cursor position report: {lead}{row};{col}R\n\t     *   The final byte must be 'R'. It is used for checking the\n\t     *   ambiguous-width character state.\n\t     *\n\t     * - window position reply: {lead}3;{x};{y}t\n\t     *\n\t     * - key with modifiers when modifyOtherKeys is enabled:\n\t     *\t    {lead}27;{modifier};{key}~\n\t     *\t    {lead}{key};{modifier}u\n\t     */\n\t    if (((tp[0] == ESC && len >= 3 && tp[1] == '[')\n\t\t\t    || (tp[0] == CSI && len >= 2))\n\t\t    && (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))\n\t    {\n\t\tint resp = handle_csi(tp, len, argp, offset, buf,\n\t\t\t\t\t     bufsize, buflen, key_name, &slen);\n\t\tif (resp != 0)\n\t\t{\n# ifdef DEBUG_TERMRESPONSE\n\t\t    if (resp == -1)\n\t\t\tLOG_TR((\"Not enough characters for CSI sequence\"));\n# endif\n\t\t    return resp;\n\t\t}\n\t    }\n\n\t    // Check for fore/background color response from the terminal,\n\t    // starting} with <Esc>] or OSC\n\t    else if ((*T_RBG != NUL || *T_RFG != NUL)\n\t\t\t&& ((tp[0] == ESC && len >= 2 && tp[1] == ']')\n\t\t\t    || tp[0] == OSC))\n\t    {\n\t\tif (handle_osc(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\n\t    // Check for key code response from xterm,\n\t    // starting with <Esc>P or DCS\n\t    else if ((check_for_codes || rcs_status.tr_progress == STATUS_SENT)\n\t\t    && ((tp[0] == ESC && len >= 2 && tp[1] == 'P')\n\t\t\t|| tp[0] == DCS))\n\t    {\n\t\tif (handle_dcs(tp, argp, len, key_name, &slen) == FAIL)\n\t\t    return -1;\n\t    }\n\t}\n#endif\n\n\tif (key_name[0] == NUL)\n\t    continue;\t    // No match at this position, try next one\n\n\t// We only get here when we have a complete termcode match\n\n#ifdef FEAT_GUI\n\t/*\n\t * Only in the GUI: Fetch the pointer coordinates of the scroll event\n\t * so that we know which window to scroll later.\n\t */\n\tif (gui.in_use\n\t\t&& key_name[0] == (int)KS_EXTRA\n\t\t&& (key_name[1] == (int)KE_X1MOUSE\n\t\t    || key_name[1] == (int)KE_X2MOUSE\n\t\t    || key_name[1] == (int)KE_MOUSEMOVE_XY\n\t\t    || key_name[1] == (int)KE_MOUSELEFT\n\t\t    || key_name[1] == (int)KE_MOUSERIGHT\n\t\t    || key_name[1] == (int)KE_MOUSEDOWN\n\t\t    || key_name[1] == (int)KE_MOUSEUP))\n\t{\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 4);\n\n\t    if (num_bytes == -1)\t// not enough coordinates\n\t\treturn -1;\n\t    mouse_col = 128 * (bytes[0] - ' ' - 1) + bytes[1] - ' ' - 1;\n\t    mouse_row = 128 * (bytes[2] - ' ' - 1) + bytes[3] - ' ' - 1;\n\t    slen += num_bytes;\n\t    // equal to K_MOUSEMOVE\n\t    if (key_name[1] == (int)KE_MOUSEMOVE_XY)\n\t\tkey_name[1] = (int)KE_MOUSEMOVE;\n\t}\n\telse\n#endif\n\t/*\n\t * If it is a mouse click, get the coordinates.\n\t */\n\tif (key_name[0] == KS_MOUSE\n#ifdef FEAT_MOUSE_GPM\n\t\t|| key_name[0] == KS_GPM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_JSB\n\t\t|| key_name[0] == KS_JSBTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_NET\n\t\t|| key_name[0] == KS_NETTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_DEC\n\t\t|| key_name[0] == KS_DEC_MOUSE\n#endif\n#ifdef FEAT_MOUSE_PTERM\n\t\t|| key_name[0] == KS_PTERM_MOUSE\n#endif\n#ifdef FEAT_MOUSE_URXVT\n\t\t|| key_name[0] == KS_URXVT_MOUSE\n#endif\n\t\t|| key_name[0] == KS_SGR_MOUSE\n\t\t|| key_name[0] == KS_SGR_MOUSE_RELEASE)\n\t{\n\t    if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,\n\t\t\t\t\t\t\t     &modifiers) == -1)\n\t\treturn -1;\n\t}\n\n#ifdef FEAT_GUI\n\t/*\n\t * If using the GUI, then we get menu and scrollbar events.\n\t *\n\t * A menu event is encoded as K_SPECIAL, KS_MENU, KE_FILLER followed by\n\t * four bytes which are to be taken as a pointer to the vimmenu_T\n\t * structure.\n\t *\n\t * A tab line event is encoded as K_SPECIAL KS_TABLINE nr, where \"nr\"\n\t * is one byte with the tab index.\n\t *\n\t * A scrollbar event is K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER followed\n\t * by one byte representing the scrollbar number, and then four bytes\n\t * representing a long_u which is the new value of the scrollbar.\n\t *\n\t * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,\n\t * KE_FILLER followed by four bytes representing a long_u which is the\n\t * new value of the scrollbar.\n\t */\n# ifdef FEAT_MENU\n\telse if (key_name[0] == (int)KS_MENU)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes = get_long_from_buf(tp + slen, &val);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_menu = (vimmenu_T *)val;\n\t    slen += num_bytes;\n\n\t    // The menu may have been deleted right after it was used, check\n\t    // for that.\n\t    if (check_menu_pointer(root_menu, current_menu) == FAIL)\n\t    {\n\t\tkey_name[0] = KS_EXTRA;\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n# endif\n# ifdef FEAT_GUI_TABLINE\n\telse if (key_name[0] == (int)KS_TABLINE)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 1);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    if (current_tab == 255)\t// -1 in a byte gives 255\n\t\tcurrent_tab = -1;\n\t    slen += num_bytes;\n\t}\n\telse if (key_name[0] == (int)KS_TABMENU)\n\t{\n\t    // Selecting tabline tab or using its menu.\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes = get_bytes_from_buf(tp + slen, bytes, 2);\n\n\t    if (num_bytes == -1)\n\t\treturn -1;\n\t    current_tab = (int)bytes[0];\n\t    current_tabmenu = (int)bytes[1];\n\t    slen += num_bytes;\n\t}\n# endif\n# ifndef USE_ON_FLY_SCROLL\n\telse if (key_name[0] == (int)KS_VER_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    char_u\tbytes[6];\n\t    int\t\tnum_bytes;\n\n\t    // Get the last scrollbar event in the queue of the same type\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_VER_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_bytes_from_buf(tp + j, bytes, 1);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tif (i == 0)\n\t\t    current_scrollbar = (int)bytes[0];\n\t\telse if (current_scrollbar != (int)bytes[0])\n\t\t    break;\n\t\tj += num_bytes;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n\telse if (key_name[0] == (int)KS_HOR_SCROLLBAR)\n\t{\n\t    long_u\tval;\n\t    int\t\tnum_bytes;\n\n\t    // Get the last horiz. scrollbar event in the queue\n\t    j = 0;\n\t    for (i = 0; tp[j] == CSI && tp[j + 1] == KS_HOR_SCROLLBAR\n\t\t\t\t\t\t     && tp[j + 2] != NUL; ++i)\n\t    {\n\t\tj += 3;\n\t\tnum_bytes = get_long_from_buf(tp + j, &val);\n\t\tif (num_bytes == -1)\n\t\t    break;\n\t\tscrollbar_value = val;\n\t\tj += num_bytes;\n\t\tslen = j;\n\t    }\n\t    if (i == 0)\t\t// not enough characters to make one\n\t\treturn -1;\n\t}\n# endif // !USE_ON_FLY_SCROLL\n#endif // FEAT_GUI\n\n#if (defined(UNIX) || defined(VMS))\n\t/*\n\t * Handle FocusIn/FocusOut event sequences reported by XTerm.\n\t * (CSI I/CSI O)\n\t */\n\tif (key_name[0] == KS_EXTRA\n# ifdef FEAT_GUI\n\t\t&& !gui.in_use\n# endif\n\t    )\n\t{\n\t    if (key_name[1] == KE_FOCUSGAINED)\n\t    {\n\t\tif (!focus_state)\n\t\t{\n\t\t    ui_focus_change(TRUE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = TRUE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t    else if (key_name[1] == KE_FOCUSLOST)\n\t    {\n\t\tif (focus_state)\n\t\t{\n\t\t    ui_focus_change(FALSE);\n\t\t    did_cursorhold = TRUE;\n\t\t    focus_state = FALSE;\n\t\t}\n\t\tkey_name[1] = (int)KE_IGNORE;\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n\t */\n\tkey = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));\n\n\t/*\n\t * Add any modifier codes to our string.\n\t */\n\tnew_slen = modifiers2keycode(modifiers, &key, string);\n\n\t// Finally, add the special key code to our string\n\tkey_name[0] = KEY2TERMCAP0(key);\n\tkey_name[1] = KEY2TERMCAP1(key);\n\tif (key_name[0] == KS_KEY)\n\t{\n\t    // from \":set <M-b>=xx\"\n\t    if (has_mbyte)\n\t\tnew_slen += (*mb_char2bytes)(key_name[1], string + new_slen);\n\t    else\n\t\tstring[new_slen++] = key_name[1];\n\t}\n\telse if (new_slen == 0 && key_name[0] == KS_EXTRA\n\t\t\t\t\t\t  && key_name[1] == KE_IGNORE)\n\t{\n\t    // Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED\n\t    // to indicate what happened.\n\t    retval = KEYLEN_REMOVED;\n\t}\n\telse\n\t{\n\t    string[new_slen++] = K_SPECIAL;\n\t    string[new_slen++] = key_name[0];\n\t    string[new_slen++] = key_name[1];\n\t}\n\tif (put_string_in_typebuf(offset, slen, string, new_slen,\n\t\t\t\t\t\t buf, bufsize, buflen) == FAIL)\n\t    return -1;\n\treturn retval == 0 ? (len + new_slen - slen + offset) : retval;\n    }\n\n#ifdef FEAT_TERMRESPONSE\n    LOG_TR((\"normal character\"));\n#endif\n\n    return 0;\t\t\t    // no match found\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-2285"
    },
    {
        "index": 600,
        "code": "static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tint alen;\n\tint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34835"
    },
    {
        "index": 601,
        "code": "void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,\n                         const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(hash);\n    CHECK_STATE(sigR);\n    CHECK_STATE(sigS);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t privateKeyMpz;\n    mpz_init(privateKeyMpz);\n    mpz_t msgMpz;\n    mpz_init(msgMpz);\n    signature sign = signature_init();\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"aes decrypt failed with status %d\");\n\n    skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n\n    if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {\n        *errStatus = -1;\n        snprintf(errString, BUF_LEN, \"invalid secret key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    if (mpz_set_str(msgMpz, hash, 16) == -1) {\n        *errStatus = -1;\n        snprintf(errString, BUF_LEN, \"invalid message hash\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    signature_sign(sign, msgMpz, privateKeyMpz, curve);\n\n    sigCounter++;\n\n    if (sigCounter % 1000 == 0) {\n\n        point Pkey = point_init();\n\n        signature_extract_public_key(Pkey, privateKeyMpz, curve);\n\n        if (!signature_verify(msgMpz, sign, Pkey, curve)) {\n            *errStatus = -2;\n            snprintf(errString, BUF_LEN, \"signature is not verified! \");\n            point_clear(Pkey);\n            goto clean;\n        }\n\n        point_clear(Pkey);\n    }\n\n    SAFE_CHAR_BUF(arrM, BUF_LEN);\n    mpz_get_str(arrM, 16, msgMpz);\n    snprintf(errString, BUF_LEN, \"message is %s \", arrM);\n\n    SAFE_CHAR_BUF(arrR, BUF_LEN);\n    mpz_get_str(arrR, base, sign->r);\n    strncpy(sigR, arrR, 1024);\n\n    SAFE_CHAR_BUF(arrS, BUF_LEN);\n    mpz_get_str(arrS, base, sign->s);\n    strncpy(sigS, arrS, 1024);\n\n    *sig_v = sign->v;\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(privateKeyMpz);\n    mpz_clear(msgMpz);\n    signature_free(sign);\n    LOG_DEBUG(__FUNCTION__ );\n    LOG_DEBUG(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 602,
        "code": "    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n\n                if ( PFB_DONE == nBlockType )\n                    break;\n\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n\n            // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0430\u043c \u0431\u043b\u043e\u043a \u0434\u0430\u043d\u043d\u044b\u0445\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n\n        return true;\n    }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29777"
    },
    {
        "index": 603,
        "code": "l_int32 main(int    argc,\n             char **argv)\n{\nL_DEWARP   *dew1, *dew2;\nL_DEWARPA  *dewa;\nPIX        *pixs, *pixn, *pixg, *pixb, *pixd, *pixt1, *pixt2;\nPIX        *pixs2, *pixn2, *pixg2, *pixb2, *pixd2;\n\n    setLeptDebugOK(1);\n    lept_mkdir(\"lept/model\");\n\n/*    pixs = pixRead(\"1555.007.jpg\"); */\n    pixs = pixRead(\"cat.035.jpg\");\n/*    pixs = pixRead(\"cat.010.jpg\"); */\n\n        /* Normalize for varying background and binarize */\n    pixn = pixBackgroundNormSimple(pixs, NULL, NULL);\n    pixg = pixConvertRGBToGray(pixn, 0.5, 0.3, 0.2);\n    pixb = pixThresholdToBinary(pixg, 130);\n\n        /* Run the basic functions */\n    dewa = dewarpaCreate(2, 30, 1, 10, 30);\n    dewarpaUseBothArrays(dewa, 1);\n    dew1 = dewarpCreate(pixb, 35);\n    dewarpaInsertDewarp(dewa, dew1);\n    dewarpBuildPageModel(dew1, \"/tmp/lept/model/dewarp_model1.pdf\");\n    dewarpaApplyDisparity(dewa, 35, pixg, 200, 0, 0, &pixd,\n                          \"/tmp/lept/model/dewarp_apply1.pdf\");\n\n         /* Write out some of the files to be imaged */\n    lept_rmdir(\"lept/dewtest\");\n    lept_mkdir(\"lept/dewtest\");\n    pixWrite(\"/tmp/lept/dewtest/001.jpg\", pixs, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/002.jpg\", pixn, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/003.jpg\", pixg, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/004.png\", pixb, IFF_TIFF_G4);\n    pixWrite(\"/tmp/lept/dewtest/005.jpg\", pixd, IFF_JFIF_JPEG);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0020.png\");\n    pixWrite(\"/tmp/lept/dewtest/006.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0030.png\");\n    pixWrite(\"/tmp/lept/dewtest/007.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0060.png\");\n    pixWrite(\"/tmp/lept/dewtest/008.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0070.png\");\n    pixWrite(\"/tmp/lept/dewtest/009.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/002.png\");\n    pixWrite(\"/tmp/lept/dewtest/010.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/003.png\");\n    pixWrite(\"/tmp/lept/dewtest/011.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/012.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0041.png\");\n    pixWrite(\"/tmp/lept/dewtest/013.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0042.png\");\n    pixWrite(\"/tmp/lept/dewtest/014.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0051.png\");\n    pixWrite(\"/tmp/lept/dewtest/015.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0052.png\");\n    pixWrite(\"/tmp/lept/dewtest/016.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n\n        /* Normalize another image, that may not have enough textlines\n         * to build an accurate model */\n/*    pixs2 = pixRead(\"1555.003.jpg\");  */\n    pixs2 = pixRead(\"cat.007.jpg\");\n/*    pixs2 = pixRead(\"cat.014.jpg\"); */\n    pixn2 = pixBackgroundNormSimple(pixs2, NULL, NULL);\n    pixg2 = pixConvertRGBToGray(pixn2, 0.5, 0.3, 0.2);\n    pixb2 = pixThresholdToBinary(pixg2, 130);\n\n        /* Apply the previous disparity model to this image */\n    dew2 = dewarpCreate(pixb2, 7);\n    dewarpaInsertDewarp(dewa, dew2);\n    dewarpaInsertRefModels(dewa, 0, 1);\n    dewarpaInfo(stderr, dewa);\n    dewarpaApplyDisparity(dewa, 7, pixg2, 200, 0, 0, &pixd2,\n                          \"/tmp/lept/model/dewarp_apply2.pdf\");\n    dewarpaDestroy(&dewa);\n\n        /* Write out files for the second image */\n    pixWrite(\"/tmp/lept/dewtest/017.jpg\", pixs2, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/018.jpg\", pixg2, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/019.png\", pixb2, IFF_TIFF_G4);\n    pixWrite(\"/tmp/lept/dewtest/020.jpg\", pixd2, IFF_JFIF_JPEG);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0060.png\");\n    pixWrite(\"/tmp/lept/dewtest/021.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/002.png\");\n    pixWrite(\"/tmp/lept/dewtest/022.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/023.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0070.png\");\n    pixWrite(\"/tmp/lept/dewtest/024.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/003.png\");\n    pixWrite(\"/tmp/lept/dewtest/025.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/026.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n\n        /* Generate the big pdf file */\n    convertFilesToPdf(\"/tmp/lept/dewtest\", NULL, 135, 1.0, 0, 0, \"Dewarp Test\",\n                      \"/tmp/lept/dewarptest1.pdf\");\n    lept_stderr(\"pdf file made: /tmp/lept/model/dewarptest1.pdf\\n\");\n\n    lept_rmdir(\"lept/dewmod\");\n    lept_rmdir(\"lept/dewtest\");\n    pixDestroy(&pixs);\n    pixDestroy(&pixn);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    pixDestroy(&pixd);\n    pixDestroy(&pixs2);\n    pixDestroy(&pixn2);\n    pixDestroy(&pixg2);\n    pixDestroy(&pixb2);\n    pixDestroy(&pixd2);\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36280"
    },
    {
        "index": 604,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& x = context->input(0);\n    const Tensor& y = context->input(1);\n    const float min_x = context->input(2).flat<float>()(0);\n    const float max_x = context->input(3).flat<float>()(0);\n    const float min_y = context->input(4).flat<float>()(0);\n    const float max_y = context->input(5).flat<float>()(0);\n\n    BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));\n    if (!bcast.IsValid()) {\n      context->SetStatus(errors::InvalidArgument(\n          \"Incompatible shapes: \", x.shape().DebugString(), \" vs. \",\n          y.shape().DebugString()));\n      return;\n    }\n    Tensor* z;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, BCast::ToShape(bcast.output_shape()), &z));\n\n    // Make sure that we have valid quantization ranges for the input buffers.\n    // If the difference between the min and max is negative or zero, it makes\n    // it hard to do meaningful intermediate operations on the values.\n    OP_REQUIRES(context, (max_x > min_x),\n                errors::InvalidArgument(\"max_x must be larger than min_a.\"));\n    OP_REQUIRES(context, (max_y > min_y),\n                errors::InvalidArgument(\"max_x must be larger than min_b.\"));\n    const int32 offset_x = FloatToQuantizedUnclamped<T>(0.0f, min_x, max_x);\n    const int32 offset_y = FloatToQuantizedUnclamped<T>(0.0f, min_y, max_y);\n    const T* x_data = x.flat<T>().data();\n    const T* y_data = y.flat<T>().data();\n    Toutput* z_data = z->flat<Toutput>().data();\n\n    const int ndims = bcast.x_reshape().size();\n    if (ndims <= 1) {\n      if (x.NumElements() == 1) {\n        ScalarMultiply<T, Toutput>(context, y_data, offset_y, y.NumElements(),\n                                   x_data[0], offset_x, z_data);\n      } else if (y.NumElements() == 1) {\n        ScalarMultiply<T, Toutput>(context, x_data, offset_x, x.NumElements(),\n                                   y_data[0], offset_y, z_data);\n      } else {\n        VectorMultiply<T, Toutput>(context, x_data, offset_x, y_data, offset_y,\n                                   x.NumElements(), z_data);\n      }\n    } else if (ndims == 2) {\n      const T* vector_data;\n      int64 vector_num_elements;\n      int32 vector_offset;\n      const T* tensor_data;\n      int64 tensor_num_elements;\n      int32 tensor_offset;\n      if (x.NumElements() < y.NumElements()) {\n        vector_data = x_data;\n        vector_num_elements = x.NumElements();\n        vector_offset = offset_x;\n        tensor_data = y_data;\n        tensor_num_elements = y.NumElements();\n        tensor_offset = offset_y;\n      } else {\n        vector_data = y_data;\n        vector_num_elements = y.NumElements();\n        vector_offset = offset_y;\n        tensor_data = x_data;\n        tensor_num_elements = x.NumElements();\n        tensor_offset = offset_x;\n      }\n      if (vector_num_elements == 0) {\n        context->SetStatus(\n            errors::InvalidArgument(\"vector must have at least 1 element\"));\n        return;\n      }\n      VectorTensorMultiply<T, Toutput>(\n          vector_data, vector_offset, vector_num_elements, tensor_data,\n          tensor_offset, tensor_num_elements, z_data);\n    } else {\n      LOG(INFO) << \"ndims=\" << ndims;\n      LOG(INFO) << \"bcast.x_reshape()=\"\n                << TensorShape(bcast.x_reshape()).DebugString();\n      LOG(INFO) << \"bcast.y_reshape()=\"\n                << TensorShape(bcast.y_reshape()).DebugString();\n      LOG(INFO) << \"bcast.x_bcast()=\"\n                << TensorShape(bcast.x_bcast()).DebugString();\n      LOG(INFO) << \"bcast.y_bcast()=\"\n                << TensorShape(bcast.y_bcast()).DebugString();\n\n      context->SetStatus(errors::Unimplemented(\n          \"Broadcast between \", context->input(0).shape().DebugString(),\n          \" and \", context->input(1).shape().DebugString(),\n          \" is not supported yet.\"));\n      return;\n    }\n\n    float min_z_value;\n    float max_z_value;\n    QuantizationRangeForMultiplication<T, T, Toutput>(\n        min_x, max_x, min_y, max_y, &min_z_value, &max_z_value);\n    Tensor* z_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));\n    z_min->flat<float>()(0) = min_z_value;\n\n    Tensor* z_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));\n    z_max->flat<float>()(0) = max_z_value;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29535"
    },
    {
        "index": 605,
        "code": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n\t\t\t    const pj_uint8_t *start, const pj_uint8_t *max,\n\t\t\t    pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n\t/* Too many name recursion */\n\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    p = start;\n    while (*p) {\n\tif ((*p & 0xc0) == 0xc0) {\n\t    /* Compression is found! */\n\t    pj_uint16_t offset;\n\n\t    /* Get the 14bit offset */\n\t    pj_memcpy(&offset, p, 2);\n\t    offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n\t    offset = pj_ntohs(offset);\n\n\t    /* Check that offset is valid */\n\t    if (offset >= max - pkt)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    /* Retrieve the name from that offset. */\n\t    status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    return PJ_SUCCESS;\n\t} else {\n\t    unsigned label_len = *p;\n\n\t    /* Check that label length is valid */\n\t    if (pkt+label_len > max)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    pj_memcpy(name->ptr + name->slen, p+1, label_len);\n\t    name->slen += label_len;\n\n\t    p += label_len + 1;\n\t    if (*p != 0) {\n\t\t*(name->ptr + name->slen) = '.';\n\t\t++name->slen;\n\t    }\n\n\t    if (p >= max)\n\t\treturn PJLIB_UTIL_EDNSINSIZE;\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24793"
    },
    {
        "index": 606,
        "code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23575"
    },
    {
        "index": 607,
        "code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32439"
    },
    {
        "index": 608,
        "code": "void jsvRemoveChild(JsVar *parent, JsVar *child) {\n  assert(jsvHasChildren(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  bool wasChild = false;\n  // unlink from parent\n  if (jsvGetFirstChild(parent) == childref) {\n    jsvSetFirstChild(parent, jsvGetNextSibling(child));\n    wasChild = true;\n  }\n  if (jsvGetLastChild(parent) == childref) {\n    jsvSetLastChild(parent, jsvGetPrevSibling(child));\n    wasChild = true;\n    // If this was an array and we were the last\n    // element, update the length\n    if (jsvIsArray(parent)) {\n      JsVarInt l = 0;\n      // get index of last child\n      if (jsvGetLastChild(parent))\n        l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;\n      // set it\n      jsvSetArrayLength(parent, l, false);\n    }\n  }\n  // unlink from child list\n  if (jsvGetPrevSibling(child)) {\n    JsVar *v = jsvLock(jsvGetPrevSibling(child));\n    assert(jsvGetNextSibling(v) == jsvGetRef(child));\n    jsvSetNextSibling(v, jsvGetNextSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n  if (jsvGetNextSibling(child)) {\n    JsVar *v = jsvLock(jsvGetNextSibling(child));\n    assert(jsvGetPrevSibling(v) == jsvGetRef(child));\n    jsvSetPrevSibling(v, jsvGetPrevSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n\n  jsvSetPrevSibling(child, 0);\n  jsvSetNextSibling(child, 0);\n  if (wasChild)\n    jsvUnRef(child);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-25044"
    },
    {
        "index": 609,
        "code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36978"
    },
    {
        "index": 610,
        "code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n\n    // In Vim9 script a command block is not split at NL characters for\n    // commands using an expression argument.  Skip over a '#' comment to check\n    // for a following NL.  Require white space before the '#'.\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2231"
    },
    {
        "index": 611,
        "code": "eval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0351"
    },
    {
        "index": 612,
        "code": "dwarf_global_formref_b(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Bool * offset_is_info,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half context_version = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Bool is_info = TRUE;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    context_version = cu_context->cc_version_stamp;\n    is_info = cu_context->cc_is_info;\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_ref1:\n        offset = *(Dwarf_Small *) attr->ar_debug_ptr;\n        goto fixoffset;\n\n    case DW_FORM_ref2:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref4:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref8:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref_udata:\n        {\n        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;\n        Dwarf_Unsigned localoffset = 0;\n\n        DECODE_LEB128_UWORD_CK(ptr,localoffset,\n            dbg,error,section_end);\n        offset = localoffset;\n\n        fixoffset: /* we have a local offset, make it global */\n\n        /* check legality of offset */\n        if (offset >= cu_context->cc_length +\n            cu_context->cc_length_size +\n            cu_context->cc_extension_size) {\n            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n            return DW_DLV_ERROR;\n        }\n\n        /* globalize the offset */\n        offset += cu_context->cc_debug_offset;\n        }\n        break;\n\n    /*  The DWARF2 document did not make clear that\n        DW_FORM_data4( and 8) were references with\n        global offsets to some section.\n        That was first clearly documented in DWARF3.\n        In DWARF4 these two forms are no longer references. */\n    case DW_FORM_data4:\n        if (context_version >= DW_CU_VERSION4) {\n            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);\n            return DW_DLV_ERROR;\n        }\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error, section_end);\n        /* The offset is global. */\n        break;\n    case DW_FORM_data8:\n        if (context_version >= DW_CU_VERSION4) {\n            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);\n            return DW_DLV_ERROR;\n        }\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        /* The offset is global. */\n        break;\n    case DW_FORM_ref_addr:\n        {\n            /*  In Dwarf V2 DW_FORM_ref_addr was defined\n                as address-size even though it is a .debug_info\n                offset.  Fixed in Dwarf V3 to be offset-size.\n                */\n            unsigned length_size = 0;\n            if (context_version == 2) {\n                length_size = cu_context->cc_address_size;\n            } else {\n                length_size = cu_context->cc_length_size;\n            }\n            if (length_size == 4) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n                    error,section_end);\n            } else if (length_size == 8) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n                    error,section_end);\n            } else {\n                _dwarf_error(dbg, error,\n                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);\n                return DW_DLV_ERROR;\n            }\n        }\n        break;\n    /*  Index into .debug_rnglists/.debug_loclists section.\n        Return the index itself. */\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx: {\n        unsigned length_size = cu_context->cc_length_size;\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, length_size,\n            error,section_end);\n        }\n        break;\n    case DW_FORM_sec_offset:\n    case DW_FORM_GNU_ref_alt:  /* 2013 GNU extension */\n    case DW_FORM_GNU_strp_alt: /* 2013 GNU extension */\n    case DW_FORM_strp_sup:     /* DWARF5, sup string section */\n    case DW_FORM_line_strp:    /* DWARF5, .debug_line_str section */\n        {\n            /*  DW_FORM_sec_offset first exists in DWARF4.*/\n            /*  It is up to the caller to know what the offset\n                of DW_FORM_sec_offset, DW_FORM_strp_sup\n                or DW_FORM_GNU_strp_alt etc refer to,\n                the offset is not going to refer to .debug_info! */\n            unsigned length_size = cu_context->cc_length_size;\n            if (length_size == 4) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n                    error,section_end);\n            } else if (length_size == 8) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n                    error,section_end);\n            } else {\n                _dwarf_error(dbg, error,\n                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);\n                return DW_DLV_ERROR;\n            }\n        }\n        break;\n    case DW_FORM_ref_sig8: {\n        /*  This, in DWARF4, is how\n            .debug_info refers to .debug_types. */\n        Dwarf_Sig8 sig8;\n        Dwarf_Bool t_is_info = TRUE;\n        Dwarf_Unsigned t_offset = 0;\n\n        memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));\n        res = find_sig8_target_as_global_offset(attr,\n            &sig8,&t_is_info,&t_offset,error);\n        if (res == DW_DLV_ERROR) {\n            _dwarf_error_string(dbg, error,\n                DW_DLE_REF_SIG8_NOT_HANDLED,\n                \"DW_DLE_REF_SIG8_NOT_HANDLED: \"\n                \" problem finding target\");\n            return DW_DLV_ERROR;\n        }\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        is_info = t_is_info;\n        offset = t_offset;\n        break;\n    }\n    default: {\n        dwarfstring m;\n        int formcode = attr->ar_attribute_form;\n        int fcres = 0;\n        const char *name = 0;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM: The form code is 0x%x \",\n            formcode);\n        fcres  = dwarf_get_FORM_name (formcode,&name);\n        if (fcres != DW_DLV_OK) {\n            name=\"<UnknownFormCode>\";\n        }\n        dwarfstring_append_printf_s(&m,\n            \" %s.\",(char *)name);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    *offset_is_info = is_info;\n    *ret_offset = offset;\n    return DW_DLV_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-34299"
    },
    {
        "index": 613,
        "code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  // Retrive all 8 bytes when axis type is kTfLiteInt64 to avoid data loss.\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  // Copy the input dimensions to output except the axis dimension.\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29603"
    },
    {
        "index": 614,
        "code": "static void addjump(JF, enum js_AstType type, js_Ast *target, int inst)\n{\n\tjs_JumpList *jump = js_malloc(J, sizeof *jump);\n\tjump->type = type;\n\tjump->inst = inst;\n\tjump->next = target->jumps;\n\ttarget->jumps = jump;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45005"
    },
    {
        "index": 615,
        "code": "  void Compute(OpKernelContext *ctx) override {\n    // (0) validations\n    const Tensor *a_indices, *b_indices, *a_values_t, *b_values_t, *a_shape,\n        *b_shape, *thresh_t;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsMatrix(a_indices->shape()) &&\n                    TensorShapeUtils::IsMatrix(b_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be matrices but received shapes: \",\n                    a_indices->shape().DebugString(), \" and \",\n                    b_indices->shape().DebugString()));\n    const int64 a_nnz = a_indices->dim_size(0);\n    const int64 b_nnz = b_indices->dim_size(0);\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                    TensorShapeUtils::IsVector(b_values_t->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be vectors but received shapes: \",\n                    a_values_t->shape().DebugString(), \" and \",\n                    b_values_t->shape().DebugString()));\n    auto a_values = ctx->input(1).vec<T>();\n    auto b_values = ctx->input(4).vec<T>();\n    OP_REQUIRES(\n        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n        errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                \" non-empty input values, got \",\n                                a_values.size(), \" and \", b_values.size()));\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_shape->shape()) &&\n                    TensorShapeUtils::IsVector(b_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    a_shape->shape().DebugString(), \" and \",\n                    b_shape->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, a_shape->IsSameSize(*b_shape),\n        errors::InvalidArgument(\n            \"Operands do not have the same ranks; got shapes: \",\n            a_shape->SummarizeValue(10), \" and \", b_shape->SummarizeValue(10)));\n    const auto a_shape_flat = a_shape->flat<int64>();\n    const auto b_shape_flat = b_shape->flat<int64>();\n    for (int i = 0; i < a_shape->NumElements(); ++i) {\n      OP_REQUIRES(ctx, a_shape_flat(i) == b_shape_flat(i),\n                  errors::InvalidArgument(\n                      \"Operands' shapes do not match: got \", a_shape_flat(i),\n                      \" and \", b_shape_flat(i), \" for dimension \", i));\n    }\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"thresh\", &thresh_t));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(thresh_t->shape()),\n                errors::InvalidArgument(\n                    \"The magnitude threshold must be a scalar: got shape \",\n                    thresh_t->shape().DebugString()));\n    // std::abs() so that it works for complex{64,128} values as well\n    const Treal thresh = thresh_t->scalar<Treal>()();\n\n    // (1) do a pass over inputs, and append values and indices to vectors\n    auto a_indices_mat = a_indices->matrix<int64>();\n    auto b_indices_mat = b_indices->matrix<int64>();\n    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx\n    entries_to_copy.reserve(a_nnz + b_nnz);\n    std::vector<T> out_values;\n    const int num_dims = a_shape->dim_size(0);\n\n    // The input and output sparse tensors are assumed to be ordered along\n    // increasing dimension number.\n    int64 i = 0, j = 0;\n    T s;\n    while (i < a_nnz && j < b_nnz) {\n      switch (sparse::DimComparator::cmp(a_indices_mat, b_indices_mat, i, j,\n                                         num_dims)) {\n        case -1:\n          entries_to_copy.emplace_back(true, i);\n          out_values.push_back(a_values(i));\n          ++i;\n          break;\n        case 0:\n          s = a_values(i) + b_values(j);\n          if (thresh <= std::abs(s)) {\n            entries_to_copy.emplace_back(true, i);\n            out_values.push_back(s);\n          }\n          ++i;\n          ++j;\n          break;\n        case 1:\n          entries_to_copy.emplace_back(false, j);\n          out_values.push_back(b_values(j));\n          ++j;\n          break;\n      }\n    }\n\n#define HANDLE_LEFTOVERS(A_OR_B, IDX, IS_A)     \\\n  while (IDX < A_OR_B##_nnz) {                  \\\n    entries_to_copy.emplace_back(IS_A, IDX);    \\\n    out_values.push_back(A_OR_B##_values(IDX)); \\\n    ++IDX;                                      \\\n  }\n\n    // at most one of these calls appends new values\n    HANDLE_LEFTOVERS(a, i, true);\n    HANDLE_LEFTOVERS(b, j, false);\n#undef HANDLE_LEFTOVERS\n\n    // (2) allocate and fill output tensors\n    const int64 sum_nnz = out_values.size();\n    Tensor *out_indices_t, *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                        &out_indices_t));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &out_values_t));\n    auto out_indices_mat = out_indices_t->matrix<int64>();\n    auto out_values_flat = out_values_t->vec<T>();\n\n    for (i = 0; i < sum_nnz; ++i) {\n      const bool from_a = entries_to_copy[i].first;\n      const int64 idx = entries_to_copy[i].second;\n      out_indices_mat.chip<0>(i) =\n          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n    }\n    if (sum_nnz > 0) {\n      std::copy_n(out_values.begin(), sum_nnz, &out_values_flat(0));\n    }\n    ctx->set_output(2, *a_shape);\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29609"
    },
    {
        "index": 616,
        "code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            // error_setg_errno(errp, errno,\n            //         \"cannot set up guest memory '%s'\",\n            //         memory_region_name(new_block->mr));\n            return;\n        }\n        // memory_try_enable_merging(new_block->host, new_block->max_length);\n    }\n\n    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,\n     * QLIST (which has an RCU-friendly variant) does not have insertion at\n     * tail, so save the last element in last_block.\n     */\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { /* list is empty */\n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n\n    /* Write list before version */\n    //smp_wmb();\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29694"
    },
    {
        "index": 617,
        "code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n\n    *t = op_def.output_arg(i).experimental_full_type();\n\n    // Resolve dependent types. The convention for op registrations is to use\n    // attributes as type variables.\n    // See https://www.tensorflow.org/guide/create_op#type_polymorphism.\n    // Once the op signature can be defined entirely in FullType, this\n    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n\n        arg->clear_s();\n      }\n    }\n  }\n\n  return ft;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-23574"
    },
    {
        "index": 618,
        "code": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n\n    return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-6018"
    },
    {
        "index": 619,
        "code": "static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tif (mffield) {\n\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t\t}\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2549"
    },
    {
        "index": 620,
        "code": "de265_error seq_parameter_set::read(error_queue* errqueue, bitreader* br)\n{\n  int vlc;\n\n  video_parameter_set_id = get_bits(br,4);\n  sps_max_sub_layers     = get_bits(br,3) +1;\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  sps_temporal_id_nesting_flag = get_bits(br,1);\n\n  profile_tier_level_.read(br, sps_max_sub_layers);\n\n  READ_VLC(seq_parameter_set_id, uvlc);\n  if (seq_parameter_set_id >= DE265_MAX_SPS_SETS) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- decode chroma type ---\n\n  READ_VLC(chroma_format_idc, uvlc);\n\n  if (chroma_format_idc == 3) {\n    separate_colour_plane_flag = get_bits(br,1);\n  }\n  else {\n    separate_colour_plane_flag = 0;\n  }\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- picture size ---\n\n  READ_VLC(pic_width_in_luma_samples,  uvlc);\n  READ_VLC(pic_height_in_luma_samples, uvlc);\n\n  if (pic_width_in_luma_samples  == 0 ||\n      pic_height_in_luma_samples == 0) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (pic_width_in_luma_samples > MAX_PICTURE_WIDTH ||\n      pic_height_in_luma_samples> MAX_PICTURE_HEIGHT) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  conformance_window_flag = get_bits(br,1);\n\n  if (conformance_window_flag) {\n    READ_VLC(conf_win_left_offset,  uvlc);\n    READ_VLC(conf_win_right_offset, uvlc);\n    READ_VLC(conf_win_top_offset,   uvlc);\n    READ_VLC(conf_win_bottom_offset,uvlc);\n  }\n  else {\n    conf_win_left_offset  = 0;\n    conf_win_right_offset = 0;\n    conf_win_top_offset   = 0;\n    conf_win_bottom_offset= 0;\n  }\n\n  READ_VLC_OFFSET(bit_depth_luma,  uvlc, 8);\n  READ_VLC_OFFSET(bit_depth_chroma,uvlc, 8);\n  if (bit_depth_luma > 16 ||\n      bit_depth_chroma > 16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  READ_VLC_OFFSET(log2_max_pic_order_cnt_lsb, uvlc, 4);\n  if (log2_max_pic_order_cnt_lsb<4 ||\n      log2_max_pic_order_cnt_lsb>16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  MaxPicOrderCntLsb = 1<<(log2_max_pic_order_cnt_lsb);\n\n\n  // --- sub_layer_ordering_info ---\n\n  sps_sub_layer_ordering_info_present_flag = get_bits(br,1);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    vlc=get_uvlc(br);\n    if (vlc == UVLC_ERROR ||\n        vlc+1 > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    sps_max_dec_pic_buffering[i] = vlc+1;\n\n    // sps_max_num_reorder_pics[i]\n\n    READ_VLC(sps_max_num_reorder_pics[i], uvlc);\n\n\n    // sps_max_latency_increase[i]\n\n    READ_VLC(sps_max_latency_increase_plus1[i], uvlc);\n\n    SpsMaxLatencyPictures[i] = (sps_max_num_reorder_pics[i] +\n                                sps_max_latency_increase_plus1[i]-1);\n  }\n\n  // copy info to all layers if only specified once\n\n  if (sps_sub_layer_ordering_info_present_flag) {\n    int ref = sps_max_sub_layers-1;\n    assert(ref<7);\n\n    for (int i=0 ; i < sps_max_sub_layers-1; i++ ) {\n      sps_max_dec_pic_buffering[i] = sps_max_dec_pic_buffering[ref];\n      sps_max_num_reorder_pics[i]  = sps_max_num_reorder_pics[ref];\n      sps_max_latency_increase_plus1[i]  = sps_max_latency_increase_plus1[ref];\n    }\n  }\n\n\n  READ_VLC_OFFSET(log2_min_luma_coding_block_size, uvlc, 3);\n  READ_VLC       (log2_diff_max_min_luma_coding_block_size, uvlc);\n  READ_VLC_OFFSET(log2_min_transform_block_size, uvlc, 2);\n  READ_VLC(log2_diff_max_min_transform_block_size, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_inter, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_intra, uvlc);\n\n  if (log2_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size + log2_diff_max_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n  scaling_list_enable_flag = get_bits(br,1);\n\n  if (scaling_list_enable_flag) {\n\n    sps_scaling_list_data_present_flag = get_bits(br,1);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=read_scaling_list(br,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n    else {\n      set_default_scaling_lists(&scaling_list);\n    }\n  }\n\n  amp_enabled_flag = get_bits(br,1);\n  sample_adaptive_offset_enabled_flag = get_bits(br,1);\n  pcm_enabled_flag = get_bits(br,1);\n  if (pcm_enabled_flag) {\n    pcm_sample_bit_depth_luma = get_bits(br,4)+1;\n    pcm_sample_bit_depth_chroma = get_bits(br,4)+1;\n    READ_VLC_OFFSET(log2_min_pcm_luma_coding_block_size, uvlc, 3);\n    READ_VLC(log2_diff_max_min_pcm_luma_coding_block_size, uvlc);\n    pcm_loop_filter_disable_flag = get_bits(br,1);\n\n    if (pcm_sample_bit_depth_luma > bit_depth_luma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pcm_sample_bit_depth_chroma > bit_depth_chroma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n  else {\n    pcm_sample_bit_depth_luma = 0;\n    pcm_sample_bit_depth_chroma = 0;\n    log2_min_pcm_luma_coding_block_size = 0;\n    log2_diff_max_min_pcm_luma_coding_block_size = 0;\n    pcm_loop_filter_disable_flag = 0;\n  }\n\n  int num_short_term_ref_pic_sets;\n  READ_VLC(num_short_term_ref_pic_sets, uvlc);\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  ref_pic_sets.resize(num_short_term_ref_pic_sets);\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = read_short_term_ref_pic_set(errqueue,this,br,\n                                               &ref_pic_sets[i], i,\n                                               ref_pic_sets,\n                                               false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  long_term_ref_pics_present_flag = get_bits(br,1);\n\n  if (long_term_ref_pics_present_flag) {\n\n    READ_VLC(num_long_term_ref_pics_sps, uvlc);\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      lt_ref_pic_poc_lsb_sps[i] = get_bits(br, log2_max_pic_order_cnt_lsb);\n      used_by_curr_pic_lt_sps_flag[i] = get_bits(br,1);\n    }\n  }\n  else {\n    num_long_term_ref_pics_sps = 0; // NOTE: missing definition in standard !\n  }\n\n  sps_temporal_mvp_enabled_flag = get_bits(br,1);\n  strong_intra_smoothing_enable_flag = get_bits(br,1);\n\n  vui_parameters_present_flag = get_bits(br,1);\n  if (vui_parameters_present_flag) {\n    vui.read(errqueue, br, this);\n  }\n\n\n  sps_extension_present_flag = get_bits(br,1);\n  if (sps_extension_present_flag) {\n    sps_range_extension_flag = get_bits(br,1);\n    sps_multilayer_extension_flag = get_bits(br,1);\n    sps_extension_6bits = get_bits(br,6);\n  }\n  else {\n    sps_range_extension_flag = 0;\n  }\n\n  if (sps_range_extension_flag) {\n    de265_error err = range_extension.read(errqueue, br);\n    if (err != DE265_OK) { return err; }\n  }\n\n  /*\n  sps_extension_flag = get_bits(br,1);\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  */\n\n\n  de265_error err = compute_derived_values();\n  if (err != DE265_OK) { return err; }\n\n  sps_read = true;\n\n  return DE265_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1253"
    },
    {
        "index": 621,
        "code": "static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 255) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 622,
        "code": "R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0519"
    },
    {
        "index": 623,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* input_indices;\n    const Tensor* input_values;\n    const Tensor* input_shape;\n    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    TensorShape tensor_input_shape(input_shape->vec<int64>());\n    gtl::InlinedVector<int64, 8> std_order(rank);\n    std::iota(std_order.begin(), std_order.end(), 0);\n    SparseTensor input_st;\n    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st));\n\n    auto input_shape_t = input_shape->vec<int64>();\n    const int64 N = input_shape_t(0);\n\n    Tensor sparse_handles(DT_INT64, TensorShape({N}));\n    auto sparse_handles_t = sparse_handles.vec<int64>();\n\n    OP_REQUIRES_OK(context, input_st.IndicesValid());\n\n    // We can generate the output shape proto string now, for all\n    // minibatch entries.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                input_shape_t.data() + 1,\n                                input_shape->NumElements() - 1, &output_shape));\n\n    // Get groups by minibatch dimension\n    std::unordered_set<int64> visited;\n    sparse::GroupIterable minibatch = input_st.group({0});\n    for (const auto& subset : minibatch) {\n      const int64 b = subset.group()[0];\n      visited.insert(b);\n      OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"));\n\n      const auto indices = subset.indices();\n      const auto values = subset.values<T>();\n      const int64 num_entries = values.size();\n\n      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n      Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n\n      auto output_indices_t = output_indices.matrix<int64>();\n      auto output_values_t = output_values.vec<T>();\n\n      for (int i = 0; i < num_entries; ++i) {\n        for (int d = 1; d < rank; ++d) {\n          output_indices_t(i, d - 1) = indices(i, d);\n        }\n        output_values_t(i) = values(i);\n      }\n\n      SparseTensor st_i;\n      OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i));\n      int64 handle;\n      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n      sparse_handles_t(b) = handle;\n    }\n\n    // Fill in any gaps; we must provide an empty ST for batch entries\n    // the grouper didn't find.\n    if (visited.size() < N) {\n      Tensor empty_indices(DT_INT64, {0, rank - 1});\n      Tensor empty_values(DataTypeToEnum<T>::value, {0});\n      SparseTensor empty_st;\n      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st));\n\n      for (int64 b = 0; b < N; ++b) {\n        // We skipped this batch entry.\n        if (visited.find(b) == visited.end()) {\n          int64 handle;\n          OP_REQUIRES_OK(context,\n                         map->AddSparseTensor(context, empty_st, &handle));\n          sparse_handles_t(b) = handle;\n        }\n      }\n    }\n\n    context->set_output(0, sparse_handles);\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-29523"
    },
    {
        "index": 624,
        "code": "njs_function_lambda_call(njs_vm_t *vm)\n{\n    uint32_t               n;\n    njs_int_t              ret;\n    njs_frame_t            *frame;\n    njs_value_t            *args, **local, *value;\n    njs_value_t            **cur_local, **cur_closures, **cur_temp;\n    njs_function_t         *function;\n    njs_declaration_t      *declr;\n    njs_function_lambda_t  *lambda;\n\n    frame = (njs_frame_t *) vm->top_frame;\n    function = frame->native.function;\n\n    if (function->global && !function->closure_copied) {\n        ret = njs_function_capture_global_closures(vm, function);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    lambda = function->u.lambda;\n\n    args = vm->top_frame->arguments;\n    local = vm->top_frame->local + function->args_offset;\n\n    /* Move all arguments. */\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(args)) {\n            njs_set_undefined(args);\n        }\n\n        *local++ = args++;\n    }\n\n    /* Store current level. */\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n\n    /* Replace current level. */\n\n    vm->levels[NJS_LEVEL_LOCAL] = vm->top_frame->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(function);\n    vm->levels[NJS_LEVEL_TEMP] = frame->native.temp;\n\n    if (lambda->rest_parameters) {\n        ret = njs_function_rest_parameters_init(vm, &frame->native);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    /* Self */\n\n    if (lambda->self != NJS_INDEX_NONE) {\n        value = njs_scope_value(vm, lambda->self);\n\n        if (!njs_is_valid(value)) {\n            njs_set_function(value, function);\n        }\n    }\n\n    vm->active_frame = frame;\n\n    /* Closures */\n\n    n = lambda->ndeclarations;\n\n    while (n != 0) {\n        n--;\n\n        declr = &lambda->declarations[n];\n        value = njs_scope_value(vm, declr->index);\n\n        *value = *declr->value;\n\n        function = njs_function_value_copy(vm, value);\n        if (njs_slow_path(function == NULL)) {\n            return NJS_ERROR;\n        }\n\n        ret = njs_function_capture_closure(vm, function, function->u.lambda);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    ret = njs_vmcode_interpreter(vm, lambda->start);\n\n    /* Restore current level. */\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    return ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-25139"
    },
    {
        "index": 625,
        "code": "undo_time(\n    long\tstep,\n    int\t\tsec,\n    int\t\tfile,\n    int\t\tabsolute)\n{\n    long\t    target;\n    long\t    closest;\n    long\t    closest_start;\n    long\t    closest_seq = 0;\n    long\t    val;\n    u_header_T\t    *uhp = NULL;\n    u_header_T\t    *last;\n    int\t\t    mark;\n    int\t\t    nomark = 0;  // shut up compiler\n    int\t\t    round;\n    int\t\t    dosec = sec;\n    int\t\t    dofile = file;\n    int\t\t    above = FALSE;\n    int\t\t    did_undo = TRUE;\n\n    // First make sure the current undoable change is synced.\n    if (curbuf->b_u_synced == FALSE)\n\tu_sync(TRUE);\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n\n    // \"target\" is the node below which we want to be.\n    // Init \"closest\" to a value we can't reach.\n    if (absolute)\n    {\n\ttarget = step;\n\tclosest = -1;\n    }\n    else\n    {\n\tif (dosec)\n\t    target = (long)(curbuf->b_u_time_cur) + step;\n\telse if (dofile)\n\t{\n\t    if (step < 0)\n\t    {\n\t\t// Going back to a previous write. If there were changes after\n\t\t// the last write, count that as moving one file-write, so\n\t\t// that \":earlier 1f\" undoes all changes since the last save.\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp != NULL)\n\t\t    uhp = uhp->uh_next.ptr;\n\t\telse\n\t\t    uhp = curbuf->b_u_newhead;\n\t\tif (uhp != NULL && uhp->uh_save_nr != 0)\n\t\t    // \"uh_save_nr\" was set in the last block, that means\n\t\t    // there were no changes since the last write\n\t\t    target = curbuf->b_u_save_nr_cur + step;\n\t\telse\n\t\t    // count the changes since the last write as one step\n\t\t    target = curbuf->b_u_save_nr_cur + step + 1;\n\t\tif (target <= 0)\n\t\t    // Go to before first write: before the oldest change. Use\n\t\t    // the sequence number for that.\n\t\t    dofile = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t// Moving forward to a newer write.\n\t\ttarget = curbuf->b_u_save_nr_cur + step;\n\t\tif (target > curbuf->b_u_save_nr_last)\n\t\t{\n\t\t    // Go to after last write: after the latest change. Use\n\t\t    // the sequence number for that.\n\t\t    target = curbuf->b_u_seq_last + 1;\n\t\t    dofile = FALSE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    target = curbuf->b_u_seq_cur + step;\n\tif (step < 0)\n\t{\n\t    if (target < 0)\n\t\ttarget = 0;\n\t    closest = -1;\n\t}\n\telse\n\t{\n\t    if (dosec)\n\t\tclosest = (long)(vim_time() + 1);\n\t    else if (dofile)\n\t\tclosest = curbuf->b_u_save_nr_last + 2;\n\t    else\n\t\tclosest = curbuf->b_u_seq_last + 2;\n\t    if (target >= closest)\n\t\ttarget = closest - 1;\n\t}\n    }\n    closest_start = closest;\n    closest_seq = curbuf->b_u_seq_cur;\n\n    // When \"target\" is 0; Back to origin.\n    if (target == 0)\n    {\n\tmark = lastmark;  // avoid that GCC complains\n\tgoto target_zero;\n    }\n\n    /*\n     * May do this twice:\n     * 1. Search for \"target\", update \"closest\" to the best match found.\n     * 2. If \"target\" not found search for \"closest\".\n     *\n     * When using the closest time we use the sequence number in the second\n     * round, because there may be several entries with the same time.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t// Find the path from the current state to where we want to go.  The\n\t// desired state can be anywhere in the undo tree, need to go all over\n\t// it.  We put \"nomark\" in uh_walk where we have been without success,\n\t// \"mark\" where it could possibly be.\n\tmark = ++lastmark;\n\tnomark = ++lastmark;\n\n\tif (curbuf->b_u_curhead == NULL)\t// at leaf of the tree\n\t    uhp = curbuf->b_u_newhead;\n\telse\n\t    uhp = curbuf->b_u_curhead;\n\n\twhile (uhp != NULL)\n\t{\n\t    uhp->uh_walk = mark;\n\t    if (dosec)\n\t\tval = (long)(uhp->uh_time);\n\t    else if (dofile)\n\t\tval = uhp->uh_save_nr;\n\t    else\n\t\tval = uhp->uh_seq;\n\n\t    if (round == 1 && !(dofile && val == 0))\n\t    {\n\t\t// Remember the header that is closest to the target.\n\t\t// It must be at least in the right direction (checked with\n\t\t// \"b_u_seq_cur\").  When the timestamp is equal find the\n\t\t// highest/lowest sequence number.\n\t\tif ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur\n\t\t\t      : uhp->uh_seq > curbuf->b_u_seq_cur)\n\t\t\t&& ((dosec && val == closest)\n\t\t\t    ? (step < 0\n\t\t\t\t? uhp->uh_seq < closest_seq\n\t\t\t\t: uhp->uh_seq > closest_seq)\n\t\t\t    : closest == closest_start\n\t\t\t\t|| (val > target\n\t\t\t\t    ? (closest > target\n\t\t\t\t\t? val - target <= closest - target\n\t\t\t\t\t: val - target <= target - closest)\n\t\t\t\t    : (closest > target\n\t\t\t\t\t? target - val <= closest - target\n\t\t\t\t\t: target - val <= target - closest))))\n\t\t{\n\t\t    closest = val;\n\t\t    closest_seq = uhp->uh_seq;\n\t\t}\n\t    }\n\n\t    // Quit searching when we found a match.  But when searching for a\n\t    // time we need to continue looking for the best uh_seq.\n\t    if (target == val && !dosec)\n\t    {\n\t\ttarget = uhp->uh_seq;\n\t\tbreak;\n\t    }\n\n\t    // go down in the tree if we haven't been there\n\t    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_prev.ptr;\n\n\t    // go to alternate branch if we haven't been there\n\t    else if (uhp->uh_alt_next.ptr != NULL\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_alt_next.ptr;\n\n\t    // go up in the tree if we haven't been there and we are at the\n\t    // start of alternate branches\n\t    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t    && uhp->uh_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_next.ptr->uh_walk != mark)\n\t    {\n\t\t// If still at the start we don't go through this change.\n\t\tif (uhp == curbuf->b_u_curhead)\n\t\t    uhp->uh_walk = nomark;\n\t\tuhp = uhp->uh_next.ptr;\n\t    }\n\n\t    else\n\t    {\n\t\t// need to backtrack; mark this node as useless\n\t\tuhp->uh_walk = nomark;\n\t\tif (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\telse\n\t\t    uhp = uhp->uh_next.ptr;\n\t    }\n\t}\n\n\tif (uhp != NULL)    // found it\n\t    break;\n\n\tif (absolute)\n\t{\n\t    semsg(_(e_undo_number_nr_not_found), step);\n\t    return;\n\t}\n\n\tif (closest == closest_start)\n\t{\n\t    if (step < 0)\n\t\tmsg(_(\"Already at oldest change\"));\n\t    else\n\t\tmsg(_(\"Already at newest change\"));\n\t    return;\n\t}\n\n\ttarget = closest_seq;\n\tdosec = FALSE;\n\tdofile = FALSE;\n\tif (step < 0)\n\t    above = TRUE;\t// stop above the header\n    }\n\ntarget_zero:\n    // If we found it: Follow the path to go to where we want to be.\n    if (uhp != NULL || target == 0)\n    {\n\t/*\n\t * First go up the tree as much as needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    // Do the change warning now, for the same reason as above.\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tuhp = curbuf->b_u_newhead;\n\t    else\n\t\tuhp = uhp->uh_next.ptr;\n\t    if (uhp == NULL || (target > 0 && uhp->uh_walk != mark)\n\t\t\t\t\t || (uhp->uh_seq == target && !above))\n\t\tbreak;\n\t    curbuf->b_u_curhead = uhp;\n\t    u_undoredo(TRUE);\n\t    if (target > 0)\n\t\tuhp->uh_walk = nomark;\t// don't go back down here\n\t}\n\n\t// When back to origin, redo is not needed.\n\tif (target > 0)\n\t{\n\t    /*\n\t     * And now go down the tree (redo), branching off where needed.\n\t     */\n\t    while (!got_int)\n\t    {\n\t\t// Do the change warning now, for the same reason as above.\n\t\tchange_warning(0);\n\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp == NULL)\n\t\t    break;\n\n\t\t// Go back to the first branch with a mark.\n\t\twhile (uhp->uh_alt_prev.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_prev.ptr->uh_walk == mark)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\n\t\t// Find the last branch with a mark, that's the one.\n\t\tlast = uhp;\n\t\twhile (last->uh_alt_next.ptr != NULL\n\t\t\t\t    && last->uh_alt_next.ptr->uh_walk == mark)\n\t\t    last = last->uh_alt_next.ptr;\n\t\tif (last != uhp)\n\t\t{\n\t\t    // Make the used branch the first entry in the list of\n\t\t    // alternatives to make \"u\" and CTRL-R take this branch.\n\t\t    while (uhp->uh_alt_prev.ptr != NULL)\n\t\t\tuhp = uhp->uh_alt_prev.ptr;\n\t\t    if (last->uh_alt_next.ptr != NULL)\n\t\t\tlast->uh_alt_next.ptr->uh_alt_prev.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_prev.ptr;\n\t\t    last->uh_alt_prev.ptr->uh_alt_next.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_next.ptr;\n\t\t    last->uh_alt_prev.ptr = NULL;\n\t\t    last->uh_alt_next.ptr = uhp;\n\t\t    uhp->uh_alt_prev.ptr = last;\n\n\t\t    if (curbuf->b_u_oldhead == uhp)\n\t\t\tcurbuf->b_u_oldhead = last;\n\t\t    uhp = last;\n\t\t    if (uhp->uh_next.ptr != NULL)\n\t\t\tuhp->uh_next.ptr->uh_prev.ptr = uhp;\n\t\t}\n\t\tcurbuf->b_u_curhead = uhp;\n\n\t\tif (uhp->uh_walk != mark)\n\t\t    break;\t    // must have reached the target\n\n\t\t// Stop when going backwards in time and didn't find the exact\n\t\t// header we were looking for.\n\t\tif (uhp->uh_seq == target && above)\n\t\t{\n\t\t    curbuf->b_u_seq_cur = target - 1;\n\t\t    break;\n\t\t}\n\n\t\tu_undoredo(FALSE);\n\n\t\t// Advance \"curhead\" to below the header we last used.  If it\n\t\t// becomes NULL then we need to set \"newhead\" to this leaf.\n\t\tif (uhp->uh_prev.ptr == NULL)\n\t\t    curbuf->b_u_newhead = uhp;\n\t\tcurbuf->b_u_curhead = uhp->uh_prev.ptr;\n\t\tdid_undo = FALSE;\n\n\t\tif (uhp->uh_seq == target)\t// found it!\n\t\t    break;\n\n\t\tuhp = uhp->uh_prev.ptr;\n\t\tif (uhp == NULL || uhp->uh_walk != mark)\n\t\t{\n\t\t    // Need to redo more but can't find it...\n\t\t    internal_error(\"undo_time()\");\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    u_undo_end(did_undo, absolute);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1897"
    },
    {
        "index": 626,
        "code": "s32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \"first_slice_segment_in_pic_flag\");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segment_flag\");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \"slice_segment_address\");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \"slice_reserved_undetermined_flag\");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"pic_output_flag\");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \"colour_plane_id\");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \"poc_lsb\");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"short_term_ref_pic_set_sps_flag\") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \"short_term_ref_pic_set_idx\");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \"num_long_term_sps\");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \"num_long_term_pics\");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \"lt_idx_sps\", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"PocLsbLt\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"UsedByCurrPicLt\", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"delta_poc_msb_present_flag\", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"slice_temporal_mvp_enabled_flag\");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_luma_flag\");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_chroma_flag\");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active\");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active\");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"mvd_l1_zero_flag\");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"cabac_init_flag\");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \"collocated_from_l0_flag\");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \"collocated_ref_idx\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \"five_minus_max_num_merge_cand\");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \"slice_qp_delta\");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_cb_qp_offset\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_cr_qp_offset\");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_flag\");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"slice_deblocking_filter_disabled_flag\");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_tc_offset_div2\");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_loop_filter_across_slices_enabled_flag\");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \"num_entry_point_offsets\");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \"offset\") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \"size_ext\");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \"byte_align\") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-30020"
    },
    {
        "index": 627,
        "code": "void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                              uint32_t enc_len, char *_hashX,\n                              char *_hashY, char *signature) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(_hashX);\n    CHECK_STATE(_hashY);\n    CHECK_STATE(signature);\n\n    SAFE_CHAR_BUF(key, BUF_LEN);SAFE_CHAR_BUF(sig, BUF_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN);\n\n    CHECK_STATUS(\"AES decrypt failed\")\n\n    if (!enclave_sign(key, _hashX, _hashY, sig)) {\n        strncpy(errString, \"Enclave failed to create bls signature\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    strncpy(signature, sig, BUF_LEN);\n\n    if (strnlen(signature, BUF_LEN) < 10) {\n        strncpy(errString, \"Signature too short\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    SET_SUCCESS\n\n    LOG_DEBUG(\"SGX call completed\");\n\n    clean:\n    ;\n    LOG_DEBUG(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 628,
        "code": "  void Compute(OpKernelContext* c) override {\n    core::RefCountPtr<Var> v;\n    OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));\n    OP_REQUIRES_OK(c, EnsureSparseVariableAccess<Device, T>(c, v.get()));\n    // NOTE: We hold the lock for the whole gather operation instead\n    // of increasing the reference count of v->tensor() to avoid a\n    // situation where a write to the same variable will see a\n    // reference count greater than one and make a copy of the\n    // (potentially very large) tensor buffer.\n    tf_shared_lock ml(*v->mu());\n    const Tensor& params = *v->tensor();\n    const Tensor& indices = c->input(1);\n    OP_REQUIRES(\n        c, TensorShapeUtils::IsVectorOrHigher(params.shape()),\n        errors::InvalidArgument(\"params must be at least 1 dimensional\"));\n\n    // Check that we have enough index space\n    const int64_t N = indices.NumElements();\n    OP_REQUIRES(\n        c, params.dim_size(0) <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"params.shape[0] too large for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", params.dim_size(0), \" > \",\n                                std::numeric_limits<Index>::max()));\n\n    // The result shape is params.shape[:batch_dims] +\n    // indices.shape[batch_dims:] + params.shape[batch_dims+1:].\n    TensorShape result_shape;\n    for (int i = 0; i < batch_dims_; ++i) {\n      result_shape.AddDim(params.dim_size(i));\n    }\n    for (int i = batch_dims_; i < indices.dims(); ++i) {\n      result_shape.AddDim(indices.dim_size(i));\n    }\n    for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n      result_shape.AddDim(params.dim_size(i));\n    }\n\n    Tensor* out = nullptr;\n    Tensor tmp;\n    if (params.dtype() == DT_VARIANT) {\n      tmp = Tensor(DT_VARIANT, result_shape);\n      c->set_output(0, tmp);\n      out = &tmp;\n    } else {\n      OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, &out));\n    }\n\n    if (N > 0) {\n      Tensor tmp_indices;\n\n      // Points to the original or updated (if batch_dims is set) indices.\n      const Tensor* op_indices = &indices;\n      if (batch_dims_ > 0) {\n        OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),\n                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(&tmp_indices, params);\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {\n        gather_dim_size *= params.dim_size(idx);\n      }\n      int64_t inner_size = 1;\n      for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n        inner_size *= params.dim_size(i);\n      }\n      auto params_flat = params.shaped<T, 3>({1, gather_dim_size, inner_size});\n      const auto indices_flat = op_indices->flat<Index>();\n      auto out_flat = out->shaped<T, 3>({1, N, out->NumElements() / N});\n\n      functor::GatherFunctor<Device, T, Index> functor;\n      int64_t bad_i = functor(c, params_flat, indices_flat, out_flat);\n\n      OP_REQUIRES(\n          c, bad_i < 0,\n          errors::InvalidArgument(\n              \"indices\", SliceDebugString(indices.shape(), bad_i), \" = \",\n              indices_flat(bad_i), \" is not in [0, \", params.dim_size(0), \")\"));\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37654"
    },
    {
        "index": 629,
        "code": "s32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \"first_slice_segment_in_pic_flag\");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segment_flag\");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \"slice_segment_address\");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \"slice_reserved_undetermined_flag\");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"pic_output_flag\");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \"colour_plane_id\");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \"poc_lsb\");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"short_term_ref_pic_set_sps_flag\") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \"short_term_ref_pic_set_idx\");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \"num_long_term_sps\");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \"num_long_term_pics\");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \"lt_idx_sps\", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"PocLsbLt\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"UsedByCurrPicLt\", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"delta_poc_msb_present_flag\", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"slice_temporal_mvp_enabled_flag\");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_luma_flag\");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_chroma_flag\");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active\");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active\");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"mvd_l1_zero_flag\");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"cabac_init_flag\");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \"collocated_from_l0_flag\");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \"collocated_ref_idx\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \"five_minus_max_num_merge_cand\");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \"slice_qp_delta\");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_cb_qp_offset\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_cr_qp_offset\");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_flag\");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"slice_deblocking_filter_disabled_flag\");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_tc_offset_div2\");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_loop_filter_across_slices_enabled_flag\");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \"num_entry_point_offsets\");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \"offset\") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \"size_ext\");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \"byte_align\") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30014"
    },
    {
        "index": 630,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n\n    // Determine relevant sizes from input and filters.\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n\n    // Output tensor is of the following dimensions:\n    // [ batch, out_rows, out_cols, depth ]\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    const std::vector<int64> out_sizes = {batch, out_rows, out_cols, depth};\n    TensorShape out_shape(out_sizes);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    // If there is nothing to compute, return.\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n\n    functor::Dilation<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), stride_rows, stride_cols, rate_rows, rate_cols,\n        pad_top, pad_left, output->tensor<T, 4>());\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-29566"
    },
    {
        "index": 631,
        "code": "\n    {                                                                                   \\\n\n        UBaseType_t uxSavedInterruptStatus;                                             \\\n\n                                                                                        \\\n\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\n\n        {                                                                               \\\n\n            if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \\\n\n            {                                                                           \\\n\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\n\n                                             ( uint32_t ) 0,                            \\\n\n                                             eNoAction,                                 \\\n\n                                             pxHigherPriorityTaskWoken );               \\\n\n                ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \\\n\n            }                                                                           \\\n\n        }                                                                               \\\n\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\n\n    }\n\n#endif /* sbSEND_COMPLETE_FROM_ISR */\n\n/*lint -restore (9026) */\n\n\n\n/* The number of bytes used to hold the length of a message in the buffer. */\n\n#define sbBYTES_TO_STORE_MESSAGE_LENGTH    ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )\n\n\n\n/* Bits stored in the ucFlags field of the stream buffer. */\n\n#define sbFLAGS_IS_MESSAGE_BUFFER          ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */\n\n#define sbFLAGS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */\n\n\n\n/*-----------------------------------------------------------*/\n\n\n\n/* Structure that hold state information on the buffer. */\n\ntypedef struct StreamBufferDef_t                 /*lint !e9058 Style convention uses tag. */\n\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-31572"
    },
    {
        "index": 632,
        "code": "void ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  // Allocator is owned by the tensor from this point.\n  allocator.release()->set_delete_on_deallocate();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41227"
    },
    {
        "index": 633,
        "code": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: /* FIXME */\n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-29242"
    },
    {
        "index": 634,
        "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45936"
    },
    {
        "index": 635,
        "code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-23308"
    },
    {
        "index": 636,
        "code": "static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n      \n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n    \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 637,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_sli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned sli_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && sli_cnt && sli, PJ_EINVAL);\n\n    len = (3 + sli_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB SLI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 2; /* FMT = 2 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB SLI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\t*p++  = (pj_uint8_t)((sli[i].first >> 5) & 0xFF);   /* 8 MSB bits */\n\t*p    = (pj_uint8_t)((sli[i].first & 31) << 3);\t    /* 5 LSB bits */\n\t/* 'number' takes 13 bit */\n\t*p++ |= (pj_uint8_t)((sli[i].number >> 10) & 7);    /* 3 MSB bits */\n\t*p++  = (pj_uint8_t)((sli[i].number >> 2) & 0xFF);  /* 8 mid bits */\n\t*p    = (pj_uint8_t)((sli[i].number & 3) << 6);\t    /* 2 LSB bits */\n\t/* 'pict_id' takes 6 bit */\n\t*p++ |= (sli[i].pict_id & 63);\n    }\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 638,
        "code": "bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node,\n                                      const GraphProperties& properties) {\n  // Push down multiplication on ConvND.\n  //                       *                  ConvND\n  //                     /   \\                /    \\\n  //                 ConvND  C2    -- >      X      *\n  //                  / \\                          / \\\n  //                 X  C1                       C1  C2\n  //\n  // where C1 and C2 are constants and X is non-constant.\n  //\n  // TODO(rmlarsen): Use PrepareConstantPushDown() to simplify this code.\n\n  if (!IsAnyMul(*node) || NumNonControlInputs(*node) != 2) return false;\n\n  NodeDef* mul_left_child = node_map_->GetNode(node->input(0));\n  NodeDef* mul_right_child = node_map_->GetNode(node->input(1));\n  // One child must be constant, and the second must be Conv op.\n  const bool left_child_is_constant = IsReallyConstant(*mul_left_child);\n  const bool right_child_is_constant = IsReallyConstant(*mul_right_child);\n  if (!left_child_is_constant && !right_child_is_constant) {\n    return false;\n  }\n  NodeDef* conv_node =\n      left_child_is_constant ? mul_right_child : mul_left_child;\n  if (!IsConv2D(*conv_node) && !IsConv3D(*conv_node)) {\n    return false;\n  }\n  if (node->device() != mul_left_child->device() ||\n      node->device() != mul_right_child->device()) {\n    return false;\n  }\n\n  // Make sure that it is safe to change the value of the convolution\n  // output.\n  if (conv_node->input_size() < 2 ||\n      NumNonControlOutputs(*conv_node, *node_map_) > 1 ||\n      nodes_to_preserve_.find(conv_node->name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n\n  // Identify the nodes to swap.\n  NodeDef* conv_left_child = node_map_->GetNode(conv_node->input(0));\n  NodeDef* conv_right_child = node_map_->GetNode(conv_node->input(1));\n  const bool conv_left_is_constant = IsReallyConstant(*conv_left_child);\n  const bool conv_right_is_constant = IsReallyConstant(*conv_right_child);\n  if (!conv_left_is_constant && !conv_right_is_constant) {\n    // At least one of the convolution inputs should be constant.\n    return false;\n  }\n  if (conv_left_is_constant && conv_right_is_constant) {\n    // Leverage regular constant folding to handle this.\n    return false;\n  }\n  const auto& mul_props = properties.GetOutputProperties(node->name());\n  const auto& conv_props = properties.GetOutputProperties(conv_node->name());\n  if (mul_props.empty() || conv_props.empty()) {\n    return false;\n  }\n  const auto& mul_shape = mul_props[0].shape();\n  const auto& conv_shape = conv_props[0].shape();\n  if (!ShapesSymbolicallyEqual(mul_shape, conv_shape)) {\n    return false;\n  }\n\n  const auto& input_props = properties.GetInputProperties(conv_node->name());\n  if (input_props.size() < 2) {\n    return false;\n  }\n  const auto& filter_shape = input_props[1].shape();\n\n  NodeDef* const_node =\n      left_child_is_constant ? mul_left_child : mul_right_child;\n  const auto& const_props = properties.GetOutputProperties(const_node->name());\n  if (const_props.empty()) {\n    return false;\n  }\n  const auto& const_shape = const_props[0].shape();\n  if (!IsValidConstShapeForMulConvPushDown(\n          conv_node->attr().at(\"data_format\").s(), filter_shape, const_shape)) {\n    return false;\n  }\n\n  string mul_new_name = AddPrefixToNodeName(\"merged_input\", conv_node->name());\n  if (node_map_->NodeExists(mul_new_name)) {\n    return false;\n  }\n  // Make sure we don't introduce loops in the graph by removing control\n  // dependencies from the conv2d node to c2.\n  string conv_const_input =\n      conv_left_is_constant ? conv_node->input(0) : conv_node->input(1);\n  if (MaybeRemoveControlInput(conv_node->name(), const_node, optimized_graph,\n                              node_map_.get())) {\n    // Add a control dep from c1 to c2 to ensure c2 is in the right frame\n    MaybeAddControlInput(conv_const_input, const_node, optimized_graph,\n                         node_map_.get());\n  }\n\n  conv_node->set_name(node->name());\n  node->set_name(mul_new_name);\n  if (conv_left_is_constant) {\n    node_map_->UpdateInput(conv_node->name(), node->input(0), mul_new_name);\n    conv_node->set_input(0, mul_new_name);\n  } else {\n    node_map_->UpdateInput(conv_node->name(), node->input(1), mul_new_name);\n    conv_node->set_input(1, mul_new_name);\n  }\n  NodeDef* conv_const_node =\n      conv_left_is_constant ? conv_left_child : conv_right_child;\n  if (left_child_is_constant) {\n    node->set_input(1, conv_const_node->name());\n  } else {\n    node->set_input(0, conv_const_node->name());\n  }\n  node_map_->AddNode(mul_new_name, node);\n\n  return true;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-23589"
    },
    {
        "index": 639,
        "code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& indices_tensor = ctx->input(0);\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(indices_tensor.shape()) ||\n                    TensorShapeUtils::IsScalar(indices_tensor.shape()),\n                errors::InvalidArgument(\n                    \"The indices can only be scalar or vector, got \\\"\",\n                    indices_tensor.shape().DebugString(), \"\\\"\"));\n\n    const Tensor& dims_tensor = ctx->input(1);\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(dims_tensor.shape()),\n        errors::InvalidArgument(\"The indices can only be 1-D, got \\\"\",\n                                dims_tensor.shape().DebugString(), \"\\\"\"));\n\n    auto dims = dims_tensor.vec<Tidx>();\n    // Make sure dims does not contain a zero\n    for (int i = 0; i < dims.size(); i++) {\n      OP_REQUIRES(\n          ctx, dims(i) != 0,\n          errors::InvalidArgument(\"Input dims cannot contain a dim of zero, \"\n                                  \"but dims contains zero at index \",\n                                  i));\n    }\n\n    // Check to make sure indices is not out of boundary\n    Eigen::Tensor<Tidx, 0, Eigen::RowMajor> dims_prod_eigen = dims.prod();\n    Tidx dims_prod = dims_prod_eigen();\n    const Tidx* indices = indices_tensor.flat<Tidx>().data();\n    int64_t size = indices_tensor.NumElements();\n    bool check = std::all_of(indices, indices + size,\n                             [&](Tidx index) { return index < dims_prod; });\n    OP_REQUIRES(ctx, check,\n                errors::InvalidArgument(\"index is out of bound as with dims\"));\n\n    Eigen::array<bool, 1> reverse({true});\n\n    Tensor strides_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<Tidx>::value,\n                                      TensorShape({dims_tensor.NumElements()}),\n                                      &strides_tensor));\n\n    auto strides = strides_tensor.vec<Tidx>();\n    strides = dims.reverse(reverse)\n                  .scan(0, Eigen::internal::ProdReducer<Tidx>(), false)\n                  .reverse(reverse);\n\n    Tensor strides_shifted_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<Tidx>::value,\n                                      TensorShape({dims_tensor.NumElements()}),\n                                      &strides_shifted_tensor));\n\n    auto strides_shifted = strides_shifted_tensor.vec<Tidx>();\n    strides_shifted = dims.reverse(reverse)\n                          .scan(0, Eigen::internal::ProdReducer<Tidx>(), true)\n                          .reverse(reverse);\n\n    Tensor* output_tensor = nullptr;\n    if (TensorShapeUtils::IsScalar(indices_tensor.shape())) {\n      OP_REQUIRES_OK(\n          ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements()}),\n                                    &output_tensor));\n\n      auto output = output_tensor->vec<Tidx>();\n\n      output = output.constant(indices_tensor.scalar<Tidx>()());\n      output = output.binaryExpr(strides, mod_op<Tidx>()) / strides_shifted;\n    } else {\n      OP_REQUIRES_OK(\n          ctx, ctx->allocate_output(0,\n                                    TensorShape({dims_tensor.NumElements(),\n                                                 indices_tensor.NumElements()}),\n                                    &output_tensor));\n\n      auto output = output_tensor->matrix<Tidx>();\n\n      Eigen::array<Eigen::Index, 2> reshape{\n          {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}};\n      Eigen::array<Eigen::Index, 2> bcast(\n          {1, static_cast<Eigen::Index>(indices_tensor.NumElements())});\n      Eigen::array<Eigen::Index, 2> indices_reshape{\n          {1, static_cast<Eigen::Index>(indices_tensor.NumElements())}};\n      Eigen::array<Eigen::Index, 2> indices_bcast(\n          {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1});\n\n      output = indices_tensor.vec<Tidx>()\n                   .reshape(indices_reshape)\n                   .broadcast(indices_bcast);\n      output = output.binaryExpr(strides.reshape(reshape).broadcast(bcast),\n                                 mod_op<Tidx>()) /\n               strides_shifted.reshape(reshape).broadcast(bcast);\n    }\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-21729"
    },
    {
        "index": 640,
        "code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\n\tgf_bs_read_u8(bs); //reserved\n\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\n\n\tISOM_DECREASE_SIZE(ptr, 17);\n\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-31254"
    },
    {
        "index": 641,
        "code": "getvcol(\n    win_T\t*wp,\n    pos_T\t*pos,\n    colnr_T\t*start,\n    colnr_T\t*cursor,\n    colnr_T\t*end)\n{\n    colnr_T\tvcol;\n    char_u\t*ptr;\t\t// points to current char\n    char_u\t*posptr;\t// points to char at pos->col\n    char_u\t*line;\t\t// start of the line\n    int\t\tincr;\n    int\t\thead;\n#ifdef FEAT_VARTABS\n    int\t\t*vts = wp->w_buffer->b_p_vts_array;\n#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\t// Special check for an empty line, which can happen on exit, when\n\t// ml_get_buf() always returns an empty string.\n\tif (*ptr == NUL)\n\t    pos->col = 0;\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    /*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.\n     * Also use this when 'list' is set but tabs take their normal size.\n     */\n    if ((!wp->w_p_list || wp->w_lcs_chars.tab1 != NUL)\n#ifdef FEAT_LINEBREAK\n\t    && !wp->w_p_lbr && *get_showbreak_value(wp) == NUL && !wp->w_p_bri\n#endif\n       )\n    {\n\tfor (;;)\n\t{\n\t    head = 0;\n\t    c = *ptr;\n\t    // make sure we don't go past the end of the line\n\t    if (c == NUL)\n\t    {\n\t\tincr = 1;\t// NUL at end of line only takes one column\n\t\tbreak;\n\t    }\n\t    // A tab gets expanded, depending on the current column\n\t    if (c == TAB)\n#ifdef FEAT_VARTABS\n\t\tincr = tabstop_padding(vcol, ts, vts);\n#else\n\t\tincr = ts - (vcol % ts);\n#endif\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // For utf-8, if the byte is >= 0x80, need to look at\n\t\t    // further bytes to find the cell width.\n\t\t    if (enc_utf8 && c >= 0x80)\n\t\t\tincr = utf_ptr2cells(ptr);\n\t\t    else\n\t\t\tincr = g_chartab[c] & CT_CELL_MASK;\n\n\t\t    // If a double-cell char doesn't fit at the end of a line\n\t\t    // it wraps to the next line, it's like this char is three\n\t\t    // cells wide.\n\t\t    if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1\n\t\t\t    && in_win_border(wp, vcol))\n\t\t    {\n\t\t\t++incr;\n\t\t\thead = 1;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    incr = g_chartab[c] & CT_CELL_MASK;\n\t    }\n\n\t    if (posptr != NULL && ptr >= posptr) // character at pos->col\n\t\tbreak;\n\n\t    vcol += incr;\n\t    MB_PTR_ADV(ptr);\n\t}\n    }\n    else\n    {\n\tfor (;;)\n\t{\n\t    // A tab gets expanded, depending on the current column\n\t    head = 0;\n\t    incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head);\n\t    // make sure we don't go past the end of the line\n\t    if (*ptr == NUL)\n\t    {\n\t\tincr = 1;\t// NUL at end of line only takes one column\n\t\tbreak;\n\t    }\n\n\t    if (posptr != NULL && ptr >= posptr) // character at pos->col\n\t\tbreak;\n\n\t    vcol += incr;\n\t    MB_PTR_ADV(ptr);\n\t}\n    }\n    if (start != NULL)\n\t*start = vcol + head;\n    if (end != NULL)\n\t*end = vcol + incr - 1;\n    if (cursor != NULL)\n    {\n\tif (*ptr == TAB\n\t\t&& (State & NORMAL)\n\t\t&& !wp->w_p_list\n\t\t&& !virtual_active()\n\t\t&& !(VIsual_active\n\t\t\t\t&& (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual)))\n\t\t)\n\t    *cursor = vcol + incr - 1;\t    // cursor at end\n\telse\n\t    *cursor = vcol + head;\t    // cursor at start\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-4193"
    },
    {
        "index": 642,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr == NULL) {\n\t\t// TODO eprintf\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_inner_classes_attr_summary(attr);\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0518"
    },
    {
        "index": 643,
        "code": "Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& op_context,\n                                                  NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n\n  const auto method = op_context.op_info.attr().find(\"method\");\n  bool use_bilinear_interp;\n  if (method == op_context.op_info.attr().end() ||\n      method->second.s() == \"bilinear\") {\n    use_bilinear_interp = true;\n  } else if (method->second.s() == \"nearest\") {\n    use_bilinear_interp = false;\n  } else {\n    LOG(WARNING) << \"method attr in CropAndResize invalid; expected bilinear \"\n                    \"or nearest.\";\n    return PredictCostOfAnUnknownOp(op_context, node_costs);\n  }\n\n  const int64_t num_boxes = op_context.op_info.inputs(1).shape().dim(0).size();\n  const auto crop_shape = MaybeGetMinimumShape(\n      op_context.op_info.outputs(0).shape(), 4, &found_unknown_shapes);\n  const int64_t crop_height = crop_shape.dim(1).size();\n  const int64_t crop_width = crop_shape.dim(2).size();\n  const int64_t output_elements = CalculateTensorElementCount(\n      op_context.op_info.outputs(0), &found_unknown_shapes);\n\n#define EIGEN_COST(X) Eigen::internal::functor_traits<Eigen::internal::X>::Cost\n  const auto sub_cost = EIGEN_COST(scalar_difference_op<float>);\n  const auto add_cost = EIGEN_COST(scalar_sum_op<float>);\n  const auto mul_cost = EIGEN_COST(scalar_product_op<float>);\n  auto div_cost = EIGEN_COST(scalar_div_cost<float>);\n  const auto floor_cost = EIGEN_COST(scalar_floor_op<float>);\n  const auto ceil_cost = EIGEN_COST(scalar_ceil_op<float>);\n  auto round_cost = EIGEN_COST(scalar_round_op<float>);\n  const auto cast_to_float_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_cast_op<int64_t, float>>::Cost;\n#undef EIGEN_COST\n\n  // Computing ops following\n  // tensorflow/core/kernels/image/crop_and_resize_op.cc at 08/25/2020. Op\n  // calculation differs from rough estimate in implementation, as it separates\n  // out cost per box from cost per pixel and cost per element.\n\n  // Ops for variables height_scale and width_scale.\n  int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;\n  // Ops for variable in_y.\n  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;\n  // Ops for variable in_x (same computation across both branches).\n  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *\n         num_boxes;\n  // Specify op_cost based on the method.\n  if (use_bilinear_interp) {\n    // Ops for variables top_y_index, bottom_y_index, y_lerp.\n    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;\n    // Ops for variables left_x, right_x, x_lerp;\n    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *\n           num_boxes;\n    // Ops for innermost loop across depth.\n    ops +=\n        (cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *\n        output_elements;\n  } else /* method == \"nearest\" */ {\n    // Ops for variables closest_x_index and closest_y_index.\n    ops += round_cost * 2 * crop_height * crop_width * num_boxes;\n    // Ops for innermost loop across depth.\n    ops += cast_to_float_cost * output_elements;\n  }\n  return PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,\n                                 node_costs);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23587"
    },
    {
        "index": 644,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned bitlen, padlen, len;\n\n    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);\n\n    bitlen = (unsigned)rpsi->rpsi_bit_len + 16;\n    padlen = (32 - (bitlen % 32)) % 32;\n    len = (3 + (bitlen+padlen)/32) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB RPSI header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 3; /* FMT = 3 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB RPSI FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    /* PB (number of padding bits) */\n    *p++ = (pj_uint8_t)padlen;\n    /* Payload type */\n    *p++ = rpsi->pt & 0x7F;\n    /* RPSI bit string */\n    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8);\n    p += rpsi->rpsi_bit_len/8;\n    if (rpsi->rpsi_bit_len % 8) {\n\t*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8);\n    }\n    /* Zero padding */\n    if (padlen >= 8)\n\tpj_bzero(p, padlen/8);\n\n    /* Finally */\n    *length = len;\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 645,
        "code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->set (*other);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-45931"
    },
    {
        "index": 646,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const auto* params =\n      reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* positions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputPositions, &positions));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (positions->type) {\n    case kTfLiteInt64:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(\n          context, \"Positions of type '%s' are not supported by gather.\",\n          TfLiteTypeGetName(positions->type));\n      return kTfLiteError;\n  }\n\n  // Assign to output the input type.\n  output->type = input->type;\n\n  // Check conditions for different types.\n  switch (input->type) {\n    case kTfLiteFloat32:\n    case kTfLiteUInt8:\n    case kTfLiteInt8:\n    case kTfLiteInt16:\n    case kTfLiteInt64:\n    case kTfLiteInt32:\n    case kTfLiteBool:\n      break;\n    case kTfLiteString: {\n      // Only 1D input is supported.\n      TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n    } break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                           TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n\n  int axis = params->axis;\n  if (axis < 0) {\n    axis += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, 0 <= axis && axis < NumDimensions(input));\n\n  int batch_dims = params->batch_dims;\n  // batch_dims should be in range: [-rank(positions), rank(positions)].\n  // Negative batch_dims is added with rank of positions.\n  if (batch_dims < 0) {\n    batch_dims += NumDimensions(positions);\n  }\n  TF_LITE_ENSURE(context, batch_dims <= axis);\n  TF_LITE_ENSURE(context, 0 <= batch_dims && batch_dims < NumDimensions(input));\n  TF_LITE_ENSURE(context, batch_dims <= NumDimensions(positions));\n  for (int i = 0; i < batch_dims; ++i) {\n    TF_LITE_ENSURE_EQ(context, input->dims->data[i], positions->dims->data[i]);\n  }\n\n  const int num_dimensions =\n      NumDimensions(input) + NumDimensions(positions) - 1 - batch_dims;\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(num_dimensions);\n  int output_index = 0;\n  for (int i = 0; i < axis; ++i) {\n    output_shape->data[output_index++] = input->dims->data[i];\n  }\n  for (int i = batch_dims; i < positions->dims->size; ++i) {\n    output_shape->data[output_index++] = positions->dims->data[i];\n  }\n  for (int i = axis + 1; i < input->dims->size; ++i) {\n    output_shape->data[output_index++] = input->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37687"
    },
    {
        "index": 647,
        "code": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-24025"
    },
    {
        "index": 648,
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1061"
    },
    {
        "index": 649,
        "code": "void create_test_key() {\n    int errStatus = 0;\n    vector<char> errMsg(1024, 0);\n    uint32_t enc_len;\n\n    SAFE_UINT8_BUF(encrypted_key, BUF_LEN);\n\n    string key = TEST_VALUE;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key, &enc_len);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_key, enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    LevelDB::getLevelDb()->writeDataUnique(\"TEST_KEY\", hexEncrKey.data());\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 650,
        "code": "static Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n\n    curlen = Jsi_ObjGetLength(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    \n    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            /* TODO: are NULL args ok? */ \n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    \n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 651,
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n\n   /*---------------------*/\n   /* MESH STRUCTURE INIT */\n   /*---------------------*/\n\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n\n   MshIdx = (int64_t)msh;\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n\n      free(msh);\n      return(0);\n   }\n\n   // Copy the FilNam into the structure\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n\n   strcpy(msh->FilNam, FilNam);\n\n   // Store the opening mod (read or write) and guess\n   // the filetype (binary or ascii) depending on the extension\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n\n   // Open the file in the required mod and initialize the mesh structure\n   if(msh->mod == GmfRead)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR READING */\n      /*-----------------------*/\n\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n\n      // Read the endian coding tag, the mesh version\n      // and the mesh dimension (mandatory kwd)\n      if(msh->typ & Bin)\n      {\n         // Create the name string and open the file\n#ifdef WITH_GMF_AIO\n         // [Bruno] added binary flag (necessary under Windows)\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n\n         // Read the endian coding tag\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         // [Bruno] added binary flag (necessary under Windows)\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n\n         // Read the endian coding tag\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n\n         // Read the mesh version and the mesh dimension (mandatory kwd)\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         // Create the name string and open the file\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -14);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -16);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      /*------------*/\n      /* KW READING */\n      /*------------*/\n\n      // Read the list of kw present in the file\n      if(!ScaKwdTab(msh))\n         return(0);\n\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR WRITING */\n      /*-----------------------*/\n\n      msh->cod = 1;\n\n      // Check if the user provided a valid version number and dimension\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      // Create the mesh file\n      if(msh->typ & Bin) \n      {\n         /* \n          * [Bruno] replaced previous call to creat():\n          * with a call to open(), because Windows needs the\n          * binary flag to be specified.\n          */\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n\n\n      /*------------*/\n      /* KW WRITING */\n      /*------------*/\n\n      // Write the mesh version and dimension\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-46225"
    },
    {
        "index": 652,
        "code": "s32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \"first_slice_segment_in_pic_flag\");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \"no_output_of_prior_pics_flag\");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \"dependent_slice_segment_flag\");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \"slice_segment_address\");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \"slice_reserved_undetermined_flag\");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"pic_output_flag\");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \"colour_plane_id\");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \"poc_lsb\");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"short_term_ref_pic_set_sps_flag\") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \"short_term_ref_pic_set_idx\");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \"num_long_term_sps\");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \"num_long_term_pics\");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \"lt_idx_sps\", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \"PocLsbLt\", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \"UsedByCurrPicLt\", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"delta_poc_msb_present_flag\", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \"DeltaPocMsbCycleLt\", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"slice_temporal_mvp_enabled_flag\");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_luma_flag\");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \"slice_sao_chroma_flag\");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active\");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active\");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"mvd_l1_zero_flag\");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"cabac_init_flag\");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \"collocated_from_l0_flag\");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \"collocated_ref_idx\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \"five_minus_max_num_merge_cand\");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \"slice_qp_delta\");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_cb_qp_offset\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_cr_qp_offset\");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_override_flag\");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"slice_deblocking_filter_disabled_flag\");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"slice_tc_offset_div2\");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_loop_filter_across_slices_enabled_flag\");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \"num_entry_point_offsets\");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \"offset\") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \"size_ext\");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \"byte_align\") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-30022"
    },
    {
        "index": 653,
        "code": "bool IsValidationSubgraph(const char* name) {\n  // NOLINTNEXTLINE: can't use absl::StartsWith as absl is not allowed.\n  return name && std::string(name).find(kValidationSubgraphNamePrefix) == 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23559"
    },
    {
        "index": 654,
        "code": "trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n    SAFE_CHAR_BUF(dkg_secret, DKG_BUFER_LENGTH);\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);\n\n    CHECK_STATUS(\"aes decrypt dkg poly failed\");\n\n    if (strcmp(dkg_secret, decr_dkg_secret) != 0) {\n        snprintf(errString, BUF_LEN,\n                 \"encrypted poly is not equal to decrypted poly\");\n        LOG_ERROR(errString);\n        *errStatus = -333;\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36218"
    },
    {
        "index": 655,
        "code": "R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tif (sz < 10) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t// Current spec does not call for variable sizes.\n\tattr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new: Processing stack map, summary is:\\n\");\n\tIFDBG r_bin_java_print_stack_map_table_attr_summary(attr);\n\tfor (i = 0; i < attr->info.stack_map_table_attr.number_of_entries; i++) {\n\t\t// read next stack frame\n\t\tIFDBG eprintf (\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\tif (stack_frame == NULL && R_BIN_JAVA_GLOBAL_BIN && R_BIN_JAVA_GLOBAL_BIN->current_code_attr) {\n\t\t\tIFDBG eprintf (\"Setting an implicit frame at #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\t\tstack_frame = R_BIN_JAVA_GLOBAL_BIN->current_code_attr->info.code_attr.implicit_frame;\n\t\t}\n\t\tIFDBG eprintf (\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \", current stack_frame: %p\\n\", i, buf_offset + offset, stack_frame);\n\t\tif (offset >= sz) {\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_stack_frame = r_bin_java_stack_map_frame_new (buffer + offset, sz - offset, stack_frame, buf_offset + offset);\n\t\tif (new_stack_frame) {\n\t\t\toffset += new_stack_frame->size;\n\t\t\t// append stack frame to the list\n\t\t\tr_list_append (attr->info.stack_map_table_attr.stack_map_frame_entries, (void *) new_stack_frame);\n\t\t\tstack_frame = new_stack_frame;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_table_attr_new: Unable to parse the stack frame for the stack map table.\\n\");\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\tattr = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr) {\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 656,
        "code": "R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {\n\tut64 size = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *se;\n\tif (sf) {\n\t\t// sf->tag = buffer[offset];\n\t\tsize += 1;\n\t\tswitch (sf->type) {\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t\t// Nothing to read\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// sf->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->local_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\t// sf->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown type\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-0521"
    },
    {
        "index": 657,
        "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t/* 'number' takes 13 bit */\n\tsli[i].number = ((p[1] & 0x07) << 10) +\n\t\t\t(p[2] << 2) +\n\t\t\t((p[3] & 0xC0) >> 6);\n\t/* 'pict_id' takes 6 bit */\n\tsli[i].pict_id = (p[3] & 0x3F);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-24786"
    },
    {
        "index": 658,
        "code": "static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(field);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n        case PB_HTYPE_ONEOF:\n            if (!check_wire_type(wire_type, field))\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            if (PB_LTYPE_IS_SUBMSG(field->type) && *(void**)field->pField != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                /* FIXME: Does this work correctly for oneofs? */\n                pb_release_single_field(field);\n            }\n        \n            if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n            {\n                *(pb_size_t*)field->pSize = field->tag;\n            }\n\n            if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n                PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n            {\n                /* pb_dec_string and pb_dec_bytes handle allocation themselves */\n                field->pData = field->pField;\n                return decode_basic_field(stream, field);\n            }\n            else\n            {\n                if (!allocate_field(stream, field->pField, field->data_size, 1))\n                    return false;\n                \n                field->pData = *(void**)field->pField;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, field);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                size_t allocated_size = *size;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        allocated_size += (substream.bytes_left - 1) / field->data_size + 1;\n                        \n                        if (!allocate_field(&substream, field->pField, field->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    field->pData = *(char**)field->pField + field->data_size * (*size);\n                    initialize_pointer_field(field->pData, field);\n                    if (!decode_basic_field(&substream, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n\n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                if (!check_wire_type(wire_type, field))\n                    PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n                (*size)++;\n                if (!allocate_field(stream, field->pField, field->data_size, *size))\n                    return false;\n            \n                field->pData = *(char**)field->pField + field->data_size * (*size - 1);\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, field);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-5235"
    },
    {
        "index": 659,
        "code": "static void test_reply_reader(void) {\n    redisReader *reader;\n    void *reply, *root;\n    int ret;\n    int i;\n\n    test(\"Error handling in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    /* when the reply already contains multiple items, they must be free'd\n     * on an error. valgrind will bark when this doesn't happen. */\n    test(\"Memory cleanup in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*2\\r\\n\",4);\n    redisReaderFeed(reader,(char*)\"$5\\r\\nhello\\r\\n\",11);\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    reader = redisReaderCreate();\n    test(\"Can handle arbitrarily nested multi-bulks: \");\n    for (i = 0; i < 128; i++) {\n        redisReaderFeed(reader,(char*)\"*1\\r\\n\", 4);\n    }\n    redisReaderFeed(reader,(char*)\"$6\\r\\nLOLWUT\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    root = reply; /* Keep track of the root reply */\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 1);\n\n    test(\"Can parse arbitrarily nested multi-bulks correctly: \");\n    while(i--) {\n        assert(reply != NULL && ((redisReply*)reply)->type == REDIS_REPLY_ARRAY);\n        reply = ((redisReply*)reply)->element[0];\n    }\n    test_cond(((redisReply*)reply)->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->str, \"LOLWUT\", 6));\n    freeReplyObject(root);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775807\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MAX);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when > LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775808\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775808\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MIN);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when < LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775809\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when array < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*-2\\r\\n+asdf\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$-2\\r\\nasdf\\r\\n\",11);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Can configure maximum multi-bulk elements: \");\n    reader = redisReaderCreate();\n    reader->maxelements = 1024;\n    redisReaderFeed(reader, \"*1025\\r\\n\", 7);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr, \"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n#if LLONG_MAX > SIZE_MAX\n    test(\"Set error when array > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*9223372036854775807\\r\\n+asdf\\r\\n\",29);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$9223372036854775807\\r\\nasdf\\r\\n\",28);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n#endif\n\n    test(\"Works with NULL functions for reply: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\\n\",5);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Works when a single newline (\\\\r\\\\n) covers two calls to feed: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_OK && reply == NULL);\n    redisReaderFeed(reader,(char*)\"\\n\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Don't reset state after protocol error: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"x\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_ERR);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR && reply == NULL);\n    redisReaderFree(reader);\n\n    /* Regression test for issue #45 on GitHub. */\n    test(\"Don't do empty allocation for empty multi bulk: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*0\\r\\n\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 verbatim strings (GitHub issue #802) */\n    test(\"Can parse RESP3 verbatim strings: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"=10\\r\\ntxt:LOLWUT\\r\\n\",17);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_VERB &&\n         !memcmp(((redisReply*)reply)->str,\"LOLWUT\", 6));\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 push messages (Github issue #815) */\n    test(\"Can parse RESP3 push messages: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\">2\\r\\n$6\\r\\nLOLWUT\\r\\n:42\\r\\n\",21);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&\n        ((redisReply*)reply)->elements == 2 &&\n        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->element[0]->str,\"LOLWUT\",6) &&\n        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n        ((redisReply*)reply)->element[1]->integer == 42);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2021-32762"
    },
    {
        "index": 660,
        "code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-2549"
    },
    {
        "index": 661,
        "code": "eval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2889"
    },
    {
        "index": 662,
        "code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n\n  /* Trim trailing whitespace from the returned string */\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n\n  }\n\n  return(ret);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-36082"
    },
    {
        "index": 663,
        "code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-30592"
    },
    {
        "index": 664,
        "code": "\n#include <stdlib.h>\n\n\n\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\n\n * all the API functions to use the MPU wrappers.  That should only be done when\n\n * task.h is included from an application file. */\n\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n\n\n#include \"FreeRTOS.h\"\n\n#include \"task.h\"\n\n\n\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n\n\n\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\n\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\n\n#endif\n\n\n\n/* A few bytes might be lost to byte aligning the heap start address. */\n\n#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )\n\n\n\n/* Allocate the memory for the heap. */\n\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\n\n\n\n/* The application writer has already defined the array used for the RTOS\n\n* heap - probably so it can be placed in a special segment or address. */\n\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-32020"
    },
    {
        "index": 665,
        "code": "TfLiteStatus Subgraph::CheckInputAndOutputForOverlap(const int* input_indices,\n                                                     int num_inputs,\n                                                     const int* output_indices,\n                                                     int num_outputs) {\n  for (int i = 0; i < num_inputs; i++) {\n    for (int j = 0; j < num_outputs; j++) {\n      if (input_indices[i] == output_indices[j]) {\n        ReportError(\"Tensor %d is both input %d and output %d\\n\",\n                    input_indices[i], i, j);\n        consistent_ = false;\n        return kTfLiteError;\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23559"
    },
    {
        "index": 666,
        "code": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n#if NE_BUG\n\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t}\n#else\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n#endif\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2022-1296"
    },
    {
        "index": 667,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(values.shape()),\n                errors::InvalidArgument(\"Input values must be a vector. Got: \",\n                                        values.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(shape.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector. Got: \",\n                                        shape.shape().DebugString()));\n    OP_REQUIRES(context,\n                values.shape().dim_size(0) == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", values.shape().dim_size(0),\n                    \" values, indices shape: \", indices.shape().DebugString()));\n    OP_REQUIRES(\n        context, shape.shape().dim_size(0) == indices.shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices.\",\n            \"Got \", shape.shape().dim_size(0),\n            \" dimensions, indices shape: \", indices.shape().DebugString()));\n    OP_REQUIRES(context, shape.NumElements() > 0,\n                errors::InvalidArgument(\n                    \"The shape argument requires at least one element.\"));\n    // Validate indices: each index must be valid for the corresponding\n    // dimension. This could be possibly done better.\n    const auto indices_values = indices.matrix<int64_t>();\n    const auto shape_vector = shape.vec<int64_t>();\n    int num_values = values.NumElements();  // same as first dim of indices\n    int rank = indices.shape().dim_size(1);\n    for (int i = 0; i < num_values; ++i) {\n      for (int j = 0; j < rank; ++j) {\n        OP_REQUIRES(\n            context,\n            indices_values(i, j) >= 0 && indices_values(i, j) < shape_vector(j),\n            errors::InvalidArgument(\n                \"Invalid index value at \", i, \": dimension \", j, \" has value \",\n                indices_values(i, j), \" which is not in [0, \", shape_vector(j),\n                \") (as given by dense shape \", shape.DebugString()));\n      }\n    }\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape_vector(0);\n\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      if (batch >= num_batches) {\n        OP_REQUIRES(context, batch < num_batches,\n                    errors::InvalidArgument(\n                        \"Indices value along the first dimension must be \",\n                        \"lower than the first index of the shape.\", \"Got \",\n                        batch, \" as batch and \", num_batches,\n                        \" as the first dimension of the shape.\"));\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-21738"
    },
    {
        "index": 668,
        "code": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\tint r;\n\n\tr = static_call(kvm_x86_skip_emulated_instruction)(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-1852"
    },
    {
        "index": 669,
        "code": "void APar_Print_TrackDetails(TrackInfo *track_info) {\n  if (track_info->max_bitrate > 0 && track_info->avg_bitrate > 0) {\n    fprintf(stdout, \"     %.2f kbp/s\", (float)track_info->avg_bitrate / 1000.0);\n  } else { // some ffmpeg encodings have avg_bitrate set to 0, but an inexact\n           // max_bitrate - actually, their esds seems a mess to me\n#if defined(_MSC_VER)\n    fprintf(stdout,\n            \"     %.2lf* kbp/s\",\n            ((double)((__int64)track_info->sample_aggregate) /\n             ((double)((__int64)track_info->duration) /\n              (double)((__int64)movie_info.timescale))) /\n                1000.0 * 8);\n    fprintf(stdout,\n            \"  %.3f sec\",\n            (float)track_info->duration / (float)movie_info.timescale);\n#else\n    fprintf(stdout,\n            \"     %.2lf* kbp/s\",\n            ((double)track_info->sample_aggregate /\n             ((double)track_info->duration / (double)movie_info.timescale)) /\n                1000.0 * 8);\n    fprintf(stdout,\n            \"  %.3f sec\",\n            (float)track_info->duration / (float)movie_info.timescale);\n#endif\n  }\n\n  if (track_info->track_codec == 0x6D703476) { // mp4v profile\n    APar_ShowObjectProfileInfo(MP4V_TRACK, track_info);\n  } else if (track_info->track_codec == 0x6D703461 ||\n             track_info->protected_codec == 0x6D703461) { // mp4a profile\n    APar_ShowObjectProfileInfo(AUDIO_TRACK, track_info);\n  } else if (track_info->track_codec ==\n             0x616C6163) { // alac - can't figure out a hardcoded bitrate either\n    fprintf(\n        stdout, \"  Apple Lossless    channels: [%u]\\n\", track_info->channels);\n  } else if (track_info->track_codec == 0x61766331 ||\n             track_info->protected_codec == 0x61766331) {\n    if (track_info->avc_version == 1) { // avc profile & level\n      APar_ShowObjectProfileInfo(AVC1_TRACK, track_info);\n    }\n  } else if (track_info->track_codec == 0x73323633) { // s263 in 3gp\n    APar_ShowObjectProfileInfo(S263_TRACK, track_info);\n  } else if (track_info->track_codec == 0x73616D72 ||\n             track_info->track_codec == 0x73617762 ||\n             track_info->track_codec == 0x73617770 ||\n             track_info->track_codec ==\n                 0x73766D72) { // samr,sawb,sawp & svmr in 3gp\n    track_info->type_of_track = S_AMR_TRACK;\n    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);\n  } else if (track_info->track_codec == 0x73657663) { // evrc in 3gp\n    track_info->type_of_track = EVRC_TRACK;\n    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);\n  } else if (track_info->track_codec == 0x73716370) { // qcelp in 3gp\n    track_info->type_of_track = QCELP_TRACK;\n    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);\n  } else if (track_info->track_codec == 0x73736D76) { // smv in 3gp\n    track_info->type_of_track = SMV_TRACK;\n    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);\n  } else { // unknown everything, 0 hardcoded bitrate\n    APar_ShowObjectProfileInfo(track_info->type_of_track, track_info);\n    fprintf(stdout, \"\\n\");\n  }\n\n  if (track_info->type_of_track & VIDEO_TRACK &&\n      ((track_info->max_bitrate > 0 &&\n        track_info->ObjectTypeIndication == 0x20) ||\n       track_info->avc_version == 1 || track_info->protected_codec != 0)) {\n    fprintf(stdout,\n            \"  %ux%u  (%\" PRIu32 \" macroblocks)\\n\",\n            track_info->video_width,\n            track_info->video_height,\n            track_info->macroblocks);\n  } else if (track_info->type_of_track & VIDEO_TRACK) {\n    fprintf(stdout, \"\\n\");\n  }\n  return;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-37232"
    },
    {
        "index": 670,
        "code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  // Use float as default for calculations.\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2022-23576"
    },
    {
        "index": 671,
        "code": "static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-40818"
    },
    {
        "index": 672,
        "code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2021-41205"
    },
    {
        "index": 673,
        "code": "  void Compute(OpKernelContext* context) override {\n    // Input tensor is of the following dimensions:\n    // [ batch, in_rows, in_cols, in_depth ]\n    const Tensor& input = context->input(0);\n\n    // Input filter is of the following dimensions:\n    // [ filter_rows, filter_cols, in_depth, out_depth]\n    const Tensor& filter = context->input(1);\n\n    // For 2D convolution, there should be 4 dimensions.\n    OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be 4-dimensional\",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(context, filter.dims() == 4,\n                errors::InvalidArgument(\"filter must be 4-dimensional: \",\n                                        filter.shape().DebugString()));\n\n    const float min_input = context->input(2).flat<float>()(0);\n    const float max_input = context->input(3).flat<float>()(0);\n    const float min_filter = context->input(4).flat<float>()(0);\n    const float max_filter = context->input(5).flat<float>()(0);\n    const int32_t offset_input =\n        FloatToQuantizedUnclamped<T1>(0.0f, min_input, max_input);\n    const int32_t offset_filter =\n        FloatToQuantizedUnclamped<T2>(0.0f, min_filter, max_filter);\n    const int32_t offset_output = 0;\n    const int32_t mult_output = 1;\n    const int32_t shift_output = 0;\n\n    // The last dimension for input is in_depth. It must be the same as the\n    // filter's in_depth.\n    const int64_t in_depth = input.dim_size(3);\n    OP_REQUIRES(context, in_depth == filter.dim_size(2),\n                errors::InvalidArgument(\n                    \"input and filter must have the same depth: \", in_depth,\n                    \" vs \", filter.dim_size(2)));\n\n    // The last dimension for filter is out_depth.\n    const int64_t out_depth = filter.dim_size(3);\n\n    // The second dimension for input is rows/height.\n    // The first dimension for filter is rows/height.\n    const int64_t input_rows = input.dim_size(1);\n    const int64_t filter_rows = filter.dim_size(0);\n\n    // The third dimension for input is columns/width.\n    // The second dimension for filter is columns/width.\n    const int64_t input_cols = input.dim_size(2);\n    const int64_t filter_cols = filter.dim_size(1);\n\n    // The first dimension for input is batch.\n    const int64_t batch = input.dim_size(0);\n\n    // For now we take the stride from the second dimension only (we\n    // assume row = col stride, and do not support striding on the\n    // batch or depth dimension).\n    const int stride = strides_[1];\n\n    int64_t out_rows = 0, out_cols = 0, pad_rows = 0, pad_cols = 0;\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(input_rows, filter_rows, stride,\n                                         padding_, &out_rows, &pad_rows));\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(input_cols, filter_cols, stride,\n                                         padding_, &out_cols, &pad_cols));\n    CHECK_GT(batch, 0);\n    CHECK_GT(out_rows, 0);\n    CHECK_GT(out_cols, 0);\n    CHECK_GT(out_depth, 0);\n    TensorShape out_shape({batch, out_rows, out_cols, out_depth});\n\n    // Output tensor is of the following dimensions:\n    // [ in_batch, out_rows, out_cols, out_depth ]\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    // This will call different implementations (e.g. reference or optimized)\n    // depending on the template parameter.\n    ConvFunctor<T1, T2, T3> conv_functor;\n    conv_functor(context, input.flat<T1>().data(), batch, input_rows,\n                 input_cols, in_depth, offset_input, filter.flat<T2>().data(),\n                 filter_rows, filter_cols, out_depth, offset_filter, stride,\n                 padding_, output->flat<T3>().data(), out_rows, out_cols,\n                 shift_output, offset_output, mult_output);\n\n    float min_output_value;\n    float max_output_value;\n    QuantizationRangeForMultiplication<T1, T2, T3>(\n        min_input, max_input, min_filter, max_filter, &min_output_value,\n        &max_output_value);\n\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_output_value;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_output_value;\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-29201"
    },
    {
        "index": 2358,
        "code": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\ttrace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2014-3690"
    },
    {
        "index": 9842,
        "code": "parse_range(char *str, size_t file_sz, int *nranges)\n{\n\tstatic struct range\t ranges[MAX_RANGES];\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\n\t/* Extract range unit */\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n\n\t*p++ = '\\0';\n\t/* Check if it's a bytes range spec */\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\n\t\t/* Extract start and end positions */\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n\t\t\tcontinue;\n\n\t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n\n\t\tp = q;\n\t}\n\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n\t\ti++;\n\n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2017-5850"
    },
    {
        "index": 11750,
        "code": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\n\tr_list_append (ret, addr);\n\treturn ret;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-0695"
    },
    {
        "index": 4534,
        "code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\t/* dock delta_exec before expiring quota (as it could span periods) */\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\n\t/*\n\t * if we're unable to extend our runtime we resched so that the active\n\t * hierarchy can be throttled\n\t */\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19922"
    },
    {
        "index": 838,
        "code": "asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\n\tenum direction dir = decode_direction(insn);\n\tint size = decode_access_size(insn);\n\n\tif(!ok_for_kernel(insn) || dir == both) {\n\t\tprintk(\"Unsupported unaligned load/store trap for kernel at <%08lx>.\\n\",\n\t\t       regs->pc);\n\t\tunaligned_panic(\"Wheee. Kernel does fpu/atomic unaligned load/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,\n\t\t\t\t\t   (unsigned long *) addr, regs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"Impossible kernel unaligned trap.\");\n\t\t\t/* Not reached... */\n\t\t}\n\t\tif (err)\n\t\t\tkernel_mna_trap_fault(regs, insn);\n\t\telse\n\t\t\tadvance(regs);\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 802,
        "code": "asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long write,\n\t\t\t      unsigned long address)\n{\n\tstruct vm_area_struct * vma = NULL;\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tconst int field = sizeof(unsigned long) * 2;\n\tsiginfo_t info;\n\tint fault;\n\n#if 0\n\tprintk(\"Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\\n\", raw_smp_processor_id(),\n\t       current->comm, current->pid, field, address, write,\n\t       field, regs->cp0_epc);\n#endif\n\n#ifdef CONFIG_KPROBES\n\t/*\n\t * This is to notify the fault handler of the kprobes.  The\n\t * exception code is redundant as it is also carried in REGS,\n\t * but we pass it anyhow.\n\t */\n\tif (notify_die(DIE_PAGE_FAULT, \"page fault\", regs, -1,\n\t\t       (regs->cp0_cause >> 2) & 0x1f, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n#endif\n\n\tinfo.si_code = SEGV_MAPERR;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t */\n#ifdef CONFIG_64BIT\n# define VMALLOC_FAULT_TARGET no_context\n#else\n# define VMALLOC_FAULT_TARGET vmalloc_fault\n#endif\n\n\tif (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))\n\t\tgoto VMALLOC_FAULT_TARGET;\n#ifdef MODULE_START\n\tif (unlikely(address >= MODULE_START && address < MODULE_END))\n\t\tgoto VMALLOC_FAULT_TARGET;\n#endif\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto bad_area_nosemaphore;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto bad_area;\n\tif (vma->vm_start <= address)\n\t\tgoto good_area;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif (expand_stack(vma, address))\n\t\tgoto bad_area;\n/*\n * Ok, we have a good vm_area for this memory access, so\n * we can handle it..\n */\ngood_area:\n\tinfo.si_code = SEGV_ACCERR;\n\n\tif (write) {\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t} else {\n\t\tif (kernel_uses_smartmips_rixi) {\n\t\t\tif (address == regs->cp0_epc && !(vma->vm_flags & VM_EXEC)) {\n#if 0\n\t\t\t\tpr_notice(\"Cpu%d[%s:%d:%0*lx:%ld:%0*lx] XI violation\\n\",\n\t\t\t\t\t  raw_smp_processor_id(),\n\t\t\t\t\t  current->comm, current->pid,\n\t\t\t\t\t  field, address, write,\n\t\t\t\t\t  field, regs->cp0_epc);\n#endif\n\t\t\t\tgoto bad_area;\n\t\t\t}\n\t\t\tif (!(vma->vm_flags & VM_READ)) {\n#if 0\n\t\t\t\tpr_notice(\"Cpu%d[%s:%d:%0*lx:%ld:%0*lx] RI violation\\n\",\n\t\t\t\t\t  raw_smp_processor_id(),\n\t\t\t\t\t  current->comm, current->pid,\n\t\t\t\t\t  field, address, write,\n\t\t\t\t\t  field, regs->cp0_epc);\n#endif\n\t\t\t\tgoto bad_area;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)))\n\t\t\t\tgoto bad_area;\n\t\t}\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault.\n\t */\n\tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,\n\t\t\t\t1, 0, regs, address);\n\t\ttsk->maj_flt++;\n\t} else {\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,\n\t\t\t\t1, 0, regs, address);\n\t\ttsk->min_flt++;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n/*\n * Something tried to access memory that isn't in our memory map..\n * Fix it, but check if it's kernel or user first..\n */\nbad_area:\n\tup_read(&mm->mmap_sem);\n\nbad_area_nosemaphore:\n\t/* User mode accesses just cause a SIGSEGV */\n\tif (user_mode(regs)) {\n\t\ttsk->thread.cp0_badvaddr = address;\n\t\ttsk->thread.error_code = write;\n#if 0\n\t\tprintk(\"do_page_fault() #2: sending SIGSEGV to %s for \"\n\t\t       \"invalid %s\\n%0*lx (epc == %0*lx, ra == %0*lx)\\n\",\n\t\t       tsk->comm,\n\t\t       write ? \"write access to\" : \"read access from\",\n\t\t       field, address,\n\t\t       field, (unsigned long) regs->cp0_epc,\n\t\t       field, (unsigned long) regs->regs[31]);\n#endif\n\t\tinfo.si_signo = SIGSEGV;\n\t\tinfo.si_errno = 0;\n\t\t/* info.si_code has been set above */\n\t\tinfo.si_addr = (void __user *) address;\n\t\tforce_sig_info(SIGSEGV, &info, tsk);\n\t\treturn;\n\t}\n\nno_context:\n\t/* Are we prepared to handle this kernel fault?  */\n\tif (fixup_exception(regs)) {\n\t\tcurrent->thread.cp0_baduaddr = address;\n\t\treturn;\n\t}\n\n\t/*\n\t * Oops. The kernel tried to access some bad page. We'll have to\n\t * terminate things with extreme prejudice.\n\t */\n\tbust_spinlocks(1);\n\n\tprintk(KERN_ALERT \"CPU %d Unable to handle kernel paging request at \"\n\t       \"virtual address %0*lx, epc == %0*lx, ra == %0*lx\\n\",\n\t       raw_smp_processor_id(), field, address, field, regs->cp0_epc,\n\t       field,  regs->regs[31]);\n\tdie(\"Oops\", regs);\n\nout_of_memory:\n\t/*\n\t * We ran out of memory, call the OOM killer, and return the userspace\n\t * (which will retry the fault, or kill us if we got oom-killed).\n\t */\n\tup_read(&mm->mmap_sem);\n\tpagefault_out_of_memory();\n\treturn;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\n\t/* Kernel mode? Handle exceptions or die */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\telse\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n#if 0\n\t\tprintk(\"do_page_fault() #3: sending SIGBUS to %s for \"\n\t\t       \"invalid %s\\n%0*lx (epc == %0*lx, ra == %0*lx)\\n\",\n\t\t       tsk->comm,\n\t\t       write ? \"write access to\" : \"read access from\",\n\t\t       field, address,\n\t\t       field, (unsigned long) regs->cp0_epc,\n\t\t       field, (unsigned long) regs->regs[31]);\n#endif\n\ttsk->thread.cp0_badvaddr = address;\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = BUS_ADRERR;\n\tinfo.si_addr = (void __user *) address;\n\tforce_sig_info(SIGBUS, &info, tsk);\n\n\treturn;\n#ifndef CONFIG_64BIT\nvmalloc_fault:\n\t{\n\t\t/*\n\t\t * Synchronize this task's top level page-table\n\t\t * with the 'reference' page table.\n\t\t *\n\t\t * Do _not_ use \"tsk\" here. We might be inside\n\t\t * an interrupt in the middle of a task switch..\n\t\t */\n\t\tint offset = __pgd_offset(address);\n\t\tpgd_t *pgd, *pgd_k;\n\t\tpud_t *pud, *pud_k;\n\t\tpmd_t *pmd, *pmd_k;\n\t\tpte_t *pte_k;\n\n\t\tpgd = (pgd_t *) pgd_current[raw_smp_processor_id()] + offset;\n\t\tpgd_k = init_mm.pgd + offset;\n\n\t\tif (!pgd_present(*pgd_k))\n\t\t\tgoto no_context;\n\t\tset_pgd(pgd, *pgd_k);\n\n\t\tpud = pud_offset(pgd, address);\n\t\tpud_k = pud_offset(pgd_k, address);\n\t\tif (!pud_present(*pud_k))\n\t\t\tgoto no_context;\n\n\t\tpmd = pmd_offset(pud, address);\n\t\tpmd_k = pmd_offset(pud_k, address);\n\t\tif (!pmd_present(*pmd_k))\n\t\t\tgoto no_context;\n\t\tset_pmd(pmd, *pmd_k);\n\n\t\tpte_k = pte_offset_kernel(pmd_k, address);\n\t\tif (!pte_present(*pte_k))\n\t\t\tgoto no_context;\n\t\treturn;\n\t}\n#endif\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 176,
        "code": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2015-8631"
    },
    {
        "index": 5597,
        "code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-1489"
    },
    {
        "index": 4594,
        "code": "static int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_master *lpspi_platform_info =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, irq;\n\tu32 temp;\n\tbool is_slave;\n\n\tis_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_slave)\n\t\tcontroller = spi_alloc_slave(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_master(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_slave = is_slave;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tfor (i = 0; i < controller->num_chipselect; i++) {\n\t\t\tint cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);\n\n\t\t\tif (!gpio_is_valid(cs_gpio) && lpspi_platform_info)\n\t\t\t\tcs_gpio = lpspi_platform_info->chipselect[i];\n\n\t\t\tfsl_lpspi->chipselect[i] = cs_gpio;\n\t\t\tif (!gpio_is_valid(cs_gpio))\n\t\t\t\tcontinue;\n\n\t\t\tret = devm_gpio_request(&pdev->dev,\n\t\t\t\t\t\tfsl_lpspi->chipselect[i],\n\t\t\t\t\t\tDRIVER_NAME);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"can't get cs gpios\\n\");\n\t\t\t\tgoto out_controller_put;\n\t\t\t}\n\t\t}\n\t\tcontroller->cs_gpios = fsl_lpspi->chipselect;\n\t\tcontroller->prepare_message = fsl_lpspi_prepare_message;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->slave_abort = fsl_lpspi_slave_abort;\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t/* enable the clock */\n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_controller_put;\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller error.\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\treturn 0;\n\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19064"
    },
    {
        "index": 11744,
        "code": "static bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {\n\tPE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));\n\tif (!metadata) {\n\t\treturn false;\n\t}\n\tPE_DWord metadata_directory = pe->clr_hdr? PE_(va2pa) (pe, pe->clr_hdr->MetaDataDirectoryAddress): 0;\n\tif (!metadata_directory) {\n\t\tfree (metadata);\n\t\treturn false;\n\t}\n\tint rr = r_buf_fread_at (pe->b, metadata_directory,\n\t\t(ut8*) metadata, pe->big_endian? \"1I2S\": \"1i2s\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (pe->b, metadata_directory + 8,\n\t\t(ut8*) (&metadata->Reserved), pe->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (pe->b, metadata_directory + 12,\n\t\t(ut8*) (&metadata->VersionStringLength), pe->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Metadata Signature: 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d\\n\",\n\t\t(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);\n\n\t// read the version string\n\tint len = metadata->VersionStringLength; // XXX: dont trust this length\n\tif (len > 0) {\n\t\tmetadata->VersionString = calloc (1, len + 1);\n\t\tif (!metadata->VersionString) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\trr = r_buf_read_at (pe->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);\n\t\tif (rr != len) {\n\t\t\teprintf (\"Warning: read (metadata header) - cannot parse version string\\n\");\n\t\t\tfree (metadata->VersionString);\n\t\t\tfree (metadata);\n\t\t\treturn 0;\n\t\t}\n\t\teprintf (\".NET Version: %s\\n\", metadata->VersionString);\n\t}\n\n\t// read the header after the string\n\trr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,\n\t\t(ut8*) (&metadata->Flags), pe->big_endian? \"2S\": \"2s\", 1);\n\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Number of Metadata Streams: %d\\n\", metadata->NumberOfStreams);\n\tpe->metadata_header = metadata;\n\n\n\t// read metadata streams\n\tint stream_addr = metadata_directory + 20 + metadata->VersionStringLength;\n\tPE_(image_metadata_stream) * stream;\n\tPE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);\n\tif (!streams) {\n\t\tgoto fail;\n\t}\n\tint count;\n\tfor (count = 0; count < metadata->NumberOfStreams; count++) {\n\t\tstream = R_NEW0 (PE_(image_metadata_stream));\n\t\tif (!stream) {\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (r_buf_size (pe->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {\n\t\t\teprintf (\"Truncated\\n\");\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (r_buf_fread_at (pe->b, stream_addr, (ut8*) stream, pe->big_endian? \"2I\": \"2i\", 1) < 1) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"DirectoryAddress: %x Size: %x\\n\", stream->Offset, stream->Size);\n\t\tchar* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);\n\n\t\tif (!stream_name) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tint c = bin_pe_read_metadata_string (stream_name, pe->b, stream_addr + 8);\n\t\tif (c == 0) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"Stream name: %s %d\\n\", stream_name, c);\n\t\tstream->Name = stream_name;\n\t\tstreams[count] = stream;\n\t\tstream_addr += 8 + c;\n\t}\n\tpe->streams = streams;\n\treturn true;\nfail:\n\teprintf (\"Warning: read (metadata header)\\n\");\n\tfree (metadata);\n\treturn false;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-0695"
    },
    {
        "index": 4631,
        "code": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19045"
    },
    {
        "index": 805,
        "code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\n\tperf_read_regs(regs);\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\t/* event has overflowed */\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\n\t/*\n\t * In case we didn't find and reset the event that caused\n\t * the interrupt, scan all events and reset any that are\n\t * negative, to avoid getting continual interrupts.\n\t * Any that we processed in the previous loop will not be negative.\n\t */\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif (pmc_overflow(val))\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\n\t/*\n\t * Reset MMCR0 to its normal value.  This will set PMXE and\n\t * clear FC (freeze counters) and PMAO (perf mon alert occurred)\n\t * and thus allow interrupts to occur again.\n\t * XXX might want to use MSR.PM to keep the events frozen until\n\t * we get back out of this interrupt.\n\t */\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 796,
        "code": "asmlinkage void do_ade(struct pt_regs *regs)\n{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, 0, regs, regs->cp0_badvaddr);\n\t/*\n\t * Did we catch a fault trying to load an instruction?\n\t * Or are we running in MIPS16 mode?\n\t */\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))\n\t\tgoto sigbus;\n\n\tpc = (unsigned int __user *) exception_epc(regs);\n\tif (user_mode(regs) && !test_thread_flag(TIF_FIXADE))\n\t\tgoto sigbus;\n\tif (unaligned_action == UNALIGNED_ACTION_SIGNAL)\n\t\tgoto sigbus;\n\telse if (unaligned_action == UNALIGNED_ACTION_SHOW)\n\t\tshow_registers(regs);\n\n\t/*\n\t * Do branch emulation only if we didn't forward the exception.\n\t * This is all so but ugly ...\n\t */\n\tseg = get_fs();\n\tif (!user_mode(regs))\n\t\tset_fs(KERNEL_DS);\n\temulate_load_store_insn(regs, (void __user *)regs->cp0_badvaddr, pc);\n\tset_fs(seg);\n\n\treturn;\n\nsigbus:\n\tdie_if_kernel(\"Kernel unaligned instruction access\", regs);\n\tforce_sig(SIGBUS, current);\n\n\t/*\n\t * XXX On return from the signal handler we should advance the epc\n\t */\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 2356,
        "code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2014-3690"
    },
    {
        "index": 13663,
        "code": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tstruct mosquitto__packet *packet;\n\n\tif(!context) return;\n\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\n\talias__free_all(context);\n\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\n\tcontext__send_will(context);\n\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2023-28366"
    },
    {
        "index": 867,
        "code": "static int intel_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tint bit, loops;\n\tu64 status;\n\tint handled;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This handler doesn't seem to have any issues with the unmasking\n\t * so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tintel_pmu_disable_all();\n\thandled = intel_pmu_drain_bts_buffer();\n\tstatus = intel_pmu_get_status();\n\tif (!status) {\n\t\tintel_pmu_enable_all(0);\n\t\treturn handled;\n\t}\n\n\tloops = 0;\nagain:\n\tintel_pmu_ack_status(status);\n\tif (++loops > 100) {\n\t\tWARN_ONCE(1, \"perfevents: irq loop stuck!\\n\");\n\t\tperf_event_print_debug();\n\t\tintel_pmu_reset();\n\t\tgoto done;\n\t}\n\n\tinc_irq_stat(apic_perf_irqs);\n\n\tintel_pmu_lbr_read();\n\n\t/*\n\t * PEBS overflow sets bit 62 in the global status register\n\t */\n\tif (__test_and_clear_bit(62, (unsigned long *)&status)) {\n\t\thandled++;\n\t\tx86_pmu.drain_pebs(regs);\n\t}\n\n\tfor_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {\n\t\tstruct perf_event *event = cpuc->events[bit];\n\n\t\thandled++;\n\n\t\tif (!test_bit(bit, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!intel_pmu_save_and_restart(event))\n\t\t\tcontinue;\n\n\t\tdata.period = event->hw.last_period;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\t/*\n\t * Repeat if there is more work to be done:\n\t */\n\tstatus = intel_pmu_get_status();\n\tif (status)\n\t\tgoto again;\n\ndone:\n\tintel_pmu_enable_all(0);\n\treturn handled;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 832,
        "code": "asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,\n\t\t\t\t\tunsigned long writeaccess,\n\t\t\t\t\tunsigned long address)\n{\n\tunsigned long vec;\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct * vma;\n\tint si_code;\n\tint fault;\n\tsiginfo_t info;\n\n\ttsk = current;\n\tmm = tsk->mm;\n\tsi_code = SEGV_MAPERR;\n\tvec = lookup_exception_vector();\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t */\n\tif (unlikely(fault_in_kernel_space(address))) {\n\t\tif (vmalloc_fault(address) >= 0)\n\t\t\treturn;\n\t\tif (notify_page_fault(regs, vec))\n\t\t\treturn;\n\n\t\tgoto bad_area_nosemaphore;\n\t}\n\n\tif (unlikely(notify_page_fault(regs, vec)))\n\t\treturn;\n\n\t/* Only enable interrupts if they were on before the fault */\n\tif ((regs->sr & SR_IMASK) != SR_IMASK)\n\t\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t/*\n\t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\tdown_read(&mm->mmap_sem);\n\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto bad_area;\n\tif (vma->vm_start <= address)\n\t\tgoto good_area;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif (expand_stack(vma, address))\n\t\tgoto bad_area;\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\ngood_area:\n\tsi_code = SEGV_ACCERR;\n\tif (writeaccess) {\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t} else {\n\t\tif (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))\n\t\t\tgoto bad_area;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault.\n\t */\n\tfault = handle_mm_fault(mm, vma, address, writeaccess ? FAULT_FLAG_WRITE : 0);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t     regs, address);\n\t}\n\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n\t/*\n\t * Something tried to access memory that isn't in our memory map..\n\t * Fix it, but check if it's kernel or user first..\n\t */\nbad_area:\n\tup_read(&mm->mmap_sem);\n\nbad_area_nosemaphore:\n\tif (user_mode(regs)) {\n\t\tinfo.si_signo = SIGSEGV;\n\t\tinfo.si_errno = 0;\n\t\tinfo.si_code = si_code;\n\t\tinfo.si_addr = (void *) address;\n\t\tforce_sig_info(SIGSEGV, &info, tsk);\n\t\treturn;\n\t}\n\nno_context:\n\t/* Are we prepared to handle this kernel fault?  */\n\tif (fixup_exception(regs))\n\t\treturn;\n\n\tif (handle_trapped_io(regs, address))\n\t\treturn;\n/*\n * Oops. The kernel tried to access some bad page. We'll have to\n * terminate things with extreme prejudice.\n *\n */\n\n\tbust_spinlocks(1);\n\n\tif (oops_may_print()) {\n\t\tunsigned long page;\n\n\t\tif (address < PAGE_SIZE)\n\t\t\tprintk(KERN_ALERT \"Unable to handle kernel NULL \"\n\t\t\t\t\t  \"pointer dereference\");\n\t\telse\n\t\t\tprintk(KERN_ALERT \"Unable to handle kernel paging \"\n\t\t\t\t\t  \"request\");\n\t\tprintk(\" at virtual address %08lx\\n\", address);\n\t\tprintk(KERN_ALERT \"pc = %08lx\\n\", regs->pc);\n\t\tpage = (unsigned long)get_TTB();\n\t\tif (page) {\n\t\t\tpage = ((__typeof__(page) *)page)[address >> PGDIR_SHIFT];\n\t\t\tprintk(KERN_ALERT \"*pde = %08lx\\n\", page);\n\t\t\tif (page & _PAGE_PRESENT) {\n\t\t\t\tpage &= PAGE_MASK;\n\t\t\t\taddress &= 0x003ff000;\n\t\t\t\tpage = ((__typeof__(page) *)\n\t\t\t\t\t\t__va(page))[address >>\n\t\t\t\t\t\t\t    PAGE_SHIFT];\n\t\t\t\tprintk(KERN_ALERT \"*pte = %08lx\\n\", page);\n\t\t\t}\n\t\t}\n\t}\n\n\tdie(\"Oops\", regs, writeaccess);\n\tbust_spinlocks(0);\n\tdo_exit(SIGKILL);\n\n/*\n * We ran out of memory, or some other thing happened to us that made\n * us unable to handle the page fault gracefully.\n */\nout_of_memory:\n\tup_read(&mm->mmap_sem);\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\tpagefault_out_of_memory();\n\treturn;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = BUS_ADRERR;\n\tinfo.si_addr = (void *)address;\n\tforce_sig_info(SIGBUS, &info, tsk);\n\n\t/* Kernel mode? Handle exceptions or die */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 11756,
        "code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tQnxObj *qo = R_NEW0 (QnxObj);\n\tif (!qo) {\n\t\treturn false;\n\t}\n\tlmf_record lrec;\n\tlmf_resource lres;\n\tlmf_data ldata;\n\tut64 offset = QNX_RECORD_SIZE;\n\tRList *sections = NULL;\n\tRList *fixups = NULL;\n\n\tif (!qo) {\n\t\tgoto beach;\n\t}\n\tif (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {\n\t\tgoto beach;\n\t}\n\tqo->kv = sdb_new0 ();\n\tif (!qo->kv) {\n\t\tgoto beach;\n\t}\n\t// Read the first record\n\tif (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\tgoto beach;\n\t}\n\t// Load the header\n\tlmf_header_load (&qo->lmfh, bf->buf, qo->kv);\n\toffset += lrec.data_nbytes;\n\n\tfor (;;) {\n\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\t\tgoto beach;\n\t\t}\n\t\toffset += sizeof (lmf_record);\n\n\t\tif (lrec.rec_type == LMF_IMAGE_END_REC) {\n\t\t\tbreak;\n\t\t} else if (lrec.rec_type == LMF_RESOURCE_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) < sizeof (lmf_resource)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup (\"LMF_RESOURCE\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof (lmf_resource);\n\t\t\tptr->size = ptr->vsize;\n\t\t\tptr->add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup (\"LMF_LOAD\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vaddr = ldata.offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof (lmf_data);\n\t\t\tptr->size = ptr->vsize;\n\t\t\tptr->add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'f'; // \"LMF_FIXUP\";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'F'; // \"LMF_8087_FIXUP\";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_RW_END_REC) {\n\t\t\tr_buf_fread_at (bf->buf, offset, (ut8 *)&qo->rwend, \"si\", 1);\n\t\t}\n\t\toffset += lrec.data_nbytes;\n\t}\n\tsdb_ns_set (sdb, \"info\", qo->kv);\n\tqo->sections = sections;\n\tqo->fixups = fixups;\n\t*bin_obj = qo;\n\treturn true;\nbeach:\n\tfree (qo);\n\tr_list_free (fixups);\n\tr_list_free (sections);\n\treturn false;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-0695"
    },
    {
        "index": 21077,
        "code": "int stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase)\n{\n    while(patternLen && stringLen) {\n        switch(pattern[0]) {\n        case '*':\n            while (patternLen && pattern[1] == '*') {\n                pattern++;\n                patternLen--;\n            }\n            if (patternLen == 1)\n                return 1; /* match */\n            while(stringLen) {\n                if (stringmatchlen(pattern+1, patternLen-1,\n                            string, stringLen, nocase))\n                    return 1; /* match */\n                string++;\n                stringLen--;\n            }\n            return 0; /* no match */\n            break;\n        case '?':\n            string++;\n            stringLen--;\n            break;\n        case '[':\n        {\n            int not, match;\n\n            pattern++;\n            patternLen--;\n            not = pattern[0] == '^';\n            if (not) {\n                pattern++;\n                patternLen--;\n            }\n            match = 0;\n            while(1) {\n                if (pattern[0] == '\\\\' && patternLen >= 2) {\n                    pattern++;\n                    patternLen--;\n                    if (pattern[0] == string[0])\n                        match = 1;\n                } else if (pattern[0] == ']') {\n                    break;\n                } else if (patternLen == 0) {\n                    pattern--;\n                    patternLen++;\n                    break;\n                } else if (patternLen >= 3 && pattern[1] == '-') {\n                    int start = pattern[0];\n                    int end = pattern[2];\n                    int c = string[0];\n                    if (start > end) {\n                        int t = start;\n                        start = end;\n                        end = t;\n                    }\n                    if (nocase) {\n                        start = tolower(start);\n                        end = tolower(end);\n                        c = tolower(c);\n                    }\n                    pattern += 2;\n                    patternLen -= 2;\n                    if (c >= start && c <= end)\n                        match = 1;\n                } else {\n                    if (!nocase) {\n                        if (pattern[0] == string[0])\n                            match = 1;\n                    } else {\n                        if (tolower((int)pattern[0]) == tolower((int)string[0]))\n                            match = 1;\n                    }\n                }\n                pattern++;\n                patternLen--;\n            }\n            if (not)\n                match = !match;\n            if (!match)\n                return 0; /* no match */\n            string++;\n            stringLen--;\n            break;\n        }\n        case '\\\\':\n            if (patternLen >= 2) {\n                pattern++;\n                patternLen--;\n            }\n            /* fall through */\n        default:\n            if (!nocase) {\n                if (pattern[0] != string[0])\n                    return 0; /* no match */\n            } else {\n                if (tolower((int)pattern[0]) != tolower((int)string[0]))\n                    return 0; /* no match */\n            }\n            string++;\n            stringLen--;\n            break;\n        }\n        pattern++;\n        patternLen--;\n        if (stringLen == 0) {\n            while(*pattern == '*') {\n                pattern++;\n                patternLen--;\n            }\n            break;\n        }\n    }\n    if (patternLen == 0 && stringLen == 0)\n        return 1;\n    return 0;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-36021"
    },
    {
        "index": 17515,
        "code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-11924"
    },
    {
        "index": 899,
        "code": "int perf_event_overflow(struct perf_event *event, int nmi,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, nmi, 1, data, regs);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 20873,
        "code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-25761"
    },
    {
        "index": 428,
        "code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2012-0879"
    },
    {
        "index": 13668,
        "code": "int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n{\n\tstruct mosquitto_client_msg *msg;\n\tstruct mosquitto_msg_data *msg_data;\n\tenum mosquitto_msg_state state = mosq_ms_invalid;\n\tint rc = 0;\n\tint i;\n\tchar **dest_ids;\n\n\tassert(stored);\n\tif(!context) return MOSQ_ERR_INVAL;\n\tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n\n\tif(dir == mosq_md_out){\n\t\tmsg_data = &context->msgs_out;\n\t}else{\n\t\tmsg_data = &context->msgs_in;\n\t}\n\n\t/* Check whether we've already sent this message to this client\n\t * for outgoing messages only.\n\t * If retain==true then this is a stale retained message and so should be\n\t * sent regardless. FIXME - this does mean retained messages will received\n\t * multiple times for overlapping subscriptions, although this is only the\n\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n\t */\n\tif(context->protocol != mosq_p_mqtt5\n\t\t\t&& db.config->allow_duplicate_messages == false\n\t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n\n\t\tfor(i=0; i<stored->dest_id_count; i++){\n\t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n\t\t\t\t/* We have already sent this message to this client. */\n\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tif(context->sock == INVALID_SOCKET){\n\t\t/* Client is not connected only queue messages with QoS>0. */\n\t\tif(qos == 0 && !db.config->queue_qos0_messages){\n\t\t\tif(!context->bridge){\n\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\treturn 2;\n\t\t\t}else{\n\t\t\t\tif(context->bridge->start_type != bst_lazy){\n\t\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(context->bridge && context->bridge->clean_start_local == true){\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif(context->sock != INVALID_SOCKET){\n\t\tif(db__ready_for_flight(context, dir, qos)){\n\t\t\tif(dir == mosq_md_out){\n\t\t\t\tswitch(qos){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(qos == 2){\n\t\t\t\t\tstate = mosq_ms_wait_for_pubrel;\n\t\t\t\t}else{\n\t\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n\t\t\tstate = mosq_ms_queued;\n\t\t\trc = 2;\n\t\t}else{\n\t\t\t/* Dropping message due to full queue. */\n\t\t\tif(context->is_dropping == false){\n\t\t\t\tcontext->is_dropping = true;\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\t\tcontext->id);\n\t\t\t}\n\t\t\tG_MSGS_DROPPED_INC();\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}else{\n\t\tif (db__ready_for_queue(context, qos, msg_data)){\n\t\t\tstate = mosq_ms_queued;\n\t\t}else{\n\t\t\tG_MSGS_DROPPED_INC();\n\t\t\tif(context->is_dropping == false){\n\t\t\t\tcontext->is_dropping = true;\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\t\tcontext->id);\n\t\t\t}\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}\n\tassert(state != mosq_ms_invalid);\n\n#ifdef WITH_PERSISTENCE\n\tif(state == mosq_ms_queued){\n\t\tdb.persistence_changes++;\n\t}\n#endif\n\n\tmsg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));\n\tif(!msg) return MOSQ_ERR_NOMEM;\n\tmsg->prev = NULL;\n\tmsg->next = NULL;\n\tmsg->store = stored;\n\tdb__msg_store_ref_inc(msg->store);\n\tmsg->mid = mid;\n\tmsg->timestamp = db.now_s;\n\tmsg->direction = dir;\n\tmsg->state = state;\n\tmsg->dup = false;\n\tif(qos > context->max_qos){\n\t\tmsg->qos = context->max_qos;\n\t}else{\n\t\tmsg->qos = qos;\n\t}\n\tmsg->retain = retain;\n\tmsg->properties = properties;\n\n\tif(state == mosq_ms_queued){\n\t\tDL_APPEND(msg_data->queued, msg);\n\t\tdb__msg_add_to_queued_stats(msg_data, msg);\n\t}else{\n\t\tDL_APPEND(msg_data->inflight, msg);\n\t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n\t}\n\n\tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n\t\t/* Record which client ids this message has been sent to so we can avoid duplicates.\n\t\t * Outgoing messages only.\n\t\t * If retain==true then this is a stale retained message and so should be\n\t\t * sent regardless. FIXME - this does mean retained messages will received\n\t\t * multiple times for overlapping subscriptions, although this is only the\n\t\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n\t\t */\n\t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n\t\tif(dest_ids){\n\t\t\tstored->dest_ids = dest_ids;\n\t\t\tstored->dest_id_count++;\n\t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n\t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t}else{\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge && context->bridge->start_type == bst_lazy\n\t\t\t&& context->sock == INVALID_SOCKET\n\t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n\n\t\tcontext->bridge->lazy_reconnect = true;\n\t}\n#endif\n\n\tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n\t\tutil__decrement_send_quota(context);\n\t}\n\n\tif(dir == mosq_md_out && update){\n\t\trc = db__message_write_inflight_out_latest(context);\n\t\tif(rc) return rc;\n\t\trc = db__message_write_queued_out(context);\n\t\tif(rc) return rc;\n\t}\n\n\treturn rc;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2023-28366"
    },
    {
        "index": 21853,
        "code": "destroyPresentationContextList(LST_HEAD ** lst)\n{\n    DUL_PRESENTATIONCONTEXT *pc;\n    DUL_TRANSFERSYNTAX *ts;\n\n    if ((lst == NULL) || (*lst == NULL))\n        return;\n    while ((pc = (DUL_PRESENTATIONCONTEXT*) LST_Dequeue(lst)) != NULL) {\n        if (pc->proposedTransferSyntax != NULL) {\n            while ((ts = (DUL_TRANSFERSYNTAX*) LST_Dequeue(&pc->proposedTransferSyntax)) != NULL) {\n                free(ts);\n            }\n            LST_Destroy(&pc->proposedTransferSyntax);\n        }\n        free(pc);\n    }\n    LST_Destroy(lst);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-41690"
    },
    {
        "index": 880,
        "code": "static inline void perf_event_task_sched_out(struct task_struct *task, struct task_struct *next)\n{\n\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, 1, NULL, 0);\n\n\t__perf_event_task_sched_out(task, next);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 425,
        "code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t\tput_io_context(ioc);\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2012-0879"
    },
    {
        "index": 4535,
        "code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19922"
    },
    {
        "index": 172,
        "code": "chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               FALSE, 0, NULL, &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,\n                                           &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2015-8631"
    },
    {
        "index": 12677,
        "code": "GF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) return NULL;\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-33365"
    },
    {
        "index": 6886,
        "code": "BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-17178"
    },
    {
        "index": 9684,
        "code": "int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, char **ret, JsonVariant **ret_package_metadata) {\n        _cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 };\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;\n        _cleanup_free_ char *buf = NULL;\n        int r;\n\n        assert(fd >= 0);\n\n        r = dlopen_dw();\n        if (r < 0)\n                return r;\n\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. */\n        r = safe_fork_full(\"(sd-parse-elf)\",\n                           (int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] },\n                           4,\n                           FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG,\n                           NULL);\n        if (r < 0) {\n                if (r == -EPROTO) { /* We should have the errno from the child, but don't clobber original error */\n                        int e, k;\n\n                        k = read(error_pipe[0], &e, sizeof(e));\n                        if (k < 0 && errno != EAGAIN) /* Pipe is non-blocking, EAGAIN means there's nothing */\n                                return -errno;\n                        if (k == sizeof(e))\n                                return e; /* propagate error sent to us from child */\n                        if (k != 0)\n                                return -EIO;\n                }\n\n                return r;\n        }\n        if (r == 0) {\n                /* We want to avoid loops, given this can be called from systemd-coredump */\n                if (fork_disable_dump) {\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        r = loop_write(return_pipe[1], buf, strlen(buf), false);\n                        if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n        return_pipe[1] = safe_close(return_pipe[1]);\n        json_pipe[1] = safe_close(json_pipe[1]);\n\n        if (ret) {\n                _cleanup_fclose_ FILE *in = NULL;\n\n                in = take_fdopen(&return_pipe[0], \"r\");\n                if (!in)\n                        return -errno;\n\n                r = read_full_stream(in, &buf, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        return r;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-45873"
    },
    {
        "index": 23823,
        "code": "static void fio_signal_handler_setup(void) {\n  /* setup signal handling */\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n\n  memset(&act, 0, sizeof(act));\n\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2024-22050"
    },
    {
        "index": 23767,
        "code": "void EventPluginsManager::loadPlugin(const QString &pluginId)\n{\n    QPluginLoader loader(\"plasmacalendarplugins/\" + pluginId);\n\n    if (!loader.load()) {\n        qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;\n        qWarning() << loader.errorString();\n        return;\n    }\n\n    QObject *obj = loader.instance();\n    if (obj) {\n        CalendarEvents::CalendarEventsPlugin *eventsPlugin = qobject_cast<CalendarEvents::CalendarEventsPlugin *>(obj);\n        if (eventsPlugin) {\n            qDebug() << \"Loading Calendar plugin\" << eventsPlugin;\n            eventsPlugin->setProperty(\"pluginId\", pluginId);\n            d->plugins << eventsPlugin;\n\n            // Connect the relay signals\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::dataReady, this, &EventPluginsManager::dataReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventModified, this, &EventPluginsManager::eventModified);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventRemoved, this, &EventPluginsManager::eventRemoved);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::alternateCalendarDateReady, this, &EventPluginsManager::alternateCalendarDateReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::subLabelReady, this, &EventPluginsManager::subLabelReady);\n        } else {\n            // not our/valid plugin, so unload it\n            loader.unload();\n        }\n    } else {\n        loader.unload();\n    }\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2024-1433"
    },
    {
        "index": 5938,
        "code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-14056"
    },
    {
        "index": 19832,
        "code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2020-5221"
    },
    {
        "index": 7786,
        "code": "void pcre_dump_cache(const std::string& filename) {\n  s_pcreCache.dump(filename);\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2019-3556"
    },
    {
        "index": 12439,
        "code": "static inline bool isMountable(const RemoteFsDevice::Details &d)\n{\n    return RemoteFsDevice::constSshfsProtocol==d.url.scheme() ||\n           RemoteFsDevice::constSambaProtocol==d.url.scheme() || RemoteFsDevice::constSambaAvahiProtocol==d.url.scheme();\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-12559"
    },
    {
        "index": 12415,
        "code": "void RemoteDevicePropertiesWidget::update(const RemoteFsDevice::Details &d, bool create, bool isConnected)\n{\n    int t=create\n            ? Type_Samba\n            : d.isLocalFile()\n                ? Type_File\n                : d.url.scheme()==RemoteFsDevice::constSshfsProtocol\n                    ? Type_SshFs\n                    : d.url.scheme()==RemoteFsDevice::constSambaProtocol\n                        ? Type_Samba\n                        : Type_SambaAvahi;\n    setEnabled(d.isLocalFile() || !isConnected);\n    infoLabel->setVisible(create);\n    orig=d;\n    name->setText(d.name);\n    sshPort->setValue(22);\n    smbPort->setValue(445);\n\n    connectionNote->setVisible(!d.isLocalFile() && isConnected);\n    sshFolder->setText(QString());\n    sshHost->setText(QString());\n    sshUser->setText(QString());\n    fileFolder->setText(QString());\n\n    switch (t) {\n    case Type_SshFs: {\n        sshFolder->setText(d.url.path());\n        if (0!=d.url.port()) {\n            sshPort->setValue(d.url.port());\n        }\n        sshHost->setText(d.url.host());\n        sshUser->setText(d.url.userName());\n        sshExtra->setText(d.extraOptions);\n        break;\n    }\n    case Type_File:\n        fileFolder->setText(d.url.path());\n        break;\n    case Type_Samba: {\n        smbShare->setText(d.url.path());\n        if (0!=d.url.port()) {\n            smbPort->setValue(d.url.port());\n        }\n        smbHost->setText(d.url.host());\n        smbUser->setText(d.url.userName());\n        smbPassword->setText(d.url.password());\n        QUrlQuery q(d.url);\n        if (q.hasQueryItem(RemoteFsDevice::constDomainQuery)) {\n            smbDomain->setText(q.queryItemValue(RemoteFsDevice::constDomainQuery));\n        } else {\n            smbDomain->setText(QString());\n        }\n        break;\n    }\n    case Type_SambaAvahi: {\n        smbAvahiShare->setText(d.url.path());\n        smbAvahiUser->setText(d.url.userName());\n        smbAvahiPassword->setText(d.url.password());\n        QUrlQuery q(d.url);\n        if (q.hasQueryItem(RemoteFsDevice::constDomainQuery)) {\n            smbAvahiDomain->setText(q.queryItemValue(RemoteFsDevice::constDomainQuery));\n        } else {\n            smbAvahiDomain->setText(QString());\n        }\n        if (q.hasQueryItem(RemoteFsDevice::constServiceNameQuery)) {\n            smbAvahiName->setText(q.queryItemValue(RemoteFsDevice::constServiceNameQuery));\n        } else {\n            smbAvahiName->setText(QString());\n        }\n        break;\n    }\n    }\n\n    name->setEnabled(d.isLocalFile() || !isConnected);\n\n    connect(type, SIGNAL(currentIndexChanged(int)), this, SLOT(setType()));\n    for (int i=1; i<type->count(); ++i) {\n        if (type->itemData(i).toInt()==t) {\n            type->setCurrentIndex(i);\n            stackedWidget->setCurrentIndex(i);\n            break;\n        }\n    }\n    connect(name, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshHost, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshUser, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshFolder, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(sshPort, SIGNAL(valueChanged(int)), this, SLOT(checkSaveable()));\n    connect(sshExtra, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(fileFolder, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbHost, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbUser, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbPassword, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbDomain, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbShare, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbPort, SIGNAL(valueChanged(int)), this, SLOT(checkSaveable()));\n    connect(smbAvahiName, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbAvahiUser, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbAvahiPassword, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbAvahiDomain, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    connect(smbAvahiShare, SIGNAL(textChanged(const QString &)), this, SLOT(checkSaveable()));\n    modified=false;\n    setType();\n    checkSaveable();\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-12559"
    },
    {
        "index": 13031,
        "code": "static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-14363"
    },
    {
        "index": 7799,
        "code": "  req::ptr<XMLDocumentData> doc() const { return m_node->doc(); }",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2019-3556"
    },
    {
        "index": 23739,
        "code": "fr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\n\treturn capabilities;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2023-52138"
    },
    {
        "index": 3652,
        "code": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tif (sk != asoc->base.sk)\n\t\t\tgoto do_error;\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2017-6353"
    },
    {
        "index": 4985,
        "code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\t/* release callback will free clt in last put */\n\tdevice_unregister(&clt->dev);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2022-29156"
    },
    {
        "index": 17426,
        "code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 21867,
        "code": "parseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \"DUL Unsupported peer protocol %04x; expected %04x in %s\", assoc->protocol, DUL_PROTOCOL, \"parseAssociate\");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\"Parsing an A-ASSOCIATE PDU\");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \"A-ASSOCIATE RQ\";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \"A-ASSOCIATE AC\";\n        else\n            s = \"Unknown: Programming bug in parseAssociate\";\n\n/*      If we hit the \"Unknown type\", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\"PDU type: \"\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc->length << OFendl\n            << \"DICOM Protocol: \"\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n            << \"Calling AP Title: \" << assoc->callingAPTitle);\n    }\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n                DCMNET_TRACE(\"Successfully parsed Application Context\");\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context == NULL) return EC_MemoryExhausted;\n            (void) memset(context, 0, sizeof(*context));\n            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n            if (cond.bad()) return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n            DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"User Information item\", pduLength, itemLength);\n            DCMNET_TRACE(\"Successfully parsed User Information\");\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n            break;\n        }\n    }\n    return cond;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2021-41688"
    },
    {
        "index": 6680,
        "code": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2016-5768"
    },
    {
        "index": 17364,
        "code": "static void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 6670,
        "code": "PHP_FUNCTION(mb_split)\n{\n\tchar *arg_pattern;\n\tint arg_pattern_len;\n\tphp_mb_regex_t *re;\n\tOnigRegion *regs = NULL;\n\tchar *string;\n\tOnigUChar *pos, *chunk_pos;\n\tint string_len;\n\n\tint n, err;\n\tlong count = -1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n\t\tRETURN_FALSE;\n\t} \n\n\tif (count > 0) {\n\t\tcount--;\n\t}\n\n\t/* create regex pattern buffer */\n\tif ((re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, MBREX(regex_default_options), MBREX(current_mbctype), MBREX(regex_default_syntax) TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tchunk_pos = pos = (OnigUChar *)string;\n\terr = 0;\n\tregs = onig_region_new();\n\t/* churn through str, generating array entries as we go */\n\twhile (count != 0 && (pos - (OnigUChar *)string) < string_len) {\n\t\tint beg, end;\n\t\terr = onig_search(re, (OnigUChar *)string, (OnigUChar *)(string + string_len), pos, (OnigUChar *)(string + string_len), regs, 0);\n\t\tif (err < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tbeg = regs->beg[0], end = regs->end[0];\n\t\t/* add it to the array */\n\t\tif ((pos - (OnigUChar *)string) < end) {\n\t\t\tif (beg < string_len && beg >= (chunk_pos - (OnigUChar *)string)) {\n\t\t\t\tadd_next_index_stringl(return_value, (char *)chunk_pos, ((OnigUChar *)(string + beg) - chunk_pos), 1);\n\t\t\t\t--count;\n\t\t\t} else {\n\t\t\t\terr = -2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* point at our new starting point */\n\t\t\tchunk_pos = pos = (OnigUChar *)string + end;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t\tonig_region_free(regs, 0);\n\t}\n\n\tonig_region_free(regs, 1);\n\n\t/* see if we encountered an error */\n\tif (err <= -2) {\n\t\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\t\tonig_error_code_to_str(err_str, err);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex search failure in mbsplit(): %s\", err_str);\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* otherwise we just have one last element to add to the array */\n\tn = ((OnigUChar *)(string + string_len) - chunk_pos);\n\tif (n > 0) {\n\t\tadd_next_index_stringl(return_value, (char *)chunk_pos, n, 1);\n\t} else {\n\t\tadd_next_index_stringl(return_value, \"\", 0, 1);\n\t}\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2016-5768"
    },
    {
        "index": 8594,
        "code": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-8099"
    },
    {
        "index": 17356,
        "code": "static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\t/* Allocate Private key X */\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 13153,
        "code": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-16423"
    },
    {
        "index": 17354,
        "code": "static TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Private key X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\t/* Allocate Subprime even if not used */\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDH_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 13211,
        "code": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount+=2;\n\t\t}\n\t}\n\treturn count;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-16424"
    },
    {
        "index": 13389,
        "code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-16425"
    },
    {
        "index": 21708,
        "code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2021-39432"
    },
    {
        "index": 6682,
        "code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2016-5768"
    },
    {
        "index": 17366,
        "code": "static TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\n\t/* Initialize all input key fields to 0 */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate the Public Exponent to maximum size */\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\n\t/* Allocate the Modulus (size_bits) [n = p * q] */\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\n\treturn TEE_SUCCESS;\n\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 13230,
        "code": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-16423"
    },
    {
        "index": 17412,
        "code": "void crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 4030,
        "code": "static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,\n\t\t\t       struct buffer_head *bh_result, int create)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n\t * while file size will be changed.\n\t */\n\tif (pos + total_len <= i_size_read(inode)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\n\t\tup_read(&oi->ip_alloc_sem);\n\n\t\tif (buffer_mapped(bh_result) &&\n\t\t    !buffer_new(bh_result) &&\n\t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-18224"
    },
    {
        "index": 649,
        "code": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 4074,
        "code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-15129"
    },
    {
        "index": 3298,
        "code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-7916"
    },
    {
        "index": 3634,
        "code": "static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f, *match;\n\tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!po->running)\n\t\treturn -EINVAL;\n\n\tif (po->fanout)\n\t\treturn -EALREADY;\n\n\tif (type == PACKET_FANOUT_ROLLOVER ||\n\t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);\n\t\tif (!po->rollover)\n\t\t\treturn -ENOMEM;\n\t\tatomic_long_set(&po->rollover->num, 0);\n\t\tatomic_long_set(&po->rollover->num_huge, 0);\n\t\tatomic_long_set(&po->rollover->num_failed, 0);\n\t}\n\n\tmutex_lock(&fanout_mutex);\n\tmatch = NULL;\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\tatomic_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tdev_add_pack(&match->prot_hook);\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\tif (match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\tatomic_inc(&match->sk_ref);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&fanout_mutex);\n\tif (err) {\n\t\tkfree(po->rollover);\n\t\tpo->rollover = NULL;\n\t}\n\treturn err;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-6346"
    },
    {
        "index": 4680,
        "code": "mptctl_eventenable (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventenable() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\t/* Have not yet allocated memory - do so now.\n\t\t */\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\n\t\tioc->eventContext = 0;\n        }\n\n\t/* Update the IOC event logging flag.\n\t */\n\tioc->eventTypes = karg.eventTypes;\n\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2020-12652"
    },
    {
        "index": 643,
        "code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\n\tcipso_v4_delopt(&req_inet->opt);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 2930,
        "code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\t/* read the data with the semaphore held (since we\n\t\t\t * might sleep) */\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2015-7550"
    },
    {
        "index": 4243,
        "code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2018-20836"
    },
    {
        "index": 5137,
        "code": "tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma) { }",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2022-39188"
    },
    {
        "index": 664,
        "code": "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n{\n\tstruct ip_options *sopt;\n\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\n\tsopt = &(IPCB(skb)->opt);\n\n\tif (sopt->optlen == 0) {\n\t\tdopt->optlen = 0;\n\t\treturn 0;\n\t}\n\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->srr) {\n\t\tunsigned char * start = sptr+sopt->srr;\n\t\t__be32 faddr;\n\n\t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 3570,
        "code": "SYSCALL_DEFINE5(perf_event_open,\n\t\tstruct perf_event_attr __user *, attr_uptr,\n\t\tpid_t, pid, int, cpu, int, group_fd, unsigned long, flags)\n{\n\tstruct perf_event *group_leader = NULL, *output_event = NULL;\n\tstruct perf_event *event, *sibling;\n\tstruct perf_event_attr attr;\n\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n\tstruct file *event_file = NULL;\n\tstruct fd group = {NULL, 0};\n\tstruct task_struct *task = NULL;\n\tstruct pmu *pmu;\n\tint event_fd;\n\tint move_group = 0;\n\tint err;\n\tint f_flags = O_RDWR;\n\tint cgroup_fd = -1;\n\n\t/* for future expandability... */\n\tif (flags & ~PERF_FLAG_ALL)\n\t\treturn -EINVAL;\n\n\terr = perf_copy_attr(attr_uptr, &attr);\n\tif (err)\n\t\treturn err;\n\n\tif (!attr.exclude_kernel) {\n\t\tif (perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (attr.freq) {\n\t\tif (attr.sample_freq > sysctl_perf_event_sample_rate)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (attr.sample_period & (1ULL << 63))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!attr.sample_max_stack)\n\t\tattr.sample_max_stack = sysctl_perf_event_max_stack;\n\n\t/*\n\t * In cgroup mode, the pid argument is used to pass the fd\n\t * opened to the cgroup directory in cgroupfs. The cpu argument\n\t * designates the cpu on which to monitor threads from that\n\t * cgroup.\n\t */\n\tif ((flags & PERF_FLAG_PID_CGROUP) && (pid == -1 || cpu == -1))\n\t\treturn -EINVAL;\n\n\tif (flags & PERF_FLAG_FD_CLOEXEC)\n\t\tf_flags |= O_CLOEXEC;\n\n\tevent_fd = get_unused_fd_flags(f_flags);\n\tif (event_fd < 0)\n\t\treturn event_fd;\n\n\tif (group_fd != -1) {\n\t\terr = perf_fget_light(group_fd, &group);\n\t\tif (err)\n\t\t\tgoto err_fd;\n\t\tgroup_leader = group.file->private_data;\n\t\tif (flags & PERF_FLAG_FD_OUTPUT)\n\t\t\toutput_event = group_leader;\n\t\tif (flags & PERF_FLAG_FD_NO_GROUP)\n\t\t\tgroup_leader = NULL;\n\t}\n\n\tif (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) {\n\t\ttask = find_lively_task_by_vpid(pid);\n\t\tif (IS_ERR(task)) {\n\t\t\terr = PTR_ERR(task);\n\t\t\tgoto err_group_fd;\n\t\t}\n\t}\n\n\tif (task && group_leader &&\n\t    group_leader->attr.inherit != attr.inherit) {\n\t\terr = -EINVAL;\n\t\tgoto err_task;\n\t}\n\n\tget_online_cpus();\n\n\tif (task) {\n\t\terr = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\t\tif (err)\n\t\t\tgoto err_cpus;\n\n\t\t/*\n\t\t * Reuse ptrace permission checks for now.\n\t\t *\n\t\t * We must hold cred_guard_mutex across this and any potential\n\t\t * perf_install_in_context() call for this new event to\n\t\t * serialize against exec() altering our credentials (and the\n\t\t * perf_event_exit_task() that could imply).\n\t\t */\n\t\terr = -EACCES;\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))\n\t\t\tgoto err_cred;\n\t}\n\n\tif (flags & PERF_FLAG_PID_CGROUP)\n\t\tcgroup_fd = pid;\n\n\tevent = perf_event_alloc(&attr, cpu, task, group_leader, NULL,\n\t\t\t\t NULL, NULL, cgroup_fd);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err_cred;\n\t}\n\n\tif (is_sampling_event(event)) {\n\t\tif (event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\t/*\n\t * Special case software events and allow them to be part of\n\t * any hardware group.\n\t */\n\tpmu = event->pmu;\n\n\tif (attr.use_clockid) {\n\t\terr = perf_event_set_clock(event, attr.clockid);\n\t\tif (err)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\tevent->event_caps |= PERF_EV_CAP_SOFTWARE;\n\n\tif (group_leader &&\n\t    (is_software_event(event) != is_software_event(group_leader))) {\n\t\tif (is_software_event(event)) {\n\t\t\t/*\n\t\t\t * If event and group_leader are not both a software\n\t\t\t * event, and event is, then group leader is not.\n\t\t\t *\n\t\t\t * Allow the addition of software events to !software\n\t\t\t * groups, this is safe because software events never\n\t\t\t * fail to schedule.\n\t\t\t */\n\t\t\tpmu = group_leader->pmu;\n\t\t} else if (is_software_event(group_leader) &&\n\t\t\t   (group_leader->group_caps & PERF_EV_CAP_SOFTWARE)) {\n\t\t\t/*\n\t\t\t * In case the group is a pure software group, and we\n\t\t\t * try to add a hardware event, move the whole group to\n\t\t\t * the hardware context.\n\t\t\t */\n\t\t\tmove_group = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_alloc;\n\t}\n\n\tif ((pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE) && group_leader) {\n\t\terr = -EBUSY;\n\t\tgoto err_context;\n\t}\n\n\t/*\n\t * Look up the group leader (we will attach this event to it):\n\t */\n\tif (group_leader) {\n\t\terr = -EINVAL;\n\n\t\t/*\n\t\t * Do not allow a recursive hierarchy (this new sibling\n\t\t * becoming part of another group-sibling):\n\t\t */\n\t\tif (group_leader->group_leader != group_leader)\n\t\t\tgoto err_context;\n\n\t\t/* All events in a group should have the same clock */\n\t\tif (group_leader->clock != event->clock)\n\t\t\tgoto err_context;\n\n\t\t/*\n\t\t * Do not allow to attach to a group in a different\n\t\t * task or CPU context:\n\t\t */\n\t\tif (move_group) {\n\t\t\t/*\n\t\t\t * Make sure we're both on the same task, or both\n\t\t\t * per-cpu events.\n\t\t\t */\n\t\t\tif (group_leader->ctx->task != ctx->task)\n\t\t\t\tgoto err_context;\n\n\t\t\t/*\n\t\t\t * Make sure we're both events for the same CPU;\n\t\t\t * grouping events for different CPUs is broken; since\n\t\t\t * you can never concurrently schedule them anyhow.\n\t\t\t */\n\t\t\tif (group_leader->cpu != event->cpu)\n\t\t\t\tgoto err_context;\n\t\t} else {\n\t\t\tif (group_leader->ctx != ctx)\n\t\t\t\tgoto err_context;\n\t\t}\n\n\t\t/*\n\t\t * Only a group leader can be exclusive or pinned\n\t\t */\n\t\tif (attr.exclusive || attr.pinned)\n\t\t\tgoto err_context;\n\t}\n\n\tif (output_event) {\n\t\terr = perf_event_set_output(event, output_event);\n\t\tif (err)\n\t\t\tgoto err_context;\n\t}\n\n\tevent_file = anon_inode_getfile(\"[perf_event]\", &perf_fops, event,\n\t\t\t\t\tf_flags);\n\tif (IS_ERR(event_file)) {\n\t\terr = PTR_ERR(event_file);\n\t\tevent_file = NULL;\n\t\tgoto err_context;\n\t}\n\n\tif (move_group) {\n\t\tgctx = group_leader->ctx;\n\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\t\tif (gctx->task == TASK_TOMBSTONE) {\n\t\t\terr = -ESRCH;\n\t\t\tgoto err_locked;\n\t\t}\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t}\n\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_locked;\n\t}\n\n\tif (!perf_event_validate_size(event)) {\n\t\terr = -E2BIG;\n\t\tgoto err_locked;\n\t}\n\n\t/*\n\t * Must be under the same ctx::mutex as perf_install_in_context(),\n\t * because we need to serialize with concurrent event creation.\n\t */\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\t/* exclusive and group stuff are assumed mutually exclusive */\n\t\tWARN_ON_ONCE(move_group);\n\n\t\terr = -EBUSY;\n\t\tgoto err_locked;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\n\t/*\n\t * This is the point on no return; we cannot fail hereafter. This is\n\t * where we start modifying current state.\n\t */\n\n\tif (move_group) {\n\t\t/*\n\t\t * See perf_event_ctx_lock() for comments on the details\n\t\t * of swizzling perf_event::ctx.\n\t\t */\n\t\tperf_remove_from_context(group_leader, 0);\n\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_remove_from_context(sibling, 0);\n\t\t\tput_ctx(gctx);\n\t\t}\n\n\t\t/*\n\t\t * Wait for everybody to stop referencing the events through\n\t\t * the old lists, before installing it on new lists.\n\t\t */\n\t\tsynchronize_rcu();\n\n\t\t/*\n\t\t * Install the group siblings before the group leader.\n\t\t *\n\t\t * Because a group leader will try and install the entire group\n\t\t * (through the sibling list, which is still in-tact), we can\n\t\t * end up with siblings installed in the wrong context.\n\t\t *\n\t\t * By installing siblings first we NO-OP because they're not\n\t\t * reachable through the group lists.\n\t\t */\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_event__state_init(sibling);\n\t\t\tperf_install_in_context(ctx, sibling, sibling->cpu);\n\t\t\tget_ctx(ctx);\n\t\t}\n\n\t\t/*\n\t\t * Removing from the context ends up with disabled\n\t\t * event. What we want here is event in the initial\n\t\t * startup state, ready to be add into new context.\n\t\t */\n\t\tperf_event__state_init(group_leader);\n\t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that all events are installed in @ctx, nothing\n\t\t * references @gctx anymore, so drop the last reference we have\n\t\t * on it.\n\t\t */\n\t\tput_ctx(gctx);\n\t}\n\n\t/*\n\t * Precalculate sample_data sizes; do while holding ctx::mutex such\n\t * that we're serialized against further additions and before\n\t * perf_install_in_context() which is the point the event is active and\n\t * can use these values.\n\t */\n\tperf_event__header_size(event);\n\tperf_event__id_header_size(event);\n\n\tevent->owner = current;\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\n\tif (move_group)\n\t\tmutex_unlock(&gctx->mutex);\n\tmutex_unlock(&ctx->mutex);\n\n\tif (task) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\tput_task_struct(task);\n\t}\n\n\tput_online_cpus();\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_add_tail(&event->owner_entry, &current->perf_event_list);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\t/*\n\t * Drop the reference on the group_event after placing the\n\t * new event on the sibling_list. This ensures destruction\n\t * of the group leader will find the pointer to itself in\n\t * perf_group_detach().\n\t */\n\tfdput(group);\n\tfd_install(event_fd, event_file);\n\treturn event_fd;\n\nerr_locked:\n\tif (move_group)\n\t\tmutex_unlock(&gctx->mutex);\n\tmutex_unlock(&ctx->mutex);\n/* err_file: */\n\tfput(event_file);\nerr_context:\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_alloc:\n\t/*\n\t * If event_file is set, the fput() above will have called ->release()\n\t * and that will take care of freeing the event.\n\t */\n\tif (!event_file)\n\t\tfree_event(event);\nerr_cred:\n\tif (task)\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\nerr_cpus:\n\tput_online_cpus();\nerr_task:\n\tif (task)\n\t\tput_task_struct(task);\nerr_group_fd:\n\tfdput(group);\nerr_fd:\n\tput_unused_fd(event_fd);\n\treturn err;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-6001"
    },
    {
        "index": 3415,
        "code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\n\t/* mlock all present pages, but do not fault in new pages */\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\t/* For mm_populate(), just skip the stack guard page. */\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\n\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\n\t * can thus safely do subsequent page lookups as if they were reads.\n\t * But only do so when looping for pte_write is futile: in some cases\n\t * userspace may also be wanting to write to the gotten user page,\n\t * which a read fault here might prevent (a readonly page might get\n\t * reCOWed by userspace write).\n\t */\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-5195"
    },
    {
        "index": 4892,
        "code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\n\t/* remove bcm_ops, timer, rx_unregister(), etc. */\n\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\n\tlock_sock(sk);\n\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\t/*\n\t\t * Don't care if we're bound or not (due to netdev problems)\n\t\t * can_rx_unregister() is always a save thing to do here.\n\t\t */\n\t\tif (op->ifindex) {\n\t\t\t/*\n\t\t\t * Only remove subscriptions that had not\n\t\t\t * been removed due to NETDEV_UNREGISTER\n\t\t\t * in bcm_notifier()\n\t\t\t */\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\tbcm_remove_op(op);\n\t}\n\n#if IS_ENABLED(CONFIG_PROC_FS)\n\t/* remove procfs entry */\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif /* CONFIG_PROC_FS */\n\n\t/* remove device reference */\n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2021-3609"
    },
    {
        "index": 674,
        "code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\n\t/* Build the IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\t/* Send it out. */\n\treturn ip_local_out(skb);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 4698,
        "code": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\n\t/* Copy the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2020-12652"
    },
    {
        "index": 2676,
        "code": "static int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tmemset(&sp->subscribe, 0, sizeof(struct sctp_event_subscribe));\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tlocal_bh_disable();\n\tpercpu_counter_inc(&sctp_sockets_allocated);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\tif (net->sctp.default_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &net->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t} else\n\t\tsp->do_auto_asconf = 0;\n\tlocal_bh_enable();\n\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2015-3212"
    },
    {
        "index": 3841,
        "code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-7533"
    },
    {
        "index": 3615,
        "code": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-5986"
    },
    {
        "index": 4067,
        "code": "static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n\tint err;\n\tstruct ip_options_data opt_copy;\n\tstruct raw_frag_vec rfv;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n\t\t */\n\t\tif (inet->hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n\n\tif (!inet->hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n\t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n\n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-17712"
    },
    {
        "index": 3418,
        "code": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct dev_pagemap *pgmap = NULL;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */\n\t\tpgmap = get_dev_pagemap(pte_pfn(pte), NULL);\n\t\tif (pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET) {\n\t\tget_page(page);\n\n\t\t/* drop the pgmap reference now that we hold the page */\n\t\tif (pgmap) {\n\t\t\tput_dev_pagemap(pgmap);\n\t\t\tpgmap = NULL;\n\t\t}\n\t}\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/* Do not mlock pte-mapped THP */\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-5195"
    },
    {
        "index": 2112,
        "code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\n\t\tath_txq_lock(sc, txq);\n\n\t\tbuffered = ath_tid_has_buffered(tid);\n\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2014-2672"
    },
    {
        "index": 2967,
        "code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\n\t\t/* Re-load page tables */\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\n\t\t/* Stop flush ipis for the previous mm */\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\n\t\t/* Load per-mm CR4 state */\n\t\tload_mm_cr4(next);\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\t/*\n\t\t * Load the LDT, if the LDT is different.\n\t\t *\n\t\t * It's possible that prev->context.ldt doesn't match\n\t\t * the LDT register.  This can happen if leave_mm(prev)\n\t\t * was called and then modify_ldt changed\n\t\t * prev->context.ldt but suppressed an IPI to this CPU.\n\t\t * In this case, prev->context.ldt != NULL, because we\n\t\t * never set context.ldt to NULL while the mm still\n\t\t * exists.  That means that next->context.ldt !=\n\t\t * prev->context.ldt, because mms never share an LDT.\n\t\t */\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\t/*\n\t\t\t * On established mms, the mm_cpumask is only changed\n\t\t\t * from irq context, from ptep_clear_flush() while in\n\t\t\t * lazy tlb mode, and here. Irqs are blocked during\n\t\t\t * schedule, protecting us from simultaneous changes.\n\t\t\t */\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\t/*\n\t\t\t * We were in lazy tlb mode and leave_mm disabled\n\t\t\t * tlb flush IPI delivery. We must reload CR3\n\t\t\t * to make sure to use no freed page tables.\n\t\t\t */\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-2069"
    }
]