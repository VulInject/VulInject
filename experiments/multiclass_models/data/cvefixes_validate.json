[
    {
        "index": 0,
        "code": "TfLiteStatus LogicalImpl(TfLiteContext* context, TfLiteNode* node,\n                         bool (*func)(bool, bool)) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (data->requires_broadcast) {\n    reference_ops::BroadcastBinaryFunction4DSlow<bool, bool, bool>(\n        GetTensorShape(input1), GetTensorData<bool>(input1),\n        GetTensorShape(input2), GetTensorData<bool>(input2),\n        GetTensorShape(output), GetTensorData<bool>(output), func);\n  } else {\n    reference_ops::BinaryFunction<bool, bool, bool>(\n        GetTensorShape(input1), GetTensorData<bool>(input1),\n        GetTensorShape(input2), GetTensorData<bool>(input2),\n        GetTensorShape(output), GetTensorData<bool>(output), func);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 1,
        "code": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 2,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = input->type;\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 3,
        "code": "void UnicodeStringTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char *par)\n{\n    if (exec) logln(\"TestSuite UnicodeStringTest: \");\n    TESTCASE_AUTO_BEGIN;\n    TESTCASE_AUTO_CREATE_CLASS(StringCaseTest);\n    TESTCASE_AUTO(TestBasicManipulation);\n    TESTCASE_AUTO(TestCompare);\n    TESTCASE_AUTO(TestExtract);\n    TESTCASE_AUTO(TestRemoveReplace);\n    TESTCASE_AUTO(TestSearching);\n    TESTCASE_AUTO(TestSpacePadding);\n    TESTCASE_AUTO(TestPrefixAndSuffix);\n    TESTCASE_AUTO(TestFindAndReplace);\n    TESTCASE_AUTO(TestBogus);\n    TESTCASE_AUTO(TestReverse);\n    TESTCASE_AUTO(TestMiscellaneous);\n    TESTCASE_AUTO(TestStackAllocation);\n    TESTCASE_AUTO(TestUnescape);\n    TESTCASE_AUTO(TestCountChar32);\n    TESTCASE_AUTO(TestStringEnumeration);\n    TESTCASE_AUTO(TestNameSpace);\n    TESTCASE_AUTO(TestUTF32);\n    TESTCASE_AUTO(TestUTF8);\n    TESTCASE_AUTO(TestReadOnlyAlias);\n    TESTCASE_AUTO(TestAppendable);\n    TESTCASE_AUTO(TestUnicodeStringImplementsAppendable);\n    TESTCASE_AUTO(TestSizeofUnicodeString);\n    TESTCASE_AUTO(TestStartsWithAndEndsWithNulTerminated);\n    TESTCASE_AUTO(TestMoveSwap);\n    TESTCASE_AUTO(TestUInt16Pointers);\n    TESTCASE_AUTO(TestWCharPointers);\n    TESTCASE_AUTO(TestNullPointers);\n    TESTCASE_AUTO(TestUnicodeStringInsertAppendToSelf);\n    TESTCASE_AUTO_END;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-10531"
    },
    {
        "index": 4,
        "code": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//parse headers\n\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-40575"
    },
    {
        "index": 5,
        "code": "ALWAYS_INLINE String serialize_impl(const Variant& value,\n                                    const SerializeOptions& opts) {\n  switch (value.getType()) {\n    case KindOfClass:\n    case KindOfLazyClass:\n    case KindOfPersistentString:\n    case KindOfString: {\n      auto const str =\n        isStringType(value.getType()) ? value.getStringData() :\n        isClassType(value.getType()) ? classToStringHelper(value.toClassVal()) :\n        lazyClassToStringHelper(value.toLazyClassVal());\n      auto const size = str->size();\n      if (size >= RuntimeOption::MaxSerializedStringSize) {\n        throw Exception(\"Size of serialized string (%d) exceeds max\", size);\n      }\n      StringBuffer sb;\n      sb.append(\"s:\");\n      sb.append(size);\n      sb.append(\":\\\"\");\n      sb.append(str->data(), size);\n      sb.append(\"\\\";\");\n      return sb.detach();\n    }\n    case KindOfResource:\n      return s_Res;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfFunc:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfDouble:\n    case KindOfObject:\n    case KindOfClsMeth:\n    case KindOfRClsMeth:\n    case KindOfRFunc:\n    case KindOfRecord:\n      break;\n  }\n  VariableSerializer vs(VariableSerializer::Type::Serialize);\n  if (opts.keepDVArrays)        vs.keepDVArrays();\n  if (opts.forcePHPArrays)      vs.setForcePHPArrays();\n  if (opts.warnOnHackArrays)    vs.setHackWarn();\n  if (opts.warnOnPHPArrays)     vs.setPHPWarn();\n  if (opts.ignoreLateInit)      vs.setIgnoreLateInit();\n  if (opts.serializeProvenanceAndLegacy) vs.setSerializeProvenanceAndLegacy();\n  // Keep the count so recursive calls to serialize() embed references properly.\n  return vs.serialize(value, true, true);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 6,
        "code": "TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  // Make sure that the input is in uint8_t with at least 1 data entry.\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n\n  // Allocate a temporary buffer with the same size of input for sorting.\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  // We can interleave scratch / persistent buffer allocation.\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 7,
        "code": "void PCRECache::dump(const std::string& filename) {\n  std::ofstream out(filename.c_str());\n  switch (m_kind) {\n    case CacheKind::Static:\n      for (auto& it : *m_staticCache) {\n        out << it.first->data() << \"\\n\";\n      }\n      break;\n    case CacheKind::Lru:\n    case CacheKind::Scalable:\n      {\n        std::vector<LRUCacheKey> keys;\n        if (m_kind == CacheKind::Lru) {\n          m_lruCache->snapshotKeys(keys);\n        } else {\n          m_scalableCache->snapshotKeys(keys);\n        }\n        for (auto& key: keys) {\n          out << key.c_str() << \"\\n\";\n        }\n      }\n      break;\n  }\n  out.close();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 8,
        "code": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 9,
        "code": "TEST(BasicInterpreter, ThreeStepAllocate) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(5), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({4}), kTfLiteOk);\n\n  TfLiteQuantizationParams quantized;\n\n  // String tensor with one string of length 3\n  union {\n    char raw_bytes[15];\n    struct {\n      int32_t num_strs;\n      int32_t offsets[2];\n      char str_data[3];\n    } tensor_data;\n  } data;\n  data.tensor_data = {1, {12, 15}, {'A', 'B', 'C'}};\n\n  // Read only string tensor.\n  ASSERT_EQ(interpreter.SetTensorParametersReadOnly(0, kTfLiteString, \"\", {1},\n                                                    quantized, data.raw_bytes,\n                                                    sizeof(data.raw_bytes)),\n            kTfLiteOk);\n  // Read-write string tensor.\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(1, kTfLiteString, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(2, kTfLiteInt32, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(3, kTfLiteString, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(4, kTfLiteInt32, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n\n  // String-in String-out node.\n  TfLiteRegistration reg_copy = {nullptr, nullptr, nullptr, nullptr};\n  reg_copy.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* input = GetInput(context, node, 0);\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    DynamicBuffer buf;\n    StringRef str_ref = GetString(input, 0);\n    buf.AddString(str_ref);\n    buf.WriteToTensorAsVector(output);\n    return kTfLiteOk;\n  };\n\n  // String-in Int-out node.\n  TfLiteRegistration reg_len = {nullptr, nullptr, nullptr, nullptr};\n  reg_len.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n    outputSize->data[0] = 1;\n    return context->ResizeTensor(context, output, outputSize);\n  };\n  reg_len.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TfLiteTensor* a1 = GetOutput(context, node, 0);\n    a1->data.i32[0] = a0->bytes;\n    return kTfLiteOk;\n  };\n\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                              &reg_copy),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({1}, {2}, nullptr, 0, nullptr,\n                                              &reg_len),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {3}, nullptr, 0, nullptr,\n                                              &reg_copy),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({3}, {4}, nullptr, 0, nullptr,\n                                              &reg_len),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.tensor(0)->bytes, 15);\n  ASSERT_NE(interpreter.tensor(0)->data.raw, nullptr);\n  ASSERT_EQ(interpreter.tensor(1)->bytes, 15);\n  ASSERT_NE(interpreter.tensor(1)->data.raw, nullptr);\n  ASSERT_EQ(interpreter.tensor(3)->bytes, 15);\n  ASSERT_NE(interpreter.tensor(4)->data.raw, nullptr);\n  ASSERT_EQ(interpreter.tensor(2)->bytes, 4);\n  ASSERT_EQ(interpreter.tensor(2)->data.i32[0], 15);\n  ASSERT_EQ(interpreter.tensor(4)->bytes, 4);\n  ASSERT_EQ(interpreter.tensor(4)->data.i32[0], 15);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 10,
        "code": "bool JSON_parser(Variant &z, const char *p, int length, bool const assoc,\n                 int depth, int64_t options) {\n  // No GC safepoints during JSON parsing, please. Code is not re-entrant.\n  NoHandleSurpriseScope no_surprise(SafepointFlags);\n\n  json_parser *json = s_json_parser.get(); /* the parser state */\n  // Clear and reuse the thread-local string buffers. They are only freed if\n  // they exceed kMaxPersistentStringBufferCapacity at exit or if the thread\n  // is explicitly flushed (e.g., due to being idle).\n  json->initSb(length);\n  SCOPE_EXIT {\n    constexpr int kMaxPersistentStringBufferCapacity = 256 * 1024;\n    if (json->sb_cap > kMaxPersistentStringBufferCapacity) json->flushSb();\n  };\n  // SimpleParser only handles the most common set of options. Also, only use it\n  // if its array nesting depth check is *more* restrictive than what the user\n  // asks for, to ensure that the precise semantics of the general case is\n  // applied for all nesting overflows.\n  if (assoc &&\n      options == (options & (k_JSON_FB_LOOSE |\n                             k_JSON_FB_DARRAYS |\n                             k_JSON_FB_DARRAYS_AND_VARRAYS |\n                             k_JSON_FB_HACK_ARRAYS |\n                             k_JSON_FB_THRIFT_SIMPLE_JSON |\n                             k_JSON_FB_LEGACY_HACK_ARRAYS)) &&\n      depth >= SimpleParser::kMaxArrayDepth &&\n      length <= RuntimeOption::EvalSimpleJsonMaxLength &&\n      SimpleParser::TryParse(p, length, json->tl_buffer.tv, z,\n                             get_container_type_from_options(options),\n                             options & k_JSON_FB_THRIFT_SIMPLE_JSON)) {\n    return true;\n  }\n\n  int b;  /* the next character */\n  int c;  /* the next character class */\n  int s;  /* the next state */\n  int state = 0;\n\n  /*<fb>*/\n  bool const loose = options & k_JSON_FB_LOOSE;\n  JSONContainerType const container_type =\n    get_container_type_from_options(options);\n  int qchr = 0;\n  int8_t const *byte_class;\n  int8_t const (*next_state_table)[32];\n  if (loose) {\n    byte_class = loose_ascii_class;\n    next_state_table = loose_state_transition_table;\n  } else {\n    byte_class = ascii_class;\n    next_state_table = state_transition_table;\n  }\n  /*</fb>*/\n\n  UncheckedBuffer *buf = &json->sb_buf;\n  UncheckedBuffer *key = &json->sb_key;\n\n  DataType type = kInvalidDataType;\n  unsigned short escaped_bytes = 0;\n\n  auto reset_type = [&] { type = kInvalidDataType; };\n\n  json->depth = depth;\n  // Since the stack is maintainined on a per request basis, for performance\n  // reasons, it only makes sense to expand if necessary and cycles are wasted\n  // contracting. Calls with a depth other than default should be rare.\n  if (depth > json->stack.size()) {\n    json->stack.resize(depth);\n  }\n  SCOPE_EXIT {\n    if (json->stack.empty()) return;\n    for (int i = 0; i <= json->mark; i++) {\n      json->stack[i].key.reset();\n      json->stack[i].val.unset();\n    }\n    json->mark = -1;\n  };\n\n  json->mark = json->top = -1;\n  push(json, Mode::DONE);\n\n  UTF8To16Decoder decoder(p, length, loose);\n  for (;;) {\n    b = decoder.decode();\n    // Fast-case most common transition: append a simple string character.\n    if (state == 3 && type == KindOfString) {\n      while (b != '\\\"' &&  b != '\\\\' && b != '\\'' && b <= 127 && b >= ' ') {\n        buf->append((char)b);\n        b = decoder.decode();\n      }\n    }\n    if (b == UTF8_END) break; // UTF-8 decoding finishes successfully.\n    if (b == UTF8_ERROR) {\n      s_json_parser->error_code = JSON_ERROR_UTF8;\n      return false;\n    }\n    assertx(b >= 0);\n\n    if ((b & 127) == b) {\n      /*<fb>*/\n      c = byte_class[b];\n      /*</fb>*/\n      if (c <= S_ERR) {\n        s_json_parser->error_code = JSON_ERROR_CTRL_CHAR;\n        return false;\n      }\n    } else {\n      c = S_ETC;\n    }\n    /*\n      Get the next state from the transition table.\n    */\n\n    /*<fb>*/\n    s = next_state_table[state][c];\n\n    if (s == -4) {\n      if (b != qchr) {\n        s = 3;\n      } else {\n        qchr = 0;\n      }\n    }\n    /*</fb>*/\n\n    if (s < 0) {\n      /*\n        Perform one of the predefined actions.\n      */\n      switch (s) {\n        /*\n          empty }\n        */\n      case -9:\n        /*<fb>*/\n        if (json->top == 1) z = json->stack[json->top].val;\n        else {\n        /*</fb>*/\n          attach_zval(json, json->stack[json->top].key, assoc, container_type);\n        /*<fb>*/\n        }\n        /*</fb>*/\n        if (!pop(json, Mode::KEY)) {\n          return false;\n        }\n        state = 9;\n        break;\n        /*\n          {\n        */\n      case -8:\n        if (!push(json, Mode::KEY)) {\n          s_json_parser->error_code = JSON_ERROR_DEPTH;\n          return false;\n        }\n\n        state = 1;\n        if (json->top > 0) {\n          Variant &top = json->stack[json->top].val;\n          /*<fb>*/\n          if (container_type == JSONContainerType::COLLECTIONS) {\n            // stable_maps is meaningless\n            top = req::make<c_Map>();\n          } else {\n          /*</fb>*/\n            if (!assoc) {\n              top = SystemLib::AllocStdClassObject();\n            /* <fb> */\n            } else if (container_type == JSONContainerType::HACK_ARRAYS) {\n              top = Array::CreateDict();\n            } else if (container_type == JSONContainerType::DARRAYS ||\n                       container_type == JSONContainerType::DARRAYS_AND_VARRAYS)\n            {\n              top = Array::CreateDArray();\n            /* </fb> */\n            } else if (\n              container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n              auto arr = staticEmptyDictArray()->copy();\n              arr->setLegacyArray(true);\n              top = arr;\n            } else {\n              top = Array::CreateDArray();\n            }\n          /*<fb>*/\n          }\n          /*</fb>*/\n          json->stack[json->top].key = copy_and_clear(*key);\n          reset_type();\n        }\n        break;\n        /*\n          }\n        */\n      case -7:\n        /*** BEGIN Facebook: json_utf8_loose ***/\n        /*\n          If this is a trailing comma in an object definition,\n          we're in Mode::KEY. In that case, throw that off the\n          stack and restore Mode::OBJECT so that we pretend the\n          trailing comma just didn't happen.\n        */\n        if (loose) {\n          if (pop(json, Mode::KEY)) {\n            push(json, Mode::OBJECT);\n          }\n        }\n        /*** END Facebook: json_utf8_loose ***/\n\n        if (type != kInvalidDataType &&\n            json->stack[json->top].mode == Mode::OBJECT) {\n          Variant mval;\n          json_create_zval(mval, *buf, type, options);\n          Variant &top = json->stack[json->top].val;\n          object_set(json, top, copy_and_clear(*key),\n                     mval, assoc, container_type);\n          buf->clear();\n          reset_type();\n        }\n\n        /*<fb>*/\n        if (json->top == 1) z = json->stack[json->top].val;\n        else {\n        /*</fb>*/\n          attach_zval(json, json->stack[json->top].key,\n            assoc, container_type);\n        /*<fb>*/\n        }\n        /*</fb>*/\n        if (!pop(json, Mode::OBJECT)) {\n          s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;\n          return false;\n        }\n        state = 9;\n        break;\n        /*\n          [\n        */\n      case -6:\n        if (!push(json, Mode::ARRAY)) {\n          s_json_parser->error_code = JSON_ERROR_DEPTH;\n          return false;\n        }\n        state = 2;\n\n        if (json->top > 0) {\n          Variant &top = json->stack[json->top].val;\n          /*<fb>*/\n          if (container_type == JSONContainerType::COLLECTIONS) {\n            top = req::make<c_Vector>();\n          } else if (container_type == JSONContainerType::HACK_ARRAYS) {\n            top = Array::CreateVec();\n          } else if (container_type == JSONContainerType::DARRAYS_AND_VARRAYS) {\n            top = Array::CreateVArray();\n          } else if (container_type == JSONContainerType::DARRAYS) {\n            top = Array::CreateDArray();\n          } else if (container_type == JSONContainerType::LEGACY_HACK_ARRAYS) {\n            auto arr = staticEmptyVecArray()->copy();\n            arr->setLegacyArray(true);\n            top = arr;\n          } else {\n            top = Array::CreateDArray();\n          }\n          /*</fb>*/\n          json->stack[json->top].key = copy_and_clear(*key);\n          reset_type();\n        }\n        break;\n        /*\n          ]\n        */\n      case -5:\n        {\n          if (type != kInvalidDataType &&\n               json->stack[json->top].mode == Mode::ARRAY) {\n            Variant mval;\n            json_create_zval(mval, *buf, type, options);\n            auto& top = json->stack[json->top].val;\n            if (container_type == JSONContainerType::COLLECTIONS) {\n              collections::append(top.getObjectData(), mval.asTypedValue());\n            } else {\n              top.asArrRef().append(mval);\n            }\n            buf->clear();\n            reset_type();\n          }\n\n          /*<fb>*/\n          if (json->top == 1) z = json->stack[json->top].val;\n          else {\n          /*</fb>*/\n            attach_zval(json, json->stack[json->top].key, assoc,\n              container_type);\n          /*<fb>*/\n          }\n          /*</fb>*/\n          if (!pop(json, Mode::ARRAY)) {\n            s_json_parser->error_code = JSON_ERROR_STATE_MISMATCH;\n            return false;\n          }\n          state = 9;\n        }\n        break;\n        /*\n          \"\n        */\n      case -4:\n        switch (json->stack[json->top].mode) {\n        case Mode::KEY:\n          state = 27;\n          std::swap(buf, key);\n          reset_type();\n          break;\n        case Mode::ARRAY:\n        case Mode::OBJECT:\n          state = 9;\n          break;\n        case Mode::DONE:\n          if (type == KindOfString) {\n            z = copy_and_clear(*buf);\n            state = 9;\n            break;\n          }\n          /* fall through if not KindOfString */\n        default:\n          s_json_parser->error_code = JSON_ERROR_SYNTAX;\n          return false;\n        }\n        break;\n        /*\n          ,\n        */\n      case -3:\n        {\n          Variant mval;\n          if (type != kInvalidDataType &&\n              (json->stack[json->top].mode == Mode::OBJECT ||\n               json->stack[json->top].mode == Mode::ARRAY)) {\n            json_create_zval(mval, *buf, type, options);\n          }\n\n          switch (json->stack[json->top].mode) {\n          case Mode::OBJECT:\n            if (pop(json, Mode::OBJECT) &&\n                push(json, Mode::KEY)) {\n              if (type != kInvalidDataType) {\n                Variant &top = json->stack[json->top].val;\n                object_set(\n                  json,\n                  top,\n                  copy_and_clear(*key),\n                  mval,\n                  assoc,\n                  container_type\n                );\n              }\n              state = 29;\n            }\n            break;\n          case Mode::ARRAY:\n            if (type != kInvalidDataType) {\n              auto& top = json->stack[json->top].val;\n              if (container_type == JSONContainerType::COLLECTIONS) {\n                collections::append(top.getObjectData(), mval.asTypedValue());\n              } else {\n                top.asArrRef().append(mval);\n              }\n            }\n            state = 28;\n            break;\n          default:\n            s_json_parser->error_code = JSON_ERROR_SYNTAX;\n            return false;\n          }\n          buf->clear();\n          reset_type();\n          check_non_safepoint_surprise();\n        }\n        break;\n\n        /*<fb>*/\n        /*\n          : (after unquoted string)\n        */\n      case -10:\n        if (json->stack[json->top].mode == Mode::KEY) {\n          state = 27;\n          std::swap(buf, key);\n          reset_type();\n          s = -2;\n        } else {\n          s = 3;\n          break;\n        }\n        /*</fb>*/\n\n        /*\n          :\n        */\n      case -2:\n        if (pop(json, Mode::KEY) && push(json, Mode::OBJECT)) {\n          state = 28;\n          break;\n        }\n        /*\n          syntax error\n        */\n      case -1:\n        s_json_parser->error_code = JSON_ERROR_SYNTAX;\n        return false;\n      }\n    } else {\n      /*\n        Change the state and iterate.\n      */\n      bool is_tsimplejson = options & k_JSON_FB_THRIFT_SIMPLE_JSON;\n      if (type == KindOfString) {\n        if (/*<fb>*/(/*</fb>*/s == 3/*<fb>*/ || s == 30)/*</fb>*/ &&\n            state != 8) {\n          if (state != 4) {\n            utf16_to_utf8(*buf, b);\n          } else {\n            switch (b) {\n            case 'b': buf->append('\\b'); break;\n            case 't': buf->append('\\t'); break;\n            case 'n': buf->append('\\n'); break;\n            case 'f': buf->append('\\f'); break;\n            case 'r': buf->append('\\r'); break;\n            default:\n              utf16_to_utf8(*buf, b);\n              break;\n            }\n          }\n        } else if (s == 6) {\n          if (UNLIKELY(is_tsimplejson)) {\n            if (UNLIKELY(b != '0'))  {\n              s_json_parser->error_code = JSON_ERROR_SYNTAX;\n              return false;\n            }\n            escaped_bytes = 0;\n          } else {\n            escaped_bytes = dehexchar(b) << 12;\n          }\n        } else if (s == 7) {\n          if (UNLIKELY(is_tsimplejson)) {\n            if (UNLIKELY(b != '0'))  {\n              s_json_parser->error_code = JSON_ERROR_SYNTAX;\n              return false;\n            }\n          } else {\n            escaped_bytes += dehexchar(b) << 8;\n          }\n        } else if (s == 8) {\n          escaped_bytes += dehexchar(b) << 4;\n        } else if (s == 3 && state == 8) {\n          escaped_bytes += dehexchar(b);\n          if (UNLIKELY(is_tsimplejson)) {\n            buf->append((char)escaped_bytes);\n          } else {\n            utf16_to_utf8(*buf, escaped_bytes);\n          }\n        }\n      } else if ((type == kInvalidDataType || type == KindOfNull) &&\n                 (c == S_DIG || c == S_ZER)) {\n        type = KindOfInt64;\n        buf->append((char)b);\n      } else if (type == KindOfInt64 && s == 24) {\n        type = KindOfDouble;\n        buf->append((char)b);\n      } else if ((type == kInvalidDataType || type == KindOfNull ||\n                  type == KindOfInt64) &&\n                 c == S_DOT) {\n        type = KindOfDouble;\n        buf->append((char)b);\n      } else if (type != KindOfString && c == S_QUO) {\n        type = KindOfString;\n        /*<fb>*/qchr = b;/*</fb>*/\n      } else if ((type == kInvalidDataType || type == KindOfNull ||\n                  type == KindOfInt64 || type == KindOfDouble) &&\n                 ((state == 12 && s == 9) ||\n                  (state == 16 && s == 9))) {\n        type = KindOfBoolean;\n      } else if (type == kInvalidDataType && state == 19 && s == 9) {\n        type = KindOfNull;\n      } else if (type != KindOfString && c > S_WSP) {\n        utf16_to_utf8(*buf, b);\n      }\n\n      state = s;\n    }\n  }\n\n  if (state == 9 && pop(json, Mode::DONE)) {\n    s_json_parser->error_code = JSON_ERROR_NONE;\n    return true;\n  }\n\n  s_json_parser->error_code = JSON_ERROR_SYNTAX;\n  return false;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1892"
    },
    {
        "index": 11,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_11FixedString_3read_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  Py_ssize_t __pyx_v_n_items;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_n_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 1); __PYX_ERR(0, 51, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 2); __PYX_ERR(0, 51, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"read_items\") < 0)) __PYX_ERR(0, 51, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_n_items = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_n_items == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 51, __pyx_L3_error)\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 51, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString_2read_items(__pyx_self, __pyx_v_self, __pyx_v_n_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 12,
        "code": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 13,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader_6__setstate_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *__pyx_v_self, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__setstate_cython__\", 0);\n\n  /* \"(tree fragment)\":17\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, state)\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedSocketReader__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<\n */\n  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedSocketReader__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":16\n *     else:\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, state)\n * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_unpickle_BufferedSocketReader__set_state(self, __pyx_state)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedSocketReader.__setstate_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 14,
        "code": "int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n#ifdef _WIN32\n    int flags = 0;\n#else\n#ifdef __APPLE__\n    int flags = 0;\n#else\n    int flags = MSG_NOSIGNAL;\n#endif\n#endif\n\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            if (errno == EPIPE)\n                conn->connected = 0;\n            conn->err = MONGO_IO_ERROR;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 15,
        "code": "TfLiteStatus SoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = static_cast<TfLiteSoftmaxParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n\n  TFLITE_DCHECK(node->user_data != nullptr);\n  SoftmaxParams* data = static_cast<SoftmaxParams*>(node->user_data);\n  return CalculateSoftmaxParams(context, input, output, params, data);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 16,
        "code": "static int __pyx_pw_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_compressor = 0;\n  PyObject *__pyx_v_bufsize = 0;\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_compressor,&__pyx_n_s_bufsize,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_compressor)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bufsize)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, 1); __PYX_ERR(0, 80, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 80, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_compressor = values[0];\n    __pyx_v_bufsize = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 80, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter___init__(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *)__pyx_v_self), __pyx_v_compressor, __pyx_v_bufsize);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 17,
        "code": "ga_add_string(garray_T *gap, char_u *p)\n{\n    char_u *cp = vim_strsave(p);\n\n    if (cp == NULL)\n\treturn FAIL;\n\n    if (ga_grow(gap, 1) == FAIL)\n    {\n\tvim_free(cp);\n\treturn FAIL;\n    }\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;\n    return OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 18,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const int scratch_tensor_index = op_data->scratch_tensor_index;\n\n  // Check we have all the inputs and outputs we need.\n  bool is_layer_norm_lstm = false;\n  if (node->inputs->size == 24) {\n    const TfLiteTensor* forget_layer_norm_coefficients = GetOptionalInputTensor(\n        context, node, lstm::full::kForgetLayerNormCoefficientsTensor);\n    if (forget_layer_norm_coefficients == nullptr) {\n      is_layer_norm_lstm = false;\n    } else {\n      is_layer_norm_lstm = true;\n    }\n  } else if (node->inputs->size == 20) {\n    // This is deprecated and is only kept here for backward compatibility.\n    is_layer_norm_lstm = false;\n  } else {\n    context->ReportError(\n        context, \"The LSTM Full kernel expects 20 or 24 inputs. Got %d inputs\",\n        node->inputs->size);\n    return kTfLiteError;\n  }\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  op_data->is_layer_norm_lstm = is_layer_norm_lstm;\n\n  // Inferring batch size, number of outputs and sequence length and\n  // number of cells from the input tensors.\n  const TfLiteTensor* input = GetInput(context, node, lstm::full::kInputTensor);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE(context, input->dims->size > 1);\n  const auto* params =\n      reinterpret_cast<TfLiteUnidirectionalSequenceLSTMParams*>(\n          node->builtin_data);\n  const bool time_major = params->time_major;\n  const int n_batch = time_major ? input->dims->data[1] : input->dims->data[0];\n  const int n_input = input->dims->data[2];\n\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, lstm::full::kInputToOutputWeightsTensor);\n  const int n_cell = input_to_output_weights->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, input_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_output_weights->dims->data[1], n_input);\n\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, lstm::full::kRecurrentToOutputWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_output_weights->dims->data[0],\n                    n_cell);\n  const int n_output = recurrent_to_output_weights->dims->data[1];\n\n  // Check that input tensor dimensions matches with each other.\n  TF_LITE_ENSURE_OK(context,\n                    CheckInputTensorDimensions(context, node, n_input, n_output,\n                                               n_cell, is_layer_norm_lstm));\n\n  // Get the pointer to output, output_state and cell_state buffer tensors.\n  TfLiteTensor* output = GetOutput(context, node, lstm::full::kOutputTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, lstm::full::kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state =\n      GetVariableInput(context, node, lstm::full::kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  // Check the shape of input state tensors.\n  // These tensor may be 1D or 2D. It's fine as long as the total size is\n  // correct.\n  TF_LITE_ENSURE_EQ(context, NumElements(output_state), n_batch * n_output);\n  TF_LITE_ENSURE_EQ(context, NumElements(cell_state), n_batch * n_cell);\n\n  // Resize the output tensors.\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  output_size->data[input->dims->size - 1] = n_output;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size));\n\n  TfLiteIntArrayFree(node->temporaries);\n  if (IsHybridOp(input, input_to_output_weights)) {\n    node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(1);\n  }\n  node->temporaries->data[kScratchBuffer] =\n      scratch_tensor_index + kScratchBuffer;\n\n  // Create a scratch buffer tensor.\n  TfLiteTensor* scratch_buffer = GetTemporary(context, node, kScratchBuffer);\n  scratch_buffer->type = input->type;\n  scratch_buffer->allocation_type = kTfLiteArenaRw;\n\n  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kInputToInputWeightsTensor);\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  TfLiteIntArray* scratch_buffer_size = TfLiteIntArrayCreate(2);\n  scratch_buffer_size->data[0] = n_batch;\n  if (use_cifg) {\n    // Reserving space for Cell, Forget, Output gates\n    scratch_buffer_size->data[1] = n_cell * 3;\n  } else {\n    // Reserving space for Input, Cell, Forget, Output gates\n    scratch_buffer_size->data[1] = n_cell * 4;\n  }\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_buffer,\n                                                   scratch_buffer_size));\n\n  if (IsHybridOp(input, input_to_output_weights)) {\n    op_data->compute_row_sums = true;\n    // Allocate temporary tensors to store quantized values of input,\n    // output_state and cell_state tensors.\n    node->temporaries->data[kInputQuantized] =\n        scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized =\n        GetTemporary(context, node, kInputQuantized);\n    input_quantized->type = input_to_output_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n    node->temporaries->data[kOutputStateQuantized] =\n        scratch_tensor_index + kOutputStateQuantized;\n    TfLiteTensor* output_state_quantized =\n        GetTemporary(context, node, kOutputStateQuantized);\n    output_state_quantized->type = input_to_output_weights->type;\n    output_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(output_state_quantized->dims,\n                             output_state->dims)) {\n      TfLiteIntArray* output_state_quantized_size =\n          TfLiteIntArrayCopy(output_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output_state_quantized,\n                                              output_state_quantized_size));\n    }\n    node->temporaries->data[kCellStateQuantized] =\n        scratch_tensor_index + kCellStateQuantized;\n    TfLiteTensor* cell_state_quantized =\n        GetTemporary(context, node, kCellStateQuantized);\n    cell_state_quantized->type = input_to_output_weights->type;\n    cell_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(cell_state_quantized->dims, cell_state->dims)) {\n      TfLiteIntArray* cell_state_quantized_size =\n          TfLiteIntArrayCopy(cell_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, cell_state_quantized,\n                                              cell_state_quantized_size));\n    }\n\n    // Allocate temporary tensors to store scaling factors and product scaling\n    // factors. The latter is a convenience storage which allows to quantize\n    // a vector once (which produces the scaling factors) and multiply it with\n    // different matrices (which requires multiplying the scaling factors with\n    // the scaling factor of the matrix).\n    node->temporaries->data[kInputScalingFactors] =\n        op_data->scratch_tensor_index + kInputScalingFactors;\n    TfLiteTensor* input_sf = GetTemporary(context, node, kInputScalingFactors);\n    input_sf->type = kTfLiteFloat32;\n    input_sf->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {n_batch};\n    if (!TfLiteIntArrayEqualsArray(input_sf->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_sf_size = TfLiteIntArrayCreate(1);\n      input_sf_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, input_sf, input_sf_size));\n    }\n    node->temporaries->data[kOutputStateScalingFactors] =\n        op_data->scratch_tensor_index + kOutputStateScalingFactors;\n    TfLiteTensor* output_state_sf =\n        GetTemporary(context, node, kOutputStateScalingFactors);\n    output_state_sf->type = kTfLiteFloat32;\n    output_state_sf->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(output_state_sf->dims, 1, scaling_dims)) {\n      TfLiteIntArray* output_state_sf_size = TfLiteIntArrayCreate(1);\n      output_state_sf_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_state_sf,\n                                                       output_state_sf_size));\n    }\n    node->temporaries->data[kProductScalingFactors] =\n        scratch_tensor_index + kProductScalingFactors;\n    TfLiteTensor* prod_scaling_factors =\n        GetTemporary(context, node, kProductScalingFactors);\n    prod_scaling_factors->type = kTfLiteFloat32;\n    prod_scaling_factors->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(prod_scaling_factors->dims, 1,\n                                   scaling_dims)) {\n      TfLiteIntArray* prod_scaling_factors_size = TfLiteIntArrayCreate(1);\n      prod_scaling_factors_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, prod_scaling_factors,\n                                              prod_scaling_factors_size));\n    }\n\n    // Allocate a temporary tensor to store the recovered cell weights. Since\n    // this is used for diagonal matrices, only need to store n_cell values.\n    node->temporaries->data[kRecoveredCellWeights] =\n        scratch_tensor_index + kRecoveredCellWeights;\n    TfLiteTensor* recovered_cell_weights =\n        GetTemporary(context, node, kRecoveredCellWeights);\n    recovered_cell_weights->type = kTfLiteFloat32;\n    recovered_cell_weights->allocation_type = kTfLiteArenaRw;\n    int recovered_cell_dims[1] = {n_cell};\n    if (!TfLiteIntArrayEqualsArray(recovered_cell_weights->dims, 1,\n                                   recovered_cell_dims)) {\n      TfLiteIntArray* recovered_cell_weights_size = TfLiteIntArrayCreate(1);\n      recovered_cell_weights_size->data[0] = n_cell;\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, recovered_cell_weights,\n                                              recovered_cell_weights_size));\n    }\n\n    // Allocate a temporary tensor to store the accumulated int32 values.\n    node->temporaries->data[kAccumScratch] =\n        scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, kAccumScratch);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {n_cell, n_batch};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);\n      accum_size->data[0] = n_cell;\n      accum_size->data[1] = n_batch;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, accum_scratch, accum_size));\n    }\n    node->temporaries->data[kInputZeroPoints] =\n        op_data->scratch_tensor_index + kInputZeroPoints;\n    TfLiteTensor* input_zp = GetTemporary(context, node, kInputZeroPoints);\n    input_zp->type = kTfLiteFloat32;\n    input_zp->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(input_zp->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_zp_size = TfLiteIntArrayCreate(1);\n      input_zp_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, input_zp, input_zp_size));\n    }\n    node->temporaries->data[kOutputStateZeroPoints] =\n        op_data->scratch_tensor_index + kOutputStateZeroPoints;\n    TfLiteTensor* output_state_zp =\n        GetTemporary(context, node, kOutputStateZeroPoints);\n    output_state_zp->type = kTfLiteFloat32;\n    output_state_zp->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(output_state_zp->dims, 1, scaling_dims)) {\n      TfLiteIntArray* output_state_zp_size = TfLiteIntArrayCreate(1);\n      output_state_zp_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_state_zp,\n                                                       output_state_zp_size));\n    }\n    node->temporaries->data[kRowSums] = scratch_tensor_index + kRowSums;\n    TfLiteTensor* row_sums = GetTemporary(context, node, kRowSums);\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_rows = use_cifg ? 6 : 8;\n    const TfLiteTensor* projection_weights = GetOptionalInputTensor(\n        context, node, lstm::full::kProjectionWeightsTensor);\n    if (projection_weights != nullptr) {\n      row_sums_rows += ceil(static_cast<float>(n_output) / n_cell);\n    }\n    int row_sums_dims[2] = {row_sums_rows, n_cell};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 2, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(2);\n      row_sums_size->data[0] = row_sums_dims[0];\n      row_sums_size->data[1] = row_sums_dims[1];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 19,
        "code": "String StringUtil::ROT13(const String& input) {\n  if (input.empty()) return input;\n  return String(string_rot13(input.data(), input.size()),\n                input.size(), AttachString);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 20,
        "code": "regmatch(\n    char_u\t*scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n\n    // Repeat for items that can be matched sequentially, without using the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning of the file when below the first\n\t    // line where we started, not at the start of the line or we\n\t    // didn't start at the first line of the buffer.\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\<word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>; rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works; happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t// matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored, which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing char is given match at any\n\t\t    // position where that composing char appears.\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we need to check if we don't keep\n\t\t// looping without matching any input.  The second and later\n\t\t// times a BACK is encountered it fails if the input is still\n\t\t// at the same position as the previous time.\n\t\t// The positions are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\", the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK, make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again, it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation: Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set: Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t// Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range is the normal way around, use longest match\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards, use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid useless match attempts when we know\n\t\t// what character comes next.\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching at least the\n\t\t// minimal number (since the range is backwards, that's also\n\t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save the subexpr to be able to restore them\n\t\t    // when there is a match but we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    // First try if what follows matches.  If it does then we\n\t\t    // check the behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n    // If there is something on the regstack execute the code for the state.\n    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t// position in the input.  This must be done at every\n\t\t// position in the input and checking if the match ends at\n\t\t// the current position.\n\n\t\t// save the position after the found match for next\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with operand at the current\n\t\t// position.  Go back one character until we find the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line (for multi-line matching).\n\t\t// Set behind_pos to where the match should end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want a match.  Need to restore the\n\t\t    // subexpr, because what follows matched, so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that doesn't end where we want it: Go\n\t\t// back one character.  May go to previous line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t// Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards, use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t// continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\n    // May need to continue with the inner loop, starting at \"scan\".\n    if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble -- normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n  // NOTREACHED\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1154"
    },
    {
        "index": 21,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_6varint_1write_varint(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  Py_ssize_t __pyx_v_number;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"write_varint (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_number,&__pyx_n_s_buf,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_number)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_varint\", 1, 2, 2, 1); __PYX_ERR(0, 4, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"write_varint\") < 0)) __PYX_ERR(0, 4, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_number = __Pyx_PyIndex_AsSsize_t(values[0]); if (unlikely((__pyx_v_number == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 4, __pyx_L3_error)\n    __pyx_v_buf = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"write_varint\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.varint.write_varint\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_6varint_write_varint(__pyx_self, __pyx_v_number, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 22,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, input.dims() == 1 || input.dims() == 2,\n                errors::InvalidArgument(\n                    \"input must be a vector or 2D tensor, but got shape \",\n                    input.shape().DebugString()));\n    if (input.dims() == 1) {\n      OP_REQUIRES(context,\n                  input.NumElements() == 2 || input.NumElements() == 4 ||\n                      input.NumElements() == 5,\n                  errors::InvalidArgument(\n                      \"1D input must be of size 2, 4 or 5, but got shape \",\n                      input.shape().DebugString()));\n    } else if (input.dims() == 2) {\n      OP_REQUIRES(context, input.dim_size(0) == 2 || input.dim_size(0) == 4,\n                  errors::InvalidArgument(\"First dimension of 2D input must be \"\n                                          \"of size 2 or 4, but got shape \",\n                                          input.shape().DebugString()));\n      OP_REQUIRES(\n          context, input.dim_size(1) == 2,\n          errors::InvalidArgument(\n              \"Second dimension of 2D input must be of size 2, but got shape \",\n              input.shape().DebugString()));\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    // Support 1D and 2D cases.\n    Eigen::DSizes<Eigen::DenseIndex, 8> dst_idx;\n    string src_format_str = src_format_;\n    string dst_format_str = dst_format_;\n    if (input.dim_size(0) == 2) {\n      // If the input is a vector of size 2, treat the two elements as spatial\n      // dimensions.\n      auto keep_only_spatial_dimensions = [](string* format_str) -> void {\n        auto new_end = std::remove_if(\n            format_str->begin(), format_str->end(),\n            [](const char dim) { return dim != 'H' && dim != 'W'; });\n        format_str->erase(new_end, format_str->end());\n      };\n      keep_only_spatial_dimensions(&src_format_str);\n      keep_only_spatial_dimensions(&dst_format_str);\n    }\n    ComputeDstIndex(src_format_str, dst_format_str, input.dims(), &dst_idx);\n\n    functor::DataFormatVecPermute<Device, T>()(context->eigen_device<Device>(),\n                                               input.flat<T>(),\n                                               output->flat<T>(), dst_idx);\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26267"
    },
    {
        "index": 23,
        "code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n\n  // Build the outer function which creates the generator.\n  // Does not have an associated source range.\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n      /* insertBefore */ nullptr);\n\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n\n    // Create a generator function, which will store the arguments.\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n\n    if (!hasSimpleParams(functionNode)) {\n      // If there are non-simple params, step the inner function once to\n      // initialize them.\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n\n    emitFunctionEpilogue(gen);\n  }\n\n  return outerFn;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 24,
        "code": "static Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    \n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    \n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[100];\n\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 25,
        "code": "static const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tif (!vga_init_done) {\n\t\tvgacon_scrollback_startup();\n\t\tvga_init_done = true;\n\t}\n\n\treturn display_desc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-28097"
    },
    {
        "index": 26,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_2write_into_stream(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"write_into_stream\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_write_into_stream(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedSocketWriter.write_into_stream\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 27,
        "code": "static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tpred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-40564"
    },
    {
        "index": 28,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 29,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = kTfLiteInt32;\n\n  // By design, the input shape is always known at the time of Prepare, even\n  // if the preceding op that generates |input| is dynamic. Thus, we can\n  // always compute the rank immediately, without waiting for Eval.\n  SetTensorToPersistentRo(output);\n\n  // Rank produces a 0-D int32 Tensor representing the rank of input.\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(0);\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_size));\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(output), 0);\n\n  // Immediately propagate the known rank to the output tensor. This allows\n  // downstream ops that rely on the value to use it during prepare.\n  if (output->type == kTfLiteInt32) {\n    int32_t* output_data = GetTensorData<int32_t>(output);\n    *output_data = NumDimensions(input);\n  } else {\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 30,
        "code": "TypedValue HHVM_FUNCTION(substr_compare,\n                         const String& main_str,\n                         const String& str,\n                         int offset,\n                         int length /* = INT_MAX */,\n                         bool case_insensitivity /* = false */) {\n  int s1_len = main_str.size();\n  int s2_len = str.size();\n\n  if (length <= 0) {\n    raise_warning(\"The length must be greater than zero\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (offset < 0) {\n    offset = s1_len + offset;\n    if (offset < 0) offset = 0;\n  }\n\n  if (offset >= s1_len) {\n    raise_warning(\"The start position cannot exceed initial string length\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  int cmp_len = s1_len - offset;\n  if (cmp_len < s2_len) cmp_len = s2_len;\n  if (cmp_len > length) cmp_len = length;\n\n  const char *s1 = main_str.data();\n  if (case_insensitivity) {\n    return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len));\n  }\n  return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 31,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 1);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputValue);\n  SetTensorToDynamic(output);\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 32,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n\n    // MatrixDiagPart and MatrixDiagPartV2 both use this OpKernel.\n    // MatrixDiagPart only has one input, so we have to check the number of\n    // inputs before reading additional parameters in MatrixDiagV2.\n    int32_t lower_diag_index = 0;\n    int32_t upper_diag_index = 0;\n    T padding_value(0);\n\n    // MatrixDiagPartV2-specific.\n    if (context->num_inputs() > kNumV1Inputs) {\n      auto& diag_index = context->input(1);\n      OP_REQUIRES(context,\n                  TensorShapeUtils::IsScalar(diag_index.shape()) ||\n                      TensorShapeUtils::IsVector(diag_index.shape()),\n                  errors::InvalidArgument(\n                      \"diag_index must be a scalar or vector, received shape: \",\n                      diag_index.shape().DebugString()));\n      OP_REQUIRES(context, diag_index.NumElements() > 0,\n                  errors::InvalidArgument(\n                      \"Expected diag_index to have at least 1 element\"));\n      lower_diag_index = diag_index.flat<int32>()(0);\n      upper_diag_index = lower_diag_index;\n      if (TensorShapeUtils::IsVector(diag_index.shape())) {\n        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n      padding_value = context->input(2).flat<T>()(0);\n    }\n    const TensorShape& input_shape = input.shape();\n\n    // Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),\n                errors::InvalidArgument(\n                    \"input must be at least 2-dim, received shape: \",\n                    input.shape().DebugString()));\n\n    // Make sure lower_diag_index and upper_diag_index is valid.\n    const int rank = input_shape.dims();\n    const Eigen::Index num_rows = input_shape.dim_size(rank - 2);\n    const Eigen::Index num_cols = input_shape.dim_size(rank - 1);\n    OP_REQUIRES(  // Checks lower_diag_index == 0 for when matrix shape = 0.\n        context,\n        (-num_rows < lower_diag_index && lower_diag_index < num_cols) ||\n            lower_diag_index == 0,\n        errors::InvalidArgument(\n            \"lower_diag_index is out of bound: \", lower_diag_index,\n            \". It must be between \", -num_rows, \" and \", num_cols));\n    OP_REQUIRES(context,\n                (-num_rows < upper_diag_index && upper_diag_index < num_cols) ||\n                    upper_diag_index == 0,\n                errors::InvalidArgument(\n                    \"upper_diag_index is out of bound: \", upper_diag_index,\n                    \" It must be between \", -num_rows, \" and \", num_cols));\n    OP_REQUIRES(\n        context, lower_diag_index <= upper_diag_index,\n        errors::InvalidArgument(\n            \"lower_diag_index must not be larger than upper_diag_index: \",\n            lower_diag_index, \" > \", upper_diag_index));\n\n    TensorShape output_shape;\n    for (int i = 0; i < rank - 2; ++i) {\n      output_shape.AddDim(input_shape.dim_size(i));\n    }\n    const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;\n    if (num_diags > 1) output_shape.AddDim(num_diags);\n    const int32_t max_diag_len =\n        std::min(num_rows + std::min(upper_diag_index, 0),\n                 num_cols - std::max(lower_diag_index, 0));\n    output_shape.AddDim(max_diag_len);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_reshaped = output->flat<T>();\n    auto input_reshaped = input.flat_inner_dims<T, 3>();\n    functor::MatrixDiagPart<Device, T>::Compute(\n        context, context->eigen_device<Device>(), input_reshaped,\n        output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,\n        padding_value, left_align_superdiagonal_, left_align_subdiagonal_);\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37643"
    },
    {
        "index": 33,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_6String_4read_items(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_n_items, PyObject *__pyx_v_buf) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  __Pyx_RefNannySetupContext(\"read_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":30\n * \n *     def read_items(self, n_items, buf):\n *         return buf.read_strings(n_items, encoding=self.encoding)             # <<<<<<<<<<<<<<\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_read_strings); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 30, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(__pyx_v_n_items);\n  __Pyx_GIVEREF(__pyx_v_n_items);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_n_items);\n  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_encoding); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 30, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_encoding, __pyx_t_4) < 0) __PYX_ERR(0, 30, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 30, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_r = __pyx_t_4;\n  __pyx_t_4 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":29\n *         buf.write_strings(items, encoding=self.encoding)\n * \n *     def read_items(self, n_items, buf):             # <<<<<<<<<<<<<<\n *         return buf.read_strings(n_items, encoding=self.encoding)\n * \n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.String.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 34,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedwriter_5__pyx_unpickle_CompressedBufferedWriter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v___pyx_type = 0;\n  long __pyx_v___pyx_checksum;\n  PyObject *__pyx_v___pyx_state = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_CompressedBufferedWriter (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_CompressedBufferedWriter\", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_CompressedBufferedWriter\", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__pyx_unpickle_CompressedBufferedWriter\") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v___pyx_type = values[0];\n    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)\n    __pyx_v___pyx_state = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_CompressedBufferedWriter\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_CompressedBufferedWriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_4__pyx_unpickle_CompressedBufferedWriter(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 35,
        "code": "MONGO_EXPORT void gridfile_get_chunk( gridfile *gfile, int n, bson* out ) {\n    bson query;\n\n    bson_iterator it;\n    bson_oid_t id;\n    int result;\n\n    bson_init( &query );\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_append_oid( &query, \"files_id\", &id );\n    bson_append_int( &query, \"n\", n );\n    bson_finish( &query );\n\n    result = (mongo_find_one(gfile->gfs->client,\n                             gfile->gfs->chunks_ns,\n                             &query, NULL, out ) == MONGO_OK );\n    bson_destroy( &query );\n    if (!result) {\n        bson empty;\n        bson_empty(&empty);\n        bson_copy(out, &empty);\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 36,
        "code": "ldns_rr_new_frm_str_internal(ldns_rr **newrr, const char *str,\n\t\t\t\t\t\t\t uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t\t\t\t ldns_rdf **prev, bool question)\n{\n\tldns_rr *new;\n\tconst ldns_rr_descriptor *desc;\n\tldns_rr_type rr_type;\n\tldns_buffer *rr_buf = NULL;\n\tldns_buffer *rd_buf = NULL;\n\tuint32_t ttl_val;\n\tchar  *owner = NULL;\n\tchar  *ttl = NULL;\n\tldns_rr_class clas_val;\n\tchar  *clas = NULL;\n\tchar  *type = NULL;\n\tsize_t type_sz;\n\tchar  *rdata = NULL;\n\tchar  *rd = NULL;\n\tchar  *xtok = NULL; /* For RDF types with spaces (i.e. extra tokens) */\n\tsize_t rd_strlen;\n\tconst char *delimiters;\n\tssize_t c;\n\tldns_rdf *owner_dname;\n        const char* endptr;\n        int was_unknown_rr_format = 0;\n\tldns_status status = LDNS_STATUS_OK;\n\n\t/* used for types with unknown number of rdatas */\n\tbool done;\n\tbool quoted;\n\n\tldns_rdf *r = NULL;\n\tuint16_t r_cnt;\n\tuint16_t r_min;\n\tuint16_t r_max;\n        size_t pre_data_pos;\n\n\tuint16_t hex_data_size;\n\tchar *hex_data_str = NULL;\n\tuint16_t cur_hex_data_size;\n\tsize_t hex_pos = 0;\n\tuint8_t *hex_data = NULL;\n\n\tnew = ldns_rr_new();\n\n\towner = LDNS_XMALLOC(char, LDNS_MAX_DOMAINLEN + 1);\n\tttl = LDNS_XMALLOC(char, LDNS_TTL_DATALEN);\n\tclas = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\trdata = LDNS_XMALLOC(char, LDNS_MAX_PACKETLEN + 1);\n\trr_buf = LDNS_MALLOC(ldns_buffer);\n\trd_buf = LDNS_MALLOC(ldns_buffer);\n\trd = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\txtok = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\tif (rr_buf) {\n\t\trr_buf->_data = NULL;\n\t}\n\tif (rd_buf) {\n\t\trd_buf->_data = NULL;\n\t}\n\tif (!new || !owner || !ttl || !clas || !rdata ||\n\t\t\t!rr_buf || !rd_buf || !rd || !xtok) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(rr_buf, (char*)str, strlen(str));\n\n\t/* split the rr in its parts -1 signals trouble */\n\tif (ldns_bget_token(rr_buf, owner, \"\\t\\n \", LDNS_MAX_DOMAINLEN) == -1){\n\n\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(rr_buf, ttl, \"\\t\\n \", LDNS_TTL_DATALEN) == -1) {\n\n\t\tstatus = LDNS_STATUS_SYNTAX_TTL_ERR;\n\t\tgoto error;\n\t}\n\tttl_val = (uint32_t) ldns_str2period(ttl, &endptr);\n\n\tif (strlen(ttl) > 0 && !isdigit((int) ttl[0])) {\n\t\t/* ah, it's not there or something */\n\t\tif (default_ttl == 0) {\n\t\t\tttl_val = LDNS_DEFAULT_TTL;\n\t\t} else {\n\t\t\tttl_val = default_ttl;\n\t\t}\n\t\t/* we not ASSUMING the TTL is missing and that\n\t\t * the rest of the RR is still there. That is\n\t\t * CLASS TYPE RDATA\n\t\t * so ttl value we read is actually the class\n\t\t */\n\t\tclas_val = ldns_get_rr_class_by_name(ttl);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(ttl) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, ttl, type_sz);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, clas, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_CLASS_ERR;\n\t\t\tgoto error;\n\t\t}\n\t\tclas_val = ldns_get_rr_class_by_name(clas);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(clas) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, clas, type_sz);\n\t\t}\n\t}\n\t/* the rest should still be waiting for us */\n\n\tif (!type) {\n\t\ttype = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\t\tif (!type) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, type, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_TYPE_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(rr_buf, rdata, \"\\0\", LDNS_MAX_PACKETLEN) == -1) {\n\t\t/* apparently we are done, and it's only a question RR\n\t\t * so do not set status and go to ldnserror here\n\t\t */\n\t}\n\tldns_buffer_new_frm_data(rd_buf, rdata, strlen(rdata));\n\n\tif (strlen(owner) <= 1 && strncmp(owner, \"@\", 1) == 0) {\n\t\tif (origin) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t} else if (prev && *prev) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t} else {\n\t\t\t/* default to root */\n\t\t\tldns_rr_set_owner(new, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* @ also overrides prev */\n\t\tif (prev) {\n\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\tif (!*prev) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(owner) == 0) {\n\t\t\t/* no ownername was given, try prev, if that fails\n\t\t\t * origin, else default to root */\n\t\t\tif (prev && *prev) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t\t} else if (origin) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(new,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(new)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\towner_dname = ldns_dname_new_frm_str(owner);\n\t\t\tif (!owner_dname) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(new, owner_dname);\n\t\t\tif (!ldns_dname_str_absolute(owner) && origin) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(new), origin)\n\t\t\t\t\t\t!= LDNS_STATUS_OK) {\n\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev) {\n\t\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\t\tif (!*prev) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(owner);\n\n\tldns_rr_set_question(new, question);\n\n\tldns_rr_set_ttl(new, ttl_val);\n\tLDNS_FREE(ttl);\n\n\tldns_rr_set_class(new, clas_val);\n\tLDNS_FREE(clas);\n\n\trr_type = ldns_get_rr_type_by_name(type);\n\tLDNS_FREE(type);\n\n\tdesc = ldns_rr_descript((uint16_t)rr_type);\n\tldns_rr_set_type(new, rr_type);\n\tif (desc) {\n\t\t/* only the rdata remains */\n\t\tr_max = ldns_rr_descriptor_maximum(desc);\n\t\tr_min = ldns_rr_descriptor_minimum(desc);\n\t} else {\n\t\tr_min = 0;\n\t\tr_max = 1;\n\t}\n\n\tfor (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) {\n\t\tquoted = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\t\tcase LDNS_RDF_TYPE_B64        :\n\t\tcase LDNS_RDF_TYPE_HEX        : /* These rdf types may con- */\n\t\tcase LDNS_RDF_TYPE_LOC        : /* tain whitespace, only if */\n\t\tcase LDNS_RDF_TYPE_WKS        : /* it is the last rd field. */\n\t\tcase LDNS_RDF_TYPE_IPSECKEY   :\n\t\tcase LDNS_RDF_TYPE_AMTRELAY   :\n\t\tcase LDNS_RDF_TYPE_NSEC       :\tif (r_cnt == r_max - 1) {\n\t\t\t\t\t\t\tdelimiters = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fallthrough */\n\t\tdefault                       :\tdelimiters = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tdesc, r_cnt)) &&\n\t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n\n\t\t\t/* skip spaces */\n\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ') {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t}\n\n\t\t\tif (*(ldns_buffer_current(rd_buf)) == '\\\"') {\n\t\t\t\tdelimiters = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t\tquoted = true;\n\t\t\t} else if (ldns_rr_descriptor_field_type(desc, r_cnt)\n\t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* because number of fields can be variable, we can't rely on\n\t\t * _maximum() only\n\t\t */\n\n\t\t/* skip spaces */\n\t\twhile (ldns_buffer_position(rd_buf) < ldns_buffer_limit(rd_buf)\n\t\t\t\t&& *(ldns_buffer_current(rd_buf)) == ' '\n\t\t\t\t&& !quoted) {\n\n\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t}\n\n\t\tpre_data_pos = ldns_buffer_position(rd_buf);\n\t\tif (-1 == (c = ldns_bget_token(\n\t\t\t\trd_buf, rd, delimiters, LDNS_MAX_RDFLEN))) {\n\n\t\t\tdone = true;\n\t\t\t(void)done; /* we're breaking, so done not read anymore */\n\t\t\tbreak;\n\t\t}\n\t\t/* hmmz, rfc3597 specifies that any type can be represented \n\t\t * with \\# method, which can contain spaces...\n\t\t * it does specify size though...\n\t\t */\n\t\trd_strlen = strlen(rd);\n\n\t\t/* unknown RR data */\n\t\tif (strncmp(rd, \"\\\\#\", 2) == 0 && !quoted &&\n\t\t\t\t(rd_strlen == 2 || rd[2]==' ')) {\n\n\t\t\twas_unknown_rr_format = 1;\n\t\t\t/* go back to before \\#\n\t\t\t * and skip it while setting delimiters better\n\t\t\t */\n\t\t\tldns_buffer_set_position(rd_buf, pre_data_pos);\n\t\t\tdelimiters = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t/* read rdata octet length */\n\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\tif (c == -1) {\n\t\t\t\t/* something goes very wrong here */\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\thex_data_size = (uint16_t) atoi(rd);\n\t\t\t/* copy hex chars into hex str (2 chars per byte) */\n\t\t\thex_data_str = LDNS_XMALLOC(char, 2*hex_data_size + 1);\n\t\t\tif (!hex_data_str) {\n\t\t\t\t/* malloc error */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tcur_hex_data_size = 0;\n\t\t\twhile(cur_hex_data_size < 2 * hex_data_size) {\n\t\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t\tif (c == -1) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\trd_strlen = strlen(rd);\n\t\t\t\tif ((size_t)cur_hex_data_size + rd_strlen >\n\t\t\t\t    2 * (size_t)hex_data_size) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(hex_data_str + cur_hex_data_size, rd,\n\t\t\t\t\t\trd_strlen + 1);\n\n\t\t\t\tcur_hex_data_size += rd_strlen;\n\t\t\t}\n\t\t\thex_data_str[cur_hex_data_size] = '\\0';\n\n\t\t\t/* correct the rdf type */\n\t\t\t/* if *we* know the type, interpret it as wireformat */\n\t\t\tif (desc) {\n\t\t\t\thex_pos = 0;\n\t\t\t\thex_data =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, hex_data_size+2);\n\n\t\t\t\tif (!hex_data) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(hex_data, hex_data_size);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\thex_data + 2, hex_data_str);\n\t\t\t\tstatus = ldns_wire2rdf(new, hex_data,\n\t\t\t\t\t\thex_data_size + 2, &hex_pos);\n\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(hex_data);\n\t\t\t} else {\n\t\t\t\tr = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_HEX,\n\t\t\t\t\t\thex_data_str);\n\t\t\t\tif (!r) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(r, LDNS_RDF_TYPE_UNKNOWN);\n\t\t\t\tif (!ldns_rr_push_rdf(new, r)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(hex_data_str);\n\n\t\t} else if(rd_strlen > 0 || quoted) {\n\t\t\t/* Normal RR */\n\t\t\tswitch(ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\n\t\t\tcase LDNS_RDF_TYPE_HEX:\n\t\t\tcase LDNS_RDF_TYPE_B64:\n\t\t\t\t/* When this is the last rdata field, then the\n\t\t\t\t * rest should be read in (cause then these\n\t\t\t\t * rdf types may contain spaces).\n\t\t\t\t */\n\t\t\t\tif (r_cnt == r_max - 1) {\n\t\t\t\t\tc = ldns_bget_token(rd_buf, xtok,\n\t\t\t\t\t\t\t\"\\n\", LDNS_MAX_RDFLEN);\n\t\t\t\t\tif (c != -1) {\n\t\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_HIP:\n\t\t\t\t/*\n\t\t\t\t * In presentation format this RDATA type has\n\t\t\t\t * three tokens: An algorithm byte, then a\n\t\t\t\t * variable length HIT (in hexbytes) and then\n\t\t\t\t * a variable length Public Key (in base64).\n\t\t\t\t *\n\t\t\t\t * We have just read the algorithm, so we need\n\t\t\t\t * two more tokens: HIT and Public Key.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\t/* Read and append HIT */\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\n\t\t\t\t\t/* Read and append Public Key*/\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_DNAME:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\n\t\t\t\t/* check if the origin should be used\n\t\t\t\t * or concatenated\n\t\t\t\t */\n\t\t\t\tif (r && ldns_rdf_size(r) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(r);\n\n\t\t\t\t\tr = origin ? ldns_rdf_clone(origin)\n\n\t\t\t\t\t  : ( rr_type == LDNS_RR_TYPE_SOA ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(new))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    LDNS_RDF_TYPE_DNAME, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (r && rd_strlen >= 1 && origin &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(rd)) {\n\n\t\t\t\t\tstatus = ldns_dname_cat(r, origin);\n\t\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!r) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(new, r);\n\t\t}\n\t\tif (quoted) {\n\t\t\tif (ldns_buffer_available(rd_buf, 1)) {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t} else {\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\n\t} /* for (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) */\n\tLDNS_FREE(rd);\n\tLDNS_FREE(xtok);\n\tldns_buffer_free(rr_buf);\n\tLDNS_FREE(rdata);\n\tif (ldns_buffer_remaining(rd_buf) > 0) {\n\t\tldns_buffer_free(rd_buf);\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR;\n\t}\n\tldns_buffer_free(rd_buf);\n\n\tif (!question && desc && !was_unknown_rr_format &&\n\t\t\tldns_rr_rd_count(new) < r_min) {\n\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR;\n\t}\n\n\tif (newrr) {\n\t\t*newrr = new;\n\t} else {\n\t\t/* Maybe the caller just wanted to see if it would parse? */\n\t\tldns_rr_free(new);\n\t}\n\treturn LDNS_STATUS_OK;\n\nmemerror:\n\tstatus = LDNS_STATUS_MEM_ERR;\nerror:\n\tif (rd_buf && rd_buf->_data) {\n\t\tldns_buffer_free(rd_buf);\n\t} else {\n\t\tLDNS_FREE(rd_buf);\n\t}\n\tif (rr_buf && rr_buf->_data) {\n\t\tldns_buffer_free(rr_buf);\n\t} else {\n\t\tLDNS_FREE(rr_buf);\n\t}\n\tLDNS_FREE(type);\n\tLDNS_FREE(owner);\n\tLDNS_FREE(ttl);\n\tLDNS_FREE(clas);\n\tLDNS_FREE(hex_data);\n\tLDNS_FREE(hex_data_str);\n\tLDNS_FREE(xtok);\n\tLDNS_FREE(rd);\n\tLDNS_FREE(rdata);\n\tldns_rr_free(new);\n\treturn status;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-19860"
    },
    {
        "index": 37,
        "code": "TEST(SegmentSumOpModelTest, Float32Test_ThreeDimensions) {\n  SegmentSumOpModel<float> model({TensorType_FLOAT32, {3, 2, 1}},\n                                 {TensorType_INT32, {3}});\n  model.PopulateTensor<float>(model.data(), {1, 2, 3, 4, 5, 6});\n  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 0, 1});\n  model.Invoke();\n  EXPECT_THAT(model.GetOutput(), ElementsAreArray({4.0f, 6.0f, 5.0f, 6.0f}));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAreArray({2, 2, 1}));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15214"
    },
    {
        "index": 38,
        "code": " VideoCaptureManager::~VideoCaptureManager() {\n  DCHECK(controllers_.empty());\n   DCHECK(device_start_request_queue_.empty());\n   if (screenlock_monitor_) {\n     screenlock_monitor_->RemoveObserver(this);\n  }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 39,
        "code": "static void ito64(char *s, long v, int n) {\n  while (--n >= 0) {\n    *s++ = itoa64[v&0x3f];\n    v >>= 6;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 40,
        "code": "compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    semsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, line_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    compile_type = COMPILE_TYPE(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 41,
        "code": "Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 42,
        "code": "rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc)\n{\n  int bytesPerPixel;\n  size_t bytesPerRow, bytesMaskData;\n  rfbXCursorColors rgb;\n  uint32_t colors[2];\n  char *buf;\n  uint8_t *ptr;\n  int x, y, b;\n\n  bytesPerPixel = client->format.bitsPerPixel / 8;\n  bytesPerRow = (width + 7) / 8;\n  bytesMaskData = bytesPerRow * height;\n\n  if (width * height == 0)\n    return TRUE;\n\n  /* Allocate memory for pixel data and temporary mask data. */\n  if(client->rcSource)\n    free(client->rcSource);\n\n  client->rcSource = malloc(width * height * bytesPerPixel);\n  if (client->rcSource == NULL)\n    return FALSE;\n\n  buf = malloc(bytesMaskData);\n  if (buf == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    return FALSE;\n  }\n\n  /* Read and decode cursor pixel data, depending on the encoding type. */\n\n  if (enc == rfbEncodingXCursor) {\n    /* Read and convert background and foreground colors. */\n    if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n    colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);\n    colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);\n\n    /* Read 1bpp pixel data into a temporary buffer. */\n    if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n    /* Convert 1bpp data to byte-wide color indices. */\n    ptr = client->rcSource;\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width / 8; x++) {\n\tfor (b = 7; b >= 0; b--) {\n\t  *ptr = buf[y * bytesPerRow + x] >> b & 1;\n\t  ptr += bytesPerPixel;\n\t}\n      }\n      for (b = 7; b > 7 - width % 8; b--) {\n\t*ptr = buf[y * bytesPerRow + x] >> b & 1;\n\tptr += bytesPerPixel;\n      }\n    }\n\n    /* Convert indices into the actual pixel values. */\n    switch (bytesPerPixel) {\n    case 1:\n      for (x = 0; x < width * height; x++)\n\tclient->rcSource[x] = (uint8_t)colors[client->rcSource[x]];\n      break;\n    case 2:\n      for (x = 0; x < width * height; x++)\n\t((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];\n      break;\n    case 4:\n      for (x = 0; x < width * height; x++)\n\t((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];\n      break;\n    }\n\n  } else {\t\t\t/* enc == rfbEncodingRichCursor */\n\n    if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n  }\n\n  /* Read and decode mask data. */\n\n  if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  client->rcMask = malloc(width * height);\n  if (client->rcMask == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  ptr = client->rcMask;\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width / 8; x++) {\n      for (b = 7; b >= 0; b--) {\n\t*ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n      }\n    }\n    for (b = 7; b > 7 - width % 8; b--) {\n      *ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n    }\n  }\n\n  if (client->GotCursorShape != NULL) {\n     client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);\n  }\n\n  free(buf);\n\n  return TRUE;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-20788"
    },
    {
        "index": 43,
        "code": "sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tint rec;\n\t\tint offs = 0;\n\t\tint rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26570"
    },
    {
        "index": 44,
        "code": "TfLiteStatus ResizeOutput(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* top_k = GetInput(context, node, kInputTopK);\n  // INT32 number of top results is supported.\n  TF_LITE_ENSURE_TYPES_EQ(context, top_k->type, kTfLiteInt32);\n  // Check that the tensor contains only one value.\n  TF_LITE_ENSURE_EQ(context, NumElements(top_k), 1);\n  const int32 k = *GetTensorData<int32_t>(top_k);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const int num_dimensions = NumDimensions(input);\n  // Check that input has one or more dimensions.\n  TF_LITE_ENSURE_MSG(context, input->dims->size >= 1,\n                     \"TopK k input must have 1 or more dimensions.\");\n  // Check that k is less or equal the internal dimension.\n  TF_LITE_ENSURE_MSG(context, k <= input->dims->data[num_dimensions - 1],\n                     \"TopK k is higher than the internal dimension.\");\n\n  TfLiteIntArray* output_indexes_shape = TfLiteIntArrayCreate(num_dimensions);\n  TfLiteIntArray* output_values_shape = TfLiteIntArrayCreate(num_dimensions);\n  for (int i = 0; i < num_dimensions - 1; ++i) {\n    output_indexes_shape->data[i] = input->dims->data[i];\n    output_values_shape->data[i] = input->dims->data[i];\n  }\n  output_indexes_shape->data[num_dimensions - 1] = k;\n  output_values_shape->data[num_dimensions - 1] = k;\n  TfLiteTensor* output_indexes = GetOutput(context, node, kOutputIndexes);\n  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n  // Force output types.\n  output_indexes->type = kTfLiteInt32;\n  output_values->type = input->type;\n  auto resize_tensor = [context](TfLiteTensor* tensor, TfLiteIntArray* new_size,\n                                 TfLiteIntArray* delete_on_error) {\n    TfLiteStatus status = context->ResizeTensor(context, tensor, new_size);\n    if (status != kTfLiteOk) {\n      if (delete_on_error != nullptr) {\n        TfLiteIntArrayFree(delete_on_error);\n      }\n    }\n    return status;\n  };\n  TF_LITE_ENSURE_OK(context, resize_tensor(output_indexes, output_indexes_shape,\n                                           output_values_shape));\n  TF_LITE_ENSURE_OK(context,\n                    resize_tensor(output_values, output_values_shape, nullptr));\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 45,
        "code": "ALWAYS_INLINE String serialize_impl(const Variant& value,\n                                    const SerializeOptions& opts) {\n  switch (value.getType()) {\n    case KindOfClass:\n    case KindOfLazyClass:\n    case KindOfPersistentString:\n    case KindOfString: {\n      auto const str =\n        isStringType(value.getType()) ? value.getStringData() :\n        isClassType(value.getType()) ? classToStringHelper(value.toClassVal()) :\n        lazyClassToStringHelper(value.toLazyClassVal());\n      auto const size = str->size();\n      if (size >= RuntimeOption::MaxSerializedStringSize) {\n        throw Exception(\"Size of serialized string (%d) exceeds max\", size);\n      }\n      StringBuffer sb;\n      sb.append(\"s:\");\n      sb.append(size);\n      sb.append(\":\\\"\");\n      sb.append(str->data(), size);\n      sb.append(\"\\\";\");\n      return sb.detach();\n    }\n    case KindOfResource:\n      return s_Res;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfFunc:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfDouble:\n    case KindOfObject:\n    case KindOfClsMeth:\n    case KindOfRClsMeth:\n    case KindOfRFunc:\n    case KindOfRecord:\n      break;\n  }\n  VariableSerializer vs(VariableSerializer::Type::Serialize);\n  if (opts.keepDVArrays)        vs.keepDVArrays();\n  if (opts.forcePHPArrays)      vs.setForcePHPArrays();\n  if (opts.warnOnHackArrays)    vs.setHackWarn();\n  if (opts.warnOnPHPArrays)     vs.setPHPWarn();\n  if (opts.ignoreLateInit)      vs.setIgnoreLateInit();\n  if (opts.serializeProvenanceAndLegacy) vs.setSerializeProvenanceAndLegacy();\n  // Keep the count so recursive calls to serialize() embed references properly.\n  return vs.serialize(value, true, true);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 46,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_4flush(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"flush\", 0);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":91\n * \n *     def flush(self):\n *         self.write_into_stream()             # <<<<<<<<<<<<<<\n */\n  __pyx_t_1 = ((struct __pyx_vtabstruct_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.write_into_stream(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v_self), 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":90\n *         self.position = 0\n * \n *     def flush(self):             # <<<<<<<<<<<<<<\n *         self.write_into_stream()\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.flush\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 47,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_2write_items(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_items, PyObject *__pyx_v_buf) {\n  Py_ssize_t __pyx_v_buf_pos;\n  Py_ssize_t __pyx_v_length;\n  Py_ssize_t __pyx_v_items_buf_size;\n  char *__pyx_v_c_value;\n  char *__pyx_v_items_buf;\n  PyObject *__pyx_v_value = NULL;\n  Py_ssize_t __pyx_v_value_len;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  int __pyx_t_3;\n  PyObject *(*__pyx_t_4)(PyObject *);\n  PyObject *__pyx_t_5 = NULL;\n  Py_ssize_t __pyx_t_6;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  char *__pyx_t_9;\n  __Pyx_RefNannySetupContext(\"write_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":132\n * \n *     def write_items(self, items, buf):\n *         cdef Py_ssize_t buf_pos = 0             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t length = self.length\n *         cdef Py_ssize_t items_buf_size = length * len(items)\n */\n  __pyx_v_buf_pos = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":133\n *     def write_items(self, items, buf):\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t items_buf_size = length * len(items)\n * \n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 133, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_length = __pyx_t_2;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":134\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length\n *         cdef Py_ssize_t items_buf_size = length * len(items)             # <<<<<<<<<<<<<<\n * \n *         cdef char* c_value\n */\n  __pyx_t_2 = PyObject_Length(__pyx_v_items); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 134, __pyx_L1_error)\n  __pyx_v_items_buf_size = (__pyx_v_length * __pyx_t_2);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":137\n * \n *         cdef char* c_value\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)             # <<<<<<<<<<<<<<\n *         if not items_buf:\n *             raise MemoryError()\n */\n  __pyx_v_items_buf = ((char *)PyMem_Malloc(__pyx_v_items_buf_size));\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":138\n *         cdef char* c_value\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)\n *         if not items_buf:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n * \n */\n  __pyx_t_3 = ((!(__pyx_v_items_buf != 0)) != 0);\n  if (unlikely(__pyx_t_3)) {\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":139\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)\n *         if not items_buf:\n *             raise MemoryError()             # <<<<<<<<<<<<<<\n * \n *         memset(items_buf, 0, items_buf_size)\n */\n    PyErr_NoMemory(); __PYX_ERR(0, 139, __pyx_L1_error)\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":138\n *         cdef char* c_value\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)\n *         if not items_buf:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n * \n */\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":141\n *             raise MemoryError()\n * \n *         memset(items_buf, 0, items_buf_size)             # <<<<<<<<<<<<<<\n * \n *         for value in items:\n */\n  (void)(memset(__pyx_v_items_buf, 0, __pyx_v_items_buf_size));\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":143\n *         memset(items_buf, 0, items_buf_size)\n * \n *         for value in items:             # <<<<<<<<<<<<<<\n *             value_len = len(value)\n *             if length < value_len:\n */\n  if (likely(PyList_CheckExact(__pyx_v_items)) || PyTuple_CheckExact(__pyx_v_items)) {\n    __pyx_t_1 = __pyx_v_items; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;\n    __pyx_t_4 = NULL;\n  } else {\n    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 143, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __pyx_t_4 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 143, __pyx_L1_error)\n  }\n  for (;;) {\n    if (likely(!__pyx_t_4)) {\n      if (likely(PyList_CheckExact(__pyx_t_1))) {\n        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;\n        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS\n        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_5); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 143, __pyx_L1_error)\n        #else\n        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 143, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        #endif\n      } else {\n        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;\n        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS\n        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_5); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 143, __pyx_L1_error)\n        #else\n        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 143, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        #endif\n      }\n    } else {\n      __pyx_t_5 = __pyx_t_4(__pyx_t_1);\n      if (unlikely(!__pyx_t_5)) {\n        PyObject* exc_type = PyErr_Occurred();\n        if (exc_type) {\n          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();\n          else __PYX_ERR(0, 143, __pyx_L1_error)\n        }\n        break;\n      }\n      __Pyx_GOTREF(__pyx_t_5);\n    }\n    __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_5);\n    __pyx_t_5 = 0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":144\n * \n *         for value in items:\n *             value_len = len(value)             # <<<<<<<<<<<<<<\n *             if length < value_len:\n *                 raise errors.TooLargeStringSize()\n */\n    __pyx_t_6 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 144, __pyx_L1_error)\n    __pyx_v_value_len = __pyx_t_6;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":145\n *         for value in items:\n *             value_len = len(value)\n *             if length < value_len:             # <<<<<<<<<<<<<<\n *                 raise errors.TooLargeStringSize()\n * \n */\n    __pyx_t_3 = ((__pyx_v_length < __pyx_v_value_len) != 0);\n    if (unlikely(__pyx_t_3)) {\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":146\n *             value_len = len(value)\n *             if length < value_len:\n *                 raise errors.TooLargeStringSize()             # <<<<<<<<<<<<<<\n * \n *             c_value = PyBytes_AsString(value)\n */\n      __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_errors); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 146, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_7);\n      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_TooLargeStringSize); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 146, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_8);\n      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n      __pyx_t_7 = NULL;\n      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {\n        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);\n        if (likely(__pyx_t_7)) {\n          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);\n          __Pyx_INCREF(__pyx_t_7);\n          __Pyx_INCREF(function);\n          __Pyx_DECREF_SET(__pyx_t_8, function);\n        }\n      }\n      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_8);\n      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;\n      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 146, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n      __Pyx_Raise(__pyx_t_5, 0, 0, 0);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __PYX_ERR(0, 146, __pyx_L1_error)\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":145\n *         for value in items:\n *             value_len = len(value)\n *             if length < value_len:             # <<<<<<<<<<<<<<\n *                 raise errors.TooLargeStringSize()\n * \n */\n    }\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":148\n *                 raise errors.TooLargeStringSize()\n * \n *             c_value = PyBytes_AsString(value)             # <<<<<<<<<<<<<<\n * \n *             memcpy(&items_buf[buf_pos], c_value, value_len)\n */\n    __pyx_t_9 = PyBytes_AsString(__pyx_v_value); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(0, 148, __pyx_L1_error)\n    __pyx_v_c_value = __pyx_t_9;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":150\n *             c_value = PyBytes_AsString(value)\n * \n *             memcpy(&items_buf[buf_pos], c_value, value_len)             # <<<<<<<<<<<<<<\n *             buf_pos += length\n * \n */\n    (void)(memcpy((&(__pyx_v_items_buf[__pyx_v_buf_pos])), __pyx_v_c_value, __pyx_v_value_len));\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":151\n * \n *             memcpy(&items_buf[buf_pos], c_value, value_len)\n *             buf_pos += length             # <<<<<<<<<<<<<<\n * \n *         buf.write(PyBytes_FromStringAndSize(items_buf, items_buf_size))\n */\n    __pyx_v_buf_pos = (__pyx_v_buf_pos + __pyx_v_length);\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":143\n *         memset(items_buf, 0, items_buf_size)\n * \n *         for value in items:             # <<<<<<<<<<<<<<\n *             value_len = len(value)\n *             if length < value_len:\n */\n  }\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":153\n *             buf_pos += length\n * \n *         buf.write(PyBytes_FromStringAndSize(items_buf, items_buf_size))             # <<<<<<<<<<<<<<\n * \n *         PyMem_Free(items_buf)\n */\n  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_write); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 153, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_5);\n  __pyx_t_8 = PyBytes_FromStringAndSize(__pyx_v_items_buf, __pyx_v_items_buf_size); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 153, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_8);\n  __pyx_t_7 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {\n    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);\n    if (likely(__pyx_t_7)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);\n      __Pyx_INCREF(__pyx_t_7);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_5, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_8);\n  __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;\n  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":155\n *         buf.write(PyBytes_FromStringAndSize(items_buf, items_buf_size))\n * \n *         PyMem_Free(items_buf)             # <<<<<<<<<<<<<<\n * \n * \n */\n  PyMem_Free(__pyx_v_items_buf);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":131\n *         return items\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteFixedString.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_value);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 48,
        "code": "MONGO_EXPORT int bson_size( const bson *b ) {\n    int i;\n    if ( ! b || ! b->data )\n        return 0;\n    bson_little_endian32( &i, b->data );\n    return i;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 49,
        "code": "find_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t // end of the command (possibly including count)\n    int\t\t*full,\t // set to TRUE for a full match\n    expand_T\t*xp,\t // used for completion, NULL otherwise\n    int\t\t*complp) // completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t&curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 50,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* data = GetInput(context, node, kInputDataTensor);\n  const TfLiteTensor* segment_ids =\n      GetInput(context, node, kInputSegmentIdsTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context,\n                 data->type == kTfLiteInt32 || data->type == kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, segment_ids->type, kTfLiteInt32);\n\n  if (!IsConstantTensor(data) || !IsConstantTensor(segment_ids)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  return ResizeOutputTensor(context, data, segment_ids, output);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 51,
        "code": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 52,
        "code": "int64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n  }\n  m_cursor += length;\n  return length;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 53,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write_into_stream(CYTHON_UNUSED struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, int __pyx_skip_dispatch) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  __Pyx_RefNannySetupContext(\"write_into_stream\", 0);\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overridden in Python */\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {\n      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      #endif\n      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_write_into_stream); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_5write_into_stream)) {\n        __Pyx_XDECREF(__pyx_r);\n        __Pyx_INCREF(__pyx_t_1);\n        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;\n        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {\n          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n          if (likely(__pyx_t_4)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n            __Pyx_INCREF(__pyx_t_4);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_3, function);\n          }\n        }\n        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 25, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_2);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __pyx_r = __pyx_t_2;\n        __pyx_t_2 = 0;\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n        goto __pyx_L0;\n      }\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));\n      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {\n        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n      }\n      #endif\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    }\n    #endif\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":26\n * \n *     cpdef write_into_stream(self):\n *         raise NotImplementedError             # <<<<<<<<<<<<<<\n * \n *     cpdef write(self, data):\n */\n  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);\n  __PYX_ERR(0, 26, __pyx_L1_error)\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":25\n *         PyMem_Free(self.buffer)\n * \n *     cpdef write_into_stream(self):             # <<<<<<<<<<<<<<\n *         raise NotImplementedError\n * \n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.write_into_stream\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 54,
        "code": "static bool set_sockaddr(sockaddr_storage &sa_storage, req::ptr<Socket> sock,\n                         const String& addr, int port,\n                         struct sockaddr *&sa_ptr, size_t &sa_size) {\n  // Always zero it out:\n  // - fields are added over time; zeroing it out is future-proofing; for\n  //   example, sockaddr_in6 did not originally include sin6_scope_id or\n  //   sin6_flowinfo.\n  // - required for all on MacOS for correct behavior\n  // - on Linux, required for sockaddr_un to deal with buggy sun_path readers\n  //   (they should look at the length)\n  memset(&sa_storage, 0, sizeof(struct sockaddr_storage));\n  struct sockaddr *sock_type = (struct sockaddr*) &sa_storage;\n  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {\n        // Linux supports 3 kinds of unix sockets; behavior of this struct\n        // is in `man 7 unix`; relevant parts:\n        // - unnamed: 0-length path. As paths are not required to be\n        //   null-terminated, this needs to be undicated by the size.\n        //   These might be created by `socketpair()`, for eaxmple.\n        // - pathname (common): nothing strange. struct size technically\n        //   indicates length, but null terminators are usually set. This\n        //   does matter if addr.length() == size of the char array though\n        // - abstract: these have a meaningful name, but start with `\\0`\n        //\n        // Setting sa_size to indicate a 0-length path is required to\n        // distinguish between unnamed and abstract.\n        sa_size = offsetof(struct sockaddr_un, sun_path);\n      }\n#endif\n\n#endif // ifdef _MSC_VER\n    }\n    break;\n  case AF_INET:\n    {\n      struct sockaddr_in *sa = (struct sockaddr_in *)sock_type;\n      sa->sin_family = AF_INET;\n      sa->sin_port = htons((unsigned short) port);\n      if (!php_set_inet_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in);\n    }\n    break;\n  case AF_INET6:\n    {\n      struct sockaddr_in6 *sa = (struct sockaddr_in6 *)sock_type;\n      sa->sin6_family = AF_INET6;\n      sa->sin6_port = htons((unsigned short) port);\n      if (!php_set_inet6_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in6);\n    }\n    break;\n  default:\n    raise_warning(\"unsupported socket type '%d', must be \"\n                    \"AF_UNIX, AF_INET, or AF_INET6\", sock->getType());\n    return false;\n  }\n#ifdef __APPLE__\n  // This field is not in the relevant standards, not defined on Linux, but is\n  // technically required on MacOS (and other BSDs) according to the man pages:\n  // - `man 4 netintro` covers the base sa_len\n  // - `man 4 unix` and `man 4 inet6` cover AF_UNIX sun_len and AF_INET6\n  //    sin6_len\n  // - ... At least MacOS Catalina includes the wrong `man 4 inet`. Look at the\n  //   (Net|Free|Open)BSD `man 4 inet` instead.\n  //   The MacOS man page says it starts with `sin_family`, which would conflict\n  //   with the base sockaddr definition. `sin_len` is actually the first field\n  //   in the header file, matching `sa_len`.\n  sa_ptr->sa_len = sa_size;\n#endif\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 55,
        "code": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-44108"
    },
    {
        "index": 56,
        "code": "static Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[100];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    \n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 57,
        "code": "void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n\n  NDPI_LOG_DBG(ndpi_struct, \"search ORACLE\\n\");\n\n  if(packet->tcp != NULL) {\n    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculating ORACLE over tcp\\n\");\n    /* Oracle Database 9g,10g,11g */\n    if ((dport == 1521 || sport == 1521)\n\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))\n\t     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) \n\t     && (packet->payload[1] != 0x00)\n\t     && (packet->payload[2] == 0x00)\n\t\t && (packet->payload[3] == 0x00)))) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&\n               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&\n               packet->payload[3] == 0x00 ) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    }\n  } else {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15476"
    },
    {
        "index": 58,
        "code": "MONGO_EXPORT int bson_append_code_w_scope( bson *b, const char *name, const char *code, const bson *scope ) {\n    return bson_append_code_w_scope_n( b, name, code, strlen ( code ), scope );\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 59,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\\n                     GetTensorData<scalar>(input), GetTensorShape(output), \\\n                     GetTensorData<scalar>(output))\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, float);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, float);\n      }\n      break;\n    case kTfLiteUInt8:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, uint8_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, uint8_t);\n      }\n      break;\n    case kTfLiteInt8:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, int8_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int8_t);\n      }\n      break;\n    case kTfLiteInt32:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, int32_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int32_t);\n      }\n      break;\n    case kTfLiteInt64:\n      if (kernel_type == kReference) {\n        TF_LITE_SPACE_TO_DEPTH(reference_ops, int64_t);\n      } else {\n        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int64_t);\n      }\n      break;\n    default:\n      context->ReportError(context, \"Type '%s' not currently supported.\",\n                           TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n#undef TF_LITE_SPACE_TO_DEPTH\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 60,
        "code": "process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37750"
    },
    {
        "index": 61,
        "code": "   void OpenSession() {\n     const int render_process_id = 1;\n     const int render_frame_id = 1;\n     const int page_request_id = 1;\n     const url::Origin security_origin =\n         url::Origin::Create(GURL(\"http://test.com\"));\n\n    ASSERT_TRUE(opened_device_label_.empty());\n\n    MediaDeviceInfoArray video_devices;\n    {\n      base::RunLoop run_loop;\n      MediaDevicesManager::BoolDeviceTypes devices_to_enumerate;\n      devices_to_enumerate[MEDIA_DEVICE_TYPE_VIDEO_INPUT] = true;\n      media_stream_manager_->media_devices_manager()->EnumerateDevices(\n          devices_to_enumerate,\n          base::BindOnce(&VideoInputDevicesEnumerated, run_loop.QuitClosure(),\n                         browser_context_.GetMediaDeviceIDSalt(),\n                         security_origin, &video_devices));\n      run_loop.Run();\n    }\n    ASSERT_FALSE(video_devices.empty());\n\n     {\n       base::RunLoop run_loop;\n       media_stream_manager_->OpenDevice(\n          render_process_id, render_frame_id, page_request_id,\n           video_devices[0].device_id, MEDIA_DEVICE_VIDEO_CAPTURE,\n           MediaDeviceSaltAndOrigin{browser_context_.GetMediaDeviceIDSalt(),\n                                    browser_context_.GetMediaDeviceIDSalt(),\n                                   security_origin},\n          base::BindOnce(&VideoCaptureTest::OnDeviceOpened,\n                         base::Unretained(this), run_loop.QuitClosure()),\n          MediaStreamManager::DeviceStoppedCallback());\n      run_loop.Run();\n    }\n    ASSERT_NE(MediaStreamDevice::kNoId, opened_session_id_);\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 62,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_2write_into_stream(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"write_into_stream\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_write_into_stream(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.write_into_stream\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 63,
        "code": "TfLiteStatus Rfft2dHelper(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const float* input_data = GetTensorData<float>(input);\n  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  complex<float>* output_data = GetTensorData<complex<float>>(output);\n\n  int fft_height, fft_width;\n  fft_height = fft_length_data[0];\n  fft_width = fft_length_data[1];\n\n  // FFT is processed for every slice on the inner most 2 dimensions.\n  // Count the number of slices in the input tensor.\n  const RuntimeShape input_shape = GetTensorShape(input);\n  const int input_dims_count = input_shape.DimensionsCount();\n  const auto* input_dims_data = input_shape.DimsData();\n  int num_slices = 1;\n  for (int i = 0; i < input_dims_count - 2; ++i) {\n    num_slices *= input_dims_data[i];\n  }\n\n  int input_height = input_dims_data[input_dims_count - 2];\n  int input_width = input_dims_data[input_dims_count - 1];\n  int input_slice_size = input_height * input_width;\n  int output_slice_size = fft_height * (fft_width / 2 + 1);\n\n  // Create input/output buffer for FFT\n  double** fft_input_output = new double*[fft_height];\n  for (int i = 0; i < fft_height; ++i) {\n    fft_input_output[i] = new double[fft_width + 2];\n  }\n\n  // Get buffer for integer working area.\n  TfLiteTensor* fft_integer_working_area =\n      GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n  int* fft_integer_working_area_data =\n      GetTensorData<int>(fft_integer_working_area);\n\n  // Get buffer for double working area.\n  TfLiteTensor* fft_double_working_area =\n      GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n  // Get double value out of the memory of fft_double_working_area_data.\n  double* fft_double_working_area_data = reinterpret_cast<double*>(\n      GetTensorData<int64_t>(fft_double_working_area));\n\n  // Process every slice in the input buffer\n  for (int i = 0; i < num_slices; ++i) {\n    PrepareInputBuffer(input_data, input_height, input_width, fft_height,\n                       fft_width, fft_input_output);\n    memset(fft_integer_working_area_data, 0, fft_integer_working_area->bytes);\n    memset(fft_double_working_area_data, 0, fft_double_working_area->bytes);\n    Rfft2dImpl(fft_height, fft_width, fft_input_output,\n               fft_integer_working_area_data, fft_double_working_area_data);\n    PrepareOutputBuffer(output_data, fft_height, fft_width, fft_input_output);\n    input_data += input_slice_size;\n    output_data += output_slice_size;\n  }\n\n  // Delete the input buffer\n  for (int i = 0; i < fft_height; ++i) {\n    delete[] fft_input_output[i];\n  }\n  delete[] fft_input_output;\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 64,
        "code": "Mat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"inflateInit returned %s\",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"Uncompressed type not MAT_T_MATRIX\");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else\n                        len_pad = len + 8 - (len % 8);\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\"Couldn't determine file position\");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\"Compressed variable found in \\\"%s\\\", but matio was \"\n                         \"built without zlib support\",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else\n                    len_pad = len + 8 - (len % 8);\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\"%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-19497"
    },
    {
        "index": 65,
        "code": "mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4110"
    },
    {
        "index": 66,
        "code": "TfLiteStatus PrepareHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, output_tensor->type, kTfLiteInt64);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, output_tensor, outputSize);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 67,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_19current_buffer_size___get__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__get__\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->current_buffer_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.current_buffer_size.__get__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 68,
        "code": "static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 69,
        "code": "static void bson_append_byte( bson *b, char c ) {\n    b->cur[0] = c;\n    b->cur++;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 70,
        "code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  return tensor->is_variable ? tensor : nullptr;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37681"
    },
    {
        "index": 71,
        "code": "inline TfLiteIntArray* GetOutputShapeFromTensor(TfLiteContext* context,\n                                                TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(shape->dims->data[0]);\n  for (int i = 0; i < output_shape->size; ++i) {\n    output_shape->data[i] = shape->data.i32[i];\n  }\n\n  return output_shape;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 73,
        "code": "void EvalImpl(const TfLiteTensor* start, const TfLiteTensor* delta,\n              TfLiteTensor* output) {\n  const T start_value = *GetTensorData<T>(start);\n  const T delta_value = *GetTensorData<T>(delta);\n  T* output_data = GetTensorData<T>(output);\n  const int num_elements = NumElements(output);\n  T value = start_value;\n  for (int i = 0; i < num_elements; ++i) {\n    output_data[i] = value;\n    value += delta_value;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 74,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_10ByteString_1write_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  CYTHON_UNUSED PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_items = 0;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"write_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 1); __PYX_ERR(0, 37, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 2); __PYX_ERR(0, 37, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"write_items\") < 0)) __PYX_ERR(0, 37, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_items = values[1];\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 37, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteString.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_10ByteString_write_items(__pyx_self, __pyx_v_self, __pyx_v_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 75,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, NumInputs(node) == 1 || NumInputs(node) == 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Always postpone sizing string tensors, even if we could in principle\n  // calculate their shapes now. String tensors don't benefit from having their\n  // shapes precalculated because the actual memory can only be allocated after\n  // we know all the content.\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  if (output->type != kTfLiteString) {\n    if (NumInputs(node) == 1 ||\n        IsConstantTensor(GetInput(context, node, kShapeTensor))) {\n      TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n    } else {\n      SetTensorToDynamic(output);\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 76,
        "code": "static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-11939"
    },
    {
        "index": 77,
        "code": "TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context,\n                                                       OpData* op_data,\n                                                       TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n\n  const int32_t input_zero_point = -input->params.zero_point;\n  const int32_t output_state_zero_point = -output_state->params.zero_point;\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  lstm_eval::IntegerLstmParameter* integer_lstm_params =\n      &op_data->integer_lstm_param;\n\n  const TfLiteTensor* intermediate =\n      &context->tensors[node->intermediates->data[4]];\n  const auto* params =\n      static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params);\n  const int32_t hidden_zp = params->zero_point->data[0];\n\n  // Get bias and perform zero point calculation.\n  // When there is layer normalization, the gate bias does not apply to matmul\n  // directly:\n  //      y = ln(w * x + w * r + w * c) + b.\n  const bool is_layer_norm = op_data->use_layer_norm;\n\n  // Forget gate.\n  const TfLiteTensor* forget_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kForgetGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_forget_weights, forget_gate_bias,\n          &(integer_lstm_params->input_to_forget_effective_bias)));\n\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_forget_weights,\n          nullptr, &(integer_lstm_params->recurrent_to_forget_effective_bias)));\n\n  // Modulation gate.\n  const TfLiteTensor* cell_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kCellGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_cell_weights, cell_gate_bias,\n          &(integer_lstm_params->input_to_cell_effective_bias)));\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_cell_weights, nullptr,\n          &(integer_lstm_params->recurrent_to_cell_effective_bias)));\n\n  // Output gate.\n  const TfLiteTensor* output_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kOutputGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_output_weights, output_gate_bias,\n          &(integer_lstm_params->input_to_output_effective_bias)));\n\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_output_weights,\n          nullptr, &(integer_lstm_params->recurrent_to_output_effective_bias)));\n\n  // Input gate. The calculation is only meaningful for non-cifg case.\n  const TfLiteTensor* input_gate_bias =\n      is_layer_norm ? nullptr : GetInput(context, node, kInputGateBiasTensor);\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, input_zero_point, input_to_input_weights, input_gate_bias,\n          &(integer_lstm_params->input_to_input_effective_bias)));\n  TF_LITE_ENSURE_OK(\n      context,\n      PrecomputeZeroPointTimesWeightWithBias(\n          context, output_state_zero_point, recurrent_to_input_weights, nullptr,\n          &(integer_lstm_params->recurrent_to_input_effective_bias)));\n\n  // Projection bias. The calculation is only meaningful for with projection.\n  TF_LITE_ENSURE_OK(context,\n                    PrecomputeZeroPointTimesWeightWithBias(\n                        context, hidden_zp, projection_weights, projection_bias,\n                        &(integer_lstm_params->projection_effective_bias)));\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 78,
        "code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1444"
    },
    {
        "index": 79,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params =\n      reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* positions = GetInput(context, node, kInputPositions);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (positions->type == kTfLiteInt32) {\n    switch (input->type) {\n      case kTfLiteFloat32:\n        return Gather<float, int32_t>(*params, input, positions, output);\n      case kTfLiteUInt8:\n        return Gather<uint8_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt8:\n        return Gather<int8_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt16:\n        return Gather<int16_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt32:\n        return Gather<int32_t, int32_t>(*params, input, positions, output);\n      case kTfLiteInt64:\n        return Gather<int64_t, int32_t>(*params, input, positions, output);\n      case kTfLiteBool:\n        return Gather<bool, int32_t>(*params, input, positions, output);\n      case kTfLiteString:\n        return GatherStrings<int32_t>(context, input, positions, output);\n      default:\n        context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                             TfLiteTypeGetName(input->type));\n        return kTfLiteError;\n    }\n  }\n  if (positions->type == kTfLiteInt64) {\n    switch (input->type) {\n      case kTfLiteFloat32:\n        return Gather<float, int64_t>(*params, input, positions, output);\n      case kTfLiteUInt8:\n        return Gather<uint8_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt8:\n        return Gather<int8_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt16:\n        return Gather<int16_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt32:\n        return Gather<int32_t, int64_t>(*params, input, positions, output);\n      case kTfLiteInt64:\n        return Gather<int64_t, int64_t>(*params, input, positions, output);\n      case kTfLiteBool:\n        return Gather<bool, int64_t>(*params, input, positions, output);\n      case kTfLiteString:\n        return GatherStrings<int64_t>(context, input, positions, output);\n      default:\n        context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                             TfLiteTypeGetName(input->type));\n        return kTfLiteError;\n    }\n  }\n  context->ReportError(context,\n                       \"Positions of type '%s' are not supported by gather.\",\n                       TfLiteTypeGetName(positions->type));\n  return kTfLiteError;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 80,
        "code": "void LibRaw::identify_process_dng_fields()\n{\n\tif (!dng_version) return;\n\tint c;\n\t{\n\t\t/* copy DNG data from per-IFD field to color.dng */\n\t\tint iifd = find_ifd_by_offset(data_offset);\n\t\tint pifd = find_ifd_by_offset(thumb_offset);\n\n#define CFAROUND(value, filters)                                               \\\n  filters ? (filters >= 1000 ? ((value + 1) / 2) * 2 : ((value + 5) / 6) * 6)  \\\n          : value\n\n#define IFDCOLORINDEX(ifd, subset, bit)                                        \\\n  (tiff_ifd[ifd].dng_color[subset].parsedfields & bit)                         \\\n      ? ifd                                                                    \\\n      : ((tiff_ifd[0].dng_color[subset].parsedfields & bit) ? 0 : -1)\n\n#define IFDLEVELINDEX(ifd, bit)                                                \\\n  (tiff_ifd[ifd].dng_levels.parsedfields & bit)                                \\\n      ? ifd                                                                    \\\n      : ((tiff_ifd[0].dng_levels.parsedfields & bit) ? 0 : -1)\n\n#define COPYARR(to, from) memmove(&to, &from, sizeof(from))\n\n\t\tif (iifd < (int)tiff_nifds && iifd >= 0)\n\t\t{\n\t\t\tint sidx;\n\t\t\t// Per field, not per structure\n\t\t\tif (!(imgdata.params.raw_processing_options &\n\t\t\t\tLIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT))\n\t\t\t{\n\t\t\t\tint illidx[2], cmidx[2], calidx[2], abidx;\n\t\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tillidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_ILLUMINANT);\n\t\t\t\t\tcmidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_COLORMATRIX);\n\t\t\t\t\tcalidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_CALIBRATION);\n\t\t\t\t}\n\t\t\t\tabidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);\n\t\t\t\t// Data found, all in same ifd, illuminants are inited\n\t\t\t\tif (illidx[0] >= 0 && illidx[0] < (int)tiff_nifds &&\n\t\t\t\t\tillidx[0] == illidx[1] && illidx[0] == cmidx[0] &&\n\t\t\t\t\tillidx[0] == cmidx[1] &&\n\t\t\t\t\ttiff_ifd[illidx[0]].dng_color[0].illuminant > 0 &&\n\t\t\t\t\ttiff_ifd[illidx[0]].dng_color[1].illuminant > 0)\n\t\t\t\t{\n\t\t\t\t\tsidx = illidx[0]; // => selected IFD\n\t\t\t\t\tdouble cc[4][4], cm[4][3], cam_xyz[4][3];\n\t\t\t\t\t// CM -> Color Matrix\n\t\t\t\t\t// CC -> Camera calibration\n\t\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t\t\t\tcc[j][i] = i == j;\n\t\t\t\t\tint colidx = -1;\n\n\t\t\t\t\t// IS D65 here?\n\t\t\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tiff_ifd[sidx].dng_color[i].illuminant == LIBRAW_WBI_D65)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcolidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Other daylight-type ill\n\t\t\t\t\tif (colidx < 0)\n\t\t\t\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ill = tiff_ifd[sidx].dng_color[i].illuminant;\n\t\t\t\t\t\t\tif (ill == LIBRAW_WBI_Daylight || ill == LIBRAW_WBI_D55 ||\n\t\t\t\t\t\t\t\till == LIBRAW_WBI_D75 || ill == LIBRAW_WBI_D50 ||\n\t\t\t\t\t\t\t\till == LIBRAW_WBI_Flash)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tif (colidx >= 0) // Selected\n\t\t\t\t\t{\n\t\t\t\t\t\t// Init camera matrix from DNG\n\t\t\t\t\t\tFORCC for (int j = 0; j < 3; j++) cm[c][j] =\n\t\t\t\t\t\t\ttiff_ifd[sidx].dng_color[colidx].colormatrix[c][j];\n\n\t\t\t\t\t\tif (calidx[colidx] == sidx)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int i = 0; i < colors; i++)\n\t\t\t\t\t\t\t\tFORCC\n\t\t\t\t\t\t\t\tcc[i][c] = tiff_ifd[sidx].dng_color[colidx].calibration[i][c];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (abidx == sidx)\n\t\t\t\t\t\t\tfor (int i = 0; i < colors; i++)\n\t\t\t\t\t\t\t\tFORCC cc[i][c] *= tiff_ifd[sidx].dng_levels.analogbalance[i];\n\t\t\t\t\t\tint j;\n\t\t\t\t\t\tFORCC for (int i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0;\n\t\t\t\t\t\t\tj < colors; j++)\n\t\t\t\t\t\t\tcam_xyz[c][i] +=\n\t\t\t\t\t\t\tcc[c][j] * cm[j][i]; // add AsShotXY later * xyz[i];\n\t\t\t\t\t\tcam_xyz_coeff(cmatrix, cam_xyz);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool noFujiDNGCrop = makeIs(LIBRAW_CAMERAMAKER_Fujifilm)\n\t\t\t\t&& (!strcmp(normalized_model, \"S3Pro\")\n\t\t\t\t\t|| !strcmp(normalized_model, \"S5Pro\")\n\t\t\t\t\t|| !strcmp(normalized_model, \"S2Pro\"));\n\n\t\t\tif (!noFujiDNGCrop &&\n\t\t\t\t(imgdata.params.raw_processing_options &LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP))\n\t\t\t{\n\t\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPORIGIN);\n\t\t\t\tint sidx2 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPSIZE);\n\t\t\t\tif (sidx >= 0 && sidx == sidx2 &&\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.default_crop[3] > 0)\n\t\t\t\t{\n\t\t\t\t\tint lm = tiff_ifd[sidx].dng_levels.default_crop[0];\n\t\t\t\t\tint lmm = CFAROUND(lm, filters);\n\t\t\t\t\tint tm = tiff_ifd[sidx].dng_levels.default_crop[1];\n\t\t\t\t\tint tmm = CFAROUND(tm, filters);\n\t\t\t\t\tint ww = tiff_ifd[sidx].dng_levels.default_crop[2];\n\t\t\t\t\tint hh = tiff_ifd[sidx].dng_levels.default_crop[3];\n\t\t\t\t\tif (lmm > lm)\n\t\t\t\t\t\tww -= (lmm - lm);\n\t\t\t\t\tif (tmm > tm)\n\t\t\t\t\t\thh -= (tmm - tm);\n\t\t\t\t\tif (left_margin + lm + ww <= raw_width &&\n\t\t\t\t\t\ttop_margin + tm + hh <= raw_height)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft_margin += lmm;\n\t\t\t\t\t\ttop_margin += tmm;\n\t\t\t\t\t\twidth = ww;\n\t\t\t\t\t\theight = hh;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(imgdata.color.dng_color[0].parsedfields &\n\t\t\t\tLIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)\n\t\t\t{\n\t\t\t\tsidx = IFDCOLORINDEX(iifd, 0, LIBRAW_DNGFM_FORWARDMATRIX);\n\t\t\t\tif (sidx >= 0)\n\t\t\t\t\tCOPYARR(imgdata.color.dng_color[0].forwardmatrix,\n\t\t\t\t\t\ttiff_ifd[sidx].dng_color[0].forwardmatrix);\n\t\t\t}\n\t\t\tif (!(imgdata.color.dng_color[1].parsedfields &\n\t\t\t\tLIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)\n\t\t\t{\n\t\t\t\tsidx = IFDCOLORINDEX(iifd, 1, LIBRAW_DNGFM_FORWARDMATRIX);\n\t\t\t\tif (sidx >= 0)\n\t\t\t\t\tCOPYARR(imgdata.color.dng_color[1].forwardmatrix,\n\t\t\t\t\t\ttiff_ifd[sidx].dng_color[1].forwardmatrix);\n\t\t\t}\n\t\t\tfor (int ss = 0; ss < 2; ss++)\n\t\t\t{\n\t\t\t\tsidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_COLORMATRIX);\n\t\t\t\tif (sidx >= 0)\n\t\t\t\t\tCOPYARR(imgdata.color.dng_color[ss].colormatrix,\n\t\t\t\t\t\ttiff_ifd[sidx].dng_color[ss].colormatrix);\n\n\t\t\t\tsidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_CALIBRATION);\n\t\t\t\tif (sidx >= 0)\n\t\t\t\t\tCOPYARR(imgdata.color.dng_color[ss].calibration,\n\t\t\t\t\t\ttiff_ifd[sidx].dng_color[ss].calibration);\n\n\t\t\t\tsidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_ILLUMINANT);\n\t\t\t\tif (sidx >= 0)\n\t\t\t\t\timgdata.color.dng_color[ss].illuminant =\n\t\t\t\t\ttiff_ifd[sidx].dng_color[ss].illuminant;\n\t\t\t}\n\t\t\t// Levels\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);\n\t\t\tif (sidx >= 0)\n\t\t\t\tCOPYARR(imgdata.color.dng_levels.analogbalance,\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.analogbalance);\n\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BASELINEEXPOSURE);\n\t\t\tif (sidx >= 0)\n\t\t\t\timgdata.color.dng_levels.baseline_exposure =\n\t\t\t\ttiff_ifd[sidx].dng_levels.baseline_exposure;\n\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_WHITE);\n\t\t\tif (sidx >= 0 && tiff_ifd[sidx].dng_levels.dng_whitelevel[0])\n\t\t\t\tCOPYARR(imgdata.color.dng_levels.dng_whitelevel,\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_whitelevel);\n\t\t\telse if (tiff_ifd[iifd].sample_format <= 2 && tiff_ifd[iifd].bps > 0 && tiff_ifd[iifd].bps < 32)\n\t\t\t\tFORC4\n\t\t\t\timgdata.color.dng_levels.dng_whitelevel[c] = (1 << tiff_ifd[iifd].bps) - 1;\n\n\n\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ASSHOTNEUTRAL);\n\t\t\tif (sidx >= 0)\n\t\t\t{\n\t\t\t\tCOPYARR(imgdata.color.dng_levels.asshotneutral,\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.asshotneutral);\n\t\t\t\tif (imgdata.color.dng_levels.asshotneutral[0])\n\t\t\t\t{\n\t\t\t\t\tcam_mul[3] = 0;\n\t\t\t\t\tFORCC\n\t\t\t\t\t\tif (fabs(imgdata.color.dng_levels.asshotneutral[c]) > 0.0001)\n\t\t\t\t\t\t\tcam_mul[c] = 1 / imgdata.color.dng_levels.asshotneutral[c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BLACK);\n\t\t\tif (sidx >= 0)\n\t\t\t{\n\t\t\t\timgdata.color.dng_levels.dng_fblack =\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_fblack;\n\t\t\t\timgdata.color.dng_levels.dng_black =\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_black;\n\t\t\t\tCOPYARR(imgdata.color.dng_levels.dng_cblack,\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_cblack);\n\t\t\t\tCOPYARR(imgdata.color.dng_levels.dng_fcblack,\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_fcblack);\n\t\t\t}\n\n\n\t\t\tif (pifd >= 0)\n\t\t\t{\n\t\t\t\tsidx = IFDLEVELINDEX(pifd, LIBRAW_DNGFM_PREVIEWCS);\n\t\t\t\tif (sidx >= 0)\n\t\t\t\t\timgdata.color.dng_levels.preview_colorspace =\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.preview_colorspace;\n\t\t\t}\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_OPCODE2);\n\t\t\tif (sidx >= 0)\n\t\t\t\tmeta_offset = tiff_ifd[sidx].opcode2_offset;\n\n\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINTABLE);\n\t\t\tINT64 linoff = -1;\n\t\t\tint linlen = 0;\n\t\t\tif (sidx >= 0)\n\t\t\t{\n\t\t\t\tlinoff = tiff_ifd[sidx].lineartable_offset;\n\t\t\t\tlinlen = tiff_ifd[sidx].lineartable_len;\n\t\t\t}\n\n\t\t\tif (linoff >= 0 && linlen > 0)\n\t\t\t{\n\t\t\t\tINT64 pos = ftell(ifp);\n\t\t\t\tfseek(ifp, linoff, SEEK_SET);\n\t\t\t\tlinear_table(linlen);\n\t\t\t\tfseek(ifp, pos, SEEK_SET);\n\t\t\t}\n\t\t\t// Need to add curve too\n\t\t}\n\t\t/* Copy DNG black level to LibRaw's */\n\t\tif (load_raw == &LibRaw::lossy_dng_load_raw)\n\t\t{\n\t\t\tmaximum = 0xffff;\n\t\t\tFORC4 imgdata.color.linear_max[c] = imgdata.color.dng_levels.dng_whitelevel[c] = 0xffff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaximum = imgdata.color.dng_levels.dng_whitelevel[0];\n\t\t}\n\t\tblack = imgdata.color.dng_levels.dng_black;\n\n\t\tif (tiff_samples == 2 && imgdata.color.dng_levels.dng_cblack[4] * imgdata.color.dng_levels.dng_cblack[5] * tiff_samples\n\t\t\t== imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1])\n\t\t{\n\t\t\tunsigned ff = filters;\n\t\t\tif (filters > 999 && colors == 3)\n\t\t\t\tfilters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) &\n\t\t\t\tfilters << 1;\n\n\t\t\t/* Special case, Fuji SuperCCD dng */\n\t\t\tint csum[4] = { 0,0,0,0 }, ccount[4] = { 0,0,0,0 };\n\t\t\tint i = 6 + shot_select;\n\t\t\tfor (unsigned row = 0; row < imgdata.color.dng_levels.dng_cblack[4]; row++)\n\t\t\t\tfor (unsigned col = 0; col < imgdata.color.dng_levels.dng_cblack[5]; col++)\n\t\t\t\t{\n\t\t\t\t\tcsum[FC(row, col)] += imgdata.color.dng_levels.dng_cblack[i];\n\t\t\t\t\tccount[FC(row, col)]++;\n\t\t\t\t\ti += tiff_samples;\n\t\t\t\t}\n\t\t\tfor (int c = 0; c < 4; c++)\n\t\t\t\tif (ccount[c])\n\t\t\t\t\timgdata.color.dng_levels.dng_cblack[c] += csum[c] / ccount[c];\n\t\t\timgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;\n\t\t\tfilters = ff;\n\t\t}\n\t\telse if (tiff_samples > 2 && tiff_samples <= 4 && imgdata.color.dng_levels.dng_cblack[4] * imgdata.color.dng_levels.dng_cblack[5] * tiff_samples\n\t\t\t== imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1])\n\t\t{\n\t\t\t/* Special case, per_channel blacks in RepeatDim, average for per-channel */\n\t\t\tint csum[4] = { 0,0,0,0 }, ccount[4] = { 0,0,0,0 };\n\t\t\tint i = 6;\n\t\t\tfor (unsigned row = 0; row < imgdata.color.dng_levels.dng_cblack[4]; row++)\n\t\t\t\tfor (unsigned col = 0; col < imgdata.color.dng_levels.dng_cblack[5]; col++)\n\t\t\t\t\tfor (unsigned c = 0; c < tiff_samples; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcsum[c] += imgdata.color.dng_levels.dng_cblack[i];\n\t\t\t\t\t\tccount[c]++;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\tfor (int c = 0; c < 4; c++)\n\t\t\t\tif (ccount[c])\n\t\t\t\t\timgdata.color.dng_levels.dng_cblack[c] += csum[c] / ccount[c];\n\t\t\timgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;\n\t\t}\n\n\t\tmemmove(cblack, imgdata.color.dng_levels.dng_cblack, sizeof(cblack));\n\n\t\tif (iifd < (int)tiff_nifds && iifd >= 0)\n\t\t{\n\t\t\tint sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINEARRESPONSELIMIT);\n\t\t\tif (sidx >= 0)\n\t\t\t{\n\t\t\t\timgdata.color.dng_levels.LinearResponseLimit =\n\t\t\t\t\ttiff_ifd[sidx].dng_levels.LinearResponseLimit;\n\t\t\t\tif (imgdata.color.dng_levels.LinearResponseLimit > 0.1 &&\n\t\t\t\t\timgdata.color.dng_levels.LinearResponseLimit <= 1.0)\n\t\t\t\t{\n\t\t\t\t\t// And approx promote it to linear_max:\n\t\t\t\t\tint bl4 = 0, bl64 = 0;\n\t\t\t\t\tfor (int chan = 0; chan < colors && chan < 4; chan++)\n\t\t\t\t\t\tbl4 += cblack[chan];\n\t\t\t\t\tbl4 /= LIM(colors, 1, 4);\n\n\t\t\t\t\tif (cblack[4] * cblack[5] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned cnt = 0;\n\t\t\t\t\t\tfor (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbl64 += cblack[c + 6];\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbl64 /= LIM(cnt, 1, 4096);\n\t\t\t\t\t}\n\t\t\t\t\tint rblack = black + bl4 + bl64;\n\t\t\t\t\tfor (int chan = 0; chan < colors && chan < 4; chan++)\n\t\t\t\t\t\timgdata.color.linear_max[chan] =\n\t\t\t\t\t\t(maximum - rblack) *\n\t\t\t\t\t\timgdata.color.dng_levels.LinearResponseLimit +\n\t\t\t\t\t\trblack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-24870"
    },
    {
        "index": 81,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteFullyConnectedParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* bias =\n      (node->inputs->size == 3)\n          ? GetOptionalInputTensor(context, node, kBiasTensor)\n          : nullptr;\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (filter->type) {\n    case kTfLiteFloat32:\n      return EvalFloat<kernel_type>(context, node, params, data, input, filter,\n                                    bias, output);\n    case kTfLiteUInt8:\n      if (params->weights_format ==\n          kTfLiteFullyConnectedWeightsFormatShuffled4x16Int8) {\n        TfLiteTensor* shuffled_input_workspace =\n            GetOutput(context, node, kShuffledInputWorkspaceTensor);\n        return EvalShuffledQuantized<kernel_type>(context, node, params, data,\n                                                  input, filter, bias, output,\n                                                  shuffled_input_workspace);\n      } else if (params->weights_format ==\n                 kTfLiteFullyConnectedWeightsFormatDefault) {\n        return EvalQuantized<kernel_type>(context, node, params, data, input,\n                                          filter, bias, output);\n      } else {\n        context->ReportError(context,\n                             \"Unhandled fully-connected weights format\");\n        return kTfLiteError;\n      }\n    case kTfLiteInt8:\n      if (params->weights_format == kTfLiteFullyConnectedWeightsFormatDefault) {\n        return EvalQuantized<kernel_type>(context, node, params, data, input,\n                                          filter, bias, output);\n      } else {\n        context->ReportError(context,\n                             \"Unhandled fully-connected weights format\");\n        return kTfLiteError;\n      }\n    default:\n      context->ReportError(context,\n                           \"Filter data type %s currently not supported.\",\n                           TfLiteTypeGetName(filter->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 82,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_create_string_column(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_spec, PyObject *__pyx_v_column_options) {\n  PyObject *__pyx_v_client_settings = NULL;\n  PyObject *__pyx_v_strings_as_bytes = NULL;\n  PyObject *__pyx_v_encoding = NULL;\n  PyObject *__pyx_v_cls = NULL;\n  PyObject *__pyx_v_length = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  PyObject *__pyx_t_6 = NULL;\n  int __pyx_t_7;\n  __Pyx_RefNannySetupContext(\"create_string_column\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":159\n * \n * def create_string_column(spec, column_options):\n *     client_settings = column_options['context'].client_settings             # <<<<<<<<<<<<<<\n *     strings_as_bytes = client_settings['strings_as_bytes']\n *     encoding = client_settings.get('strings_encoding', String.default_encoding)\n */\n  __pyx_t_1 = __Pyx_PyObject_Dict_GetItem(__pyx_v_column_options, __pyx_n_u_context); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_client_settings); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 159, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_client_settings = __pyx_t_2;\n  __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":160\n * def create_string_column(spec, column_options):\n *     client_settings = column_options['context'].client_settings\n *     strings_as_bytes = client_settings['strings_as_bytes']             # <<<<<<<<<<<<<<\n *     encoding = client_settings.get('strings_encoding', String.default_encoding)\n * \n */\n  __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_v_client_settings, __pyx_n_u_strings_as_bytes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 160, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_v_strings_as_bytes = __pyx_t_2;\n  __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":161\n *     client_settings = column_options['context'].client_settings\n *     strings_as_bytes = client_settings['strings_as_bytes']\n *     encoding = client_settings.get('strings_encoding', String.default_encoding)             # <<<<<<<<<<<<<<\n * \n *     if spec == 'String':\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_client_settings, __pyx_n_s_get); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_String); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 161, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_default_encoding); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 161, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  __pyx_t_5 = 0;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_1, function);\n      __pyx_t_5 = 1;\n    }\n  }\n  #if CYTHON_FAST_PYCALL\n  if (PyFunction_Check(__pyx_t_1)) {\n    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_n_u_strings_encoding, __pyx_t_4};\n    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  } else\n  #endif\n  #if CYTHON_FAST_PYCCALL\n  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {\n    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_n_u_strings_encoding, __pyx_t_4};\n    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  } else\n  #endif\n  {\n    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 161, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    if (__pyx_t_3) {\n      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;\n    }\n    __Pyx_INCREF(__pyx_n_u_strings_encoding);\n    __Pyx_GIVEREF(__pyx_n_u_strings_encoding);\n    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_n_u_strings_encoding);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_4);\n    __pyx_t_4 = 0;\n    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n  }\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_encoding = __pyx_t_2;\n  __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":163\n *     encoding = client_settings.get('strings_encoding', String.default_encoding)\n * \n *     if spec == 'String':             # <<<<<<<<<<<<<<\n *         cls = ByteString if strings_as_bytes else String\n *         return cls(encoding=encoding, **column_options)\n */\n  __pyx_t_7 = (__Pyx_PyUnicode_Equals(__pyx_v_spec, __pyx_n_u_String, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 163, __pyx_L1_error)\n  if (__pyx_t_7) {\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":164\n * \n *     if spec == 'String':\n *         cls = ByteString if strings_as_bytes else String             # <<<<<<<<<<<<<<\n *         return cls(encoding=encoding, **column_options)\n *     else:\n */\n    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_strings_as_bytes); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 164, __pyx_L1_error)\n    if (__pyx_t_7) {\n      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ByteString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      __pyx_t_2 = __pyx_t_1;\n      __pyx_t_1 = 0;\n    } else {\n      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_String); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      __pyx_t_2 = __pyx_t_1;\n      __pyx_t_1 = 0;\n    }\n    __pyx_v_cls = __pyx_t_2;\n    __pyx_t_2 = 0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":165\n *     if spec == 'String':\n *         cls = ByteString if strings_as_bytes else String\n *         return cls(encoding=encoding, **column_options)             # <<<<<<<<<<<<<<\n *     else:\n *         length = int(spec[12:-1])\n */\n    __Pyx_XDECREF(__pyx_r);\n    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_encoding, __pyx_v_encoding) < 0) __PYX_ERR(0, 165, __pyx_L1_error)\n    __pyx_t_2 = __pyx_t_1;\n    __pyx_t_1 = 0;\n    if (unlikely(__pyx_v_column_options == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"argument after ** must be a mapping, not NoneType\");\n      __PYX_ERR(0, 165, __pyx_L1_error)\n    }\n    if (__Pyx_MergeKeywords(__pyx_t_2, __pyx_v_column_options) < 0) __PYX_ERR(0, 165, __pyx_L1_error)\n    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_v_cls, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_r = __pyx_t_1;\n    __pyx_t_1 = 0;\n    goto __pyx_L0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":163\n *     encoding = client_settings.get('strings_encoding', String.default_encoding)\n * \n *     if spec == 'String':             # <<<<<<<<<<<<<<\n *         cls = ByteString if strings_as_bytes else String\n *         return cls(encoding=encoding, **column_options)\n */\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":167\n *         return cls(encoding=encoding, **column_options)\n *     else:\n *         length = int(spec[12:-1])             # <<<<<<<<<<<<<<\n *         cls = ByteFixedString if strings_as_bytes else FixedString\n *         return cls(length, encoding=encoding, **column_options)\n */\n  /*else*/ {\n    __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_spec, 12, -1L, NULL, NULL, &__pyx_slice_, 1, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 167, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 167, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_length = __pyx_t_2;\n    __pyx_t_2 = 0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":168\n *     else:\n *         length = int(spec[12:-1])\n *         cls = ByteFixedString if strings_as_bytes else FixedString             # <<<<<<<<<<<<<<\n *         return cls(length, encoding=encoding, **column_options)\n */\n    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_strings_as_bytes); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 168, __pyx_L1_error)\n    if (__pyx_t_7) {\n      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ByteFixedString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      __pyx_t_2 = __pyx_t_1;\n      __pyx_t_1 = 0;\n    } else {\n      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_FixedString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      __pyx_t_2 = __pyx_t_1;\n      __pyx_t_1 = 0;\n    }\n    __pyx_v_cls = __pyx_t_2;\n    __pyx_t_2 = 0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":169\n *         length = int(spec[12:-1])\n *         cls = ByteFixedString if strings_as_bytes else FixedString\n *         return cls(length, encoding=encoding, **column_options)             # <<<<<<<<<<<<<<\n */\n    __Pyx_XDECREF(__pyx_r);\n    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 169, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_v_length);\n    __Pyx_GIVEREF(__pyx_v_length);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_length);\n    __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 169, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_encoding, __pyx_v_encoding) < 0) __PYX_ERR(0, 169, __pyx_L1_error)\n    __pyx_t_1 = __pyx_t_6;\n    __pyx_t_6 = 0;\n    if (unlikely(__pyx_v_column_options == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"argument after ** must be a mapping, not NoneType\");\n      __PYX_ERR(0, 169, __pyx_L1_error)\n    }\n    if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_column_options) < 0) __PYX_ERR(0, 169, __pyx_L1_error)\n    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_v_cls, __pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 169, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_r = __pyx_t_6;\n    __pyx_t_6 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":158\n * \n * \n * def create_string_column(spec, column_options):             # <<<<<<<<<<<<<<\n *     client_settings = column_options['context'].client_settings\n *     strings_as_bytes = client_settings['strings_as_bytes']\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.create_string_column\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_client_settings);\n  __Pyx_XDECREF(__pyx_v_strings_as_bytes);\n  __Pyx_XDECREF(__pyx_v_encoding);\n  __Pyx_XDECREF(__pyx_v_cls);\n  __Pyx_XDECREF(__pyx_v_length);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 83,
        "code": "TfLiteStatus PopulateQuantizedLstmParams8x8_16(\n    TfLiteContext* context, TfLiteNode* node,\n    lstm_eval::IntegerLstmParameter* integer_lstm_param) {\n  // Calculate quantized clip for projection and cell.\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n  const float cell_clip = params->cell_clip;\n  const float proj_clip = params->proj_clip;\n\n  const TfLiteTensor* cell_state =\n      GetVariableInput(context, node, kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n  const TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n\n  auto* cell_state_params =\n      static_cast<TfLiteAffineQuantization*>(cell_state->quantization.params);\n  auto* proj_params = static_cast<TfLiteAffineQuantization*>(\n      output_tensor->quantization.params);\n  if (cell_clip > 0.0) {\n    integer_lstm_param->quantized_cell_clip = static_cast<int16_t>(std::min(\n        std::max(cell_clip / cell_state_params->scale->data[0], -32768.0f),\n        32767.0f));\n  } else {\n    integer_lstm_param->quantized_cell_clip = 0;\n  }\n  if (proj_clip > 0.0) {\n    integer_lstm_param->quantized_proj_clip = static_cast<int8_t>(std::min(\n        std::max(proj_clip / proj_params->scale->data[0], -128.0f), 127.0f));\n  } else {\n    integer_lstm_param->quantized_proj_clip = 0;\n  }\n\n  // Calculate effective scales.\n  OpData* op_data = static_cast<OpData*>(node->user_data);\n  const bool use_layer_norm = op_data->use_layer_norm;\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kInputLayerNormCoefficientsTensor);\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kForgetLayerNormCoefficientsTensor);\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kCellLayerNormCoefficientsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n\n  // Since we have already checked that weights are all there or none, we can\n  // check the existence of only one to get the condition.\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  const bool use_peephole = (cell_to_output_weights != nullptr);\n  const bool use_projection = (projection_weights != nullptr);\n\n  // Get intermediate scales and zero points.\n  std::vector<float> intermediate_scale;\n  std::vector<int32> intermediate_zp;\n  for (int i = 0; i < 4; ++i) {\n    if (use_layer_norm) {\n      const TfLiteTensor* intermediate = GetIntermediates(context, node, i);\n      auto* params = static_cast<TfLiteAffineQuantization*>(\n          intermediate->quantization.params);\n      intermediate_scale.push_back(params->scale->data[0]);\n      intermediate_zp.push_back(params->zero_point->data[0]);\n    } else {\n      // Q3.12 for activation functions.\n      intermediate_scale.push_back(std::pow(2, -12));\n      intermediate_zp.push_back(0);\n    }\n  }\n  // In the absense of projection, hidden becomes otuput and this intermediate\n  // is ignored.\n  const TfLiteTensor* hidden = GetIntermediates(context, node, 4);\n  auto* hidden_params =\n      static_cast<TfLiteAffineQuantization*>(hidden->quantization.params);\n  intermediate_scale.push_back(hidden_params->scale->data[0]);\n  intermediate_zp.push_back(hidden_params->zero_point->data[0]);\n\n  // Scales.\n  const float default_scale = 1.0;\n  float input_scale = default_scale;\n  float input_to_input_weight_scale = default_scale;\n  float recurrent_to_input_weight_scale = default_scale;\n  float cell_to_input_weight_scale = default_scale;\n  float input_to_forget_weight_scale = default_scale;\n  float recurrent_to_forget_weight_scale = default_scale;\n  float cell_to_forget_weight_scale = default_scale;\n  float input_to_cell_weight_scale = default_scale;\n  float recurrent_to_cell_weight_scale = default_scale;\n  float input_to_output_weight_scale = default_scale;\n  float recurrent_to_output_weight_scale = default_scale;\n  float cell_to_output_weight_scale = default_scale;\n  float projection_weight_scale = default_scale;\n  float layer_norm_input_scale = default_scale;\n  float layer_norm_forget_scale = default_scale;\n  float layer_norm_cell_scale = default_scale;\n  float layer_norm_output_scale = default_scale;\n  float output_state_scale = default_scale;\n  int cell_scale = 1;\n\n  // Effective scales.\n  float effective_input_to_input_scale = default_scale;\n  float effective_recurrent_to_input_scale = default_scale;\n  float effective_cell_to_input_scale = default_scale;\n  float effective_input_to_forget_scale = default_scale;\n  float effective_recurrent_to_forget_scale = default_scale;\n  float effective_cell_to_forget_scale = default_scale;\n  float effective_input_to_cell_scale = default_scale;\n  float effective_recurrent_to_cell_scale = default_scale;\n  float effective_input_to_output_scale = default_scale;\n  float effective_recurrent_to_output_scale = default_scale;\n  float effective_cell_to_output_scale = default_scale;\n  float effective_proj_scale = default_scale;\n  float effective_hidden_scale = default_scale;\n\n  // Populate scales.\n  if (!use_cifg) {\n    input_to_input_weight_scale = input_to_input_weights->params.scale;\n    recurrent_to_input_weight_scale = recurrent_to_input_weights->params.scale;\n  }\n\n  if (use_peephole) {\n    if (!use_cifg) {\n      cell_to_input_weight_scale = cell_to_input_weights->params.scale;\n    }\n    cell_to_forget_weight_scale = cell_to_forget_weights->params.scale;\n    cell_to_output_weight_scale = cell_to_output_weights->params.scale;\n  }\n\n  if (use_layer_norm) {\n    if (!use_cifg) {\n      layer_norm_input_scale = input_layer_norm_coefficients->params.scale;\n    }\n    layer_norm_forget_scale = forget_layer_norm_coefficients->params.scale;\n    layer_norm_cell_scale = cell_layer_norm_coefficients->params.scale;\n    layer_norm_output_scale = output_layer_norm_coefficients->params.scale;\n  }\n\n  if (use_projection) {\n    projection_weight_scale = projection_weights->params.scale;\n  }\n  output_state_scale = output_state->params.scale;\n\n  input_to_forget_weight_scale = input_to_forget_weights->params.scale;\n  input_to_cell_weight_scale = input_to_cell_weights->params.scale;\n  input_to_output_weight_scale = input_to_output_weights->params.scale;\n  recurrent_to_forget_weight_scale = recurrent_to_forget_weights->params.scale;\n  recurrent_to_cell_weight_scale = recurrent_to_cell_weights->params.scale;\n  recurrent_to_output_weight_scale = recurrent_to_output_weights->params.scale;\n\n  // Check cell state (already used above)\n  TF_LITE_ENSURE(context, CheckedLog2(cell_state->params.scale, &cell_scale));\n  TF_LITE_ENSURE(context, cell_scale <= -9);\n  integer_lstm_param->cell_scale = cell_scale;\n  input_scale = input->params.scale;\n\n  // Calculate effective scales.\n  if (!use_cifg) {\n    effective_input_to_input_scale =\n        input_to_input_weight_scale * input_scale / intermediate_scale[0];\n    effective_recurrent_to_input_scale = recurrent_to_input_weight_scale *\n                                         output_state_scale /\n                                         intermediate_scale[0];\n  }\n  effective_input_to_forget_scale =\n      input_to_forget_weight_scale * input_scale / intermediate_scale[1];\n  effective_recurrent_to_forget_scale = recurrent_to_forget_weight_scale *\n                                        output_state_scale /\n                                        intermediate_scale[1];\n\n  effective_input_to_cell_scale =\n      input_to_cell_weight_scale * input_scale / intermediate_scale[2];\n  effective_recurrent_to_cell_scale = recurrent_to_cell_weight_scale *\n                                      output_state_scale /\n                                      intermediate_scale[2];\n\n  effective_input_to_output_scale =\n      input_to_output_weight_scale * input_scale / intermediate_scale[3];\n  effective_recurrent_to_output_scale = recurrent_to_output_weight_scale *\n                                        output_state_scale /\n                                        intermediate_scale[3];\n\n  effective_hidden_scale =\n      std::pow(2, -15) / intermediate_scale[4] * std::pow(2, -15);\n\n  effective_proj_scale =\n      projection_weight_scale * intermediate_scale[4] / output_state_scale;\n\n  if (use_peephole) {\n    if (!use_cifg) {\n      effective_cell_to_input_scale = std::pow(2, cell_scale) *  // NOLINT\n                                      cell_to_input_weight_scale /\n                                      intermediate_scale[0];\n    }\n    effective_cell_to_forget_scale = std::pow(2, cell_scale) *  // NOLINT\n                                     cell_to_forget_weight_scale /\n                                     intermediate_scale[1];\n    effective_cell_to_output_scale = std::pow(2, cell_scale) *  // NOLINT\n                                     cell_to_output_weight_scale /\n                                     intermediate_scale[3];\n  }\n\n  // Decompose scales.\n  QuantizeMultiplier(effective_input_to_input_scale,\n                     &integer_lstm_param->effective_input_to_input_scale_a,\n                     &integer_lstm_param->effective_input_to_input_scale_b);\n  QuantizeMultiplier(effective_recurrent_to_input_scale,\n                     &integer_lstm_param->effective_recurrent_to_input_scale_a,\n                     &integer_lstm_param->effective_recurrent_to_input_scale_b);\n  QuantizeMultiplier(effective_cell_to_input_scale,\n                     &integer_lstm_param->effective_cell_to_input_scale_a,\n                     &integer_lstm_param->effective_cell_to_input_scale_b);\n  QuantizeMultiplier(effective_input_to_forget_scale,\n                     &integer_lstm_param->effective_input_to_forget_scale_a,\n                     &integer_lstm_param->effective_input_to_forget_scale_b);\n  QuantizeMultiplier(\n      effective_recurrent_to_forget_scale,\n      &integer_lstm_param->effective_recurrent_to_forget_scale_a,\n      &integer_lstm_param->effective_recurrent_to_forget_scale_b);\n  QuantizeMultiplier(effective_cell_to_forget_scale,\n                     &integer_lstm_param->effective_cell_to_forget_scale_a,\n                     &integer_lstm_param->effective_cell_to_forget_scale_b);\n  QuantizeMultiplier(effective_input_to_cell_scale,\n                     &integer_lstm_param->effective_input_to_cell_scale_a,\n                     &integer_lstm_param->effective_input_to_cell_scale_b);\n  QuantizeMultiplier(effective_recurrent_to_cell_scale,\n                     &integer_lstm_param->effective_recurrent_to_cell_scale_a,\n                     &integer_lstm_param->effective_recurrent_to_cell_scale_b);\n  QuantizeMultiplier(effective_input_to_output_scale,\n                     &integer_lstm_param->effective_input_to_output_scale_a,\n                     &integer_lstm_param->effective_input_to_output_scale_b);\n  QuantizeMultiplier(\n      effective_recurrent_to_output_scale,\n      &integer_lstm_param->effective_recurrent_to_output_scale_a,\n      &integer_lstm_param->effective_recurrent_to_output_scale_b);\n  QuantizeMultiplier(effective_cell_to_output_scale,\n                     &integer_lstm_param->effective_cell_to_output_scale_a,\n                     &integer_lstm_param->effective_cell_to_output_scale_b);\n  QuantizeMultiplier(effective_proj_scale,\n                     &integer_lstm_param->effective_proj_scale_a,\n                     &integer_lstm_param->effective_proj_scale_b);\n  QuantizeMultiplier(effective_hidden_scale,\n                     &integer_lstm_param->effective_hidden_scale_a,\n                     &integer_lstm_param->effective_hidden_scale_b);\n  QuantizeMultiplier(layer_norm_input_scale,\n                     &integer_lstm_param->layer_norm_input_scale_a,\n                     &integer_lstm_param->layer_norm_input_scale_b);\n  QuantizeMultiplier(layer_norm_forget_scale,\n                     &integer_lstm_param->layer_norm_forget_scale_a,\n                     &integer_lstm_param->layer_norm_forget_scale_b);\n  QuantizeMultiplier(layer_norm_cell_scale,\n                     &integer_lstm_param->layer_norm_cell_scale_a,\n                     &integer_lstm_param->layer_norm_cell_scale_b);\n  QuantizeMultiplier(layer_norm_output_scale,\n                     &integer_lstm_param->layer_norm_output_scale_a,\n                     &integer_lstm_param->layer_norm_output_scale_b);\n\n  integer_lstm_param->hidden_zp = intermediate_zp[4];\n\n  // 10000 is used to make sure the kernel logic does not overflow.\n  if (!use_cifg) {\n    integer_lstm_param->input_variance_guard =\n        std::max(1, static_cast<int32_t>(10000 * layer_norm_input_scale));\n  }\n  integer_lstm_param->forget_variance_guard =\n      std::max(1, static_cast<int32_t>(10000 * layer_norm_forget_scale));\n  integer_lstm_param->cell_variance_guard =\n      std::max(1, static_cast<int32_t>(10000 * layer_norm_cell_scale));\n  integer_lstm_param->output_variance_guard =\n      std::max(1, static_cast<int32_t>(10000 * layer_norm_output_scale));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 84,
        "code": "static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-14147"
    },
    {
        "index": 85,
        "code": "static void __pyx_tp_dealloc_17clickhouse_driver_14bufferedwriter_BufferedWriter(PyObject *o) {\n  #if CYTHON_USE_TP_FINALIZE\n  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {\n    if (PyObject_CallFinalizerFromDealloc(o)) return;\n  }\n  #endif\n  {\n    PyObject *etype, *eval, *etb;\n    PyErr_Fetch(&etype, &eval, &etb);\n    ++Py_REFCNT(o);\n    __pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_3__dealloc__(o);\n    --Py_REFCNT(o);\n    PyErr_Restore(etype, eval, etb);\n  }\n  (*Py_TYPE(o)->tp_free)(o);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 86,
        "code": "static int __pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  Py_ssize_t __pyx_v_bufsize;\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_bufsize,0};\n    PyObject* values[1] = {0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bufsize)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 12, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n    }\n    __pyx_v_bufsize = __Pyx_PyIndex_AsSsize_t(values[0]); if (unlikely((__pyx_v_bufsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 12, __pyx_L3_error)\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter___init__(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v_self), __pyx_v_bufsize);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 87,
        "code": "void do_change_user(int afdt_fd) {\n  std::string uname;\n  lwp_read(afdt_fd, uname);\n  if (!uname.length()) return;\n\n  auto buf = PasswdBuffer{};\n  struct passwd *pw;\n  if (getpwnam_r(uname.c_str(), &buf.ent, buf.data.get(), buf.size, &pw)) {\n    // TODO(alexeyt) should we log something and/or fail to start?\n    return;\n  }\n  if (!pw) {\n    // TODO(alexeyt) should we log something and/or fail to start?\n    return;\n  }\n\n  if (pw->pw_gid) {\n    initgroups(pw->pw_name, pw->pw_gid);\n    setgid(pw->pw_gid);\n  }\n  if (pw->pw_uid) {\n    setuid(pw->pw_uid);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 88,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_1create_string_column(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_spec = 0;\n  PyObject *__pyx_v_column_options = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"create_string_column (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_spec,&__pyx_n_s_column_options,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_spec)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_column_options)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"create_string_column\", 1, 2, 2, 1); __PYX_ERR(0, 158, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"create_string_column\") < 0)) __PYX_ERR(0, 158, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_spec = values[0];\n    __pyx_v_column_options = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"create_string_column\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 158, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.create_string_column\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_create_string_column(__pyx_self, __pyx_v_spec, __pyx_v_column_options);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 89,
        "code": "codegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (!s2) {/* super at top-level */\n          push();      /* no need to push block */\n        }\n        else {\n          gen_blkmove(s, s2->ainfo, lv);\n        }\n        st++;\n      }\n      else {\n        if (!s2) push();\n        else gen_blkmove(s, s2->ainfo, lv);\n        st++;\n      }\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0632"
    },
    {
        "index": 91,
        "code": "jsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    //printf(\"HEE: %d = %s\\n\", pss->wid, Jsi_DSValue(dStr) );\n    return i;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 92,
        "code": "static pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &error);\n\tbool flag = (code & FLAG_REF);\n\tRListIter *ref_idx = NULL;\n\tut8 type = (code & ~FLAG_REF);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tpyc_object *noneret = get_none_object ();\n\t\tif (noneret) {\n\t\t\tref_idx = r_list_append (refs, noneret);\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Get not implemented for type 0x%x\\n\", type);\n\t\tr_list_pop (refs);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in get_object (0x%x)\\n\", type);\n\t\t// r_list_pop (refs);\n\t\treturn NULL;\n\t}\n\n\tif (ret && flag && ref_idx) {\n\t\tif (ref_idx->data != ret) {\n\t\t\tfree_object (ref_idx->data);\n\t\t}\n\t\tref_idx->data = copy_object (ret);\n\t}\n\tif (ret) {\n\t\treturn ret;\n\t}\n\tret = get_none_object ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tr_list_append (refs, ret);\n\treturn ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0520"
    },
    {
        "index": 93,
        "code": "static int __Pyx_modinit_function_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_import_code\", 0);\n  /*--- Function import code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 94,
        "code": "PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad Elf64_Dyn[%d].d_tag %#lx\", -1+ ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);\n        if ((u64_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad DT_STRSZ %#x\", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-20805"
    },
    {
        "index": 95,
        "code": "TfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n\n  return reg;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 96,
        "code": "const char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); /* TODO: windows home dir. */\n#else\n        \n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 97,
        "code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  if (update) return -1;\n  return len;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0326"
    },
    {
        "index": 98,
        "code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1734"
    },
    {
        "index": 99,
        "code": "void pcre_init() {\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 100,
        "code": "static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 101,
        "code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-23931"
    },
    {
        "index": 102,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter___init__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v_self, PyObject *__pyx_v_compressor, PyObject *__pyx_v_bufsize) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":81\n * \n *     def __init__(self, compressor, bufsize):\n *         self.compressor = compressor             # <<<<<<<<<<<<<<\n *         super(CompressedBufferedWriter, self).__init__(bufsize)\n * \n */\n  __Pyx_INCREF(__pyx_v_compressor);\n  __Pyx_GIVEREF(__pyx_v_compressor);\n  __Pyx_GOTREF(__pyx_v_self->compressor);\n  __Pyx_DECREF(__pyx_v_self->compressor);\n  __pyx_v_self->compressor = __pyx_v_compressor;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":82\n *     def __init__(self, compressor, bufsize):\n *         self.compressor = compressor\n *         super(CompressedBufferedWriter, self).__init__(bufsize)             # <<<<<<<<<<<<<<\n * \n *     cpdef write_into_stream(self):\n */\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 82, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter));\n  __Pyx_GIVEREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter));\n  __Pyx_INCREF(((PyObject *)__pyx_v_self));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_self));\n  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 82, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 82, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_bufsize) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_bufsize);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":80\n *     cdef object compressor\n * \n *     def __init__(self, compressor, bufsize):             # <<<<<<<<<<<<<<\n *         self.compressor = compressor\n *         super(CompressedBufferedWriter, self).__init__(bufsize)\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 103,
        "code": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tstruct bpf_insn mask_and_div[] = {\n\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_JMP_IMM(BPF_JNE, insn->src_reg, 0, 2),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn mask_and_mod[] = {\n\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_JMP_IMM(BPF_JEQ, insn->src_reg, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn *patchlet;\n\n\t\t\tif (insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\t\tpatchlet = mask_and_div + (is64 ? 1 : 0);\n\t\t\t\tcnt = ARRAY_SIZE(mask_and_div) - (is64 ? 1 : 0);\n\t\t\t} else {\n\t\t\t\tpatchlet = mask_and_mod + (is64 ? 1 : 0);\n\t\t\t\tcnt = ARRAY_SIZE(mask_and_mod) - (is64 ? 1 : 0);\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tenv->prog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tenv->prog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 104,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedreader_1__pyx_unpickle_BufferedReader(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v___pyx_type = 0;\n  long __pyx_v___pyx_checksum;\n  PyObject *__pyx_v___pyx_state = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedReader (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedReader\", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedReader\", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__pyx_unpickle_BufferedReader\") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v___pyx_type = values[0];\n    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)\n    __pyx_v___pyx_state = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedReader\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedReader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 105,
        "code": "static int exif_scan_thumbnail(image_info_type *ImageInfo) {\n  unsigned char c, *data = (unsigned char*)ImageInfo->Thumbnail.data;\n  int n, marker;\n  size_t length=2, pos=0;\n  jpeg_sof_info sof_info;\n\n  if (!data || ImageInfo->Thumbnail.size < 4) {\n    return 0; /* nothing to do here */\n  }\n  if (memcmp(data, \"\\xFF\\xD8\\xFF\", 3)) {\n    if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {\n      raise_warning(\"Thumbnail is not a JPEG image\");\n    }\n    return 0;\n  }\n  for (;;) {\n    pos += length;\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    c = data[pos++];\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    if (c != 0xFF) {\n      return 0;\n    }\n    n = 8;\n    while ((c = data[pos++]) == 0xFF && n--) {\n      if (pos+3>=ImageInfo->Thumbnail.size)\n        return 0;\n      /* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n    }\n    if (c == 0xFF)\n      return 0;\n    marker = c;\n    length = php_jpg_get16(data+pos);\n    if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {\n      return 0;\n    }\n    switch (marker) {\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        /* handle SOFn block */\n        if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {\n          /* exif_process_SOFn needs 8 bytes */\n          return 0;\n        }\n        exif_process_SOFn(data+pos, marker, &sof_info);\n        ImageInfo->Thumbnail.height   = sof_info.height;\n        ImageInfo->Thumbnail.width    = sof_info.width;\n        return 1;\n\n      case M_SOS:\n      case M_EOI:\n        raise_warning(\"Could not compute size of thumbnail\");\n        return 0;\n        break;\n\n      default:\n        /* just skip */\n        break;\n    }\n  }\n\n  raise_warning(\"Could not compute size of thumbnail\");\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 106,
        "code": "MONGO_EXPORT int bson_append_undefined( bson *b, const char *name ) {\n    if ( bson_append_estart( b, BSON_UNDEFINED, name, 0 ) == BSON_ERROR )\n        return BSON_ERROR;\n    return BSON_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 107,
        "code": "get_user_var_name(expand_T *xp, int idx)\n{\n    static long_u\tgdone;\n    static long_u\tbdone;\n    static long_u\twdone;\n    static long_u\ttdone;\n    static int\t\tvidx;\n    static hashitem_T\t*hi;\n    hashtab_T\t\t*ht;\n\n    if (idx == 0)\n    {\n\tgdone = bdone = wdone = vidx = 0;\n\ttdone = 0;\n    }\n\n    // Global variables\n    if (gdone < globvarht.ht_used)\n    {\n\tif (gdone++ == 0)\n\t    hi = globvarht.ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tif (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)\n\t    return cat_prefix_varname('g', hi->hi_key);\n\treturn hi->hi_key;\n    }\n\n    // b: variables\n    ht =\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab :\n#endif\n\t&curbuf->b_vars->dv_hashtab;\n    if (bdone < ht->ht_used)\n    {\n\tif (bdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('b', hi->hi_key);\n    }\n\n    // w: variables\n    ht =\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative window should be used.\n\tis_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :\n#endif\n\t&curwin->w_vars->dv_hashtab;\n    if (wdone < ht->ht_used)\n    {\n\tif (wdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('w', hi->hi_key);\n    }\n\n    // t: variables\n    ht = &curtab->tp_vars->dv_hashtab;\n    if (tdone < ht->ht_used)\n    {\n\tif (tdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('t', hi->hi_key);\n    }\n\n    // v: variables\n    if (vidx < VV_LEN)\n\treturn cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);\n\n    VIM_CLEAR(varnamebuf);\n    varnamebuflen = 0;\n    return NULL;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 108,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_skip_dispatch) {\n  Py_ssize_t __pyx_v_written;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_data_len;\n  char *__pyx_v_c_data;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  Py_ssize_t __pyx_t_5;\n  char *__pyx_t_6;\n  int __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  __Pyx_RefNannySetupContext(\"write\", 0);\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overridden in Python */\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {\n      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      #endif\n      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_write); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_7write)) {\n        __Pyx_XDECREF(__pyx_r);\n        __Pyx_INCREF(__pyx_t_1);\n        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;\n        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {\n          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n          if (likely(__pyx_t_4)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n            __Pyx_INCREF(__pyx_t_4);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_3, function);\n          }\n        }\n        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_data);\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_2);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __pyx_r = __pyx_t_2;\n        __pyx_t_2 = 0;\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n        goto __pyx_L0;\n      }\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));\n      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {\n        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n      }\n      #endif\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    }\n    #endif\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":29\n * \n *     cpdef write(self, data):\n *         cdef Py_ssize_t written = 0             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t to_write, size\n *         cdef Py_ssize_t data_len = len(data)\n */\n  __pyx_v_written = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":31\n *         cdef Py_ssize_t written = 0\n *         cdef Py_ssize_t to_write, size\n *         cdef Py_ssize_t data_len = len(data)             # <<<<<<<<<<<<<<\n *         cdef char* c_data\n * \n */\n  __pyx_t_5 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 31, __pyx_L1_error)\n  __pyx_v_data_len = __pyx_t_5;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":34\n *         cdef char* c_data\n * \n *         c_data = PyBytes_AsString(data)             # <<<<<<<<<<<<<<\n * \n *         while written < data_len:\n */\n  __pyx_t_6 = PyBytes_AsString(__pyx_v_data); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(0, 34, __pyx_L1_error)\n  __pyx_v_c_data = __pyx_t_6;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":36\n *         c_data = PyBytes_AsString(data)\n * \n *         while written < data_len:             # <<<<<<<<<<<<<<\n *             size = min(data_len - written, self.buffer_size - self.position)\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n */\n  while (1) {\n    __pyx_t_7 = ((__pyx_v_written < __pyx_v_data_len) != 0);\n    if (!__pyx_t_7) break;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":37\n * \n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)             # <<<<<<<<<<<<<<\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n */\n    __pyx_t_5 = (__pyx_v_self->buffer_size - __pyx_v_self->position);\n    __pyx_t_8 = (__pyx_v_data_len - __pyx_v_written);\n    if (((__pyx_t_5 < __pyx_t_8) != 0)) {\n      __pyx_t_9 = __pyx_t_5;\n    } else {\n      __pyx_t_9 = __pyx_t_8;\n    }\n    __pyx_v_size = __pyx_t_9;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":38\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)\n *             memcpy(&self.buffer[self.position], &c_data[written], size)             # <<<<<<<<<<<<<<\n * \n *             if self.position == self.buffer_size:\n */\n    (void)(memcpy((&(__pyx_v_self->buffer[__pyx_v_self->position])), (&(__pyx_v_c_data[__pyx_v_written])), __pyx_v_size));\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":40\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n *             if self.position == self.buffer_size:             # <<<<<<<<<<<<<<\n *                 self.write_into_stream()\n * \n */\n    __pyx_t_7 = ((__pyx_v_self->position == __pyx_v_self->buffer_size) != 0);\n    if (__pyx_t_7) {\n\n      /* \"clickhouse_driver/bufferedwriter.pyx\":41\n * \n *             if self.position == self.buffer_size:\n *                 self.write_into_stream()             # <<<<<<<<<<<<<<\n * \n *             self.position += size\n */\n      __pyx_t_1 = ((struct __pyx_vtabstruct_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v_self->__pyx_vtab)->write_into_stream(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 41, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n      /* \"clickhouse_driver/bufferedwriter.pyx\":40\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n *             if self.position == self.buffer_size:             # <<<<<<<<<<<<<<\n *                 self.write_into_stream()\n * \n */\n    }\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":43\n *                 self.write_into_stream()\n * \n *             self.position += size             # <<<<<<<<<<<<<<\n *             written += size\n * \n */\n    __pyx_v_self->position = (__pyx_v_self->position + __pyx_v_size);\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":44\n * \n *             self.position += size\n *             written += size             # <<<<<<<<<<<<<<\n * \n *     def flush(self):\n */\n    __pyx_v_written = (__pyx_v_written + __pyx_v_size);\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":28\n *         raise NotImplementedError\n * \n *     cpdef write(self, data):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t written = 0\n *         cdef Py_ssize_t to_write, size\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.write\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 109,
        "code": "mrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4110"
    },
    {
        "index": 110,
        "code": "static int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n\n        mm = mongo_message_create( 16 /*header*/\n                                   +4 /*ZERO*/\n                                   +sl\n                                   +4 /*numToReturn*/\n                                   +8 /*cursorID*/\n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n\n        return MONGO_OK;\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 111,
        "code": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_.emplace(id, std::move(operation));\n   return id;\n }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5788"
    },
    {
        "index": 112,
        "code": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 113,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* cond_tensor =\n      GetInput(context, node, kInputConditionTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (cond_tensor->type != kTfLiteBool) {\n    context->ReportError(context,\n                         \"Condition tensor must be of type bool, but saw '%s'.\",\n                         TfLiteTypeGetName(cond_tensor->type));\n    return kTfLiteError;\n  }\n\n  // As output will be a 2D tensor of indices, use int64 to be consistent with\n  // tensorflow.\n  output->type = kTfLiteInt64;\n\n  // Exit early if cond is a non-const tensor. Set output tensor to dynamic so\n  // output size can be determined in Eval.\n  if (!IsConstantTensor(cond_tensor)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n  return ResizeOutputTensor(context, cond_tensor, output);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 114,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedWriter(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_v___pyx_PickleError = 0;\n  PyObject *__pyx_v___pyx_result = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedWriter\", 0);\n\n  /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x25d1d0c:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)\n */\n  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x25d1d0c) != 0);\n  if (__pyx_t_1) {\n\n    /* \"(tree fragment)\":5\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x25d1d0c:\n *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedWriter.__new__(__pyx_type)\n */\n    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_n_s_PickleError);\n    __Pyx_GIVEREF(__pyx_n_s_PickleError);\n    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);\n    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_t_2);\n    __pyx_v___pyx_PickleError = __pyx_t_2;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":6\n *     if __pyx_checksum != 0x25d1d0c:\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)             # <<<<<<<<<<<<<<\n *     __pyx_result = BufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:\n */\n    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x25, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_INCREF(__pyx_v___pyx_PickleError);\n    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_5)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_5);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);\n    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_Raise(__pyx_t_3, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __PYX_ERR(1, 6, __pyx_L1_error)\n\n    /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x25d1d0c:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)\n */\n  }\n\n  /* \"(tree fragment)\":7\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedWriter.__new__(__pyx_type)             # <<<<<<<<<<<<<<\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedWriter), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v___pyx_result = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);\n  __pyx_t_6 = (__pyx_t_1 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":9\n *     __pyx_result = BufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):\n */\n    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)\n    __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedWriter__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x25d1d0c = (buffer, buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  }\n\n  /* \"(tree fragment)\":10\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result             # <<<<<<<<<<<<<<\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v___pyx_result);\n  __pyx_r = __pyx_v___pyx_result;\n  goto __pyx_L0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedWriter(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedWriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v___pyx_PickleError);\n  __Pyx_XDECREF(__pyx_v___pyx_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 115,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteIntArray* input_dims = input->dims;\n  int input_dims_size = input_dims->size;\n  TF_LITE_ENSURE(context, input_dims_size >= 1);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  // Resize the output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(input_dims_size + 1);\n  for (int i = 0; i < input_dims_size; i++) {\n    output_shape->data[i] = input_dims->data[i];\n  }\n  // Last dimension in the output is the same as the last dimension in the\n  // input.\n  output_shape->data[input_dims_size] = input_dims->data[input_dims_size - 1];\n  output->type = input->type;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_shape));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 116,
        "code": "jsi_wscallback_websock(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len)\n{\n    struct lws_context *context = lws_get_context(wsi);\n\n    jsi_wsPss *pss = NULL;\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj *)lws_context_user(context);\n    if (!cmdPtr) {\n        fprintf(stderr, \"null ws context\\n\");\n        return -1;\n    }\n    Jsi_Interp *interp = cmdPtr->interp;\n    char *inPtr = (char*)in;\n    int sLen, n, rc =0;\n    WSSIGASSERT(cmdPtr, OBJ);\n    if (Jsi_InterpGone(interp))\n        cmdPtr->deleted = 1;\n\n    if (cmdPtr->debug>=32) {\n        switch (reason) {\n            case LWS_CALLBACK_SERVER_WRITEABLE:\n            case LWS_CALLBACK_CLIENT_WRITEABLE:\n                break;\n            default:\n                fprintf(stderr, \"WS CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n        }\n    }\n\n    switch (reason) {\n    case LWS_CALLBACK_PROTOCOL_INIT:\n        if (cmdPtr->noWebsock)\n            return 1;\n        break;\n\n    case LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n        Jsi_DSSet(&pss->url, inPtr);\n        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {\n            pss->clientName = cmdPtr->clientName;\n            pss->clientIP = cmdPtr->clientIP;\n        }\n        if (cmdPtr->onFilter && !cmdPtr->deleted) {\n            if (!pss)\n                pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 0);\n            int killcon = 0, n = 0;\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10], *ret = Jsi_ValueNew1(interp);\n\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)in, len);\n            vargs[n++] = Jsi_ValueNewBoolean(interp, 0);\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onFilter, vpargs, &ret, NULL);\n            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr, \"WS:KILLING CONNECTION: %p\\n\", user);\n                killcon = 1;\n            }\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n            if (killcon)\n                return 1;\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_ESTABLISHED:\n    case LWS_CALLBACK_ESTABLISHED:\n        if (cmdPtr->bufferPwr2>0) {\n            char nbuf[100];\n            snprintf(nbuf, sizeof(nbuf), \"%d\", cmdPtr->bufferPwr2);\n            lws_set_extension_option(wsi, \"permessage-deflate\", \"rx_buf_size\", nbuf);\n            lws_set_extension_option(wsi, \"permessage-deflate\", \"tx_buf_size\", nbuf);\n        }\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 0);\n        if (cmdPtr->onOpen && !cmdPtr->deleted) {\n            /* Pass 2 args: ws id. */\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10];\n            int n = 0;\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n\n            Jsi_Value *ret = Jsi_ValueNew1(interp);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK)\n                return Jsi_LogError(\"websock bad rcv eval\");\n        }\n        break;\n\n    case LWS_CALLBACK_WSI_DESTROY:\n        break;\n\n    case LWS_CALLBACK_CLOSED:\n    case LWS_CALLBACK_PROTOCOL_DESTROY:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss) break;\n        if (cmdPtr->onClose || pss->onClose) {\n            rc = jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 1);\n            if (rc != JSI_OK)\n                return Jsi_LogError(\"websock bad rcv eval\");\n        }\n        jsi_wsdeletePss(pss);\n        if (cmdPtr->stats.connectCnt<=0 && cmdPtr->onCloseLast && !Jsi_InterpGone(interp)) {\n            Jsi_RC jrc;\n            Jsi_Value *retStr = Jsi_ValueNew1(interp);\n            // 1 args: ws\n            Jsi_Value *vpargs, *vargs[10];\n            int n = 0;\n            vargs[n++] = (cmdPtr->deleted?Jsi_ValueNewNull(interp):Jsi_ValueNewObj(interp, cmdPtr->fobj));\n            vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            jrc = Jsi_FunctionInvoke(interp, cmdPtr->onCloseLast, vpargs, &retStr, NULL);\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, retStr);\n            if (Jsi_InterpGone(interp))\n                return JSI_ERROR;\n            return jrc;\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_WRITEABLE:\n    case LWS_CALLBACK_SERVER_WRITEABLE: {\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss || !pss->stack) break;\n        if (pss->lastData)\n            Jsi_Free(pss->lastData);\n        n=0;\n        char *data = pss->lastData = (char*)Jsi_StackUnshift(pss->stack);\n        unsigned char *p;\n        if (data == NULL)\n            break;\n        pss->stats.msgQLen--;\n        pss->state = PWS_SENT;\n        p = (unsigned char *)data+LWS_PRE;\n        sLen = Jsi_Strlen((char*)p);\n        n = jsi_wswrite(pss, wsi, p, sLen, (pss->stats.isBinary?LWS_WRITE_BINARY:LWS_WRITE_TEXT));\n        if (cmdPtr->debug>=10)\n            fprintf(stderr, \"WS:CLIENT WRITE(%p): %d=>%d\\n\", pss, sLen, n);\n\n        if (n >= 0) {\n            cmdPtr->stats.sentCnt++;\n            cmdPtr->stats.sentLast = time(NULL);\n            pss->stats.sentCnt++;\n            pss->stats.sentLast = time(NULL);\n        } else {\n            lwsl_err(\"ERROR %d writing to socket\\n\", n);\n            pss->state = PWS_SENDERR;\n            pss->stats.sentErrCnt++;\n            pss->stats.sentErrLast = time(NULL);\n            cmdPtr->stats.sentErrCnt++;\n            cmdPtr->stats.sentErrLast = time(NULL);\n            rc = 1;\n        }\n        break;\n    }\n\n    case LWS_CALLBACK_CLIENT_RECEIVE:\n    case LWS_CALLBACK_RECEIVE:\n    {\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss) break;\n\n        pss->stats.recvCnt++;\n        pss->stats.recvLast = time(NULL);\n        cmdPtr->stats.recvCnt++;\n        cmdPtr->stats.recvLast = time(NULL);\n\n        if (cmdPtr->onRecv || pss->onRecv) {\n            /* Pass 2 args: id and data. */\n            int nlen = len;\n            if (nlen<=0)\n                return 0;\n            int rblen = Jsi_DSLength(&pss->recvBuf),\n                bmax = cmdPtr->recvBufMax,\n                isfin = pss->stats.isFinal = lws_is_final_fragment(wsi);\n            pss->stats.isBinary = lws_frame_is_binary(wsi);\n            if (rblen) {\n                if (bmax && rblen>bmax) {\n                    fprintf(stderr, \"WS: Recv exceeds recvBufMax: %d>%d\\n\", rblen, bmax);\n                    rc = 1;\n                    break;\n                }\n                Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);\n                if (!isfin) break;\n                cmdPtr->recvBufCnt--;\n                nlen = Jsi_DSLength(&pss->recvBuf);\n                inPtr = Jsi_DSFreeDup(&pss->recvBuf);\n            } else {\n                if (!isfin) {\n                    cmdPtr->recvBufCnt++;\n                    Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);\n                    break;\n                }\n            }\n            rc = jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, nlen, 0);\n            if (inPtr != in)\n                Jsi_Free(inPtr);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n        }\n        lws_callback_on_writable_all_protocol(cmdPtr->context, lws_get_protocol(wsi));\n        break;\n\n    }\n    default:\n        break;\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 117,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_12__setstate_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__setstate_cython__\", 0);\n\n  /* \"(tree fragment)\":17\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, state)\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedReader__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<\n */\n  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":16\n *     else:\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, state)\n * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_unpickle_BufferedReader__set_state(self, __pyx_state)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.__setstate_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 118,
        "code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-32440"
    },
    {
        "index": 119,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_10ByteString_3read_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  CYTHON_UNUSED PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_n_items = 0;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_n_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 1); __PYX_ERR(0, 40, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 2); __PYX_ERR(0, 40, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"read_items\") < 0)) __PYX_ERR(0, 40, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_n_items = values[1];\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 40, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_10ByteString_2read_items(__pyx_self, __pyx_v_self, __pyx_v_n_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 120,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteIntArray* input_dims = input->dims;\n  int input_dims_size = input_dims->size;\n  TF_LITE_ENSURE(context, input_dims_size >= 2);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(input_dims_size);\n  for (int i = 0; i < input_dims_size; i++) {\n    output_shape->data[i] = input_dims->data[i];\n  }\n\n  // Resize the output tensor to the same size as the input tensor.\n  output->type = input->type;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_shape));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 121,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TfLitePackParams* data =\n      reinterpret_cast<TfLitePackParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), data->values_count);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input0 = GetInput(context, node, 0);\n  const int dimension_size = NumDimensions(input0) + 1;\n  if (data->axis < 0) {\n    data->axis += dimension_size;\n  }\n  TF_LITE_ENSURE(context, NumDimensions(input0) >= data->axis);\n  TF_LITE_ENSURE(context, data->axis >= 0);\n\n  if (input0->type != kTfLiteInt32 && input0->type != kTfLiteFloat32 &&\n      input0->type != kTfLiteUInt8 && input0->type != kTfLiteInt8 &&\n      input0->type != kTfLiteInt16 && input0->type != kTfLiteInt64) {\n    context->ReportError(context, \"Type '%s' is not supported by pack.\",\n                         TfLiteTypeGetName(input0->type));\n    return kTfLiteError;\n  }\n  // Make sure all inputs have the same shape and type.\n  for (int i = 1; i < data->values_count; ++i) {\n    const TfLiteTensor* input = GetInput(context, node, i);\n    TF_LITE_ENSURE(context, HaveSameShapes(input0, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input0->type, input->type);\n  }\n\n  // Resize output. rank R will become rank R + 1\n  const TfLiteIntArray* input_shape = input0->dims;\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(dimension_size);\n  int i = 0;\n  for (int index = 0; index < dimension_size; ++index) {\n    if (index == data->axis) {\n      output_shape->data[index] = data->values_count;\n    } else {\n      output_shape->data[index] = input_shape->data[i++];\n    }\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input0->type);\n\n  // Guarantee input/output quantization params match as we do not support\n  // packing quantized tensors.\n  for (int i = 0; i < data->values_count; i++) {\n    const TfLiteTensor* input = GetInput(context, node, i);\n    TF_LITE_ENSURE_EQ(context, input->params.zero_point,\n                      output->params.zero_point);\n    TF_LITE_ENSURE_EQ(context, input->params.scale, output->params.scale);\n  }\n\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 122,
        "code": "static void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[250];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        // if (Jsi_GetIntFromValueBase(interp, ret, &i, 0, JSI_NO_ERRMSG);\n        // sqlite3_result_int64(context, v);\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            //TODO: handle objects???\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 123,
        "code": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n\n        //\n        // if file is a multipart file, we have to seek to the required tile\n        // since we don't know where the file pointer is\n        //\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-16589"
    },
    {
        "index": 124,
        "code": "static int __Pyx_modinit_type_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_type_import_code\", 0);\n  /*--- Type import code ---*/\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"type\", \n  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000\n  sizeof(PyTypeObject),\n  #else\n  sizeof(PyHeapTypeObject),\n  #endif\n  __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(1, 9, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 8, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"bool\", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(2, 8, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"complex\", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(3, 15, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_RefNannyFinishContext();\n  return 0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 125,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, /*index=*/0);\n  const TfLiteTensor* paddings = GetInput(context, node, /*index=*/1);\n  const TfLiteTensor* constant_values =\n      NumInputs(node) == 3 ? GetInput(context, node, /*index=*/2) : nullptr;\n  TfLiteTensor* output = GetOutput(context, node, /*index=*/0);\n\n  TF_LITE_ENSURE_EQ(context, input->type, output->type);\n\n  // Current implementations rely on the inputs being <= 4D.\n  TF_LITE_ENSURE(context, NumDimensions(input) <=\n                              reference_ops::PadKernelMaxDimensionCount());\n\n  if (constant_values != nullptr) {\n    TF_LITE_ENSURE_EQ(context, input->type, constant_values->type);\n    // Ensure that constant_values is a scalar.\n    TF_LITE_ENSURE_EQ(context, NumElements(constant_values), 1);\n  }\n\n  // There must be a pair of paddings for each output dimension.\n  TF_LITE_ENSURE_EQ(context, GetTensorShape(paddings).FlatSize(),\n                    output->dims->size * 2);\n\n  // On Micro, outputs must be properly sized by the converter.\n  // NOTE: This data is only available because the paddings buffer is stored in\n  // the flatbuffer:\n  TF_LITE_ENSURE(context, IsConstantTensor(paddings));\n  const int32_t* paddings_data = GetTensorData<int32_t>(paddings);\n  for (int i = 0; i < output->dims->size; i++) {\n    int output_dim = output->dims->data[i];\n    int expected_dim =\n        input->dims->data[i] + paddings_data[i * 2] + paddings_data[i * 2 + 1];\n    TF_LITE_ENSURE_EQ(context, output_dim, expected_dim);\n  }\n\n  // Calculate OpData:\n  data->params.resizing_category = ResizingCategory::kGenericResize;\n  const int paddings_total = GetTensorShape(paddings).FlatSize();\n  if (paddings_total == 8 && (paddings_data[0] == 0 && paddings_data[1] == 0) &&\n      (paddings_data[6] == 0 && paddings_data[7] == 0)) {\n    data->params.resizing_category = ResizingCategory::kImageStyle;\n  }\n\n  const int num_input_dimensions = NumDimensions(input);\n  data->params.left_padding_count = num_input_dimensions;\n  data->params.right_padding_count = num_input_dimensions;\n\n  for (int idx = num_input_dimensions - 1; idx >= 0; --idx) {\n    data->params.left_padding[idx] = paddings_data[idx * 2];\n    data->params.right_padding[idx] = paddings_data[idx * 2 + 1];\n  }\n\n  if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8) {\n    if (constant_values == nullptr) {\n      // Quantized Pad requires that 0 is represented in the quantized\n      // range.\n      if (input->type == kTfLiteUInt8) {\n        TF_LITE_ENSURE(context, output->params.zero_point >=\n                                    std::numeric_limits<uint8_t>::min());\n        TF_LITE_ENSURE(context, output->params.zero_point <=\n                                    std::numeric_limits<uint8_t>::max());\n      } else {\n        TF_LITE_ENSURE(context, output->params.zero_point >=\n                                    std::numeric_limits<int8_t>::min());\n        TF_LITE_ENSURE(context, output->params.zero_point <=\n                                    std::numeric_limits<int8_t>::max());\n      }\n    } else {\n      // Quantized Pad requires that 'constant_values' is represented in the\n      // same quantized range as the input and output tensors.\n      TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                        constant_values->params.zero_point);\n      TF_LITE_ENSURE_EQ(context, static_cast<double>(output->params.scale),\n                        static_cast<double>(constant_values->params.scale));\n    }\n    data->output_zero_point = output->params.zero_point;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 126,
        "code": "static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        \n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 127,
        "code": "ALWAYS_INLINE String serialize_impl(const Variant& value,\n                                    const SerializeOptions& opts) {\n  switch (value.getType()) {\n    case KindOfClass:\n    case KindOfLazyClass:\n    case KindOfPersistentString:\n    case KindOfString: {\n      auto const str =\n        isStringType(value.getType()) ? value.getStringData() :\n        isClassType(value.getType()) ? classToStringHelper(value.toClassVal()) :\n        lazyClassToStringHelper(value.toLazyClassVal());\n      auto const size = str->size();\n      if (size >= RuntimeOption::MaxSerializedStringSize) {\n        throw Exception(\"Size of serialized string (%d) exceeds max\", size);\n      }\n      StringBuffer sb;\n      sb.append(\"s:\");\n      sb.append(size);\n      sb.append(\":\\\"\");\n      sb.append(str->data(), size);\n      sb.append(\"\\\";\");\n      return sb.detach();\n    }\n    case KindOfResource:\n      return s_Res;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfFunc:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfDouble:\n    case KindOfObject:\n    case KindOfClsMeth:\n    case KindOfRClsMeth:\n    case KindOfRFunc:\n    case KindOfRecord:\n      break;\n  }\n  VariableSerializer vs(VariableSerializer::Type::Serialize);\n  if (opts.keepDVArrays)        vs.keepDVArrays();\n  if (opts.forcePHPArrays)      vs.setForcePHPArrays();\n  if (opts.warnOnHackArrays)    vs.setHackWarn();\n  if (opts.warnOnPHPArrays)     vs.setPHPWarn();\n  if (opts.ignoreLateInit)      vs.setIgnoreLateInit();\n  if (opts.serializeProvenanceAndLegacy) vs.setSerializeProvenanceAndLegacy();\n  // Keep the count so recursive calls to serialize() embed references properly.\n  return vs.serialize(value, true, true);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 128,
        "code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0559"
    },
    {
        "index": 129,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_2__pyx_unpickle_BufferedSocketWriter(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_v___pyx_PickleError = 0;\n  PyObject *__pyx_v___pyx_result = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedSocketWriter\", 0);\n\n  /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x3baf4af:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)\n */\n  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x3baf4af) != 0);\n  if (__pyx_t_1) {\n\n    /* \"(tree fragment)\":5\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x3baf4af:\n *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketWriter.__new__(__pyx_type)\n */\n    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_n_s_PickleError);\n    __Pyx_GIVEREF(__pyx_n_s_PickleError);\n    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);\n    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_t_2);\n    __pyx_v___pyx_PickleError = __pyx_t_2;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":6\n *     if __pyx_checksum != 0x3baf4af:\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)             # <<<<<<<<<<<<<<\n *     __pyx_result = BufferedSocketWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:\n */\n    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x3b, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_INCREF(__pyx_v___pyx_PickleError);\n    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_5)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_5);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);\n    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_Raise(__pyx_t_3, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __PYX_ERR(1, 6, __pyx_L1_error)\n\n    /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x3baf4af:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)\n */\n  }\n\n  /* \"(tree fragment)\":7\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketWriter.__new__(__pyx_type)             # <<<<<<<<<<<<<<\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedSocketWriter__set_state(<BufferedSocketWriter> __pyx_result, __pyx_state)\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v___pyx_result = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedSocketWriter__set_state(<BufferedSocketWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);\n  __pyx_t_6 = (__pyx_t_1 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":9\n *     __pyx_result = BufferedSocketWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedSocketWriter__set_state(<BufferedSocketWriter> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedSocketWriter__set_state(BufferedSocketWriter __pyx_result, tuple __pyx_state):\n */\n    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)\n    __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedSocketWriter__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x3baf4af = (buffer, buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedSocketWriter__set_state(<BufferedSocketWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  }\n\n  /* \"(tree fragment)\":10\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedSocketWriter__set_state(<BufferedSocketWriter> __pyx_result, __pyx_state)\n *     return __pyx_result             # <<<<<<<<<<<<<<\n * cdef __pyx_unpickle_BufferedSocketWriter__set_state(BufferedSocketWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v___pyx_result);\n  __pyx_r = __pyx_v___pyx_result;\n  goto __pyx_L0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedSocketWriter(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedSocketWriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v___pyx_PickleError);\n  __Pyx_XDECREF(__pyx_v___pyx_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 130,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_6buffer_2__set__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v_value) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__set__\", 0);\n  if (!(likely(PyByteArray_CheckExact(__pyx_v_value))||((__pyx_v_value) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"bytearray\", Py_TYPE(__pyx_v_value)->tp_name), 0))) __PYX_ERR(0, 12, __pyx_L1_error)\n  __pyx_t_1 = __pyx_v_value;\n  __Pyx_INCREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v_self->buffer);\n  __Pyx_DECREF(__pyx_v_self->buffer);\n  __pyx_v_self->buffer = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.buffer.__set__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 131,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8position_2__set__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v_value) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  Py_ssize_t __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__set__\", 0);\n  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_value); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 11, __pyx_L1_error)\n  __pyx_v_self->position = __pyx_t_1;\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.position.__set__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 132,
        "code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     \"Not an even split\");\n  const int slice_size = input_size / num_splits;\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = slice_size;\n    TfLiteTensor* output = GetOutput(context, node, i);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 133,
        "code": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-14401"
    },
    {
        "index": 134,
        "code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-15900"
    },
    {
        "index": 135,
        "code": "Variant HHVM_FUNCTION(fwrite,\n                      const Resource& handle,\n                      const String& data,\n                      int64_t length /* = 0 */) {\n  CHECK_HANDLE(handle, f);\n  int64_t ret = f->write(data, length);\n  if (ret < 0) {\n    raise_notice(\"fwrite(): send of %d bytes failed with errno=%d %s\",\n                 data.size(), errno, folly::errnoStr(errno).c_str());\n    ret = 0;\n  }\n  return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 136,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* start = GetInput(context, node, kStartTensor);\n  const TfLiteTensor* limit = GetInput(context, node, kLimitTensor);\n  const TfLiteTensor* delta = GetInput(context, node, kDeltaTensor);\n  // Make sure all the inputs are scalars.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(start), 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(limit), 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(delta), 0);\n\n  // Currently only supports int32 and float.\n  // TODO(b/117912892): Support quantization as well.\n  const auto dtype = start->type;\n  if (dtype != kTfLiteFloat32 && dtype != kTfLiteInt32) {\n    context->ReportError(context, \"Unknown index output data type: %s\",\n                         TfLiteTypeGetName(dtype));\n    return kTfLiteError;\n  }\n\n  TF_LITE_ENSURE_TYPES_EQ(context, limit->type, dtype);\n  TF_LITE_ENSURE_TYPES_EQ(context, delta->type, dtype);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = dtype;\n\n  if (IsConstantTensor(start) && IsConstantTensor(limit) &&\n      IsConstantTensor(delta)) {\n    return ResizeOutput(context, start, limit, delta, output);\n  }\n\n  SetTensorToDynamic(output);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 137,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_6__reduce_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v_self) {\n  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.compressor, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->__pyx_base.buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_INCREF(__pyx_v_self->compressor);\n  __Pyx_GIVEREF(__pyx_v_self->compressor);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_self->compressor);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_t_3);\n  __pyx_t_1 = 0;\n  __pyx_t_2 = 0;\n  __pyx_t_3 = 0;\n  __pyx_v_state = ((PyObject*)__pyx_t_4);\n  __pyx_t_4 = 0;\n\n  /* \"(tree fragment)\":6\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.compressor, self.position)\n *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<\n *     if _dict is not None:\n *         state += (_dict,)\n */\n  __pyx_t_4 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_v__dict = __pyx_t_4;\n  __pyx_t_4 = 0;\n\n  /* \"(tree fragment)\":7\n *     state = (self.buffer, self.buffer_size, self.compressor, self.position)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n  __pyx_t_5 = (__pyx_v__dict != Py_None);\n  __pyx_t_6 = (__pyx_t_5 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":8\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *         state += (_dict,)             # <<<<<<<<<<<<<<\n *         use_setstate = True\n *     else:\n */\n    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(__pyx_v__dict);\n    __Pyx_GIVEREF(__pyx_v__dict);\n    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v__dict);\n    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_3));\n    __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":9\n *     if _dict is not None:\n *         state += (_dict,)\n *         use_setstate = True             # <<<<<<<<<<<<<<\n *     else:\n *         use_setstate = self.compressor is not None\n */\n    __pyx_v_use_setstate = 1;\n\n    /* \"(tree fragment)\":7\n *     state = (self.buffer, self.buffer_size, self.compressor, self.position)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n    goto __pyx_L3;\n  }\n\n  /* \"(tree fragment)\":11\n *         use_setstate = True\n *     else:\n *         use_setstate = self.compressor is not None             # <<<<<<<<<<<<<<\n *     if use_setstate:\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, None), state\n */\n  /*else*/ {\n    __pyx_t_6 = (__pyx_v_self->compressor != Py_None);\n    __pyx_v_use_setstate = __pyx_t_6;\n  }\n  __pyx_L3:;\n\n  /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.compressor is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, None), state\n *     else:\n */\n  __pyx_t_6 = (__pyx_v_use_setstate != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":13\n *         use_setstate = self.compressor is not None\n *     if use_setstate:\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, None), state             # <<<<<<<<<<<<<<\n *     else:\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyx_unpickle_CompressedBuffere); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_17355272);\n    __Pyx_GIVEREF(__pyx_int_17355272);\n    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_int_17355272);\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    PyTuple_SET_ITEM(__pyx_t_4, 2, Py_None);\n    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_state);\n    __pyx_t_3 = 0;\n    __pyx_t_4 = 0;\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n\n    /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.compressor is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, None), state\n *     else:\n */\n  }\n\n  /* \"(tree fragment)\":15\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, None), state\n *     else:\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, state)             # <<<<<<<<<<<<<<\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_CompressedBufferedWriter__set_state(self, __pyx_state)\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_CompressedBuffere); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_17355272);\n    __Pyx_GIVEREF(__pyx_int_17355272);\n    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_int_17355272);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_state);\n    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_GIVEREF(__pyx_t_2);\n    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_4);\n    __pyx_t_2 = 0;\n    __pyx_t_4 = 0;\n    __pyx_r = __pyx_t_3;\n    __pyx_t_3 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"(tree fragment)\":1\n * def __reduce_cython__(self):             # <<<<<<<<<<<<<<\n *     cdef tuple state\n *     cdef object _dict\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.__reduce_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_state);\n  __Pyx_XDECREF(__pyx_v__dict);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 138,
        "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 139,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_1read_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  Py_ssize_t __pyx_v_n_items;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_n_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 1); __PYX_ERR(0, 118, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 2); __PYX_ERR(0, 118, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"read_items\") < 0)) __PYX_ERR(0, 118, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_n_items = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_n_items == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L3_error)\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 118, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteFixedString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_read_items(__pyx_self, __pyx_v_self, __pyx_v_n_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 140,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedWriter__set_state(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  char *__pyx_t_2;\n  Py_ssize_t __pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  PyObject *__pyx_t_9 = NULL;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedWriter__set_state\", 0);\n\n  /* \"(tree fragment)\":12\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]             # <<<<<<<<<<<<<<\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[3])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyObject_AsWritableString(__pyx_t_1); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __pyx_v___pyx_result->buffer = __pyx_t_2;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_3 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->buffer_size = __pyx_t_3;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_3 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->position = __pyx_t_3;\n\n  /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[3])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(1, 13, __pyx_L1_error)\n  }\n  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_5 = ((__pyx_t_3 > 3) != 0);\n  if (__pyx_t_5) {\n  } else {\n    __pyx_t_4 = __pyx_t_5;\n    goto __pyx_L4_bool_binop_done;\n  }\n  __pyx_t_5 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_6 = (__pyx_t_5 != 0);\n  __pyx_t_4 = __pyx_t_6;\n  __pyx_L4_bool_binop_done:;\n  if (__pyx_t_4) {\n\n    /* \"(tree fragment)\":14\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[3])             # <<<<<<<<<<<<<<\n */\n    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_update); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_8);\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    if (unlikely(__pyx_v___pyx_state == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(1, 14, __pyx_L1_error)\n    }\n    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_9 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {\n      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);\n      if (likely(__pyx_t_9)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);\n        __Pyx_INCREF(__pyx_t_9);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_8, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_9, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_7);\n    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n    /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[3])\n */\n  }\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_XDECREF(__pyx_t_9);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedWriter__set_state\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 141,
        "code": "static CYTHON_INLINE PyObject* __Pyx_decode_c_string(\n         const char* cstring, Py_ssize_t start, Py_ssize_t stop,\n         const char* encoding, const char* errors,\n         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {\n    Py_ssize_t length;\n    if (unlikely((start < 0) | (stop < 0))) {\n        size_t slen = strlen(cstring);\n        if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"c-string too long to convert to Python\");\n            return NULL;\n        }\n        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 142,
        "code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\t/* We cannot use the standard wcstombs() here because it\n\t * cannot tell us how big the output buffer should be.  So\n\t * I've built a loop around wcrtomb() or wctomb() that\n\t * converts a character at a time and resizes the string as\n\t * needed.  We prefer wcrtomb() when it's available because\n\t * it's thread-safe. */\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\twctomb(NULL, L'\\0');\n#endif\n\t/*\n\t * Allocate buffer for MBS.\n\t * We need this allocation here since it is possible that\n\t * as->s is still NULL.\n\t */\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\t/* Re-allocate buffer for MBS. */\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t/* Skip an illegal wide char. */\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21674"
    },
    {
        "index": 143,
        "code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 144,
        "code": "TfLiteStatus CheckInputTensorDimensions(TfLiteContext* context,\n                                        TfLiteNode* node, int n_input,\n                                        int n_output, int n_cell,\n                                        bool use_layer_norm, bool is_integer) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n\n  // Making sure clipping parameters have valid values.\n  // == 0 means no clipping\n  //  > 0 means clipping\n  TF_LITE_ENSURE(context, params->cell_clip >= 0);\n  TF_LITE_ENSURE(context, params->proj_clip >= 0);\n\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->data[1], n_input);\n  TF_LITE_ENSURE(context, (input_to_forget_weights->type == kTfLiteFloat32) ||\n                              (input_to_forget_weights->type == kTfLiteUInt8) ||\n                              (input_to_forget_weights->type == kTfLiteInt8));\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  if (!use_cifg) {\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->data[1], n_input);\n    TF_LITE_ENSURE_TYPES_EQ(context, input_to_input_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->data[1], n_input);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_to_cell_weights->type,\n                          input_to_forget_weights->type);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  if (recurrent_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->data[0],\n                      n_cell);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->data[1],\n                      n_output);\n    TF_LITE_ENSURE_TYPES_EQ(context, recurrent_to_input_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->data[0],\n                    n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->data[1],\n                    n_output);\n  TF_LITE_ENSURE_TYPES_EQ(context, recurrent_to_forget_weights->type,\n                          input_to_forget_weights->type);\n\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->data[1],\n                    n_output);\n  TF_LITE_ENSURE_TYPES_EQ(context, recurrent_to_cell_weights->type,\n                          input_to_forget_weights->type);\n\n  // We make sure the input-gate's parameters are either both present (regular\n  // LSTM) or not at all (CIFG-LSTM).\n  const bool cifg_weights_all_or_none =\n      ((input_to_input_weights != nullptr) &&\n       (recurrent_to_input_weights != nullptr)) ||\n      ((input_to_input_weights == nullptr) &&\n       (recurrent_to_input_weights == nullptr));\n  TF_LITE_ENSURE(context, cifg_weights_all_or_none == true);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  if (cell_to_input_weights) {\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(\n        context, cell_to_input_weights->type,\n        is_integer ? kTfLiteInt16 : input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  if (cell_to_forget_weights) {\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(\n        context, cell_to_forget_weights->type,\n        is_integer ? kTfLiteInt16 : input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kCellToOutputWeightsTensor);\n  if (cell_to_output_weights) {\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(\n        context, cell_to_output_weights->type,\n        is_integer ? kTfLiteInt16 : input_to_forget_weights->type);\n  }\n\n  // Making sure the peephole weights are there all or none.\n  const bool peephole_weights_all_or_none =\n      ((cell_to_input_weights != nullptr || use_cifg) &&\n       (cell_to_forget_weights != nullptr) &&\n       (cell_to_output_weights != nullptr)) ||\n      ((cell_to_input_weights == nullptr) &&\n       (cell_to_forget_weights == nullptr) &&\n       (cell_to_output_weights == nullptr));\n  TF_LITE_ENSURE(context, peephole_weights_all_or_none == true);\n\n  // Make sure the input gate bias is present only when not a CIFG-LSTM.\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  if (use_cifg) {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias, nullptr);\n  } else {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, input_gate_bias->dims->data[0], n_cell);\n    if (is_integer) {\n      TF_LITE_ENSURE_TYPES_EQ(context, input_gate_bias->type, kTfLiteInt32);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, input_gate_bias->type, kTfLiteFloat32);\n    }\n  }\n\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, kForgetGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias->dims->data[0], n_cell);\n  if (is_integer) {\n    TF_LITE_ENSURE_TYPES_EQ(context, forget_gate_bias->type, kTfLiteInt32);\n  } else {\n    TF_LITE_ENSURE_TYPES_EQ(context, forget_gate_bias->type, kTfLiteFloat32);\n  }\n\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, kCellGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->dims->data[0], n_cell);\n  if (is_integer) {\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_gate_bias->type, kTfLiteInt32);\n  } else {\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_gate_bias->type, kTfLiteFloat32);\n  }\n\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, kOutputGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias->dims->data[0], n_cell);\n  if (is_integer) {\n    TF_LITE_ENSURE_TYPES_EQ(context, output_gate_bias->type, kTfLiteInt32);\n  } else {\n    TF_LITE_ENSURE_TYPES_EQ(context, output_gate_bias->type, kTfLiteFloat32);\n  }\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  if (projection_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->data[0], n_output);\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->data[1], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, projection_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n  if (projection_bias != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_bias->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, projection_bias->dims->data[0], n_output);\n    if (is_integer) {\n      TF_LITE_ENSURE_TYPES_EQ(context, projection_bias->type, kTfLiteInt32);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, projection_bias->type, kTfLiteFloat32);\n    }\n  }\n\n  // Making sure the projection tensors are consistent:\n  // 1) If projection weight is not present, then projection bias should not be\n  // present.\n  // 2) If projection weight is present, then projection bias is optional.\n  // TODO(ghodrat): make sure this is correct.\n  const bool projection_tensors_consistent =\n      ((projection_weights != nullptr) || (projection_bias == nullptr));\n  TF_LITE_ENSURE(context, projection_tensors_consistent == true);\n\n  if (use_layer_norm) {\n    const TfLiteTensor* input_layer_norm_coefficients = GetOptionalInputTensor(\n        context, node, kInputLayerNormCoefficientsTensor);\n    if (use_cifg) {\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients, nullptr);\n    } else {\n      TF_LITE_ENSURE(context, input_layer_norm_coefficients != nullptr);\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients->dims->size, 1);\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients->dims->data[0],\n                        n_cell);\n      if (is_integer) {\n        TF_LITE_ENSURE_TYPES_EQ(context, input_layer_norm_coefficients->type,\n                                kTfLiteInt16);\n      } else {\n        TF_LITE_ENSURE_TYPES_EQ(context, input_layer_norm_coefficients->type,\n                                kTfLiteFloat32);\n      }\n    }\n\n    const TfLiteTensor* forget_layer_norm_coefficients = GetOptionalInputTensor(\n        context, node, kForgetLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, forget_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, forget_layer_norm_coefficients->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, forget_layer_norm_coefficients->dims->data[0],\n                      n_cell);\n    if (is_integer) {\n      TF_LITE_ENSURE_TYPES_EQ(context, forget_layer_norm_coefficients->type,\n                              kTfLiteInt16);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, forget_layer_norm_coefficients->type,\n                              kTfLiteFloat32);\n    }\n\n    const TfLiteTensor* cell_layer_norm_coefficients =\n        GetOptionalInputTensor(context, node, kCellLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, cell_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, cell_layer_norm_coefficients->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_layer_norm_coefficients->dims->data[0],\n                      n_cell);\n    if (is_integer) {\n      TF_LITE_ENSURE_TYPES_EQ(context, cell_layer_norm_coefficients->type,\n                              kTfLiteInt16);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, cell_layer_norm_coefficients->type,\n                              kTfLiteFloat32);\n    }\n\n    const TfLiteTensor* output_layer_norm_coefficients = GetOptionalInputTensor(\n        context, node, kOutputLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, output_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, output_layer_norm_coefficients->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, output_layer_norm_coefficients->dims->data[0],\n                      n_cell);\n    if (is_integer) {\n      TF_LITE_ENSURE_TYPES_EQ(context, output_layer_norm_coefficients->type,\n                              kTfLiteInt16);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, output_layer_norm_coefficients->type,\n                              kTfLiteFloat32);\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 145,
        "code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n\n    return result;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 146,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {\n    case kTfLiteFloat32:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",\n                           TfLiteTypeGetName(type));\n      return kTfLiteError;\n  }\n  output->type = type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 147,
        "code": "static bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tint i;\n\n\tif (old->curframe != cur->curframe)\n\t\treturn false;\n\n\t/* for states to be equal callsites have to be the same\n\t * and all frame states need to be equivalent\n\t */\n\tfor (i = 0; i <= old->curframe; i++) {\n\t\tif (old->frame[i]->callsite != cur->frame[i]->callsite)\n\t\t\treturn false;\n\t\tif (!func_states_equal(old->frame[i], cur->frame[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 148,
        "code": "static void Process_ipfix_template_add(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\ninput_translation_t *translation_table;\nipfix_template_record_t *ipfix_template_record;\nipfix_template_elements_std_t *NextElement;\nint i;\n\n\t// a template flowset can contain multiple records ( templates )\n\twhile ( size_left ) {\n\t\tuint32_t table_id, count, size_required;\n\t\tuint32_t num_extensions = 0;\n\n\t\tif ( size_left && size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// map next record.\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\n\t\ttable_id = ntohs(ipfix_template_record->TemplateID);\n\t\tcount\t = ntohs(ipfix_template_record->FieldCount);\n\n\t\tdbg_printf(\"\\n[%u] Template ID: %u\\n\", exporter->info.id, table_id);\n\t\tdbg_printf(\"FieldCount: %u buffersize: %u\\n\", count, size_left);\n\n\t\t// prepare\n\t\t// clear helper tables\n\t\tmemset((void *)cache.common_extensions, 0,  (Max_num_extensions+1)*sizeof(uint32_t));\n\t\tmemset((void *)cache.lookup_info, 0, 65536 * sizeof(struct element_param_s));\n\t\tfor (i=1; ipfix_element_map[i].id != 0; i++ ) {\n\t\t\tuint32_t Type = ipfix_element_map[i].id;\n\t\t\tif ( ipfix_element_map[i].id == ipfix_element_map[i-1].id )\n\t\t\t\tcontinue;\n\t\t\tcache.lookup_info[Type].index   = i;\n\t\t\t// other elements cleard be memset\n\t\t}\n\t\tcache.input_order = calloc(count, sizeof(struct order_s));\n\t\tif ( !cache.input_order ) {\n\t\t\tLogError(\"Process_ipfix: Panic! malloc(): %s line %d: %s\", __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache.input_count = count;\n\n\t\t// assume all elements in template are std elements. correct this value, if we find an enterprise element\n\t\tsize_required   = 4*count;\n\t\tif ( size_left < size_required ) {\n\t\t\t// if we fail this check, this flowset must be skipped.\n\t\t\tLogError(\"Process_ipfix: [%u] Not enough data for template elements! required: %i, left: %u\", \n\t\t\t\t\texporter->info.id, size_required, size_left);\n\t\t\tdbg_printf(\"ERROR: Not enough data for template elements! required: %i, left: %u\", size_required, size_left);\n\t\t\treturn;\n\t\t}\n\n\t\t// process all elements in this record\n\t\tNextElement \t = (ipfix_template_elements_std_t *)ipfix_template_record->elements;\n\t\tfor ( i=0; i<count; i++ ) {\n\t\t\tuint16_t Type, Length;\n\t\t\tuint32_t ext_id;\n\t\t\tint Enterprise;\n\t\n\t\t\tType   = ntohs(NextElement->Type);\n\t\t\tLength = ntohs(NextElement->Length);\n\t\t\tEnterprise = Type & 0x8000 ? 1 : 0;\n\t\t\tType = Type & 0x7FFF;\n\n\t\t\text_id = MapElement(Type, Length, i);\n\n\t\t\t// do we store this extension? enabled != 0\n\t\t\t// more than 1 v9 tag may map to an extension - so count this extension once only\n\t\t\tif ( ext_id && extension_descriptor[ext_id].enabled ) {\n\t\t\t\tif ( cache.common_extensions[ext_id] == 0 ) {\n\t\t\t\t\tcache.common_extensions[ext_id] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t} \n\t\n\t\t\tif ( Enterprise ) {\n\t\t\t\tipfix_template_elements_e_t *e = (ipfix_template_elements_e_t *)NextElement;\n\t\t\t\tsize_required += 4;\t// ad 4 for enterprise value\n\t\t\t\tif ( size_left < size_required ) {\n\t\t\t\t\tLogError(\"Process_ipfix: [%u] Not enough data for template elements! required: %i, left: %u\", \n\t\t\t\t\t\t\texporter->info.id, size_required, size_left);\n\t\t\t\t\tdbg_printf(\"ERROR: Not enough data for template elements! required: %i, left: %u\", size_required, size_left);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( ntohl(e->EnterpriseNumber) == IPFIX_ReverseInformationElement ) {\n\t\t\t\t\tdbg_printf(\" [%i] Enterprise: 1, Type: %u, Length %u Reverse Information Element: %u\\n\", i, Type, Length, ntohl(e->EnterpriseNumber));\n\t\t\t\t} else {\n\t\t\t\t\tdbg_printf(\" [%i] Enterprise: 1, Type: %u, Length %u EnterpriseNumber: %u\\n\", i, Type, Length, ntohl(e->EnterpriseNumber));\n\t\t\t\t}\n\t\t\t\te++;\n\t\t\t\tNextElement = (ipfix_template_elements_std_t *)e;\n\t\t\t} else {\n\t\t\t\tdbg_printf(\" [%i] Enterprise: 0, Type: %u, Length %u\\n\", i, Type, Length);\n\t\t\t\tNextElement++;\n\t\t\t}\n\t\t}\n\n\t\tdbg_printf(\"Processed: %u\\n\", size_required);\n\n\t\t// compact input order and reorder sequencer\n\t\tif ( compact_input_order() ) {\n\t\t\t// valid template with common inout fields\n\n\t\t\t// as the router IP address extension is not part announced in a template, we need to deal with it here\n\t\t\tif ( extension_descriptor[EX_ROUTER_IP_v4].enabled ) {\n\t\t\t\tif ( cache.common_extensions[EX_ROUTER_IP_v4] == 0 ) {\n\t\t\t\t\tcache.common_extensions[EX_ROUTER_IP_v4] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t\tdbg_printf(\"Add sending router IP address (%s) => Extension: %u\\n\", \n\t\t\t\t\tfs->sa_family == PF_INET6 ? \"ipv6\" : \"ipv4\", EX_ROUTER_IP_v4);\n\t\t\t}\n\t\n\t\t\t// XXX for now, we do not store router ID in IPFIX\n\t\t\textension_descriptor[EX_ROUTER_ID].enabled = 0;\n\n/*\t\n\t\t// as the router IP address extension is not part announced in a template, we need to deal with it here\n\t\tif ( extension_descriptor[EX_ROUTER_ID].enabled ) {\n\t\t\tif ( cache.common_extensions[EX_ROUTER_ID] == 0 ) {\n\t\t\t\tcache.common_extensions[EX_ROUTER_ID] = 1;\n\t\t\t\tnum_extensions++;\n\t\t\t}\n\t\t\tdbg_printf(\"Force add router ID (engine type/ID), Extension: %u\\n\", EX_ROUTER_ID);\n\t\t}\n*/\n\t\t\t// received time \n\t\t\tif ( extension_descriptor[EX_RECEIVED].enabled ) {\n\t\t\t\tif ( cache.common_extensions[EX_RECEIVED] == 0 ) {\n\t\t\t\t\tcache.common_extensions[EX_RECEIVED] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t\tdbg_printf(\"Force add packet received time, Extension: %u\\n\", EX_RECEIVED);\n\t\t\t}\n\n#ifdef DEVEL\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i=4; extension_descriptor[i].id; i++ ) {\n\t\t\t\tif ( cache.common_extensions[i] ) {\n\t\t\t\t\tprintf(\"Enabled extension: %i\\n\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\n\t\t\ttranslation_table = setup_translation_table(exporter, table_id);\n\t\t\tif (translation_table->extension_map_changed ) {\n\t\t\t\t// refresh he map in the ouput buffer\n\t\t\t\tdbg_printf(\"Translation Table changed! Add extension map ID: %i\\n\", translation_table->extension_info.map->map_id);\n\t\t\t\tAddExtensionMap(fs, translation_table->extension_info.map);\n\t\t\t\ttranslation_table->extension_map_changed = 0;\n\t\t\t\tdbg_printf(\"Translation Table added! map ID: %i\\n\", translation_table->extension_info.map->map_id);\n\t\t\t}\n\t\n\t\t\tif ( !reorder_sequencer(translation_table) ) {\n\t\t\t\tLogError(\"Process_ipfix: [%u] Failed to reorder sequencer. Remove table id: %u\", \n\t\t\t\t\t\t\texporter->info.id, table_id);\n\t\t\t\tremove_translation_table(fs, exporter, table_id);\n\t\t\t}\n\t\t} else {\n\t\t\tdbg_printf(\"Template does not contain any common fields - skip\\n\");\n\t\t}\n\t\t// update size left of this flowset\n\t\tsize_left -= size_required;\n\t\tDataPtr = DataPtr + size_required+4;\t// +4 for header\n\t\tif ( size_left < 4 ) {\n\t\t\t// pading\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t\tfree(cache.input_order);\n\t\tcache.input_order = NULL;\n\t}\n\n} // End of Process_ipfix_template_add\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-14459"
    },
    {
        "index": 149,
        "code": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  /* get all extra arguments available */\n    checkstackp(L, nextra, where);  /* ensure stack space */\n    L->top = where + nextra;  /* next instruction will need top */\n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   /* complete required results with nil */\n    setnilvalue(s2v(where + i));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 150,
        "code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n\n  // Matching GetWindowedOutputSize in TensorFlow.\n  auto padding = params->padding;\n  int out_width, out_height;\n\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n      // We currently don't have a quantized implementation of L2Pool\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 151,
        "code": "ignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_add_string(&ignore_error_list, error);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 152,
        "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 153,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter___init__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, Py_ssize_t __pyx_v_bufsize) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":13\n * \n *     def __init__(self, Py_ssize_t bufsize):\n *         self.buffer = <char *> PyMem_Malloc(bufsize)             # <<<<<<<<<<<<<<\n *         if not self.buffer:\n *             raise MemoryError()\n */\n  __pyx_v_self->buffer = ((char *)PyMem_Malloc(__pyx_v_bufsize));\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":14\n *     def __init__(self, Py_ssize_t bufsize):\n *         self.buffer = <char *> PyMem_Malloc(bufsize)\n *         if not self.buffer:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n * \n */\n  __pyx_t_1 = ((!(__pyx_v_self->buffer != 0)) != 0);\n  if (unlikely(__pyx_t_1)) {\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":15\n *         self.buffer = <char *> PyMem_Malloc(bufsize)\n *         if not self.buffer:\n *             raise MemoryError()             # <<<<<<<<<<<<<<\n * \n *         self.position = 0\n */\n    PyErr_NoMemory(); __PYX_ERR(0, 15, __pyx_L1_error)\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":14\n *     def __init__(self, Py_ssize_t bufsize):\n *         self.buffer = <char *> PyMem_Malloc(bufsize)\n *         if not self.buffer:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n * \n */\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":17\n *             raise MemoryError()\n * \n *         self.position = 0             # <<<<<<<<<<<<<<\n *         self.buffer_size = bufsize\n * \n */\n  __pyx_v_self->position = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":18\n * \n *         self.position = 0\n *         self.buffer_size = bufsize             # <<<<<<<<<<<<<<\n * \n *         super(BufferedWriter, self).__init__()\n */\n  __pyx_v_self->buffer_size = __pyx_v_bufsize;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":20\n *         self.buffer_size = bufsize\n * \n *         super(BufferedWriter, self).__init__()             # <<<<<<<<<<<<<<\n * \n *     def __dealloc__(self):\n */\n  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_INCREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedWriter));\n  __Pyx_GIVEREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedWriter));\n  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedWriter));\n  __Pyx_INCREF(((PyObject *)__pyx_v_self));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n  PyTuple_SET_ITEM(__pyx_t_3, 1, ((PyObject *)__pyx_v_self));\n  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_3, function);\n    }\n  }\n  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":12\n *     cdef Py_ssize_t position, buffer_size\n * \n *     def __init__(self, Py_ssize_t bufsize):             # <<<<<<<<<<<<<<\n *         self.buffer = <char *> PyMem_Malloc(bufsize)\n *         if not self.buffer:\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 155,
        "code": "static int __pyx_pw_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_read_block = 0;\n  PyObject *__pyx_v_bufsize = 0;\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_read_block,&__pyx_n_s_bufsize,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_read_block)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bufsize)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, 1); __PYX_ERR(0, 197, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 197, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_read_block = values[0];\n    __pyx_v_bufsize = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 197, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.CompressedBufferedReader.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader___init__(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *)__pyx_v_self), __pyx_v_read_block, __pyx_v_bufsize);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 157,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  OpContext op_context(context, node);\n\n  TF_LITE_ENSURE(context, op_context.input->type == kTfLiteUInt8 ||\n                              op_context.input->type == kTfLiteInt8 ||\n                              op_context.input->type == kTfLiteInt16 ||\n                              op_context.input->type == kTfLiteFloat16);\n  TF_LITE_ENSURE(context, op_context.ref->type == kTfLiteFloat32);\n\n  op_data->max_diff = op_data->tolerance * op_context.input->params.scale;\n  switch (op_context.input->type) {\n    case kTfLiteUInt8:\n    case kTfLiteInt8:\n      op_data->max_diff *= (1 << 8);\n      break;\n    case kTfLiteInt16:\n      op_data->max_diff *= (1 << 16);\n      break;\n    default:\n      break;\n  }\n\n  // Allocate tensor to store the dequantized inputs.\n  if (op_data->cache_tensor_id == kTensorNotAllocated) {\n    TF_LITE_ENSURE_OK(\n        context, context->AddTensors(context, 1, &op_data->cache_tensor_id));\n  }\n\n  TfLiteIntArrayFree(node->temporaries);\n  node->temporaries = TfLiteIntArrayCreate(1);\n  node->temporaries->data[0] = op_data->cache_tensor_id;\n\n  TfLiteTensor* dequantized = GetTemporary(context, node, /*index=*/0);\n  dequantized->type = op_context.ref->type;\n  dequantized->allocation_type = kTfLiteDynamic;\n\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(\n                                 context, dequantized,\n                                 TfLiteIntArrayCopy(op_context.input->dims)));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 158,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_4__pyx_unpickle_CompressedBufferedReader(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_v___pyx_PickleError = 0;\n  PyObject *__pyx_v___pyx_result = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_CompressedBufferedReader\", 0);\n\n  /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x183c0eb:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)\n */\n  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x183c0eb) != 0);\n  if (__pyx_t_1) {\n\n    /* \"(tree fragment)\":5\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x183c0eb:\n *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedReader.__new__(__pyx_type)\n */\n    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_n_s_PickleError);\n    __Pyx_GIVEREF(__pyx_n_s_PickleError);\n    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);\n    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_t_2);\n    __pyx_v___pyx_PickleError = __pyx_t_2;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":6\n *     if __pyx_checksum != 0x183c0eb:\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)             # <<<<<<<<<<<<<<\n *     __pyx_result = CompressedBufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:\n */\n    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x18, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_INCREF(__pyx_v___pyx_PickleError);\n    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_5)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_5);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);\n    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_Raise(__pyx_t_3, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __PYX_ERR(1, 6, __pyx_L1_error)\n\n    /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x183c0eb:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)\n */\n  }\n\n  /* \"(tree fragment)\":7\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedReader.__new__(__pyx_type)             # <<<<<<<<<<<<<<\n *     if __pyx_state is not None:\n *         __pyx_unpickle_CompressedBufferedReader__set_state(<CompressedBufferedReader> __pyx_result, __pyx_state)\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v___pyx_result = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_CompressedBufferedReader__set_state(<CompressedBufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);\n  __pyx_t_6 = (__pyx_t_1 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":9\n *     __pyx_result = CompressedBufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:\n *         __pyx_unpickle_CompressedBufferedReader__set_state(<CompressedBufferedReader> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<\n *     return __pyx_result\n * cdef __pyx_unpickle_CompressedBufferedReader__set_state(CompressedBufferedReader __pyx_result, tuple __pyx_state):\n */\n    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)\n    __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_CompressedBufferedReader__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x183c0eb = (buffer, current_buffer_size, position, read_block))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_CompressedBufferedReader__set_state(<CompressedBufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  }\n\n  /* \"(tree fragment)\":10\n *     if __pyx_state is not None:\n *         __pyx_unpickle_CompressedBufferedReader__set_state(<CompressedBufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result             # <<<<<<<<<<<<<<\n * cdef __pyx_unpickle_CompressedBufferedReader__set_state(CompressedBufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.read_block = __pyx_state[3]\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v___pyx_result);\n  __pyx_r = __pyx_v___pyx_result;\n  goto __pyx_L0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_CompressedBufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_CompressedBufferedReader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v___pyx_PickleError);\n  __Pyx_XDECREF(__pyx_v___pyx_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 160,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSubParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32 ||\n      output->type == kTfLiteInt64) {\n    EvalSub<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n             output->type == kTfLiteInt16) {\n    EvalQuantized<kernel_type>(context, node, params, data, input1, input2,\n                               output);\n  } else {\n    context->ReportError(\n        context,\n        \"output type %d is not supported, requires float|uint8|int32 types.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 161,
        "code": "static void TreeTest(Jsi_Interp* interp) {\n    Jsi_Tree *st, *wt, *mt;\n    Jsi_TreeEntry *hPtr, *hPtr2;\n    bool isNew, i;\n    Jsi_TreeSearch srch;\n    struct tdata {\n        int n;\n        int m;\n    } t1, t2;\n    char nbuf[100];\n    \n    wt = Jsi_TreeNew(interp, JSI_KEYS_ONEWORD, NULL);\n    mt = Jsi_TreeNew(interp, sizeof(struct tdata), NULL);\n\n    Jsi_TreeSet(wt, wt,(void*)0x88);\n    Jsi_TreeSet(wt, mt,(void*)0x99);\n    printf(\"WT: %p\\n\", Jsi_TreeGet(wt, mt));\n    printf(\"WT2: %p\\n\", Jsi_TreeGet(wt, wt));\n    Jsi_TreeDelete(wt);\n\n    t1.n = 0; t1.m = 1;\n    t2.n = 1; t2.m = 2;\n    Jsi_TreeSet(mt, &t1,(void*)0x88);\n    Jsi_TreeSet(mt, &t2,(void*)0x99);\n    Jsi_TreeSet(mt, &t2,(void*)0x98);\n    printf(\"CT: %p\\n\", Jsi_TreeGet(mt, &t1));\n    printf(\"CT2: %p\\n\", Jsi_TreeGet(mt, &t2));\n    Jsi_TreeDelete(mt);\n\n    st = Jsi_TreeNew(interp, JSI_KEYS_STRING, NULL);\n    hPtr = Jsi_TreeEntryNew(st, \"bob\", &isNew);\n    Jsi_TreeValueSet(hPtr, (void*)99);\n    Jsi_TreeSet(st, \"zoe\",(void*)77);\n    hPtr2 = Jsi_TreeSet(st, \"ted\",(void*)55);\n    Jsi_TreeSet(st, \"philip\",(void*)66);\n    Jsi_TreeSet(st, \"alice\",(void*)77);\n    puts(\"SRCH\");\n    for (hPtr=Jsi_TreeSearchFirst(st,&srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch))\n        mycall(st, hPtr, NULL);\n    Jsi_TreeSearchDone(&srch);\n    puts(\"IN\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_IN);\n    puts(\"PRE\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_PRE);\n    puts(\"POST\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_POST);\n    puts(\"LEVEL\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_LEVEL);\n    Jsi_TreeEntryDelete(hPtr2);\n    puts(\"INDEL\");\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n\n    for (i=0; i<1000; i++) {\n        snprintf(nbuf, sizeof(nbuf), \"name%d\", i);\n        Jsi_TreeSet(st, nbuf,(void*)i);\n    }\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n    for (i=0; i<1000; i++) {\n        Jsi_TreeEntryDelete(st->root);\n    }\n    puts(\"OK\");\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n    Jsi_TreeDelete(st);\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 162,
        "code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-10531"
    },
    {
        "index": 163,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 164,
        "code": "static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_InitCachedConstants\", 0);\n\n  /* \"clickhouse_driver/varint.pyx\":4\n * \n * \n * def write_varint(Py_ssize_t number, buf):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Writes integer of variable length using LEB128.\n */\n  __pyx_tuple_ = PyTuple_Pack(5, __pyx_n_s_number, __pyx_n_s_buf, __pyx_n_s_i, __pyx_n_s_towrite, __pyx_n_s_num_buf); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 4, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_tuple_);\n  __Pyx_GIVEREF(__pyx_tuple_);\n  __pyx_codeobj__2 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple_, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_clickhouse_driver_varint_pyx, __pyx_n_s_write_varint, 4, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__2)) __PYX_ERR(0, 4, __pyx_L1_error)\n\n  /* \"clickhouse_driver/varint.pyx\":29\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.\n */\n  __pyx_tuple__3 = PyTuple_Pack(5, __pyx_n_s_f, __pyx_n_s_shift, __pyx_n_s_result, __pyx_n_s_i, __pyx_n_s_read_one); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 29, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_tuple__3);\n  __Pyx_GIVEREF(__pyx_tuple__3);\n  __pyx_codeobj__4 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_clickhouse_driver_varint_pyx, __pyx_n_s_read_varint, 29, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__4)) __PYX_ERR(0, 29, __pyx_L1_error)\n  __Pyx_RefNannyFinishContext();\n  return 0;\n  __pyx_L1_error:;\n  __Pyx_RefNannyFinishContext();\n  return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 165,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1212"
    },
    {
        "index": 166,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLitePackParams* data =\n      reinterpret_cast<TfLitePackParams*>(node->builtin_data);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      return PackImpl<float>(context, node, output, data->values_count,\n                             data->axis);\n    }\n    case kTfLiteUInt8: {\n      return PackImpl<uint8_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt8: {\n      return PackImpl<int8_t>(context, node, output, data->values_count,\n                              data->axis);\n    }\n    case kTfLiteInt16: {\n      return PackImpl<int16_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt32: {\n      return PackImpl<int32_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt64: {\n      return PackImpl<int64_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by pack.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 167,
        "code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4043"
    },
    {
        "index": 168,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* op_data = static_cast<OpData*>(node->user_data);\n  // Inputs: box_encodings, scores, anchors\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  const TfLiteTensor* input_box_encodings =\n      GetInput(context, node, kInputTensorBoxEncodings);\n  const TfLiteTensor* input_class_predictions =\n      GetInput(context, node, kInputTensorClassPredictions);\n  const TfLiteTensor* input_anchors =\n      GetInput(context, node, kInputTensorAnchors);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_box_encodings), 3);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_class_predictions), 3);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_anchors), 2);\n  // number of detected boxes\n  const int num_detected_boxes =\n      op_data->max_detections * op_data->max_classes_per_detection;\n\n  // Outputs: detection_boxes, detection_scores, detection_classes,\n  // num_detections\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 4);\n  // Output Tensor detection_boxes: size is set to (1, num_detected_boxes, 4)\n  TfLiteTensor* detection_boxes =\n      GetOutput(context, node, kOutputTensorDetectionBoxes);\n  detection_boxes->type = kTfLiteFloat32;\n  SetTensorSizes(context, detection_boxes,\n                 {kBatchSize, num_detected_boxes, kNumCoordBox});\n\n  // Output Tensor detection_classes: size is set to (1, num_detected_boxes)\n  TfLiteTensor* detection_classes =\n      GetOutput(context, node, kOutputTensorDetectionClasses);\n  detection_classes->type = kTfLiteFloat32;\n  SetTensorSizes(context, detection_classes, {kBatchSize, num_detected_boxes});\n\n  // Output Tensor detection_scores: size is set to (1, num_detected_boxes)\n  TfLiteTensor* detection_scores =\n      GetOutput(context, node, kOutputTensorDetectionScores);\n  detection_scores->type = kTfLiteFloat32;\n  SetTensorSizes(context, detection_scores, {kBatchSize, num_detected_boxes});\n\n  // Output Tensor num_detections: size is set to 1\n  TfLiteTensor* num_detections =\n      GetOutput(context, node, kOutputTensorNumDetections);\n  num_detections->type = kTfLiteFloat32;\n  // TODO (chowdhery): Make it a scalar when available\n  SetTensorSizes(context, num_detections, {1});\n\n  // Temporary tensors\n  TfLiteIntArrayFree(node->temporaries);\n  node->temporaries = TfLiteIntArrayCreate(3);\n  node->temporaries->data[0] = op_data->decoded_boxes_index;\n  node->temporaries->data[1] = op_data->scores_index;\n  node->temporaries->data[2] = op_data->active_candidate_index;\n\n  // decoded_boxes\n  TfLiteTensor* decoded_boxes = &context->tensors[op_data->decoded_boxes_index];\n  decoded_boxes->type = kTfLiteFloat32;\n  decoded_boxes->allocation_type = kTfLiteArenaRw;\n  SetTensorSizes(context, decoded_boxes,\n                 {input_box_encodings->dims->data[1], kNumCoordBox});\n\n  // scores\n  TfLiteTensor* scores = &context->tensors[op_data->scores_index];\n  scores->type = kTfLiteFloat32;\n  scores->allocation_type = kTfLiteArenaRw;\n  SetTensorSizes(context, scores,\n                 {input_class_predictions->dims->data[1],\n                  input_class_predictions->dims->data[2]});\n\n  // active_candidate\n  TfLiteTensor* active_candidate =\n      &context->tensors[op_data->active_candidate_index];\n  active_candidate->type = kTfLiteUInt8;\n  active_candidate->allocation_type = kTfLiteArenaRw;\n  SetTensorSizes(context, active_candidate,\n                 {input_box_encodings->dims->data[1]});\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 169,
        "code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      // Unsupported, malformed, or trailing garbage. Release entire stack.\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1893"
    },
    {
        "index": 170,
        "code": "check_target_class(mrb_state *mrb)\n{\n  struct RClass *target = mrb_vm_ci_target_class(mrb->c->ci);\n  if (!target) {\n    mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n    mrb_exc_set(mrb, exc);\n  }\n  return target;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1934"
    },
    {
        "index": 171,
        "code": "mwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\n\tif (!adapter)\n\t\treturn -1;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\n\t/*\n\t * Fill in the parameters for 2 data structures:\n\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\n\t *   2. bss_desc\n\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\n\t * probe delay, and Cap info.\n\t * Firmware will fill up beacon period, Basic rates\n\t * and operational rates.\n\t */\n\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\n\t/* Set the BSS mode */\n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n\n\t/* Set Physical param set */\n/* Parameter IE Id */\n#define DS_PARA_IE_ID   3\n/* Parameter IE length */\n#define DS_PARA_IE_LEN  1\n\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\t/* Set IBSS param set */\n/* IBSS parameter IE Id */\n#define IBSS_PARA_IE_ID   6\n/* IBSS parameter IE length */\n#define IBSS_PARA_IE_LEN  2\n\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\n\t/* Set Capability info */\n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\n\t/* Set up privacy in bss_desc */\n\tif (priv->sec_info.encryption_mode) {\n\t\t/* Ad-Hoc capability privacy on */\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Find the last non zero */\n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\n\tpriv->curr_bss_params.num_of_rates = i;\n\n\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\n\tif (adapter->adhoc_11n_enabled) {\n\t\t/* Fill HT CAPABILITY */\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\n\t\t/* Fill HT INFORMATION */\n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36158"
    },
    {
        "index": 172,
        "code": "int CGIFFF DGifSlurp(CGIFFF GifFileType *GifFile)\n{\n    static unsigned InterlacedOffset[] = { 0, 4, 2, 1 }, /* The way Interlaced image should. */\n                    InterlacedJumps[] = { 8, 8, 4, 2 };  /* be read - offsets and jumps... */\n    /**** pts: unused vars ****/\n    /* int i, j, Error, ImageSize; */\n    int ext_code;\n\n    GifRecordType RecordType;\n    /**** pts ****/\n    SavedImage *sp=0; /**** pts: avoid gcc warning */\n    /** Extension info of next SavedImage */\n    SavedImage ext;\n    /** No-extension info */\n    SavedImage noext;\n\n    GifByteType *ExtData;\n\n    /**** pts ****/\n    memset(&noext, 0, sizeof(noext));\n    noext.delay=0;\n    noext.dispose=0;\n    noext.iter=1;\n    noext.transp=(-1);\n    noext.ExtensionBlocks=NULL;\n    noext.ExtensionBlockCount=0;\n    ext=noext;\n\n    /**** pts ****/\n    GifFile->SavedImages=0;\n\n    do {\n\tif (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)\n\t    return(GIF_ERROR);\n\n\tswitch (RecordType) {\n\t    case IMAGE_DESC_RECORD_TYPE:\n\t\tif (DGifGetImageDesc(GifFile) == GIF_ERROR)\n\t\t    return(GIF_ERROR);\n\n                /**** pts: DGifGetImageDesc has already allocated the mem ****/\n\t\tsp = &GifFile->SavedImages[GifFile->ImageCount-1];\n\t\t/**** pts: apply extensions to the image just read */\n\t\text.RasterBits=sp->RasterBits;\n\t\text.ImageDesc=sp->ImageDesc;\n\t\t*sp=ext;\n\t\text=noext;\n\n\t\t/**** pts ****/\n\t\tsp->RasterBits = (GifPixelType*) xmalloc((0L+sp->ImageDesc.Width) * sp->ImageDesc.Height * sizeof(GifPixelType));\n\t\tif (sp->ImageDesc.Interlace) {\n\t\t  unsigned i, j, Height=sp->ImageDesc.Height, Width=sp->ImageDesc.Width;\n\t\t  /* Need to perform 4 passes on the images: */\n \t\t  for (i = 0; i < 4; i++)\n\t\t    for (j = InterlacedOffset[i]; j < Height; j += InterlacedJumps[i])\n\t\t      if (DGifGetLine(GifFile, sp->RasterBits+Width*j, Width) != GIF_OK) return GIF_ERROR;\n\t\t} else {\n\t\t  if (DGifGetLine(GifFile, sp->RasterBits, (0L+sp->ImageDesc.Width) * sp->ImageDesc.Height)\n\t\t      == GIF_ERROR)\n\t\t      return(GIF_ERROR);\n\t\t}\n\t\tbreak;\n\n\t    case EXTENSION_RECORD_TYPE:\n\n\t\tif (DGifGetExtension(GifFile,&ext_code,&ExtData)==GIF_ERROR)\n\t\t    return(GIF_ERROR);\n\t\tif (ExtData!=NULL) {\n\t\t    #if 0 /**** pts ****/\n\t\t      ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];\n\t\t      ep->ByteCount = ExtData[0];\n\t\t      ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));\n\t\t      memcpy(ep->Bytes, ExtData, ep->ByteCount * sizeof(char));\n\t\t    #else\n                      /**** pts ****/\n                      if (0xf9==(unsigned char)(ext_code)) {\n                        if (ExtData[0] < 4) { ext_too_short:\n                          _GifError = D_GIF_ERR_EXT_TOO_SHORT;\n                          return GIF_ERROR;\n                        }\n                        ext.dispose=ExtData[1]>>2;\n                        ext.delay=(ExtData[3] << 8) | ExtData[2];\n                        if ((ExtData[1] & 0x01) == 1) {\n                          if (ExtData[0] < 5) goto ext_too_short;\n                          ext.transp=ExtData[4];\n                        }\n                      } else if (0xff==(unsigned char)(ext_code)) {\n                        if (ExtData[0] < 4) goto ext_too_short;\n                        ext.iter=(ExtData[3] << 8) | ExtData[2];\n                      } else {\n                        AddExtensionBlock(&ext, ExtData[0], ExtData+1);\n                        ext.ExtensionBlocks[ext.ExtensionBlockCount-1].code=ext_code;\n                      }\n\t\t    #endif\n\t\t    while (1) {\n\t\t        if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)\n\t\t\t  return(GIF_ERROR);\n\t\t        #if 0 /**** pts ****/\n  \t\t\t  ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];\n  \t\t\t  ep->ByteCount = ExtData[0];\n\t\t\t  ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));\n  \t\t\t  memcpy(ep->Bytes,ExtData,ep->ByteCount * sizeof(char));\n  \t\t\t#else\n  \t\t\t  if (ExtData==NULL) break;\n  \t\t\t  AddExtensionBlock(sp, ExtData[0], ExtData+1);\n  \t\t\t#endif\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case TERMINATE_RECORD_TYPE:\n\t\tbreak;\n\n\t    default:\t/* Should be trapped by DGifGetRecordType */\n\t\tbreak;\n\t}\n    }\n    while\n\t(RecordType != TERMINATE_RECORD_TYPE);\n\n    return(GIF_OK);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-19491"
    },
    {
        "index": 173,
        "code": "TfLiteStatus NonMaxSuppressionSingleClassHelper(\n    TfLiteContext* context, TfLiteNode* node, OpData* op_data,\n    const std::vector<float>& scores, std::vector<int>* selected,\n    int max_detections) {\n  const TfLiteTensor* input_box_encodings =\n      GetInput(context, node, kInputTensorBoxEncodings);\n  const TfLiteTensor* decoded_boxes =\n      &context->tensors[op_data->decoded_boxes_index];\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const float non_max_suppression_score_threshold =\n      op_data->non_max_suppression_score_threshold;\n  const float intersection_over_union_threshold =\n      op_data->intersection_over_union_threshold;\n  // Maximum detections should be positive.\n  TF_LITE_ENSURE(context, (max_detections >= 0));\n  // intersection_over_union_threshold should be positive\n  // and should be less than 1.\n  TF_LITE_ENSURE(context, (intersection_over_union_threshold > 0.0f) &&\n                              (intersection_over_union_threshold <= 1.0f));\n  // Validate boxes\n  TF_LITE_ENSURE(context, ValidateBoxes(decoded_boxes, num_boxes));\n\n  // threshold scores\n  std::vector<int> keep_indices;\n  // TODO (chowdhery): Remove the dynamic allocation and replace it\n  // with temporaries, esp for std::vector<float>\n  std::vector<float> keep_scores;\n  SelectDetectionsAboveScoreThreshold(\n      scores, non_max_suppression_score_threshold, &keep_scores, &keep_indices);\n\n  int num_scores_kept = keep_scores.size();\n  std::vector<int> sorted_indices;\n  sorted_indices.resize(num_scores_kept);\n  DecreasingPartialArgSort(keep_scores.data(), num_scores_kept, num_scores_kept,\n                           sorted_indices.data());\n  const int num_boxes_kept = num_scores_kept;\n  const int output_size = std::min(num_boxes_kept, max_detections);\n  selected->clear();\n  TfLiteTensor* active_candidate =\n      &context->tensors[op_data->active_candidate_index];\n  TF_LITE_ENSURE(context, (active_candidate->dims->data[0]) == num_boxes);\n  int num_active_candidate = num_boxes_kept;\n  uint8_t* active_box_candidate = (active_candidate->data.uint8);\n  for (int row = 0; row < num_boxes_kept; row++) {\n    active_box_candidate[row] = 1;\n  }\n\n  for (int i = 0; i < num_boxes_kept; ++i) {\n    if (num_active_candidate == 0 || selected->size() >= output_size) break;\n    if (active_box_candidate[i] == 1) {\n      selected->push_back(keep_indices[sorted_indices[i]]);\n      active_box_candidate[i] = 0;\n      num_active_candidate--;\n    } else {\n      continue;\n    }\n    for (int j = i + 1; j < num_boxes_kept; ++j) {\n      if (active_box_candidate[j] == 1) {\n        float intersection_over_union = ComputeIntersectionOverUnion(\n            decoded_boxes, keep_indices[sorted_indices[i]],\n            keep_indices[sorted_indices[j]]);\n\n        if (intersection_over_union > intersection_over_union_threshold) {\n          active_box_candidate[j] = 0;\n          num_active_candidate--;\n        }\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 174,
        "code": "const TfLiteTensor* GetInput(const TfLiteContext* context,\n                             const TfLiteNode* node, int index) {\n  return GetMutableInput(context, node, index);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 175,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n\n  const RuntimeShape input_shape = GetTensorShape(input);\n  const RuntimeShape output_shape = GetTensorShape(output);\n\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      // Float to int8, uint8, int16.\n      tflite::QuantizationParams op_params;\n      op_params.zero_point = output->params.zero_point;\n      op_params.scale = output->params.scale;\n      const float* input_data = GetTensorData<float>(input);\n      switch (output->type) {\n        case kTfLiteInt8:\n          AffineQuantize<kernel_type>(op_params, input_shape, input_data,\n                                      output_shape,\n                                      GetTensorData<int8_t>(output));\n          return kTfLiteOk;\n        case kTfLiteUInt8:\n          AffineQuantize<kernel_type>(op_params, input_shape, input_data,\n                                      output_shape,\n                                      GetTensorData<uint8_t>(output));\n          return kTfLiteOk;\n        case kTfLiteInt16:\n          AffineQuantize<kernel_type>(op_params, input_shape, input_data,\n                                      output_shape,\n                                      GetTensorData<int16_t>(output));\n          return kTfLiteOk;\n        default:\n          ReportError(context, input->type, output->type);\n          return kTfLiteError;\n      }\n    }\n    case kTfLiteInt16: {\n      // int16 to int8 or int16.\n      switch (output->type) {\n        case kTfLiteInt8:\n          Requantize<kernel_type>(GetTensorData<int16_t>(input),\n                                  MatchingFlatSize(input_shape, output_shape),\n                                  data->output_multiplier, data->output_shift,\n                                  input->params.zero_point,\n                                  output->params.zero_point,\n                                  GetTensorData<int8_t>(output));\n          return kTfLiteOk;\n        case kTfLiteInt16:\n          Requantize<kernel_type>(GetTensorData<int16_t>(input),\n                                  MatchingFlatSize(input_shape, output_shape),\n                                  data->output_multiplier, data->output_shift,\n                                  input->params.zero_point,\n                                  output->params.zero_point,\n                                  GetTensorData<int16_t>(output));\n          return kTfLiteOk;\n        default:\n          ReportError(context, input->type, output->type);\n          return kTfLiteError;\n      }\n    }\n    case kTfLiteInt8: {\n      // int8 to int8, uint8.\n      const int32_t size = MatchingFlatSize(input_shape, output_shape);\n      const int8_t* input_data = GetTensorData<int8_t>(input);\n      switch (output->type) {\n        case kTfLiteInt8:\n          Requantize<kernel_type>(input_data, size, data->output_multiplier,\n                                  data->output_shift, input->params.zero_point,\n                                  output->params.zero_point,\n                                  GetTensorData<int8_t>(output));\n          return kTfLiteOk;\n        case kTfLiteUInt8:\n          Requantize<kernel_type>(input_data, size, data->output_multiplier,\n                                  data->output_shift, input->params.zero_point,\n                                  output->params.zero_point,\n                                  GetTensorData<uint8_t>(output));\n          return kTfLiteOk;\n        default:\n          ReportError(context, input->type, output->type);\n          return kTfLiteError;\n      }\n    }\n    case kTfLiteUInt8: {\n      // uint8 to int8, uint8.\n      const int32_t size = MatchingFlatSize(input_shape, output_shape);\n      const uint8_t* input_data = GetTensorData<uint8_t>(input);\n      switch (output->type) {\n        case kTfLiteInt8:\n          Requantize<kernel_type>(input_data, size, data->output_multiplier,\n                                  data->output_shift, input->params.zero_point,\n                                  output->params.zero_point,\n                                  GetTensorData<int8_t>(output));\n          return kTfLiteOk;\n        case kTfLiteUInt8:\n          Requantize<kernel_type>(input_data, size, data->output_multiplier,\n                                  data->output_shift, input->params.zero_point,\n                                  output->params.zero_point,\n                                  GetTensorData<uint8_t>(output));\n          return kTfLiteOk;\n        default:\n          ReportError(context, input->type, output->type);\n          return kTfLiteError;\n      }\n    }\n    default:\n      ReportError(context, input->type, output->type);\n      return kTfLiteError;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 176,
        "code": "TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,\n                      TfLiteNode* node) {\n  // Map from value, to index in the unique elements vector.\n  // Note that we prefer to use map than unordered_map as it showed less\n  // increase in the binary size.\n  std::map<T, int> unique_values;\n  TfLiteTensor* output_indexes = GetOutput(context, node, 1);\n  std::vector<T> output_values;\n  I* indexes = GetTensorData<I>(output_indexes);\n  const T* data = GetTensorData<T>(input);\n  const int num_elements = NumElements(input);\n\n  for (int i = 0; i < num_elements; ++i) {\n    const auto element_it = unique_values.find(data[i]);\n    if (element_it != unique_values.end()) {\n      indexes[i] = element_it->second;\n    } else {\n      const int unique_index = unique_values.size();\n      unique_values[data[i]] = unique_index;\n      indexes[i] = unique_index;\n      output_values.push_back(data[i]);\n    }\n  }\n  // Allocate output tensor.\n  TfLiteTensor* unique_output = GetOutput(context, node, 0);\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(NumDimensions(input)), TfLiteIntArrayFree);\n  shape->data[0] = unique_values.size();\n  TF_LITE_ENSURE_STATUS(\n      context->ResizeTensor(context, unique_output, shape.release()));\n  // Set the values in the output tensor.\n  T* output_unique_values = GetTensorData<T>(unique_output);\n  for (int i = 0; i < output_values.size(); ++i) {\n    output_unique_values[i] = output_values[i];\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 177,
        "code": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-23928"
    },
    {
        "index": 178,
        "code": "mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4110"
    },
    {
        "index": 179,
        "code": "MONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n\n    return BSON_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 180,
        "code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1899"
    },
    {
        "index": 181,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* axis = GetInput(context, node, kAxis);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  output->type = input->type;\n  if (IsConstantTensor(axis)) {\n    int axis_value;\n    TF_LITE_ENSURE_OK(context,\n                      GetAxisValueFromTensor(context, *axis, &axis_value));\n    return ExpandTensorDim(context, *input, axis_value, output);\n  }\n  SetTensorToDynamic(output);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 182,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  ruy::profiler::ScopeLabel label(\"MirrorPad\");\n  const TfLiteTensor* input_tensor = GetInput(context, node, 0);\n  const TfLiteTensor* padding_matrix = GetInput(context, node, 1);\n  auto* params =\n      reinterpret_cast<TfLiteMirrorPaddingParams*>(node->builtin_data);\n\n  if (params == nullptr) {\n    return kTfLiteError;\n  }\n  const int input_dims = NumDimensions(input_tensor);\n\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n  if (IsDynamicTensor(output_tensor)) {\n    auto output_size = GetPaddedOutputShape(input_tensor, padding_matrix);\n    if (output_size == nullptr) {\n      return kTfLiteError;\n    }\n    TF_LITE_ENSURE_STATUS(\n        context->ResizeTensor(context, output_tensor, output_size.release()));\n  }\n\n  std::vector<int> output_dims_num_elements(input_dims, 1);\n  std::vector<int> input_dims_num_elements(input_dims, 1);\n  for (int i = input_dims - 2; i >= 0; i--) {\n    output_dims_num_elements[i] =\n        output_dims_num_elements[i + 1] * output_tensor->dims->data[i + 1];\n    input_dims_num_elements[i] =\n        input_dims_num_elements[i + 1] * input_tensor->dims->data[i + 1];\n  }\n\n  const int offset =\n      params->mode != TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect ? 0\n                                                                           : 1;\n\n  CpuBackendContext* cpu_backend_context =\n      CpuBackendContext::GetFromContext(context);\n  const int thread_count = cpu_backend_context->max_num_threads();\n  TfLiteStatus status = kTfLiteOk;\n  const int output_size = NumElements(output_tensor);\n#define TF_LITE_MIRROR_PAD(type)                                           \\\n  EvalData<type> eval_data;                                                \\\n  eval_data.input_data = GetTensorData<type>(input_tensor);                \\\n  eval_data.input_dims = input_tensor->dims;                               \\\n  eval_data.input_dims = input_tensor->dims;                               \\\n  eval_data.output_dims_num_elements = &output_dims_num_elements;          \\\n  eval_data.input_dims_num_elements = &input_dims_num_elements;            \\\n  eval_data.num_dims = input_dims;                                         \\\n  eval_data.offset = offset;                                               \\\n  eval_data.output_data = GetTensorData<type>(output_tensor);              \\\n  eval_data.padding_matrix = padding_matrix;                               \\\n  std::vector<MirrorPadWorkerTask<type>> tasks;                            \\\n  tasks.reserve(thread_count);                                             \\\n  int start = 0;                                                           \\\n  for (int i = 0; i < thread_count; ++i) {                                 \\\n    int end = start + (output_size - start) / (thread_count - i);          \\\n    tasks.emplace_back(MirrorPadWorkerTask<type>(&eval_data, start, end)); \\\n    start = end;                                                           \\\n  }                                                                        \\\n  cpu_backend_threadpool::Execute(tasks.size(), tasks.data(),              \\\n                                  cpu_backend_context);\n\n  switch (output_tensor->type) {\n    case kTfLiteFloat32: {\n      TF_LITE_MIRROR_PAD(float);\n      break;\n    }\n    case kTfLiteInt32: {\n      TF_LITE_MIRROR_PAD(int32_t);\n      break;\n    }\n    case kTfLiteUInt8: {\n      TF_LITE_MIRROR_PAD(uint8_t);\n      break;\n    }\n    case kTfLiteInt8: {\n      TF_LITE_MIRROR_PAD(int8_t);\n      break;\n    }\n    case kTfLiteInt64: {\n      TF_LITE_MIRROR_PAD(int64_t);\n      break;\n    }\n    default:\n      status = kTfLiteError;\n      break;\n  }\n#undef TF_LITE_MIRROR_PAD\n  return status;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 183,
        "code": "static char *BF_crypt(const char *key, const char *setting,\n  char *output, int size,\n  BF_word min)\n{\n#if BF_ASM\n  extern void _BF_body_r(BF_ctx *ctx);\n#endif\n  static const unsigned char flags_by_subtype[26] =\n    {2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0};\n  struct {\n    BF_ctx ctx;\n    BF_key expanded_key;\n    union {\n      BF_word salt[4];\n      BF_word output[6];\n    } binary;\n  } data;\n  BF_word L, R;\n  BF_word tmp1, tmp2, tmp3, tmp4;\n  BF_word *ptr;\n  BF_word count;\n  int i;\n\n  if (size < 7 + 22 + 31 + 1) {\n    __set_errno(ERANGE);\n    return NULL;\n  }\n\n  if (setting[0] != '$' ||\n      setting[1] != '2' ||\n      setting[2] < 'a' || setting[2] > 'z' ||\n      !flags_by_subtype[(unsigned int)(unsigned char)setting[2] - 'a'] ||\n      setting[3] != '$' ||\n      setting[4] < '0' || setting[4] > '3' ||\n      setting[5] < '0' || setting[5] > '9' ||\n      (setting[4] == '3' && setting[5] > '1') ||\n      setting[6] != '$') {\n    __set_errno(EINVAL);\n    return NULL;\n  }\n\n  count = (BF_word)1 << ((setting[4] - '0') * 10 + (setting[5] - '0'));\n  if (count < min || BF_decode(data.binary.salt, &setting[7], 16)) {\n    __set_errno(EINVAL);\n    return NULL;\n  }\n  BF_swap(data.binary.salt, 4);\n\n  BF_set_key(key, data.expanded_key, data.ctx.P,\n      flags_by_subtype[(unsigned int)(unsigned char)setting[2] - 'a']);\n\n  memcpy(data.ctx.S, BF_init_state.S, sizeof(data.ctx.S));\n\n  L = R = 0;\n  for (i = 0; i < BF_N + 2; i += 2) {\n    L ^= data.binary.salt[i & 2];\n    R ^= data.binary.salt[(i & 2) + 1];\n    BF_ENCRYPT;\n    data.ctx.P[i] = L;\n    data.ctx.P[i + 1] = R;\n  }\n\n  ptr = data.ctx.S[0];\n  do {\n    ptr += 4;\n    L ^= data.binary.salt[(BF_N + 2) & 3];\n    R ^= data.binary.salt[(BF_N + 3) & 3];\n    BF_ENCRYPT;\n    *(ptr - 4) = L;\n    *(ptr - 3) = R;\n\n    L ^= data.binary.salt[(BF_N + 4) & 3];\n    R ^= data.binary.salt[(BF_N + 5) & 3];\n    BF_ENCRYPT;\n    *(ptr - 2) = L;\n    *(ptr - 1) = R;\n  } while (ptr < &data.ctx.S[3][0xFF]);\n\n  do {\n    int done;\n\n    for (i = 0; i < BF_N + 2; i += 2) {\n      data.ctx.P[i] ^= data.expanded_key[i];\n      data.ctx.P[i + 1] ^= data.expanded_key[i + 1];\n    }\n\n    done = 0;\n    do {\n      BF_body();\n      if (done)\n        break;\n      done = 1;\n\n      tmp1 = data.binary.salt[0];\n      tmp2 = data.binary.salt[1];\n      tmp3 = data.binary.salt[2];\n      tmp4 = data.binary.salt[3];\n      for (i = 0; i < BF_N; i += 4) {\n        data.ctx.P[i] ^= tmp1;\n        data.ctx.P[i + 1] ^= tmp2;\n        data.ctx.P[i + 2] ^= tmp3;\n        data.ctx.P[i + 3] ^= tmp4;\n      }\n      data.ctx.P[16] ^= tmp1;\n      data.ctx.P[17] ^= tmp2;\n    } while (1);\n  } while (--count);\n\n  for (i = 0; i < 6; i += 2) {\n    L = BF_magic_w[i];\n    R = BF_magic_w[i + 1];\n\n    count = 64;\n    do {\n      BF_ENCRYPT;\n    } while (--count);\n\n    data.binary.output[i] = L;\n    data.binary.output[i + 1] = R;\n  }\n\n  memcpy(output, setting, 7 + 22 - 1);\n  output[7 + 22 - 1] = BF_itoa64[(int)\n    BF_atoi64[(int)setting[7 + 22 - 1] - 0x20] & 0x30];\n\n/* This has to be bug-compatible with the original implementation, so\n * only encode 23 of the 24 bytes. :-) */\n  BF_swap(data.binary.output, 6);\n  BF_encode(&output[7 + 22], data.binary.output, 23);\n  output[7 + 22 + 31] = '\\0';\n\n  return output;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 184,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeBilinearParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_RESIZE_BILINEAR(type, datatype)                              \\\n  tflite::ResizeBilinearParams op_params;                                    \\\n  op_params.align_corners = params->align_corners;                           \\\n  op_params.half_pixel_centers = params->half_pixel_centers;                 \\\n  type::ResizeBilinear(op_params, GetTensorShape(input),                     \\\n                       GetTensorData<datatype>(input), GetTensorShape(size), \\\n                       GetTensorData<int32>(size), GetTensorShape(output),   \\\n                       GetTensorData<datatype>(output))\n\n    if (kernel_type == kReference) {\n      TF_LITE_RESIZE_BILINEAR(reference_ops, float);\n    }\n    if (kernel_type == kGenericOptimized || kernel_type == kNeonOptimized) {\n      TF_LITE_RESIZE_BILINEAR(optimized_ops, float);\n    }\n  } else if (output->type == kTfLiteUInt8) {\n    if (kernel_type == kReference) {\n      TF_LITE_RESIZE_BILINEAR(reference_ops, uint8_t);\n    }\n    if (kernel_type == kGenericOptimized || kernel_type == kNeonOptimized) {\n      TF_LITE_RESIZE_BILINEAR(optimized_ops, uint8_t);\n    }\n  } else if (output->type == kTfLiteInt8) {\n    TF_LITE_RESIZE_BILINEAR(reference_ops, int8_t);\n#undef TF_LITE_RESIZE_BILINEAR\n  } else {\n    context->ReportError(context, \"Output type is %d, requires float.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 185,
        "code": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tint i, err;\n\n\t/* if dst has more stack frames then src frame, free them */\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->curframe = src->curframe;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 186,
        "code": "int64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n  }\n  m_cursor += length;\n  return length;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 187,
        "code": "void FilterManager::decodeMetadata(ActiveStreamDecoderFilter* filter, MetadataMap& metadata_map) {\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    if ((*entry)->skipFilter()) {\n      continue;\n    }\n    // If the filter pointed by entry has stopped for all frame type, stores metadata and returns.\n    // If the filter pointed by entry hasn't returned from decodeHeaders, stores newly added\n    // metadata in case decodeHeaders returns StopAllIteration. The latter can happen when headers\n    // callbacks generate new metadata.\n    if (!(*entry)->decode_headers_called_ || (*entry)->stoppedAll()) {\n      Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n      (*entry)->getSavedRequestMetadata()->emplace_back(std::move(metadata_map_ptr));\n      return;\n    }\n\n    FilterMetadataStatus status = (*entry)->handle_->decodeMetadata(metadata_map);\n    ENVOY_STREAM_LOG(trace, \"decode metadata called: filter={} status={}, metadata: {}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status),\n                     metadata_map);\n  }\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43825"
    },
    {
        "index": 188,
        "code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 189,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_6__setstate_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *__pyx_v_self, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__setstate_cython__\", 0);\n\n  /* \"(tree fragment)\":17\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, state)\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedSocketWriter__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<\n */\n  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedSocketWriter__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":16\n *     else:\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, state)\n * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_unpickle_BufferedSocketWriter__set_state(self, __pyx_state)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedSocketWriter.__setstate_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 191,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString_4write_items(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_items, PyObject *__pyx_v_buf) {\n  Py_ssize_t __pyx_v_buf_pos;\n  Py_ssize_t __pyx_v_length;\n  Py_ssize_t __pyx_v_items_buf_size;\n  PyObject *__pyx_v_encoding = NULL;\n  char *__pyx_v_c_value;\n  char *__pyx_v_items_buf;\n  PyObject *__pyx_v_value = NULL;\n  Py_ssize_t __pyx_v_value_len;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  int __pyx_t_3;\n  PyObject *(*__pyx_t_4)(PyObject *);\n  PyObject *__pyx_t_5 = NULL;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  Py_ssize_t __pyx_t_8;\n  char *__pyx_t_9;\n  __Pyx_RefNannySetupContext(\"write_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":84\n * \n *     def write_items(self, items, buf):\n *         cdef Py_ssize_t buf_pos = 0             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t length = self.length\n *         cdef Py_ssize_t items_buf_size = length * len(items)\n */\n  __pyx_v_buf_pos = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":85\n *     def write_items(self, items, buf):\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t items_buf_size = length * len(items)\n *         encoding = self.encoding\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 85, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_length = __pyx_t_2;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":86\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length\n *         cdef Py_ssize_t items_buf_size = length * len(items)             # <<<<<<<<<<<<<<\n *         encoding = self.encoding\n * \n */\n  __pyx_t_2 = PyObject_Length(__pyx_v_items); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 86, __pyx_L1_error)\n  __pyx_v_items_buf_size = (__pyx_v_length * __pyx_t_2);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":87\n *         cdef Py_ssize_t length = self.length\n *         cdef Py_ssize_t items_buf_size = length * len(items)\n *         encoding = self.encoding             # <<<<<<<<<<<<<<\n * \n *         cdef char* c_value\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_encoding); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_encoding = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":90\n * \n *         cdef char* c_value\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)             # <<<<<<<<<<<<<<\n *         if not items_buf:\n *             raise MemoryError()\n */\n  __pyx_v_items_buf = ((char *)PyMem_Malloc(__pyx_v_items_buf_size));\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":91\n *         cdef char* c_value\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)\n *         if not items_buf:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n * \n */\n  __pyx_t_3 = ((!(__pyx_v_items_buf != 0)) != 0);\n  if (unlikely(__pyx_t_3)) {\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":92\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)\n *         if not items_buf:\n *             raise MemoryError()             # <<<<<<<<<<<<<<\n * \n *         memset(items_buf, 0, items_buf_size)\n */\n    PyErr_NoMemory(); __PYX_ERR(0, 92, __pyx_L1_error)\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":91\n *         cdef char* c_value\n *         cdef char* items_buf = <char *>PyMem_Malloc(items_buf_size)\n *         if not items_buf:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n * \n */\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":94\n *             raise MemoryError()\n * \n *         memset(items_buf, 0, items_buf_size)             # <<<<<<<<<<<<<<\n * \n *         for value in items:\n */\n  (void)(memset(__pyx_v_items_buf, 0, __pyx_v_items_buf_size));\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":96\n *         memset(items_buf, 0, items_buf_size)\n * \n *         for value in items:             # <<<<<<<<<<<<<<\n *             if not PyBytes_Check(value):\n *                 value = value.encode(encoding)\n */\n  if (likely(PyList_CheckExact(__pyx_v_items)) || PyTuple_CheckExact(__pyx_v_items)) {\n    __pyx_t_1 = __pyx_v_items; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;\n    __pyx_t_4 = NULL;\n  } else {\n    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 96, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __pyx_t_4 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 96, __pyx_L1_error)\n  }\n  for (;;) {\n    if (likely(!__pyx_t_4)) {\n      if (likely(PyList_CheckExact(__pyx_t_1))) {\n        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;\n        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS\n        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_5); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 96, __pyx_L1_error)\n        #else\n        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 96, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        #endif\n      } else {\n        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;\n        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS\n        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_5); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 96, __pyx_L1_error)\n        #else\n        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 96, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        #endif\n      }\n    } else {\n      __pyx_t_5 = __pyx_t_4(__pyx_t_1);\n      if (unlikely(!__pyx_t_5)) {\n        PyObject* exc_type = PyErr_Occurred();\n        if (exc_type) {\n          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();\n          else __PYX_ERR(0, 96, __pyx_L1_error)\n        }\n        break;\n      }\n      __Pyx_GOTREF(__pyx_t_5);\n    }\n    __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_5);\n    __pyx_t_5 = 0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":97\n * \n *         for value in items:\n *             if not PyBytes_Check(value):             # <<<<<<<<<<<<<<\n *                 value = value.encode(encoding)\n * \n */\n    __pyx_t_3 = ((!(PyBytes_Check(__pyx_v_value) != 0)) != 0);\n    if (__pyx_t_3) {\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":98\n *         for value in items:\n *             if not PyBytes_Check(value):\n *                 value = value.encode(encoding)             # <<<<<<<<<<<<<<\n * \n *             value_len = len(value)\n */\n      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_encode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 98, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_6);\n      __pyx_t_7 = NULL;\n      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {\n        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);\n        if (likely(__pyx_t_7)) {\n          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);\n          __Pyx_INCREF(__pyx_t_7);\n          __Pyx_INCREF(function);\n          __Pyx_DECREF_SET(__pyx_t_6, function);\n        }\n      }\n      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_encoding) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_encoding);\n      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;\n      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 98, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n      __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_5);\n      __pyx_t_5 = 0;\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":97\n * \n *         for value in items:\n *             if not PyBytes_Check(value):             # <<<<<<<<<<<<<<\n *                 value = value.encode(encoding)\n * \n */\n    }\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":100\n *                 value = value.encode(encoding)\n * \n *             value_len = len(value)             # <<<<<<<<<<<<<<\n *             if length < value_len:\n *                 raise errors.TooLargeStringSize()\n */\n    __pyx_t_8 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 100, __pyx_L1_error)\n    __pyx_v_value_len = __pyx_t_8;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":101\n * \n *             value_len = len(value)\n *             if length < value_len:             # <<<<<<<<<<<<<<\n *                 raise errors.TooLargeStringSize()\n * \n */\n    __pyx_t_3 = ((__pyx_v_length < __pyx_v_value_len) != 0);\n    if (unlikely(__pyx_t_3)) {\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":102\n *             value_len = len(value)\n *             if length < value_len:\n *                 raise errors.TooLargeStringSize()             # <<<<<<<<<<<<<<\n * \n *             c_value = PyBytes_AsString(value)\n */\n      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_errors); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 102, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_6);\n      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_TooLargeStringSize); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 102, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_7);\n      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n      __pyx_t_6 = NULL;\n      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {\n        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_7);\n        if (likely(__pyx_t_6)) {\n          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);\n          __Pyx_INCREF(__pyx_t_6);\n          __Pyx_INCREF(function);\n          __Pyx_DECREF_SET(__pyx_t_7, function);\n        }\n      }\n      __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_7);\n      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;\n      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 102, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n      __Pyx_Raise(__pyx_t_5, 0, 0, 0);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __PYX_ERR(0, 102, __pyx_L1_error)\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":101\n * \n *             value_len = len(value)\n *             if length < value_len:             # <<<<<<<<<<<<<<\n *                 raise errors.TooLargeStringSize()\n * \n */\n    }\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":104\n *                 raise errors.TooLargeStringSize()\n * \n *             c_value = PyBytes_AsString(value)             # <<<<<<<<<<<<<<\n * \n *             memcpy(&items_buf[buf_pos], c_value, value_len)\n */\n    __pyx_t_9 = PyBytes_AsString(__pyx_v_value); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(0, 104, __pyx_L1_error)\n    __pyx_v_c_value = __pyx_t_9;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":106\n *             c_value = PyBytes_AsString(value)\n * \n *             memcpy(&items_buf[buf_pos], c_value, value_len)             # <<<<<<<<<<<<<<\n *             buf_pos += length\n * \n */\n    (void)(memcpy((&(__pyx_v_items_buf[__pyx_v_buf_pos])), __pyx_v_c_value, __pyx_v_value_len));\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":107\n * \n *             memcpy(&items_buf[buf_pos], c_value, value_len)\n *             buf_pos += length             # <<<<<<<<<<<<<<\n * \n *         buf.write(PyBytes_FromStringAndSize(items_buf, items_buf_size))\n */\n    __pyx_v_buf_pos = (__pyx_v_buf_pos + __pyx_v_length);\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":96\n *         memset(items_buf, 0, items_buf_size)\n * \n *         for value in items:             # <<<<<<<<<<<<<<\n *             if not PyBytes_Check(value):\n *                 value = value.encode(encoding)\n */\n  }\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":109\n *             buf_pos += length\n * \n *         buf.write(PyBytes_FromStringAndSize(items_buf, items_buf_size))             # <<<<<<<<<<<<<<\n * \n *         PyMem_Free(items_buf)\n */\n  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_write); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 109, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_5);\n  __pyx_t_7 = PyBytes_FromStringAndSize(__pyx_v_items_buf, __pyx_v_items_buf_size); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_7);\n  __pyx_t_6 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {\n    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);\n    if (likely(__pyx_t_6)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);\n      __Pyx_INCREF(__pyx_t_6);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_5, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;\n  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":111\n *         buf.write(PyBytes_FromStringAndSize(items_buf, items_buf_size))\n * \n *         PyMem_Free(items_buf)             # <<<<<<<<<<<<<<\n * \n * \n */\n  PyMem_Free(__pyx_v_items_buf);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":83\n *         return items\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_encoding);\n  __Pyx_XDECREF(__pyx_v_value);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 192,
        "code": "void FillDiagHelper(const TfLiteTensor* input, const TfLiteTensor* diag,\n                    TfLiteTensor* output) {\n  const int num_output_dims = output->dims->size;\n  int batch_size = 1;\n  for (int i = 0; i < num_output_dims - 2; ++i) {\n    batch_size *= output->dims->data[i];\n  }\n\n  const int row_size = output->dims->data[num_output_dims - 2];\n  const int col_size = output->dims->data[num_output_dims - 1];\n  switch (output->type) {\n    case kTfLiteInt64: {\n      return FillDiag<int64_t>(input, diag, output, batch_size, row_size,\n                               col_size);\n    }\n    case kTfLiteInt32: {\n      return FillDiag<int32_t>(input, diag, output, batch_size, row_size,\n                               col_size);\n    }\n    case kTfLiteInt16: {\n      return FillDiag<int16_t>(input, diag, output, batch_size, row_size,\n                               col_size);\n    }\n    case kTfLiteInt8: {\n      return FillDiag<int8_t>(input, diag, output, batch_size, row_size,\n                              col_size);\n    }\n    case kTfLiteUInt8: {\n      return FillDiag<uint8_t>(input, diag, output, batch_size, row_size,\n                               col_size);\n    }\n    default:\n      return FillDiag<float>(input, diag, output, batch_size, row_size,\n                             col_size);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 193,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedreader_5__pyx_unpickle_CompressedBufferedReader(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v___pyx_type = 0;\n  long __pyx_v___pyx_checksum;\n  PyObject *__pyx_v___pyx_state = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_CompressedBufferedReader (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_CompressedBufferedReader\", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_CompressedBufferedReader\", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__pyx_unpickle_CompressedBufferedReader\") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v___pyx_type = values[0];\n    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)\n    __pyx_v___pyx_state = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_CompressedBufferedReader\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_CompressedBufferedReader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_4__pyx_unpickle_CompressedBufferedReader(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 194,
        "code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22874"
    },
    {
        "index": 195,
        "code": "static int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx,\n\t\t     int *insn_idx)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem, *head = env->head;\n\tint err;\n\n\tif (env->head == NULL)\n\t\treturn -ENOENT;\n\n\tif (cur) {\n\t\terr = copy_verifier_state(cur, &head->st);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (insn_idx)\n\t\t*insn_idx = head->insn_idx;\n\tif (prev_insn_idx)\n\t\t*prev_insn_idx = head->prev_insn_idx;\n\telem = head->next;\n\tfree_verifier_state(&head->st, false);\n\tkfree(head);\n\tenv->head = elem;\n\tenv->stack_size--;\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 196,
        "code": "sixel_allocator_calloc(\n    sixel_allocator_t   /* in */ *allocator,  /* allocator object */\n    size_t              /* in */ nelm,        /* number of elements */\n    size_t              /* in */ elsize)      /* size of element */\n{\n    /* precondition */\n    assert(allocator);\n    assert(allocator->fn_calloc);\n\n    return allocator->fn_calloc(nelm, elsize);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21049"
    },
    {
        "index": 197,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n\n  OpContext op_context(context, node);\n\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), op_context.params->num_splits);\n\n  auto input_type = op_context.input->type;\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt16 || input_type == kTfLiteInt32 ||\n                     input_type == kTfLiteInt64 || input_type == kTfLiteInt8);\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    GetOutput(context, node, i)->type = input_type;\n  }\n\n  auto size_splits = op_context.size_splits;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size_splits), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), NumElements(size_splits));\n\n  // If we know the contents of the 'size_splits' tensor and the 'axis' tensor,\n  // resize all outputs. Otherwise, wait until Eval().\n  if (IsConstantTensor(op_context.size_splits) &&\n      IsConstantTensor(op_context.axis)) {\n    return ResizeOutputTensors(context, node, op_context.input,\n                               op_context.size_splits, op_context.axis);\n  } else {\n    return UseDynamicOutputTensors(context, node);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 198,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      UnpackImpl<float>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt32: {\n      UnpackImpl<int32_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteUInt8: {\n      UnpackImpl<uint8_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt8: {\n      UnpackImpl<int8_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteBool: {\n      UnpackImpl<bool>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt16: {\n      UnpackImpl<int16_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by unpack.\",\n                           TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 199,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteSubParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  // 8bit -> 8bit general quantized path, with general rescalings\n  // as well as, 16bit -> 16bit with general rescalings\n  bool pot_scale_int16 = true;\n\n  bool input1_scale_is_pot = false;\n  bool input2_scale_is_pot = false;\n  bool output_scale_is_pot = false;\n\n  int input1_scale_log2_rounded{0};\n  int input2_scale_log2_rounded{0};\n  int output_scale_log2_rounded{0};\n\n  if (input1->type == kTfLiteInt16 && input2->type == kTfLiteInt16 &&\n      output->type == kTfLiteInt16) {\n    // In case of 16-bit, there are two implementation:\n    // the scale parameter is a general number\n    // the scale parameter is POT and\n    // zero_point is zero for inputs/output.\n    pot_scale_int16 = (input1->params.zero_point == 0) &&\n                      (input2->params.zero_point == 0) &&\n                      (output->params.zero_point == 0);\n\n    input1_scale_is_pot =\n        CheckedLog2(input1->params.scale, &input1_scale_log2_rounded);\n\n    input2_scale_is_pot =\n        CheckedLog2(input2->params.scale, &input2_scale_log2_rounded);\n\n    output_scale_is_pot =\n        CheckedLog2(output->params.scale, &output_scale_log2_rounded);\n\n    pot_scale_int16 &=\n        input1_scale_is_pot && input2_scale_is_pot && output_scale_is_pot;\n  }\n\n  data->pot_scale_int16 = pot_scale_int16;\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      !pot_scale_int16) {\n    TF_LITE_ENSURE_OK(context, PrepareGeneralSubOp(context, input1, input2,\n                                                   output, params, data, -1));\n  } else if (output->type == kTfLiteInt16) {\n    // LSTM-special case with scale parameter of POT\n    TF_LITE_ENSURE_OK(context, PrepareInt16SubOpPOT(context, input1, input2,\n                                                    output, params, data));\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 200,
        "code": "bool ActiveStreamDecoderFilter::canContinue() {\n  // It is possible for the connection manager to respond directly to a request even while\n  // a filter is trying to continue. If a response has already happened, we should not\n  // continue to further filters. A concrete example of this is a filter buffering data, the\n  // last data frame comes in and the filter continues, but the final buffering takes the stream\n  // over the high watermark such that a 413 is returned.\n  return !parent_.state_.local_complete_;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43825"
    },
    {
        "index": 201,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_14__setstate_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__setstate_cython__\", 0);\n\n  /* \"(tree fragment)\":17\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, state)\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedWriter__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<\n */\n  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedWriter__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":16\n *     else:\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, state)\n * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_unpickle_BufferedWriter__set_state(self, __pyx_state)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.__setstate_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 202,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader_6__setstate_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *__pyx_v_self, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__setstate_cython__\", 0);\n\n  /* \"(tree fragment)\":17\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, state)\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_CompressedBufferedReader__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<\n */\n  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_CompressedBufferedReader__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":16\n *     else:\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, state)\n * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_unpickle_CompressedBufferedReader__set_state(self, __pyx_state)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.CompressedBufferedReader.__setstate_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 203,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  const TfLiteTensor* multipliers = GetInput(context, node, kInputMultipliers);\n  // Only int32 and int64 multipliers type is supported.\n  if (multipliers->type != kTfLiteInt32 && multipliers->type != kTfLiteInt64) {\n    context->ReportError(context,\n                         \"Multipliers of type '%s' are not supported by tile.\",\n                         TfLiteTypeGetName(multipliers->type));\n    return kTfLiteError;\n  }\n\n  if (IsConstantTensor(multipliers)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 204,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_10ByteString_write_items(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_items, PyObject *__pyx_v_buf) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"write_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":38\n * \n *     def write_items(self, items, buf):\n *         buf.write_strings(items)             # <<<<<<<<<<<<<<\n * \n *     def read_items(self, n_items, buf):\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_write_strings); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 38, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_items) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_items);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":37\n *     null_value = b''\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         buf.write_strings(items)\n * \n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteString.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 206,
        "code": "TfLiteStatus FillString(const TfLiteTensor* value, TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const auto string_ref = GetString(value, 0);\n  int n = 1;\n  for (int i = 0; i < output->dims->size; ++i) {\n    n *= output->dims->data[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, /*new_shape=*/nullptr);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 207,
        "code": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-28097"
    },
    {
        "index": 208,
        "code": "MONGO_EXPORT int bson_append_code( bson *b, const char *name, const char *value ) {\n    return bson_append_string_base( b, name, value, strlen ( value ), BSON_CODE );\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 209,
        "code": "Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    \n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n        \n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n\n    if (r >= REG_BADPAT) {\n        char buf[100];\n\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    \n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 210,
        "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 211,
        "code": "TfLiteIntArray* MultiplyShapeDims(const TfLiteIntArray& shape,\n                                  const TfLiteTensor* multipliers,\n                                  int num_dimensions) {\n  const T* multipliers_v = GetTensorData<T>(multipliers);\n\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(num_dimensions);\n  for (int i = 0; i < num_dimensions; ++i) {\n    output_shape->data[i] = shape.data[i] * multipliers_v[i];\n  }\n  return output_shape;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 212,
        "code": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  // Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight = GetInput(context, node, 2);\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 213,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  if (type != kTfLiteInt32 && type != kTfLiteFloat32) {\n    TF_LITE_KERNEL_LOG(context, \"Unsupported data type %s.\",\n                       TfLiteTypeGetName(type));\n    return kTfLiteError;\n  }\n  output->type = type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 214,
        "code": "  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    OP_REQUIRES(\n        context, node_id_range_t->dims() == 1,\n        errors::InvalidArgument(\"node_id_range must be a rank 1 tensor, but \"\n                                \"given node_id_range has dims of \",\n                                node_id_range_t->dims()));\n    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,\n                errors::InvalidArgument(\n                    \"node_id_range must be a rank 1 tensor with shape=[2], but \"\n                    \"given node_id_range has shape \",\n                    node_id_range_t->dim_size(0), \" on its first dim\"));\n    const int32_t node_id_first = node_id_range(0);  // Inclusive.\n    const int32_t node_id_last = node_id_range(1);   // Exclusive.\n\n    // Get stats_summaries_list.\n    OpInputList stats_summaries_list;\n    OP_REQUIRES_OK(context, context->input_list(\"stats_summaries_list\",\n                                                &stats_summaries_list));\n\n    // Infer dimensions of a stats_summary.\n    DCHECK_GT(stats_summaries_list.size(), 0);\n    const int32_t feature_dims = stats_summaries_list[0].dim_size(1);\n    // The last bucket is for default/missing value.\n    const int32_t num_buckets = stats_summaries_list[0].dim_size(2) - 1;\n    const int32_t logits_dim = logits_dim_;\n    const int32_t hessian_dim =\n        stats_summaries_list[0].dim_size(3) - logits_dim;\n    DCHECK_GT(hessian_dim, 0);\n    DCHECK_LE(hessian_dim, logits_dim * logits_dim);\n\n    // Vector of stats_summaries; each element is stats for feature of shape\n    // [max_splits, feature_dim, num_buckets, logits_dim + hessian_dim].\n    std::vector<TTypes<float, 4>::ConstTensor> stats_summaries;\n    DCHECK_EQ(stats_summaries_list.size(), num_features_);\n    stats_summaries.reserve(num_features_);\n    for (const auto& tensor : stats_summaries_list) {\n      stats_summaries.emplace_back(tensor.tensor<float, 4>());\n    }\n\n    // Split types.\n    const Tensor* split_types_t;\n    OP_REQUIRES_OK(context, context->input(\"split_types\", &split_types_t));\n    const auto split_types = split_types_t->vec<tstring>();\n    DCHECK_EQ(split_types.size(), num_features_);\n    // Validate.\n    for (int i = 0; i < num_features_; ++i) {\n      if (!(split_types(i) == kInequalitySplit ||\n            split_types(i) == kEqualitySplit)) {\n        OP_REQUIRES_OK(\n            context,\n            errors::Aborted(\n                \"Operation received an exception: Incorrect split type\"));\n      }\n    }\n    // Feature ids.\n    const Tensor* candidate_feature_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"candidate_feature_ids\",\n                                           &candidate_feature_ids_t));\n    const auto candidate_feature_ids = candidate_feature_ids_t->vec<int32>();\n    DCHECK_EQ(candidate_feature_ids.size(), num_features_);\n\n    // L1, L2, tree_complexity, min_node_weight.\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n    DCHECK_GE(l1, 0);\n    if (logits_dim_ > 1) {\n      // Multi-class L1 regularization not supported yet.\n      DCHECK_EQ(l1, 0);\n    }\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n    DCHECK_GE(l2, 0);\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_ids;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<Eigen::VectorXf> output_left_node_contribs;\n    std::vector<Eigen::VectorXf> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    // TODO(tanzheny) parallelize the computation.\n    // Iterate each node and find the best gain per node.\n    float parent_gain;\n    for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {\n      float best_gain = std::numeric_limits<float>::lowest();\n      int32_t best_bucket;\n      int32_t best_f_id;\n      int32_t best_f_dim;\n      string best_split_type;\n      Eigen::VectorXf best_contrib_for_left(logits_dim);\n      Eigen::VectorXf best_contrib_for_right(logits_dim);\n\n      // Sum of gradient and hessian. Compute parent gain using first feature.\n      ConstMatrixMap stats_mat(&stats_summaries[0](node_id, 0, 0, 0),\n                               num_buckets + 1,  // Including default bucket.\n                               logits_dim + hessian_dim);\n      const Eigen::VectorXf total_grad =\n          stats_mat.leftCols(logits_dim).colwise().sum();\n      const Eigen::VectorXf total_hess =\n          stats_mat.rightCols(hessian_dim).colwise().sum();\n      if (total_hess.norm() < min_node_weight) {\n        continue;\n      }\n      Eigen::VectorXf unused(logits_dim);\n      CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &unused,\n                               &parent_gain);\n      for (int f_idx = 0; f_idx < num_features_; ++f_idx) {\n        const string split_type = split_types(f_idx);\n        TTypes<float, 4>::ConstTensor stats_summary = stats_summaries[f_idx];\n        float f_best_gain = std::numeric_limits<float>::lowest();\n        int32_t f_best_bucket;\n        int32_t f_best_f_dim;\n        string f_best_split_type;\n        Eigen::VectorXf f_best_contrib_for_left(logits_dim);\n        Eigen::VectorXf f_best_contrib_for_right(logits_dim);\n\n        if (split_type == kInequalitySplit) {\n          CalculateBestInequalitySplit(\n              stats_summary, node_id, feature_dims, logits_dim, hessian_dim,\n              num_buckets, min_node_weight, l1, l2, &f_best_gain,\n              &f_best_bucket, &f_best_f_dim, &f_best_split_type,\n              &f_best_contrib_for_left, &f_best_contrib_for_right);\n        } else {\n          CalculateBestEqualitySplit(\n              stats_summary, total_grad, total_hess, node_id, feature_dims,\n              logits_dim, hessian_dim, num_buckets, l1, l2, &f_best_gain,\n              &f_best_bucket, &f_best_f_dim, &f_best_split_type,\n              &f_best_contrib_for_left, &f_best_contrib_for_right);\n        }\n        if (f_best_gain > best_gain) {\n          best_gain = f_best_gain;\n          best_f_id = candidate_feature_ids(f_idx);\n          best_f_dim = f_best_f_dim;\n          best_split_type = f_best_split_type;\n          best_bucket = f_best_bucket;\n          best_contrib_for_left = f_best_contrib_for_left;\n          best_contrib_for_right = f_best_contrib_for_right;\n        }\n      }  // For feature id.\n      if (best_gain == std::numeric_limits<float>::lowest()) {\n        // Do not add the node if no split is found.\n        continue;\n      }\n      output_node_ids.push_back(node_id);\n      // Remove the parent gain for the parent node.\n      output_gains.push_back(best_gain - parent_gain);\n      output_feature_ids.push_back(best_f_id);\n      output_feature_dimensions.push_back(best_f_dim);\n      // Default direction is fixed for dense splits.\n      // TODO(tanzheny) account for default values.\n      output_split_types.push_back(best_split_type);\n      output_thresholds.push_back(best_bucket);\n      output_left_node_contribs.push_back(best_contrib_for_left);\n      output_right_node_contribs.push_back(best_contrib_for_right);\n    }  // for node id.\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_ids\n    Tensor* output_features_ids_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"feature_ids\", {num_nodes},\n                                                     &output_features_ids_t));\n    auto output_features_vec = output_features_ids_t->vec<int32>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"left_node_contribs\", {num_nodes, logits_dim},\n                                &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"right_node_contribs\", {num_nodes, logits_dim},\n                                &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      output_features_vec(i) = output_feature_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      for (int j = 0; j < logits_dim; ++j) {\n        output_left_node_contribs_matrix(i, j) =\n            output_left_node_contribs[i][j];\n        output_right_node_contribs_matrix(i, j) =\n            output_right_node_contribs[i][j];\n      }\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-41208"
    },
    {
        "index": 215,
        "code": "static Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[100];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 216,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_11FixedString_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_length = 0;\n  PyObject *__pyx_v_kwargs = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;\n  __Pyx_GOTREF(__pyx_v_kwargs);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_length,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_length)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, 1); __PYX_ERR(0, 47, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 47, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_length = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 47, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString___init__(__pyx_self, __pyx_v_self, __pyx_v_length, __pyx_v_kwargs);\n\n  /* function exit code */\n  __Pyx_XDECREF(__pyx_v_kwargs);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 217,
        "code": "static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int depth) {\n\tchar *bp_reg = NULL;\n\tchar *sp_reg = NULL;\n\tchar *op_dst = NULL;\n\tchar *op_src = NULL;\n\tif (depth < 1) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Too deep fcn_recurse at 0x%\"PFMT64x \"\\n\", addr);\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE TOO DEEP\n\t}\n\t// TODO Store all this stuff in the heap so we save memory in the stack\n\tRAnalOp *op = NULL;\n\tchar *movbasereg = NULL;\n\tconst int addrbytes = anal->iob.io ? anal->iob.io->addrbytes : 1;\n\tchar *last_reg_mov_lea_name = NULL;\n\tRAnalBlock *bb = NULL;\n\tRAnalBlock *bbg = NULL;\n\tint ret = R_ANAL_RET_END, skip_ret = 0;\n\tbool overlapped = false;\n\tint oplen, idx = 0;\n\tsize_t lea_cnt = 0;\n\tsize_t nop_prefix_cnt = 0;\n\tstatic ut64 cmpval = UT64_MAX; // inherited across functions, otherwise it breaks :?\n\tstruct {\n\t\tint cnt;\n\t\tint idx;\n\t\tint after;\n\t\tint pending;\n\t\tint adjust;\n\t\tint un_idx; // delay.un_idx\n\t} delay = {\n\t\t0\n\t};\n\tbool arch_destroys_dst = does_arch_destroys_dst (anal->cur->arch);\n\tconst bool is_arm = anal->cur->arch && !strncmp (anal->cur->arch, \"arm\", 3);\n\tconst bool is_v850 = is_arm ? false: (anal->cur->arch && (!strncmp (anal->cur->arch, \"v850\", 4) || !strncmp (anal->coreb.cfgGet (anal->coreb.core, \"asm.cpu\"), \"v850\", 4)));\n\tconst bool is_x86 = is_arm ? false: anal->cur->arch && !strncmp (anal->cur->arch, \"x86\", 3);\n\tconst bool is_amd64 = is_x86 ? fcn->cc && !strcmp (fcn->cc, \"amd64\") : false;\n\tconst bool is_dalvik = is_x86 ? false : anal->cur->arch && !strncmp (anal->cur->arch, \"dalvik\", 6);\n\tRRegItem *variadic_reg = NULL;\n\tif (is_amd64) {\n\t\tvariadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);\n\t}\n\tbool has_variadic_reg = !!variadic_reg;\n\n\tif (r_cons_is_breaked ()) {\n\t\treturn R_ANAL_RET_END;\n\t}\n\tif (anal->sleep) {\n\t\tr_sys_usleep (anal->sleep);\n\t}\n\n\t// check if address is readable //:\n\tif (!anal->iob.is_valid_offset (anal->iob.io, addr, 0)) {\n\t\tif (addr != UT64_MAX && !anal->iob.io->va) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Invalid address 0x%\"PFMT64x \". Try with io.va=true\\n\", addr);\n\t\t\t}\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE TOO DEEP\n\t}\n\n\tRAnalFunction *fcn_at_addr = r_anal_get_function_at (anal, addr);\n\tif (fcn_at_addr && fcn_at_addr != fcn) {\n\t\treturn R_ANAL_RET_ERROR; // MUST BE NOT FOUND\n\t}\n\n\tRAnalBlock *existing_bb = bbget (anal, addr, anal->opt.jmpmid && is_x86);\n\tif (existing_bb) {\n\t\tbool existing_in_fcn = r_list_contains (existing_bb->fcns, fcn);\n\t\texisting_bb = r_anal_block_split (existing_bb, addr);\n\t\tif (!existing_in_fcn && existing_bb) {\n\t\t\tif (existing_bb->addr == fcn->addr) {\n\t\t\t\t// our function starts directly there, so we steal what is ours!\n\t\t\t\tfcn_takeover_block_recursive (fcn, existing_bb);\n\t\t\t}\n\t\t}\n\t\tif (existing_bb) {\n\t\t\tr_anal_block_unref (existing_bb);\n\t\t}\n\t\tif (anal->opt.recont) {\n\t\t\treturn R_ANAL_RET_END;\n\t\t}\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"r_anal_function_bb() fails at 0x%\"PFMT64x \"\\n\", addr);\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE NOT DUP\n\t}\n\n\tbb = fcn_append_basic_block (anal, fcn, addr);\n\t// we checked before whether there is a bb at addr, so the create should have succeeded\n\tr_return_val_if_fail (bb, R_ANAL_RET_ERROR);\n\n\tif (!anal->leaddrs) {\n\t\tanal->leaddrs = r_list_newf (free_leaddr_pair);\n\t\tif (!anal->leaddrs) {\n\t\t\teprintf (\"Cannot create leaddr list\\n\");\n\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t}\n\t}\n\tstatic ut64 lea_jmptbl_ip = UT64_MAX;\n\tut64 last_reg_mov_lea_val = UT64_MAX;\n\tbool last_is_reg_mov_lea = false;\n\tbool last_is_push = false;\n\tbool last_is_mov_lr_pc = false;\n\tut64 last_push_addr = UT64_MAX;\n\tif (anal->limit && addr + idx < anal->limit->from) {\n\t\tgotoBeach (R_ANAL_RET_END);\n\t}\n\n\tbool varset = has_vars (anal, addr); // Checks if var is already analyzed at given addr\n\n\tut64 movdisp = UT64_MAX; // used by jmptbl when coded as \"mov Reg,[Reg*Scale+Disp]\"\n\tut64 movscale = 0;\n\tint maxlen = len * addrbytes;\n\tif (is_dalvik) {\n\t\tbool skipAnalysis = false;\n\t\tif (!strncmp (fcn->name, \"sym.\", 4)) {\n\t\t\tif (!strncmp (fcn->name + 4, \"imp.\", 4)) {\n\t\t\t\tskipAnalysis = true;\n\t\t\t} else if (strstr (fcn->name, \"field\")) {\n\t\t\t\tskipAnalysis = true;\n\t\t\t}\n\t\t}\n\t\tif (skipAnalysis) {\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t}\n\t}\n\tif ((maxlen - (addrbytes * idx)) > MAX_SCAN_SIZE) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Warning: Skipping large memory region.\\n\");\n\t\t}\n\t\tmaxlen = 0;\n\t}\n\tconst char *_bp_reg = anal->reg->name[R_REG_NAME_BP];\n\tconst char *_sp_reg = anal->reg->name[R_REG_NAME_SP];\n\tconst bool has_stack_regs = _bp_reg && _sp_reg;\n\tif (has_stack_regs) {\n\t\tbp_reg = strdup (_bp_reg);\n\t\tsp_reg = strdup (_sp_reg);\n\t}\n\n\top = r_anal_op_new ();\n\twhile (addrbytes * idx < maxlen) {\n\t\tif (!last_is_reg_mov_lea) {\n\t\t\tfree (last_reg_mov_lea_name);\n\t\t\tlast_reg_mov_lea_name = NULL;\n\t\t}\n\t\tif (anal->limit && anal->limit->to <= addr + idx) {\n\t\t\tbreak;\n\t\t}\nrepeat:\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 buf[32]; // 32 bytes is enough to hold any instruction.\n\t\tut32 at_delta = addrbytes * idx;\n\t\tut64 at = addr + at_delta;\n\t\tut64 bytes_read = R_MIN (len - at_delta, sizeof (buf));\n\t\tret = read_ahead (anal, at, buf, bytes_read);\n\n\t\tif (ret < 0) {\n\t\t\teprintf (\"Failed to read\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (is_invalid_memory (anal, buf, bytes_read)) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Warning: FFFF opcode at 0x%08\"PFMT64x \"\\n\", at);\n\t\t\t}\n\t\t\tgotoBeach (R_ANAL_RET_ERROR)\n\t\t}\n\t\tr_anal_op_fini (op);\n\t\tif ((oplen = r_anal_op (anal, op, at, buf, bytes_read, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) < 1) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Invalid instruction at 0x%\"PFMT64x\" with %d bits\\n\", at, anal->bits);\n\t\t\t}\n\t\t\t// gotoBeach (R_ANAL_RET_ERROR);\n\t\t\t// RET_END causes infinite loops somehow\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t}\n\t\tfree (op_dst);\n\t\top_dst = (op->dst && op->dst->reg && op->dst->reg->name)? strdup (op->dst->reg->name): NULL;\n\t\tfree (op_src);\n\t\top_src = (op->src[0] && op->src[0]->reg && op->src[0]->reg->name) ? strdup (op->src[0]->reg->name): NULL;\n\n\t\tif (anal->opt.nopskip && fcn->addr == at) {\n\t\t\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, addr, false);\n\t\t\tif (!fi || strncmp (fi->name, \"sym.\", 4)) {\n\t\t\t\tif ((addr + delay.un_idx - oplen) == fcn->addr) {\n\t\t\t\t\tif (r_anal_block_relocate (bb, bb->addr + oplen, bb->size - oplen)) {\n\t\t\t\t\t\tfcn->addr += oplen;\n\t\t\t\t\t\tidx = delay.un_idx;\n\t\t\t\t\t\tgoto repeat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t\tnop_prefix_cnt++;\n\t\t\t\tif (nop_prefix_cnt > MAX_NOP_PREFIX_CNT) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t}\n\t\t\t\tif (r_anal_block_relocate (bb, at + op->size, bb->size)) {\n\t\t\t\t\taddr = at + op->size;\n\t\t\t\t\tfcn->addr = addr;\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (op->hint.new_bits) {\n\t\t\tr_anal_hint_set_bits (anal, op->jump, op->hint.new_bits);\n\t\t}\n\t\tif (idx > 0 && !overlapped) {\n\t\t\tbbg = bbget (anal, at, anal->opt.jmpmid && is_x86);\n\t\t\tif (bbg && bbg != bb) {\n\t\t\t\tbb->jump = at;\n\t\t\t\tif (anal->opt.jmpmid && is_x86) {\n\t\t\t\t\t// This happens when we purposefully walked over another block and overlapped it\n\t\t\t\t\t// and now we hit an offset where the instructions match again.\n\t\t\t\t\t// So we need to split the overwalked block.\n\t\t\t\t\tRAnalBlock *split = r_anal_block_split (bbg, at);\n\t\t\t\t\tr_anal_block_unref (split);\n\t\t\t\t}\n\t\t\t\toverlapped = true;\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Overlapped at 0x%08\"PFMT64x \"\\n\", at);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!overlapped) {\n\t\t\tconst ut64 newbbsize = bb->size + oplen;\n\t\t\tif (newbbsize > MAX_FCN_SIZE) {\n\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t}\n\t\t\tr_anal_bb_set_offset (bb, bb->ninstr++, at - bb->addr);\n\t\t\tr_anal_block_set_size (bb, newbbsize);\n\t\t\tfcn->ninstr++;\n\t\t}\n\t\tif (anal->opt.trycatch) {\n\t\t\tconst char *name = anal->coreb.getName (anal->coreb.core, at);\n\t\t\tif (name) {\n\t\t\t\tif (r_str_startswith (name, \"try.\") && r_str_endswith (name, \".from\")) {\n\t\t\t\t\tchar *handle = strdup (name);\n\t\t\t\t\t// handle = r_str_replace (handle, \".from\", \".to\", 0);\n\t\t\t\t\tut64 from_addr = anal->coreb.numGet (anal->coreb.core, handle);\n\t\t\t\t\thandle = r_str_replace (handle, \".from\", \".catch\", 0);\n\t\t\t\t\tut64 handle_addr = anal->coreb.numGet (anal->coreb.core, handle);\n\t\t\t\t\tbb->jump = at + oplen;\n\t\t\t\t\tif (from_addr != bb->addr) {\n\t\t\t\t\t\tbb->fail = handle_addr;\n\t\t\t\t\t\tret = r_anal_function_bb (anal, fcn, handle_addr, depth - 1);\n\t\t\t\t\t\teprintf (\"(%s) 0x%08\"PFMT64x\"\\n\", handle, handle_addr);\n\t\t\t\t\t\tif (bb->size == 0) {\n\t\t\t\t\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_block_unref (bb);\n\t\t\t\t\t\tbb = fcn_append_basic_block (anal, fcn, addr);\n\t\t\t\t\t\tif (!bb) {\n\t\t\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tidx += oplen;\n\t\tdelay.un_idx = idx;\n\t\tif (anal->opt.delay && op->delay > 0 && !delay.pending) {\n\t\t\t// Handle first pass through a branch delay jump:\n\t\t\t// Come back and handle the current instruction later.\n\t\t\t// Save the location of it in `delay.idx`\n\t\t\t// note, we have still increased size of basic block\n\t\t\t// (and function)\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf(\"Enter branch delay at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", at - oplen, bb->size);\n\t\t\t}\n\t\t\tdelay.idx = idx - oplen;\n\t\t\tdelay.cnt = op->delay;\n\t\t\tdelay.pending = 1; // we need this in case the actual idx is zero...\n\t\t\tdelay.adjust = !overlapped; // adjustment is required later to avoid double count\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (delay.cnt > 0) {\n\t\t\t// if we had passed a branch delay instruction, keep\n\t\t\t// track of how many still to process.\n\t\t\tdelay.cnt--;\n\t\t\tif (!delay.cnt) {\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Last branch delayed opcode at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", addr + idx - oplen, bb->size);\n\t\t\t\t}\n\t\t\t\tdelay.after = idx;\n\t\t\t\tidx = delay.idx;\n\t\t\t\t// At this point, we are still looking at the\n\t\t\t\t// last instruction in the branch delay group.\n\t\t\t\t// Next time, we will again be looking\n\t\t\t\t// at the original instruction that entered\n\t\t\t\t// the branch delay.\n\t\t\t}\n\t\t} else if (op->delay > 0 && delay.pending) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Revisit branch delay jump at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", addr + idx - oplen, bb->size);\n\t\t\t}\n\t\t\t// This is the second pass of the branch delaying opcode\n\t\t\t// But we also already counted this instruction in the\n\t\t\t// size of the current basic block, so we need to fix that\n\t\t\tif (delay.adjust) {\n\t\t\t\tr_anal_block_set_size (bb, (ut64)addrbytes * (ut64)delay.after);\n\t\t\t\tfcn->ninstr--;\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Correct for branch delay @ %08\"PFMT64x \" bb.addr=%08\"PFMT64x \" corrected.bb=%\"PFMT64u\" f.uncorr=%\"PFMT64u\"\\n\",\n\t\t\t\t\taddr + idx - oplen, bb->addr, bb->size, r_anal_function_linear_size (fcn));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Next time, we go to the opcode after the delay count\n\t\t\t// Take care not to use this below, use delay.un_idx instead ...\n\t\t\tidx = delay.after;\n\t\t\tdelay.pending = delay.after = delay.idx = delay.adjust = 0;\n\t\t}\n\t\t// Note: if we got two branch delay instructions in a row due to an\n\t\t// compiler bug or junk or something it wont get treated as a delay\n\t\tswitch (op->stackop) {\n\t\tcase R_ANAL_STACK_INC:\n\t\t\tif (R_ABS (op->stackptr) < R_ANAL_MAX_INCSTACK) {\n\t\t\t\tfcn->stack += op->stackptr;\n\t\t\t\tif (fcn->stack > fcn->maxstack) {\n\t\t\t\t\tfcn->maxstack = fcn->stack;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbb->stackptr += op->stackptr;\n\t\t\tbreak;\n\t\tcase R_ANAL_STACK_RESET:\n\t\t\tbb->stackptr = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (op->ptr && op->ptr != UT64_MAX && op->ptr != UT32_MAX) {\n\t\t\t// swapped parameters wtf\n\t\t\tr_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);\n\t\t}\n\t\tanalyze_retpoline (anal, op);\n\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t\tif (is_arm) { // mov lr, pc\n\t\t\t\tconst char *esil = r_strbuf_get (&op->esil);\n\t\t\t\tif (!r_str_cmp (esil, \"pc,lr,=\", -1)) {\n\t\t\t\t\tlast_is_mov_lr_pc = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)) {\n\t\t\t\tfcn->bp_off = fcn->stack;\n\t\t\t}\n\t\t\t// Is this a mov of immediate value into a register?\n\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->val > 0 && op->val != UT64_MAX) {\n\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\tif ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {\n\t\t\t\t\tlast_reg_mov_lea_val = op->val;\n\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// skip mov reg, reg\n\t\t\tif (anal->opt.jmptbl && op->scale && op->ireg) {\n\t\t\t\tmovdisp = op->disp;\n\t\t\t\tmovscale = op->scale;\n\t\t\t\tif (op->src[0] && op->src[0]->reg) {\n\t\t\t\t\tfree (movbasereg);\n\t\t\t\t\tmovbasereg = strdup (op->src[0]->reg->name);\n\t\t\t\t} else {\n\t\t\t\t\tR_FREE (movbasereg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anal->opt.hpskip && regs_exist (op->src[0], op->dst) && !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {\n\t\t\t\tskip_ret = skip_hp (anal, fcn, op, bb, addr, oplen, delay.un_idx, &idx);\n\t\t\t\tif (skip_ret == 1) {\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tif (skip_ret == 2) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t\t// if first byte in op->ptr is 0xff, then set leaddr assuming its a jumptable\n#if 0\n\t\t\t{\n\t\t\t\tut8 buf[4];\n\t\t\t\tanal->iob.read_at (anal->iob.io, op->ptr, buf, sizeof (buf));\n\t\t\t\tif ((buf[2] == 0xff || buf[2] == 0xfe) && buf[3] == 0xff) {\n\t\t\t\t\tleaddr_pair *pair = R_NEW (leaddr_pair);\n\t\t\t\t\tif (!pair) {\n\t\t\t\t\t\teprintf (\"Cannot create leaddr_pair\\n\");\n\t\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\tpair->op_addr = op->addr;\n\t\t\t\t\tpair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately\n\t\t\t\t\tr_list_append (anal->leaddrs, pair);\n\t\t\t\t}\n\t\t\t\tif (has_stack_regs && op_is_set_bp (op, bp_reg, sp_reg)) {\n\t\t\t\t\tfcn->bp_off = fcn->stack - op->src[0]->delta;\n\t\t\t\t}\n\t\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {\n\t\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\t\tif ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {\n\t\t\t\t\t\tlast_reg_mov_lea_val = op->ptr;\n\t\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\tif (op->ptr != UT64_MAX) {\n\t\t\t\tleaddr_pair *pair = R_NEW (leaddr_pair);\n\t\t\t\tif (!pair) {\n\t\t\t\t\teprintf (\"Cannot create leaddr_pair\\n\");\n\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t}\n\t\t\t\tpair->op_addr = op->addr;\n\t\t\t\tpair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately\n\t\t\t\tpair->reg = op->reg\n\t\t\t\t\t? strdup (op->reg)\n\t\t\t\t\t: op->dst && op->dst->reg\n\t\t\t\t\t? strdup (op->dst->reg->name)\n\t\t\t\t\t: NULL;\n\t\t\t\tlea_cnt++;\n\t\t\t\tr_list_append (anal->leaddrs, pair);\n\t\t\t}\n\t\t\tif (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)     ) {\n\t\t\t\tfcn->bp_off = fcn->stack - op->src[0]->delta;\n\t\t\t}\n\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {\n\t\t\t\tfree(last_reg_mov_lea_name);\n\t\t\t\tif ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {\n\t\t\t\t\tlast_reg_mov_lea_val = op->ptr;\n\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t// skip lea reg,[reg]\n\t\t\tif (anal->opt.hpskip && regs_exist (op->src[0], op->dst)\n\t\t\t&& !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {\n\t\t\t\tskip_ret = skip_hp (anal, fcn, op, bb, at, oplen, delay.un_idx, &idx);\n\t\t\t\tif (skip_ret == 1) {\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tif (skip_ret == 2) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anal->opt.jmptbl) {\n\t\t\t\tRAnalOp *jmp_aop = r_anal_op_new ();\n\t\t\t\tut64 jmptbl_addr = op->ptr;\n\t\t\t\tut64 casetbl_addr = op->ptr;\n\t\t\t\tif (is_delta_pointer_table (anal, fcn, op->addr, op->ptr, &jmptbl_addr, &casetbl_addr, jmp_aop)) {\n\t\t\t\t\tut64 table_size, default_case = 0;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\t// we require both checks here since try_get_jmptbl_info uses\n\t\t\t\t\t// BB info of the final jmptbl jump, which is no present with\n\t\t\t\t\t// is_delta_pointer_table just scanning ahead\n\t\t\t\t\t// try_get_delta_jmptbl_info doesn't work at times where the\n\t\t\t\t\t// lea comes after the cmp/default case cjmp, which can be\n\t\t\t\t\t// handled with try_get_jmptbl_info\n\t\t\t\t\tut64 addr = jmp_aop->addr;\n\t\t\t\t\tbool ready = false;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tready = true;\n\t\t\t\t\t} else if (try_get_delta_jmptbl_info (anal, fcn, addr, op->addr, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tready = true;\n\t\t\t\t\t}\n// TODO: -1-\n\t\t\t\t\tif (ready) {\n\t\t\t\t\t\tret = casetbl_addr == op->ptr\n\t\t\t\t\t\t\t? try_walkthrough_jmptbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, op->ptr, 4, table_size, default_case, 4)\n\t\t\t\t\t\t\t: try_walkthrough_casetbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, casetbl_addr, op->ptr, 4, table_size, default_case, 4);\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tlea_jmptbl_ip = addr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (jmp_aop);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\tif (anal->opt.loads) {\n\t\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, op->ptr, 0)) {\n\t\t\t\t\tr_meta_set (anal, R_META_TYPE_DATA, op->ptr, 4, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t// Case of valid but unused \"add [rax], al\"\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (anal->opt.ijmp) {\n\t\t\t\tif ((op->size + 4 <= bytes_read) && !memcmp (buf + op->size, \"\\x00\\x00\\x00\\x00\", 4)) {\n\t\t\t\t\tr_anal_block_set_size (bb, bb->size - oplen);\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t// do nothing, because the nopskip goes before this switch\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tif (op->jump == UT64_MAX) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t{\n\t\t\t\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, op->jump, false);\n\t\t\t\tif (fi && strstr (fi->name, \"imp.\")) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tif (anal->opt.jmpref) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);\n\t\t\t}\n\t\t\tif (!anal->opt.jmpabove && (op->jump < fcn->addr)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tif (r_anal_noreturn_at (anal, op->jump)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t{\n\t\t\t\tbool must_eob = true;\n\t\t\t\tRIOMap *map = anal->iob.map_get_at (anal->iob.io, addr);\n\t\t\t\tif (map) {\n\t\t\t\t\tmust_eob = ( ! r_io_map_contain (map, op->jump) );\n\t\t\t\t}\n\t\t\t\tif (must_eob) {\n\t\t\t\t\top->jump = UT64_MAX;\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n#if FIX_JMP_FWD\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->fail = UT64_MAX;\n\t\t\tFITFCNSZ ();\n\t\t\tgotoBeach (R_ANAL_RET_END);\n#else\n\t\t\tif (!overlapped) {\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tbb->fail = UT64_MAX;\n\t\t\t}\n\t\t\t// -1\n\t\t\tret = r_anal_function_bb (anal, fcn, op->jump, depth);\n\t\t\tint tc = anal->opt.tailcall;\n\t\t\tif (tc) {\n\t\t\t\t// eprintf (\"TAIL CALL AT 0x%llx\\n\", op->addr);\n\t\t\t\tint diff = op->jump - op->addr;\n\t\t\t\tif (tc < 0) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\t(void)anal->iob.read_at (anal->iob.io, op->jump, (ut8 *) buf, sizeof (buf));\n\t\t\t\t\tif (r_anal_is_prelude (anal, buf, sizeof (buf))) {\n\t\t\t\t\t\tfcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);\n\t\t\t\t\t}\n\t\t\t\t} else if (R_ABS (diff) > tc) {\n\t\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\tfcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto beach;\n#endif\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tif (op->val != UT64_MAX && op->val > 0) {\n\t\t\t\t// if register is not stack\n\t\t\t\tcmpval = op->val;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CMP: {\n\t\t\tut64 val = (is_x86 || is_v850)? op->val : op->ptr;\n\t\t\tif (val) {\n\t\t\t\tcmpval = val;\n\t\t\t\tbb->cmpval = cmpval;\n\t\t\t\tbb->cmpreg = op->reg;\n\t\t\t\tr_anal_cond_free (bb->cond);\n\t\t\t\tbb->cond = r_anal_cond_new_from_op (op);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_MCJMP:\n\t\tcase R_ANAL_OP_TYPE_RCJMP:\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tif (anal->opt.cjmpref) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);\n\t\t\t}\n\t\t\tif (!overlapped) {\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tbb->fail = op->fail;\n\t\t\t}\n\t\t\tif (bb->cond) {\n\t\t\t\tbb->cond->type = op->cond;\n\t\t\t}\n\t\t\tif (anal->opt.jmptbl) {\n\t\t\t\tif (op->ptr != UT64_MAX) {\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\ttable_size = cmpval + 1;\n\t\t\t\t\tdefault_case = op->fail; // is this really default case?\n\t\t\t\t\tif (cmpval != UT64_MAX && default_case != UT64_MAX && (op->reg || op->ireg)) {\n\t\t\t\t\t\t// TODO -1\n\t\t\t\t\t\tif (op->ireg) {\n\t\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, 0, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t} else { // op->reg\n\t\t\t\t\t\t\tret = walkthrough_arm_jmptbl_style (anal, fcn, bb, depth, op->addr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check if op->jump and op->fail contain jump table location\n\t\t\t\t\t\t// clear jump address, because it's jump table location\n\t\t\t\t\t\tif (op->jump == op->ptr) {\n\t\t\t\t\t\t\top->jump = UT64_MAX;\n\t\t\t\t\t\t} else if (op->fail == op->ptr) {\n\t\t\t\t\t\t\top->fail = UT64_MAX;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcmpval = UT64_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint saved_stack = fcn->stack;\n\t\t\t// TODO: depth -1 in here\n\t\t\tr_anal_function_bb (anal, fcn, op->jump, depth);\n\t\t\tfcn->stack = saved_stack;\n\t\t\tret = r_anal_function_bb (anal, fcn, op->fail, depth);\n\t\t\tfcn->stack = saved_stack;\n\n\t\t\t// XXX breaks mips analysis too !op->delay\n\t\t\t// this will be all x86, arm (at least)\n\t\t\t// without which the analysis is really slow,\n\t\t\t// presumably because each opcode would get revisited\n\t\t\t// (and already covered by a bb) many times\n\t\t\tgoto beach;\n\t\t\t// For some reason, branch delayed code (MIPS) needs to continue\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t/* call [dst] */\n\t\t\t// XXX: this is TYPE_MCALL or indirect-call\n\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_CALL);\n\n\t\t\tif (r_anal_noreturn_at (anal, op->ptr)) {\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (anal, op->ptr);\n\t\t\t\tif (f) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t/* call dst */\n\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);\n\n\t\t\tif (r_anal_noreturn_at (anal, op->jump)) {\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (anal, op->jump);\n\t\t\t\tif (f) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tif (is_arm && last_is_mov_lr_pc) {\n\t\t\t\tbreak;\n\t\t\t} else if (is_v850 && anal->opt.jmptbl) {\n\t\t\t\tint ptsz = cmpval? cmpval + 1: 4;\n\t\t\t\tif ((int)cmpval > 0) {\n\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr,\n\t\t\t\t\t\t0, op->addr + 2, op->addr + 2, 2, ptsz, 0, ret);\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\t// if the next instruction is a symbol\n\t\t\tif (anal->opt.ijmp && next_instruction_is_symbol (anal, op)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t// switch statement\n\t\t\tif (anal->opt.jmptbl && lea_jmptbl_ip != op->addr) {\n\t\t\t\tut8 buf[32]; // 32 bytes is enough to hold any instruction.\n\t\t\t\t// op->ireg since rip relative addressing produces way too many false positives otherwise\n\t\t\t\t// op->ireg is 0 for rip relative, \"rax\", etc otherwise\n\t\t\t\tif (op->ptr != UT64_MAX && op->ireg) { // direct jump\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tbool case_table = false;\n\t\t\t\t\t\tRAnalOp *prev_op = r_anal_op_new ();\n\t\t\t\t\t\tanal->iob.read_at (anal->iob.io, op->addr - op->size, buf, sizeof (buf));\n\t\t\t\t\t\tif (r_anal_op (anal, prev_op, op->addr - op->size, buf, sizeof (buf), R_ANAL_OP_MASK_VAL) > 0) {\n\t\t\t\t\t\t\tbool prev_op_has_dst_name = prev_op->dst && prev_op->dst->reg && prev_op->dst->reg->name;\n\t\t\t\t\t\t\tbool op_has_src_name = op->src[0] && op->src[0]->reg && op->src[0]->reg->name;\n\t\t\t\t\t\t\tbool same_reg = (op->ireg && prev_op_has_dst_name && !strcmp (op->ireg, prev_op->dst->reg->name))\n\t\t\t\t\t\t\t\t|| (op_has_src_name && prev_op_has_dst_name && !strcmp (op->src[0]->reg->name, prev_op->dst->reg->name));\n\t\t\t\t\t\t\tif (prev_op->type == R_ANAL_OP_TYPE_MOV && prev_op->disp && prev_op->disp != UT64_MAX && same_reg) {\n\t\t\t\t\t\t\t\t//\tmovzx reg, byte [reg + case_table]\n\t\t\t\t\t\t\t\t//\tjmp dword [reg*4 + jump_table]\n\t\t\t\t\t\t\t\tif (try_walkthrough_casetbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, prev_op->disp, op->ptr, anal->bits >> 3, table_size, default_case, ret)) {\n\t\t\t\t\t\t\t\t\tret = case_table = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (prev_op);\n\t\t\t\t\t\tif (!case_table) {\n\t\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (op->ptr != UT64_MAX && op->reg) { // direct jump\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t}\n\t\t\t\t} else if (movdisp != UT64_MAX) {\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tut64 jmptbl_base = 0; //UT64_MAX;\n\t\t\t\t\tut64 lea_op_off = UT64_MAX;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tleaddr_pair *pair;\n\t\t\t\t\tif (movbasereg) {\n\t\t\t\t\t\t// find nearest candidate leaddr before op.addr\n\t\t\t\t\t\tr_list_foreach_prev (anal->leaddrs, iter, pair) {\n\t\t\t\t\t\t\tif (pair->op_addr >= op->addr) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((lea_op_off == UT64_MAX || lea_op_off > op->addr - pair->op_addr) && pair->reg && !strcmp (movbasereg, pair->reg)) {\n\t\t\t\t\t\t\t\tlea_op_off = op->addr - pair->op_addr;\n\t\t\t\t\t\t\t\tjmptbl_base = pair->leaddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\ttable_size = cmpval + 1;\n\t\t\t\t\t\tdefault_case = -1;\n\t\t\t\t\t}\n\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, jmptbl_base + movdisp, jmptbl_base, movscale, table_size, default_case, ret);\n\t\t\t\t\tcmpval = UT64_MAX;\n#if 0\n\t\t\t\t} else if (movdisp != UT64_MAX) {\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\top->ptr = movdisp;\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t}\n\t\t\t\t\tmovdisp = UT64_MAX;\n#endif\n\t\t\t\t} else if (is_arm) {\n\t\t\t\t\tif (op->ptrsize == 1) { // TBB\n\t\t\t\t\t\tut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);\n\t\t\t\t\t\tut64 table_size = 0;\n\t\t\t\t\t\tif (pred_cmpval != UT64_MAX) {\n\t\t\t\t\t\t\ttable_size += pred_cmpval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttable_size += cmpval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,\n\t\t\t\t\t\t\top->addr + 4, 1, table_size, UT64_MAX, ret);\n\t\t\t\t\t\t// skip inlined jumptable\n\t\t\t\t\t\tidx += table_size;\n\t\t\t\t\t}\n\t\t\t\t\tif (op->ptrsize == 2) { // LDRH on thumb/arm\n\t\t\t\t\t\tut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);\n\t\t\t\t\t\tint tablesize = 1;\n\t\t\t\t\t\tif (pred_cmpval != UT64_MAX) {\n\t\t\t\t\t\t\ttablesize += pred_cmpval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttablesize += cmpval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,\n\t\t\t\t\t\t\top->addr + 4, 2, tablesize, UT64_MAX, ret);\n\t\t\t\t\t\t// skip inlined jumptable\n\t\t\t\t\t\tidx += (tablesize * 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lea_jmptbl_ip == op->addr) {\n\t\t\t\tlea_jmptbl_ip = UT64_MAX;\n\t\t\t}\n\t\t\tif (anal->opt.ijmp) {\n\t\t\t\tr_anal_function_bb (anal, fcn, op->jump, depth - 1);\n\t\t\t\tret = r_anal_function_bb (anal, fcn, op->fail, depth - 1);\n\t\t\t\tif (overlapped) {\n\t\t\t\t\tgoto analopfinish;\n\t\t\t\t}\n\t\t\t\tif (r_anal_noreturn_at (anal, op->jump) || op->eob) {\n\t\t\t\t\tgoto analopfinish;\n\t\t\t\t}\n\t\t\t} else {\nanalopfinish:\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_RJMP) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_NOP);\n\t\t\t\t} else {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/* fallthru */\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tlast_is_push = true;\n\t\t\tlast_push_addr = op->val;\n\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\t\tif ((op->type & R_ANAL_OP_TYPE_REG) && last_is_reg_mov_lea && op->src[0] && op->src[0]->reg\n\t\t\t\t&& op->src[0]->reg->name && !strcmp (op->src[0]->reg->name, last_reg_mov_lea_name)) {\n\t\t\t\tlast_is_push = true;\n\t\t\t\tlast_push_addr = last_reg_mov_lea_val;\n\t\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {\n\t\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tif (op->family == R_ANAL_OP_FAMILY_PRIV) {\n\t\t\t\tfcn->type = R_ANAL_FCN_TYPE_INT;\n\t\t\t}\n\t\t\tif (last_is_push && anal->opt.pushret) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\t\top->jump = last_push_addr;\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tret = r_anal_function_bb (anal, fcn, op->jump, depth - 1);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!op->cond) {\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"RET 0x%08\"PFMT64x \". overlap=%s %\"PFMT64u\" %\"PFMT64u\"\\n\",\n\t\t\t\t\t\taddr + delay.un_idx - oplen, r_str_bool (overlapped),\n\t\t\t\t\t\tbb->size, r_anal_function_linear_size (fcn));\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (has_stack_regs && arch_destroys_dst) {\n\t\t\t// op->dst->reg->name is invalid pointer\n\t\t\tif (op_is_set_bp (op_dst, op_src, bp_reg, sp_reg) && op->src[1]) {\n\t\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t\t\tfcn->bp_off = fcn->stack - op->src[1]->imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\t\t\tfcn->bp_off = fcn->stack + op->src[1]->imm;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anal->opt.vars && !varset) {\n\t\t\t// XXX uses op.src/dst and fails because regprofile invalidates the regitems\n\t\t\tr_anal_extract_vars (anal, fcn, op);\n\t\t}\n\t\tif (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t}\n\t\tif (op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_RPUSH) {\n\t\t\tlast_is_push = false;\n\t\t}\n\t\tif (is_arm && op->type != R_ANAL_OP_TYPE_MOV) {\n\t\t\tlast_is_mov_lr_pc = false;\n\t\t}\n\t\tif (has_variadic_reg && !fcn->is_variadic) {\n\t\t\tvariadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);\n\t\t\tbool dst_is_variadic = op->dst && op->dst->reg\n\t\t\t\t\t&& variadic_reg && op->dst->reg->offset == variadic_reg->offset;\n\t\t\tbool op_is_cmp = (op->type == R_ANAL_OP_TYPE_CMP) || op->type == R_ANAL_OP_TYPE_ACMP;\n\t\t\tif (dst_is_variadic && !op_is_cmp) {\n\t\t\t\thas_variadic_reg = false;\n\t\t\t} else if (op_is_cmp) {\n\t\t\t\tif (op->src[0] && op->src[0]->reg && (op->dst->reg == op->src[0]->reg) && dst_is_variadic) {\n\t\t\t\t\tfcn->is_variadic = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tfree (op_src);\n\tfree (op_dst);\n\tfree (bp_reg);\n\tfree (sp_reg);\n\twhile (lea_cnt > 0) {\n\t\tr_list_delete (anal->leaddrs, r_list_tail (anal->leaddrs));\n\t\tlea_cnt--;\n\t}\n\tr_anal_op_free (op);\n\tR_FREE (last_reg_mov_lea_name);\n\tif (bb && bb->size == 0) {\n\t\tr_anal_function_remove_block (fcn, bb);\n\t}\n\tr_anal_block_update_hash (bb);\n\tr_anal_block_unref (bb);\n\tfree (movbasereg);\n\treturn ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1031"
    },
    {
        "index": 218,
        "code": "TfLiteStatus ResizeOutputandTemporaryTensors(TfLiteContext* context,\n                                             TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const int num_dims = NumDimensions(input);\n  TF_LITE_ENSURE(context, num_dims >= 2);\n  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n  // The lib, fft2d, can only handle fft_lengths of power of 2.\n  TF_LITE_ENSURE(context, IsPowerOfTwo(fft_length_data[0]));\n  TF_LITE_ENSURE(context, IsPowerOfTwo(fft_length_data[1]));\n\n  int fft_height, fft_width;\n  fft_height = fft_length_data[0];\n  fft_width = fft_length_data[1];\n  int fft_working_length = std::max(fft_height, fft_width / 2);\n  int half_fft_working_length = fft_working_length / 2;\n\n  // Resize output tensor.\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input->dims);\n  output_shape->data[num_dims - 2] = fft_length_data[0];\n  output_shape->data[num_dims - 1] = fft_length_data[1] / 2 + 1;\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n\n  // Resize temporary tensors, fft_integer_working_area.\n  TfLiteTensor* fft_integer_working_area =\n      GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n  TfLiteIntArray* fft_integer_working_area_shape = TfLiteIntArrayCreate(1);\n  fft_integer_working_area_shape->data[0] =\n      2 + static_cast<int>(sqrt(fft_working_length));\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, fft_integer_working_area,\n                                              fft_integer_working_area_shape));\n\n  // Resize temporary tensors, fft_double_working_area.\n  TfLiteTensor* fft_double_working_area =\n      GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n  TfLiteIntArray* fft_double_working_area_shape = TfLiteIntArrayCreate(1);\n  fft_double_working_area_shape->data[0] =\n      half_fft_working_length + fft_width / 4;\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, fft_double_working_area,\n                                              fft_double_working_area_shape));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 219,
        "code": "TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n    // We don't have a quantized implementation, so just fall through to the\n    // 'default' case.\n    default:\n      context->ReportError(context, \"Type %d not currently supported.\",\n                           input->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 220,
        "code": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-44108"
    },
    {
        "index": 221,
        "code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\n\t// a template flowset can contain multiple records ( templates )\n\twhile ( size_left ) {\n\t\tuint32_t id;\n\n\t\t// map next record.\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\t// count = ntohs(ipfix_template_record->FieldCount);\n\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\t// withdraw all templates\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\t// pading\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n \n} // End of Process_ipfix_template_withdraw\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-14459"
    },
    {
        "index": 222,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_4__reduce_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *__pyx_v_self) {\n  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position, self.sock)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->__pyx_base.buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);\n  __Pyx_INCREF(__pyx_v_self->sock);\n  __Pyx_GIVEREF(__pyx_v_self->sock);\n  PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_v_self->sock);\n  __pyx_t_1 = 0;\n  __pyx_t_2 = 0;\n  __pyx_t_3 = 0;\n  __pyx_v_state = ((PyObject*)__pyx_t_4);\n  __pyx_t_4 = 0;\n\n  /* \"(tree fragment)\":6\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position, self.sock)\n *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<\n *     if _dict is not None:\n *         state += (_dict,)\n */\n  __pyx_t_4 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_v__dict = __pyx_t_4;\n  __pyx_t_4 = 0;\n\n  /* \"(tree fragment)\":7\n *     state = (self.buffer, self.buffer_size, self.position, self.sock)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n  __pyx_t_5 = (__pyx_v__dict != Py_None);\n  __pyx_t_6 = (__pyx_t_5 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":8\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *         state += (_dict,)             # <<<<<<<<<<<<<<\n *         use_setstate = True\n *     else:\n */\n    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(__pyx_v__dict);\n    __Pyx_GIVEREF(__pyx_v__dict);\n    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v__dict);\n    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_3));\n    __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":9\n *     if _dict is not None:\n *         state += (_dict,)\n *         use_setstate = True             # <<<<<<<<<<<<<<\n *     else:\n *         use_setstate = self.sock is not None\n */\n    __pyx_v_use_setstate = 1;\n\n    /* \"(tree fragment)\":7\n *     state = (self.buffer, self.buffer_size, self.position, self.sock)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n    goto __pyx_L3;\n  }\n\n  /* \"(tree fragment)\":11\n *         use_setstate = True\n *     else:\n *         use_setstate = self.sock is not None             # <<<<<<<<<<<<<<\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, None), state\n */\n  /*else*/ {\n    __pyx_t_6 = (__pyx_v_self->sock != Py_None);\n    __pyx_v_use_setstate = __pyx_t_6;\n  }\n  __pyx_L3:;\n\n  /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.sock is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, None), state\n *     else:\n */\n  __pyx_t_6 = (__pyx_v_use_setstate != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":13\n *         use_setstate = self.sock is not None\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, None), state             # <<<<<<<<<<<<<<\n *     else:\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyx_unpickle_BufferedSocketWri); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_62583983);\n    __Pyx_GIVEREF(__pyx_int_62583983);\n    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_int_62583983);\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    PyTuple_SET_ITEM(__pyx_t_4, 2, Py_None);\n    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_state);\n    __pyx_t_3 = 0;\n    __pyx_t_4 = 0;\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n\n    /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.sock is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, None), state\n *     else:\n */\n  }\n\n  /* \"(tree fragment)\":15\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, None), state\n *     else:\n *         return __pyx_unpickle_BufferedSocketWriter, (type(self), 0x3baf4af, state)             # <<<<<<<<<<<<<<\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedSocketWriter__set_state(self, __pyx_state)\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_BufferedSocketWri); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_62583983);\n    __Pyx_GIVEREF(__pyx_int_62583983);\n    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_int_62583983);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_state);\n    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_GIVEREF(__pyx_t_2);\n    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_4);\n    __pyx_t_2 = 0;\n    __pyx_t_4 = 0;\n    __pyx_r = __pyx_t_3;\n    __pyx_t_3 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"(tree fragment)\":1\n * def __reduce_cython__(self):             # <<<<<<<<<<<<<<\n *     cdef tuple state\n *     cdef object _dict\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedSocketWriter.__reduce_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_state);\n  __Pyx_XDECREF(__pyx_v__dict);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 223,
        "code": "void process_packet_tail(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tenum state_kind from_state = md->v1_from_state;\n\tconst struct state_v1_microcode *smc = md->smc;\n\tbool new_iv_set = md->new_iv_set;\n\tbool self_delete = FALSE;\n\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\tendpoint_buf b;\n\t\tdbg(\"received encrypted packet from %s\", str_endpoint(&md->sender, &b));\n\n\t\tif (st == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"discarding encrypted message for an unknown ISAKMP SA\");\n\t\t\treturn;\n\t\t}\n\t\tif (st->st_skeyid_e_nss == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\"discarding encrypted message because we haven't yet negotiated keying material\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Mark as encrypted */\n\t\tmd->encrypted = TRUE;\n\n\t\t/* do the specified decryption\n\t\t *\n\t\t * IV is from st->st_iv or (if new_iv_set) st->st_new_iv.\n\t\t * The new IV is placed in st->st_new_iv\n\t\t *\n\t\t * See RFC 2409 \"IKE\" Appendix B\n\t\t *\n\t\t * XXX The IV should only be updated really if the packet\n\t\t * is successfully processed.\n\t\t * We should keep this value, check for a success return\n\t\t * value from the parsing routines and then replace.\n\t\t *\n\t\t * Each post phase 1 exchange generates IVs from\n\t\t * the last phase 1 block, not the last block sent.\n\t\t */\n\t\tconst struct encrypt_desc *e = st->st_oakley.ta_encrypt;\n\n\t\tif (pbs_left(&md->message_pbs) % e->enc_blocksize != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"malformed message: not a multiple of encryption blocksize\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* XXX Detect weak keys */\n\n\t\t/* grab a copy of raw packet (for duplicate packet detection) */\n\t\tmd->raw_packet = clone_bytes_as_chunk(md->packet_pbs.start,\n\t\t\t\t\t\t      pbs_room(&md->packet_pbs),\n\t\t\t\t\t\t      \"raw packet\");\n\n\t\t/* Decrypt everything after header */\n\t\tif (!new_iv_set) {\n\t\t\tif (st->st_v1_iv.len == 0) {\n\t\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\t} else {\n\t\t\t\t/* use old IV */\n\t\t\t\trestore_new_iv(st, st->st_v1_iv);\n\t\t\t}\n\t\t}\n\n\t\tpassert(st->st_v1_new_iv.len >= e->enc_blocksize);\n\t\tst->st_v1_new_iv.len = e->enc_blocksize;   /* truncate */\n\n\t\tif (DBGP(DBG_CRYPT)) {\n\t\t\tDBG_log(\"decrypting %u bytes using algorithm %s\",\n\t\t\t\t(unsigned) pbs_left(&md->message_pbs),\n\t\t\t\tst->st_oakley.ta_encrypt->common.fqn);\n\t\t\tDBG_dump_hunk(\"IV before:\", st->st_v1_new_iv);\n\t\t}\n\t\te->encrypt_ops->do_crypt(e, md->message_pbs.cur,\n\t\t\t\t\t pbs_left(&md->message_pbs),\n\t\t\t\t\t st->st_enc_key_nss,\n\t\t\t\t\t st->st_v1_new_iv.ptr, FALSE);\n\t\tif (DBGP(DBG_CRYPT)) {\n\t\t\tDBG_dump_hunk(\"IV after:\", st->st_v1_new_iv);\n\t\t\tDBG_log(\"decrypted payload (starts at offset %td):\",\n\t\t\t\tmd->message_pbs.cur - md->message_pbs.roof);\n\t\t\tDBG_dump(NULL, md->message_pbs.start,\n\t\t\t\t md->message_pbs.roof - md->message_pbs.start);\n\t\t}\n\t} else {\n\t\t/* packet was not encryped -- should it have been? */\n\n\t\tif (smc->flags & SMF_INPUT_ENCRYPTED) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"packet rejected: should have been encrypted\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Digest the message.\n\t * Padding must be removed to make hashing work.\n\t * Padding comes from encryption (so this code must be after decryption).\n\t * Padding rules are described before the definition of\n\t * struct isakmp_hdr in packet.h.\n\t */\n\t{\n\t\tenum next_payload_types_ikev1 np = md->hdr.isa_np;\n\t\tlset_t needed = smc->req_payloads;\n\t\tconst char *excuse =\n\t\t\tLIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,\n\t\t\t    smc->flags) ?\n\t\t\t\"probable authentication failure (mismatch of preshared secrets?): \"\n\t\t\t:\n\t\t\t\"\";\n\n\t\twhile (np != ISAKMP_NEXT_NONE) {\n\t\t\tstruct_desc *sd = v1_payload_desc(np);\n\n\t\t\tif (md->digest_roof >= elemsof(md->digest)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"more than %zu payloads in message; ignored\",\n\t\t\t\t       elemsof(md->digest));\n\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstruct payload_digest *const pd = md->digest + md->digest_roof;\n\n\t\t\t/*\n\t\t\t * only do this in main mode. In aggressive mode, there\n\t\t\t * is no negotiation of NAT-T method. Get it right.\n\t\t\t */\n\t\t\tif (st != NULL && st->st_connection != NULL &&\n\t\t\t    (st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)\n\t\t\t{\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_NATD_RFC:\n\t\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t\tif ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t\t\t\t\t * unless we're using NAT-T RFC\n\t\t\t\t\t\t */\n\t\t\t\t\t\tDBG(DBG_NATT,\n\t\t\t\t\t\t    DBG_log(\"st_nat_traversal was: %s\",\n\t\t\t\t\t\t\t    bitnamesof(natt_bit_names,\n\t\t\t\t\t\t\t\t       st->hidden_variables.st_nat_traversal)));\n\t\t\t\t\t\tsd = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd == NULL) {\n\t\t\t\t/* payload type is out of range or requires special handling */\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\t\t\t/* ??? two kinds of ID payloads */\n\t\t\t\t\tsd = (IS_PHASE1(from_state) ||\n\t\t\t\t\t      IS_PHASE15(from_state)) ?\n\t\t\t\t\t\t&isakmp_identification_desc :\n\t\t\t\t\t\t&isakmp_ipsec_identification_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATD_DRAFTS: /* out of range */\n\t\t\t\t\t/*\n\t\t\t\t\t * ISAKMP_NEXT_NATD_DRAFTS was a private use type before RFC-3947.\n\t\t\t\t\t * Since it has the same format as ISAKMP_NEXT_NATD_RFC,\n\t\t\t\t\t * just rewrite np and sd, and carry on.\n\t\t\t\t\t */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATD_RFC;\n\t\t\t\t\tsd = &isakmp_nat_d_drafts;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATOA_DRAFTS: /* out of range */\n\t\t\t\t\t/* NAT-OA was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATOA_RFC;\n\t\t\t\t\tsd = &isakmp_nat_oa_drafts;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_SAK: /* or ISAKMP_NEXT_NATD_BADDRAFTS */\n\t\t\t\t\t/*\n\t\t\t\t\t * Official standards say that this is ISAKMP_NEXT_SAK,\n\t\t\t\t\t * a part of Group DOI, something we don't implement.\n\t\t\t\t\t * Old non-updated Cisco gear abused this number in ancient NAT drafts.\n\t\t\t\t\t * We ignore (rather than reject) this in support of people\n\t\t\t\t\t * with crufty Cisco machines.\n\t\t\t\t\t */\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored\",\n\t\t\t\t\t\texcuse);\n\t\t\t\t\t/*\n\t\t\t\t\t * Hack to discard payload, whatever it was.\n\t\t\t\t\t * Since we are skipping the rest of the loop\n\t\t\t\t\t * body we must do some things ourself:\n\t\t\t\t\t * - demarshall the payload\n\t\t\t\t\t * - grab the next payload number (np)\n\t\t\t\t\t * - don't keep payload (don't increment pd)\n\t\t\t\t\t * - skip rest of loop body\n\t\t\t\t\t */\n\t\t\t\t\tif (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,\n\t\t\t\t\t\t       &pd->pbs)) {\n\t\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t\t\t       excuse);\n\t\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\t\t\t/* NOTE: we do not increment pd! */\n\t\t\t\t\tcontinue;  /* skip rest of the loop */\n\n\t\t\t\tdefault:\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpassert(sd != NULL);\n\t\t\t}\n\n\t\t\tpassert(np < LELEM_ROOF);\n\n\t\t\t{\n\t\t\t\tlset_t s = LELEM(np);\n\n\t\t\t\tif (LDISJOINT(s,\n\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tst->st_state->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));\n\t\t\t\tneeded &= ~s;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Read in the payload recording what type it\n\t\t\t * should be\n\t\t\t */\n\t\t\tpd->payload_type = np;\n\t\t\tif (!in_struct(&pd->payload, sd, &md->message_pbs,\n\t\t\t\t       &pd->pbs)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t       excuse);\n\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* do payload-type specific debugging */\n\t\t\tswitch (np) {\n\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t/* dump ID section */\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_dump(\"     obj: \", pd->pbs.cur,\n\t\t\t\t\t     pbs_left(&pd->pbs)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * Place payload at the end of the chain for this type.\n\t\t\t * This code appears in ikev1.c and ikev2.c.\n\t\t\t */\n\t\t\t{\n\t\t\t\t/* np is a proper subscript for chain[] */\n\t\t\t\tpassert(np < elemsof(md->chain));\n\t\t\t\tstruct payload_digest **p = &md->chain[np];\n\n\t\t\t\twhile (*p != NULL)\n\t\t\t\t\tp = &(*p)->next;\n\t\t\t\t*p = pd;\n\t\t\t\tpd->next = NULL;\n\t\t\t}\n\n\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\tmd->digest_roof++;\n\n\t\t\t/* since we've digested one payload happily, it is probably\n\t\t\t * the case that any decryption worked.  So we will not suggest\n\t\t\t * encryption failure as an excuse for subsequent payload\n\t\t\t * problems.\n\t\t\t */\n\t\t\texcuse = \"\";\n\t\t}\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    if (pbs_left(&md->message_pbs) != 0)\n\t\t\t\t    DBG_log(\"removing %d bytes of padding\",\n\t\t\t\t\t    (int) pbs_left(&md->message_pbs));\n\t\t    });\n\n\t\tmd->message_pbs.roof = md->message_pbs.cur;\n\n\t\t/* check that all mandatory payloads appeared */\n\n\t\tif (needed != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"message for %s is missing payloads %s\",\n\t\t\t       finite_states[from_state]->name,\n\t\t\t       bitnamesof(payload_name_ikev1, needed));\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!check_v1_HASH(smc->hash_type, smc->message, st, md)) {\n\t\t/*SEND_NOTIFICATION(INVALID_HASH_INFORMATION);*/\n\t\treturn;\n\t}\n\n\t/* more sanity checking: enforce most ordering constraints */\n\n\tif (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5 Exchanges:\n\t\t * \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n\t\t */\n\t\tif (md->chain[ISAKMP_NEXT_SA] != NULL &&\n\t\t    md->hdr.isa_np != ISAKMP_NEXT_SA) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Phase 1 message: does not start with an SA payload\");\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t} else if (IS_QUICK(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode\n\t\t *\n\t\t * \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n\t\t *  header and a SA payload MUST immediately follow the HASH.\"\n\t\t * [NOTE: there may be more than one SA payload, so this is not\n\t\t *  totally reasonable.  Probably all SAs should be so constrained.]\n\t\t *\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t *\n\t\t * \"With the exception of the HASH, SA, and the optional ID payloads,\n\t\t *  there are no payload ordering restrictions on Quick Mode.\"\n\t\t */\n\n\t\tif (md->hdr.isa_np != ISAKMP_NEXT_HASH) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Quick Mode message: does not start with a HASH payload\");\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t{\n\t\t\tstruct payload_digest *p;\n\t\t\tint i;\n\n\t\t\tp = md->chain[ISAKMP_NEXT_SA];\n\t\t\ti = 1;\n\t\t\twhile (p != NULL) {\n\t\t\t\tif (p != &md->digest[i]) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"malformed Quick Mode message: SA payload is in wrong position\");\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tp = p->next;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode:\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t */\n\t\t{\n\t\t\tstruct payload_digest *id = md->chain[ISAKMP_NEXT_ID];\n\n\t\t\tif (id != NULL) {\n\t\t\t\tif (id->next == NULL ||\n\t\t\t\t    id->next->next != NULL) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"malformed Quick Mode message: if any ID payload is present, there must be exactly two\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (id + 1 != id->next) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"malformed Quick Mode message: the ID payloads are not adjacent\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Ignore payloads that we don't handle:\n\t */\n\t/* XXX Handle Notifications */\n\t{\n\t\tstruct payload_digest *p = md->chain[ISAKMP_NEXT_N];\n\n\t\twhile (p != NULL) {\n\t\t\tswitch (p->payload.notification.isan_type) {\n\t\t\tcase R_U_THERE:\n\t\t\tcase R_U_THERE_ACK:\n\t\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tcase PAYLOAD_MALFORMED:\n\t\t\tcase INVALID_MESSAGE_ID:\n\t\t\tcase IPSEC_RESPONDER_LIFETIME:\n\t\t\t\tif (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {\n\t\t\t\t\t/* these are handled later on in informational() */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tdefault:\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t       \"ignoring informational payload %s, no corresponding state\",\n\t\t\t\t\t       enum_show(& ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.notification.isan_type)));\n\t\t\t\t} else {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"ignoring informational payload %s, msgid=%08\" PRIx32 \", length=%d\",\n\t\t\t\t\t       enum_show(&ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.notification.isan_type),\n\t\t\t\t\t       st->st_v1_msgid.id,\n\t\t\t\t\t       p->payload.notification.isan_length);\n\t\t\t\t\tDBG_dump_pbs(&p->pbs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\tDBG_dump(\"info:\", p->pbs.cur,\n\t\t\t\t\t pbs_left(&p->pbs));\n\t\t\t}\n\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_D];\n\t\twhile (p != NULL) {\n\t\t\tself_delete |= accept_delete(md, p);\n\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\tDBG_dump(\"del:\", p->pbs.cur,\n\t\t\t\t\t pbs_left(&p->pbs));\n\t\t\t}\n\t\t\tif (md->st != st) {\n\t\t\t\tpexpect(md->st == NULL);\n\t\t\t\tdbg(\"zapping ST as accept_delete() zapped MD.ST\");\n\t\t\t\tst = md->st;\n\t\t\t}\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_VID];\n\t\twhile (p != NULL) {\n\t\t\thandle_vendorid(md, (char *)p->pbs.cur,\n\t\t\t\t\tpbs_left(&p->pbs), FALSE);\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (self_delete) {\n\t\taccept_self_delete(md);\n\t\tst = md->st;\n\t\t/* note: st ought to be NULL from here on */\n\t}\n\n\tpexpect(st == md->st);\n\tstatetime_t start = statetime_start(md->st);\n\t/*\n\t * XXX: danger - the .informational() processor deletes ST;\n\t * and then tunnels this loss through MD.ST.\n\t */\n\tcomplete_v1_state_transition(md, smc->processor(st, md));\n\tstatetime_stop(&start, \"%s()\", __func__);\n\t/* our caller will release_any_md(mdp); */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1763"
    },
    {
        "index": 224,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString_2read_items(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, Py_ssize_t __pyx_v_n_items, PyObject *__pyx_v_buf) {\n  Py_ssize_t __pyx_v_i;\n  Py_ssize_t __pyx_v_j;\n  Py_ssize_t __pyx_v_length;\n  PyObject *__pyx_v_encoding = NULL;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_data = NULL;\n  char *__pyx_v_data_ptr;\n  char *__pyx_v_c_string;\n  PyObject *__pyx_v_items = NULL;\n  PyObject *__pyx_v_item = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  PyObject *__pyx_t_6 = NULL;\n  int __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  int __pyx_t_10;\n  PyObject *__pyx_t_11 = NULL;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  int __pyx_t_14;\n  __Pyx_RefNannySetupContext(\"read_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":52\n * \n *     def read_items(self, Py_ssize_t n_items, buf):\n *         cdef Py_ssize_t i, j, length = self.length             # <<<<<<<<<<<<<<\n *         encoding = self.encoding.encode('utf-8')\n *         cdef char* c_encoding = encoding\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 52, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 52, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_length = __pyx_t_2;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":53\n *     def read_items(self, Py_ssize_t n_items, buf):\n *         cdef Py_ssize_t i, j, length = self.length\n *         encoding = self.encoding.encode('utf-8')             # <<<<<<<<<<<<<<\n *         cdef char* c_encoding = encoding\n *         data = buf.read(length * n_items)\n */\n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_encoding); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 53, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 53, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_4, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_u_utf_8);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 53, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __pyx_v_encoding = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":54\n *         cdef Py_ssize_t i, j, length = self.length\n *         encoding = self.encoding.encode('utf-8')\n *         cdef char* c_encoding = encoding             # <<<<<<<<<<<<<<\n *         data = buf.read(length * n_items)\n *         cdef char* data_ptr = PyBytes_AsString(data)\n */\n  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 54, __pyx_L1_error)\n  __pyx_v_c_encoding = __pyx_t_5;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":55\n *         encoding = self.encoding.encode('utf-8')\n *         cdef char* c_encoding = encoding\n *         data = buf.read(length * n_items)             # <<<<<<<<<<<<<<\n *         cdef char* data_ptr = PyBytes_AsString(data)\n * \n */\n  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 55, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_t_3 = PyInt_FromSsize_t((__pyx_v_length * __pyx_v_n_items)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 55, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_6 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {\n    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);\n    if (likely(__pyx_t_6)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);\n      __Pyx_INCREF(__pyx_t_6);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_4, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 55, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __pyx_v_data = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":56\n *         cdef char* c_encoding = encoding\n *         data = buf.read(length * n_items)\n *         cdef char* data_ptr = PyBytes_AsString(data)             # <<<<<<<<<<<<<<\n * \n *         cdef char* c_string = <char *>PyMem_Malloc(length + 1)\n */\n  __pyx_t_5 = PyBytes_AsString(__pyx_v_data); if (unlikely(__pyx_t_5 == ((char *)NULL))) __PYX_ERR(0, 56, __pyx_L1_error)\n  __pyx_v_data_ptr = __pyx_t_5;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":58\n *         cdef char* data_ptr = PyBytes_AsString(data)\n * \n *         cdef char* c_string = <char *>PyMem_Malloc(length + 1)             # <<<<<<<<<<<<<<\n *         if not c_string:\n *             raise MemoryError()\n */\n  __pyx_v_c_string = ((char *)PyMem_Malloc((__pyx_v_length + 1)));\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":59\n * \n *         cdef char* c_string = <char *>PyMem_Malloc(length + 1)\n *         if not c_string:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n *         c_string[length] = 0\n */\n  __pyx_t_7 = ((!(__pyx_v_c_string != 0)) != 0);\n  if (unlikely(__pyx_t_7)) {\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":60\n *         cdef char* c_string = <char *>PyMem_Malloc(length + 1)\n *         if not c_string:\n *             raise MemoryError()             # <<<<<<<<<<<<<<\n *         c_string[length] = 0\n * \n */\n    PyErr_NoMemory(); __PYX_ERR(0, 60, __pyx_L1_error)\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":59\n * \n *         cdef char* c_string = <char *>PyMem_Malloc(length + 1)\n *         if not c_string:             # <<<<<<<<<<<<<<\n *             raise MemoryError()\n *         c_string[length] = 0\n */\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":61\n *         if not c_string:\n *             raise MemoryError()\n *         c_string[length] = 0             # <<<<<<<<<<<<<<\n * \n *         items = PyTuple_New(n_items)\n */\n  (__pyx_v_c_string[__pyx_v_length]) = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":63\n *         c_string[length] = 0\n * \n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n *         for i in range(n_items):\n *             memcpy(c_string, &data_ptr[i * length], length)\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":64\n * \n *         items = PyTuple_New(n_items)\n *         for i in range(n_items):             # <<<<<<<<<<<<<<\n *             memcpy(c_string, &data_ptr[i * length], length)\n * \n */\n  __pyx_t_2 = __pyx_v_n_items;\n  __pyx_t_8 = __pyx_t_2;\n  for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {\n    __pyx_v_i = __pyx_t_9;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":65\n *         items = PyTuple_New(n_items)\n *         for i in range(n_items):\n *             memcpy(c_string, &data_ptr[i * length], length)             # <<<<<<<<<<<<<<\n * \n *             # Get last non zero byte of string from the end.\n */\n    (void)(memcpy(__pyx_v_c_string, (&(__pyx_v_data_ptr[(__pyx_v_i * __pyx_v_length)])), __pyx_v_length));\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":68\n * \n *             # Get last non zero byte of string from the end.\n *             j = length - 1             # <<<<<<<<<<<<<<\n *             while j >= 0 and not c_string[j]:\n *                 j -= 1\n */\n    __pyx_v_j = (__pyx_v_length - 1);\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":69\n *             # Get last non zero byte of string from the end.\n *             j = length - 1\n *             while j >= 0 and not c_string[j]:             # <<<<<<<<<<<<<<\n *                 j -= 1\n * \n */\n    while (1) {\n      __pyx_t_10 = ((__pyx_v_j >= 0) != 0);\n      if (__pyx_t_10) {\n      } else {\n        __pyx_t_7 = __pyx_t_10;\n        goto __pyx_L8_bool_binop_done;\n      }\n      __pyx_t_10 = ((!((__pyx_v_c_string[__pyx_v_j]) != 0)) != 0);\n      __pyx_t_7 = __pyx_t_10;\n      __pyx_L8_bool_binop_done:;\n      if (!__pyx_t_7) break;\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":70\n *             j = length - 1\n *             while j >= 0 and not c_string[j]:\n *                 j -= 1             # <<<<<<<<<<<<<<\n * \n *             try:\n */\n      __pyx_v_j = (__pyx_v_j - 1);\n    }\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":72\n *                 j -= 1\n * \n *             try:             # <<<<<<<<<<<<<<\n *                 item = c_string[:j + 1].decode(c_encoding)\n *             except UnicodeDecodeError:\n */\n    {\n      __Pyx_PyThreadState_declare\n      __Pyx_PyThreadState_assign\n      __Pyx_ExceptionSave(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);\n      __Pyx_XGOTREF(__pyx_t_11);\n      __Pyx_XGOTREF(__pyx_t_12);\n      __Pyx_XGOTREF(__pyx_t_13);\n      /*try:*/ {\n\n        /* \"clickhouse_driver/columns/stringcolumn.pyx\":73\n * \n *             try:\n *                 item = c_string[:j + 1].decode(c_encoding)             # <<<<<<<<<<<<<<\n *             except UnicodeDecodeError:\n *                 item = PyBytes_FromStringAndSize(c_string, length)\n */\n        __pyx_t_1 = __Pyx_decode_c_string(__pyx_v_c_string, 0, (__pyx_v_j + 1), __pyx_v_c_encoding, NULL, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L10_error)\n        __Pyx_GOTREF(__pyx_t_1);\n        __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_1);\n        __pyx_t_1 = 0;\n\n        /* \"clickhouse_driver/columns/stringcolumn.pyx\":72\n *                 j -= 1\n * \n *             try:             # <<<<<<<<<<<<<<\n *                 item = c_string[:j + 1].decode(c_encoding)\n *             except UnicodeDecodeError:\n */\n      }\n      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;\n      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;\n      __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;\n      goto __pyx_L17_try_end;\n      __pyx_L10_error:;\n      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":74\n *             try:\n *                 item = c_string[:j + 1].decode(c_encoding)\n *             except UnicodeDecodeError:             # <<<<<<<<<<<<<<\n *                 item = PyBytes_FromStringAndSize(c_string, length)\n *             Py_INCREF(item)\n */\n      __pyx_t_14 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_UnicodeDecodeError);\n      if (__pyx_t_14) {\n        __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_4, &__pyx_t_3) < 0) __PYX_ERR(0, 74, __pyx_L12_except_error)\n        __Pyx_GOTREF(__pyx_t_1);\n        __Pyx_GOTREF(__pyx_t_4);\n        __Pyx_GOTREF(__pyx_t_3);\n\n        /* \"clickhouse_driver/columns/stringcolumn.pyx\":75\n *                 item = c_string[:j + 1].decode(c_encoding)\n *             except UnicodeDecodeError:\n *                 item = PyBytes_FromStringAndSize(c_string, length)             # <<<<<<<<<<<<<<\n *             Py_INCREF(item)\n *             PyTuple_SET_ITEM(items, i, item)\n */\n        __pyx_t_6 = PyBytes_FromStringAndSize(__pyx_v_c_string, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 75, __pyx_L12_except_error)\n        __Pyx_GOTREF(__pyx_t_6);\n        __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_6);\n        __pyx_t_6 = 0;\n        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n        goto __pyx_L11_exception_handled;\n      }\n      goto __pyx_L12_except_error;\n      __pyx_L12_except_error:;\n\n      /* \"clickhouse_driver/columns/stringcolumn.pyx\":72\n *                 j -= 1\n * \n *             try:             # <<<<<<<<<<<<<<\n *                 item = c_string[:j + 1].decode(c_encoding)\n *             except UnicodeDecodeError:\n */\n      __Pyx_XGIVEREF(__pyx_t_11);\n      __Pyx_XGIVEREF(__pyx_t_12);\n      __Pyx_XGIVEREF(__pyx_t_13);\n      __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);\n      goto __pyx_L1_error;\n      __pyx_L11_exception_handled:;\n      __Pyx_XGIVEREF(__pyx_t_11);\n      __Pyx_XGIVEREF(__pyx_t_12);\n      __Pyx_XGIVEREF(__pyx_t_13);\n      __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);\n      __pyx_L17_try_end:;\n    }\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":76\n *             except UnicodeDecodeError:\n *                 item = PyBytes_FromStringAndSize(c_string, length)\n *             Py_INCREF(item)             # <<<<<<<<<<<<<<\n *             PyTuple_SET_ITEM(items, i, item)\n * \n */\n    Py_INCREF(__pyx_v_item);\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":77\n *                 item = PyBytes_FromStringAndSize(c_string, length)\n *             Py_INCREF(item)\n *             PyTuple_SET_ITEM(items, i, item)             # <<<<<<<<<<<<<<\n * \n *         PyMem_Free(c_string)\n */\n    PyTuple_SET_ITEM(__pyx_v_items, __pyx_v_i, __pyx_v_item);\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":79\n *             PyTuple_SET_ITEM(items, i, item)\n * \n *         PyMem_Free(c_string)             # <<<<<<<<<<<<<<\n * \n *         return items\n */\n  PyMem_Free(__pyx_v_c_string);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":81\n *         PyMem_Free(c_string)\n * \n *         return items             # <<<<<<<<<<<<<<\n * \n *     def write_items(self, items, buf):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":51\n *         super(FixedString, self).__init__(**kwargs)\n * \n *     def read_items(self, Py_ssize_t n_items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t i, j, length = self.length\n *         encoding = self.encoding.encode('utf-8')\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_encoding);\n  __Pyx_XDECREF(__pyx_v_data);\n  __Pyx_XDECREF(__pyx_v_items);\n  __Pyx_XDECREF(__pyx_v_item);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 225,
        "code": "Function *ESTreeIRGen::genES5Function(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode,\n    bool isGeneratorInnerFunction) {\n  assert(functionNode && \"Function AST cannot be null\");\n\n  auto *body = ESTree::getBlockStatement(functionNode);\n  assert(body && \"body of ES5 function cannot be null\");\n\n  Function *newFunction = isGeneratorInnerFunction\n      ? Builder.createGeneratorInnerFunction(\n            originalName,\n            Function::DefinitionKind::ES5Function,\n            ESTree::isStrict(functionNode->strictness),\n            functionNode->getSourceRange(),\n            /* insertBefore */ nullptr)\n      : Builder.createFunction(\n            originalName,\n            Function::DefinitionKind::ES5Function,\n            ESTree::isStrict(functionNode->strictness),\n            functionNode->getSourceRange(),\n            /* isGlobal */ false,\n            /* insertBefore */ nullptr);\n\n  newFunction->setLazyClosureAlias(lazyClosureAlias);\n\n  if (auto *bodyBlock = llvh::dyn_cast<ESTree::BlockStatementNode>(body)) {\n    if (bodyBlock->isLazyFunctionBody) {\n      // Set the AST position and variable context so we can continue later.\n      newFunction->setLazyScope(saveCurrentScope());\n      auto &lazySource = newFunction->getLazySource();\n      lazySource.bufferId = bodyBlock->bufferId;\n      lazySource.nodeKind = getLazyFunctionKind(functionNode);\n      lazySource.functionRange = functionNode->getSourceRange();\n\n      // Set the function's .length.\n      newFunction->setExpectedParamCountIncludingThis(\n          countExpectedArgumentsIncludingThis(functionNode));\n      return newFunction;\n    }\n  }\n\n  FunctionContext newFunctionContext{\n      this, newFunction, functionNode->getSemInfo()};\n\n  if (isGeneratorInnerFunction) {\n    // StartGeneratorInst\n    // ResumeGeneratorInst\n    // at the beginning of the function, to allow for the first .next() call.\n    auto *initGenBB = Builder.createBasicBlock(newFunction);\n    Builder.setInsertionBlock(initGenBB);\n    Builder.createStartGeneratorInst();\n    auto *prologueBB = Builder.createBasicBlock(newFunction);\n    auto *prologueResumeIsReturn = Builder.createAllocStackInst(\n        genAnonymousLabelName(\"isReturn_prologue\"));\n    genResumeGenerator(nullptr, prologueResumeIsReturn, prologueBB);\n\n    if (hasSimpleParams(functionNode)) {\n      // If there are simple params, then we don't need an extra yield/resume.\n      // They can simply be initialized on the first call to `.next`.\n      Builder.setInsertionBlock(prologueBB);\n      emitFunctionPrologue(\n          functionNode,\n          prologueBB,\n          InitES5CaptureState::Yes,\n          DoEmitParameters::Yes);\n    } else {\n      // If there are non-simple params, then we must add a new yield/resume.\n      // The `.next()` call will occur once in the outer function, before\n      // the iterator is returned to the caller of the `function*`.\n      auto *entryPointBB = Builder.createBasicBlock(newFunction);\n      auto *entryPointResumeIsReturn =\n          Builder.createAllocStackInst(genAnonymousLabelName(\"isReturn_entry\"));\n\n      // Initialize parameters.\n      Builder.setInsertionBlock(prologueBB);\n      emitFunctionPrologue(\n          functionNode,\n          prologueBB,\n          InitES5CaptureState::Yes,\n          DoEmitParameters::Yes);\n      Builder.createSaveAndYieldInst(\n          Builder.getLiteralUndefined(), entryPointBB);\n\n      // Actual entry point of function from the caller's perspective.\n      Builder.setInsertionBlock(entryPointBB);\n      genResumeGenerator(\n          nullptr,\n          entryPointResumeIsReturn,\n          Builder.createBasicBlock(newFunction));\n    }\n  } else {\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(newFunction),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::Yes);\n  }\n\n  genStatement(body);\n  emitFunctionEpilogue(Builder.getLiteralUndefined());\n\n  return curFunction()->function;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 226,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_LOCAL_RESPONSE_NORM(type)                            \\\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\\n  op_params.bias = params->bias;                                     \\\n  op_params.alpha = params->alpha;                                   \\\n  op_params.beta = params->beta;                                     \\\n  type::LocalResponseNormalization(                                  \\\n      op_params, GetTensorShape(input), GetTensorData<float>(input), \\\n      GetTensorShape(output), GetTensorData<float>(output))\n    if (kernel_type == kReference) {\n      TF_LITE_LOCAL_RESPONSE_NORM(reference_ops);\n    }\n    if (kernel_type == kGenericOptimized) {\n      TF_LITE_LOCAL_RESPONSE_NORM(optimized_ops);\n    }\n#undef TF_LITE_LOCAL_RESPONSE_NORM\n  } else {\n    context->ReportError(context, \"Output type is %d, requires float.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 227,
        "code": "get_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tchar_u\t    **line_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    theline = get_function_line(eap, line_to_free, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_str_str), \"enddef\", p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\".\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (*line_to_free != NULL\n\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n\t\t\t{\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = *line_to_free;\n\t\t\t    *line_to_free = NULL;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 228,
        "code": "char *string_crypt(const char *key, const char *salt) {\n  assert(key);\n  assert(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  if ((strlen(salt) > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n    if (php_crypt_blowfish_rn(key, salt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 229,
        "code": "Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 230,
        "code": "void PrepareOutputBuffer(complex<float>* output_data, int fft_height,\n                         int fft_width, double** fft_input_output) {\n  int cnt = 0;\n  for (int i = 0; i < fft_height; ++i) {\n    for (int j = 0; j < fft_width / 2 + 1; ++j) {\n      output_data[cnt++] = complex<float>(fft_input_output[i][j * 2],\n                                          fft_input_output[i][j * 2 + 1]);\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 231,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_6varint_2read_varint(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_result;\n  unsigned char __pyx_v_i;\n  PyObject *__pyx_v_read_one = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  unsigned char __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_varint\", 0);\n\n  /* \"clickhouse_driver/varint.pyx\":33\n *     Reads integer of variable length using LEB128.\n *     \"\"\"\n *     cdef Py_ssize_t shift = 0             # <<<<<<<<<<<<<<\n *     cdef Py_ssize_t result = 0\n *     cdef unsigned char i\n */\n  __pyx_v_shift = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":34\n *     \"\"\"\n *     cdef Py_ssize_t shift = 0\n *     cdef Py_ssize_t result = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned char i\n * \n */\n  __pyx_v_result = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":37\n *     cdef unsigned char i\n * \n *     read_one = f.read_one             # <<<<<<<<<<<<<<\n * \n *     while True:\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_read_one); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 37, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_read_one = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":39\n *     read_one = f.read_one\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n */\n  while (1) {\n\n    /* \"clickhouse_driver/varint.pyx\":40\n * \n *     while True:\n *         i = read_one()             # <<<<<<<<<<<<<<\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n */\n    __Pyx_INCREF(__pyx_v_read_one);\n    __pyx_t_2 = __pyx_v_read_one; __pyx_t_3 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_3)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_3);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 40, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_4 = __Pyx_PyInt_As_unsigned_char(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 40, __pyx_L1_error)\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_i = __pyx_t_4;\n\n    /* \"clickhouse_driver/varint.pyx\":41\n *     while True:\n *         i = read_one()\n *         result |= (i & 0x7f) << shift             # <<<<<<<<<<<<<<\n *         shift += 7\n *         if i < 0x80:\n */\n    __pyx_v_result = (__pyx_v_result | ((__pyx_v_i & 0x7f) << __pyx_v_shift));\n\n    /* \"clickhouse_driver/varint.pyx\":42\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *         shift += 7             # <<<<<<<<<<<<<<\n *         if i < 0x80:\n *             break\n */\n    __pyx_v_shift = (__pyx_v_shift + 7);\n\n    /* \"clickhouse_driver/varint.pyx\":43\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    __pyx_t_5 = ((__pyx_v_i < 0x80) != 0);\n    if (__pyx_t_5) {\n\n      /* \"clickhouse_driver/varint.pyx\":44\n *         shift += 7\n *         if i < 0x80:\n *             break             # <<<<<<<<<<<<<<\n * \n *     return result\n */\n      goto __pyx_L4_break;\n\n      /* \"clickhouse_driver/varint.pyx\":43\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    }\n  }\n  __pyx_L4_break:;\n\n  /* \"clickhouse_driver/varint.pyx\":46\n *             break\n * \n *     return result             # <<<<<<<<<<<<<<\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/varint.pyx\":29\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.varint.read_varint\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_read_one);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 232,
        "code": "static TfLiteStatus InitTemporaryTensors(TfLiteContext* context,\n                                         TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  // The prepare function may be executed multiple times. But temporary tensors\n  // only need to be initiated once.\n  if (data->fft_integer_working_area_id != kTensorNotAllocated &&\n      data->fft_double_working_area_id != kTensorNotAllocated) {\n    return kTfLiteOk;\n  }\n\n  TfLiteIntArrayFree(node->temporaries);\n  // Create two temporary tensors.\n  node->temporaries = TfLiteIntArrayCreate(2);\n  int first_new_index;\n  TF_LITE_ENSURE_STATUS(context->AddTensors(context, 2, &first_new_index));\n  node->temporaries->data[kFftIntegerWorkingAreaTensor] = first_new_index;\n  data->fft_integer_working_area_id = first_new_index;\n  node->temporaries->data[kFftDoubleWorkingAreaTensor] = first_new_index + 1;\n  data->fft_double_working_area_id = first_new_index + 1;\n\n  // Set up FFT integer working area buffer.\n  TfLiteTensor* fft_integer_working_area =\n      GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n  fft_integer_working_area->type = kTfLiteInt32;\n  // If fft_length is not a constant tensor, fft_integer_working_area will be\n  // set to dynamic later in Prepare.\n  fft_integer_working_area->allocation_type = kTfLiteArenaRw;\n\n  // Set up FFT double working area buffer.\n  TfLiteTensor* fft_double_working_area =\n      GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n  // fft_double_working_area is a double tensor. Ideally, double should be\n  // added into tflite data types. However, since fft_double_working_area is a\n  // temporary tensor, and there are no ops having double input/output tensors\n  // in tflite at this point, adding double as a tflite data type may confuse\n  // users that double is supported. As a results, kTfLiteInt64 is used here\n  // for memory allocation. And it will be cast into double in Eval when being\n  // used.\n  fft_double_working_area->type = kTfLiteInt64;\n  // If fft_length is not a constant tensor, fft_double_working_area will be\n  // set to dynamic later in Prepare.\n  fft_double_working_area->allocation_type = kTfLiteArenaRw;\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 233,
        "code": "mrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)\n{\n  const struct RProc *p = mrb->c->ci->proc;\n  struct REnv *e;\n\n  if (!p || !MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from non-cfunc proc\");\n  }\n  e = MRB_PROC_ENV(p);\n  if (!e) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from cfunc Proc without REnv\");\n  }\n  if (idx < 0 || MRB_ENV_LEN(e) <= idx) {\n    mrb_raisef(mrb, E_INDEX_ERROR, \"Env index out of range: %i (expected: 0 <= index < %i)\",\n               idx, MRB_ENV_LEN(e));\n  }\n\n  return e->stack[idx];\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4110"
    },
    {
        "index": 234,
        "code": "static void bson_append32( bson *b, const void *data ) {\n    bson_little_endian32( b->cur, data );\n    b->cur += 4;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 235,
        "code": "Http1StreamEncoderOptionsOptRef ActiveStreamEncoderFilter::http1StreamEncoderOptions() {\n  // TODO(mattklein123): At some point we might want to actually wrap this interface but for now\n  // we give the filter direct access to the encoder options.\n  return parent_.filter_manager_callbacks_.http1StreamEncoderOptions();\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43825"
    },
    {
        "index": 236,
        "code": "int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n\t\t    u64 devid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 num_devices;\n\tint ret = 0;\n\n\tmutex_lock(&uuid_mutex);\n\n\tnum_devices = btrfs_num_devices(fs_info);\n\n\tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n\n\tif (IS_ERR(device)) {\n\t\tif (PTR_ERR(device) == -ENOENT &&\n\t\t    strcmp(device_path, \"missing\") == 0)\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\telse\n\t\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n\t\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t    fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tif (!ret)\n\t\tbtrfs_reada_remove_dev(device);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tbtrfs_scrub_cancel_dev(device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\t/*\n\t * In normal cases the cur_devices == fs_devices. But in case\n\t * of deleting a seed device, the cur_devices should point to\n\t * its own fs_devices listed under the fs_devices->seed.\n\t */\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tcur_devices->num_devices--;\n\tcur_devices->total_devices--;\n\t/* Update total_devices of the parent fs_devices if it's seed */\n\tif (cur_devices != fs_devices)\n\t\tfs_devices->total_devices--;\n\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\tcur_devices->missing_devices--;\n\n\tbtrfs_assign_next_active_device(device, NULL);\n\n\tif (device->bdev) {\n\t\tcur_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_sysfs_remove_device(device);\n\t}\n\n\tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t/*\n\t * at this point, the device is zero sized and detached from\n\t * the devices list.  All that's left is to zero out the old\n\t * supers and free the device.\n\t */\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n\t\t\t\t\t  device->name->str);\n\n\tbtrfs_close_bdev(device);\n\tsynchronize_rcu();\n\tbtrfs_free_device(device);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tlist_del_init(&cur_devices->seed_list);\n\t\tclose_fs_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n\nerror_undo:\n\tbtrfs_reada_undo_remove_dev(device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\tgoto out;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-3739"
    },
    {
        "index": 237,
        "code": "TfLiteStatus ReverseSequenceHelper(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* seq_lengths_tensor =\n      GetInput(context, node, kSeqLengthsTensor);\n  switch (seq_lengths_tensor->type) {\n    case kTfLiteInt32: {\n      return ReverseSequenceImpl<T, int32_t>(context, node);\n    }\n    case kTfLiteInt64: {\n      return ReverseSequenceImpl<T, int64_t>(context, node);\n    }\n    default: {\n      context->ReportError(\n          context,\n          \"Seq_lengths type '%s' is not supported by reverse_sequence.\",\n          TfLiteTypeGetName(seq_lengths_tensor->type));\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 238,
        "code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n    // Set output size to the input size in CancelOp::Prepare(). Code exists to\n    // have a framework in Prepare. The input and output tensors are not used.\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 239,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  auto& resources = subgraph->resources();\n  auto* variable = resource::GetResourceVariable(&resources, resource_id);\n  TF_LITE_ENSURE(context, variable != nullptr);\n\n  TfLiteTensor* variable_tensor = variable->GetTensor();\n  TfLiteTensor* output = GetOutput(context, node, kOutputValue);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, variable_tensor->type, output->type);\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(\n                   context, output, TfLiteIntArrayCopy(variable_tensor->dims)));\n  memcpy(output->data.raw, variable_tensor->data.raw, output->bytes);\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 240,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_11write_strings(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_items = 0;\n  PyObject *__pyx_v_encoding = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"write_strings (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_items,&__pyx_n_s_encoding,0};\n    PyObject* values[2] = {0,0};\n    values[1] = ((PyObject *)Py_None);\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_items)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (kw_args > 0) {\n          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_encoding);\n          if (value) { values[1] = value; kw_args--; }\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"write_strings\") < 0)) __PYX_ERR(0, 49, __pyx_L3_error)\n      }\n    } else {\n      switch (PyTuple_GET_SIZE(__pyx_args)) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n    }\n    __pyx_v_items = values[0];\n    __pyx_v_encoding = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"write_strings\", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 49, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.write_strings\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_10write_strings(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v_self), __pyx_v_items, __pyx_v_encoding);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 241,
        "code": "bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_supported_band *sband =\n\t\tlocal->hw.wiphy->bands[info->band];\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\t/* check for not even having the fixed radiotap header part */\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; /* too short to be possibly valid */\n\n\t/* is it a header version we can trust to find length from? */\n\tif (unlikely(rthdr->it_version))\n\t\treturn false; /* only version 0 is supported */\n\n\t/* does the skb contain enough to deliver on the alleged length? */\n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; /* skb too short for claimed rt header extent */\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.rst\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\tif (rate_found) {\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-38206"
    },
    {
        "index": 242,
        "code": "static bool set_sockaddr(sockaddr_storage &sa_storage, req::ptr<Socket> sock,\n                         const String& addr, int port,\n                         struct sockaddr *&sa_ptr, size_t &sa_size) {\n  // Always zero it out:\n  // - fields are added over time; zeroing it out is future-proofing; for\n  //   example, sockaddr_in6 did not originally include sin6_scope_id or\n  //   sin6_flowinfo.\n  // - required for all on MacOS for correct behavior\n  // - on Linux, required for sockaddr_un to deal with buggy sun_path readers\n  //   (they should look at the length)\n  memset(&sa_storage, 0, sizeof(struct sockaddr_storage));\n  struct sockaddr *sock_type = (struct sockaddr*) &sa_storage;\n  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {\n        // Linux supports 3 kinds of unix sockets; behavior of this struct\n        // is in `man 7 unix`; relevant parts:\n        // - unnamed: 0-length path. As paths are not required to be\n        //   null-terminated, this needs to be undicated by the size.\n        //   These might be created by `socketpair()`, for eaxmple.\n        // - pathname (common): nothing strange. struct size technically\n        //   indicates length, but null terminators are usually set. This\n        //   does matter if addr.length() == size of the char array though\n        // - abstract: these have a meaningful name, but start with `\\0`\n        //\n        // Setting sa_size to indicate a 0-length path is required to\n        // distinguish between unnamed and abstract.\n        sa_size = offsetof(struct sockaddr_un, sun_path);\n      }\n#endif\n\n#endif // ifdef _MSC_VER\n    }\n    break;\n  case AF_INET:\n    {\n      struct sockaddr_in *sa = (struct sockaddr_in *)sock_type;\n      sa->sin_family = AF_INET;\n      sa->sin_port = htons((unsigned short) port);\n      if (!php_set_inet_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in);\n    }\n    break;\n  case AF_INET6:\n    {\n      struct sockaddr_in6 *sa = (struct sockaddr_in6 *)sock_type;\n      sa->sin6_family = AF_INET6;\n      sa->sin6_port = htons((unsigned short) port);\n      if (!php_set_inet6_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in6);\n    }\n    break;\n  default:\n    raise_warning(\"unsupported socket type '%d', must be \"\n                    \"AF_UNIX, AF_INET, or AF_INET6\", sock->getType());\n    return false;\n  }\n#ifdef __APPLE__\n  // This field is not in the relevant standards, not defined on Linux, but is\n  // technically required on MacOS (and other BSDs) according to the man pages:\n  // - `man 4 netintro` covers the base sa_len\n  // - `man 4 unix` and `man 4 inet6` cover AF_UNIX sun_len and AF_INET6\n  //    sin6_len\n  // - ... At least MacOS Catalina includes the wrong `man 4 inet`. Look at the\n  //   (Net|Free|Open)BSD `man 4 inet` instead.\n  //   The MacOS man page says it starts with `sin_family`, which would conflict\n  //   with the base sockaddr definition. `sin_len` is actually the first field\n  //   in the header file, matching `sa_len`.\n  sa_ptr->sa_len = sa_size;\n#endif\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 243,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  if (type != kTfLiteInt32 && type != kTfLiteFloat32 && type != kTfLiteInt64) {\n    context->ReportError(context, \"Type '%s' is not supported by floor_mod.\",\n                         TfLiteTypeGetName(type));\n    return kTfLiteError;\n  }\n  output->type = type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 244,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader___init__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *__pyx_v_self, PyObject *__pyx_v_sock, PyObject *__pyx_v_bufsize) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":184\n * \n *     def __init__(self, sock, bufsize):\n *         self.sock = sock             # <<<<<<<<<<<<<<\n *         super(BufferedSocketReader, self).__init__(bufsize)\n * \n */\n  __Pyx_INCREF(__pyx_v_sock);\n  __Pyx_GIVEREF(__pyx_v_sock);\n  __Pyx_GOTREF(__pyx_v_self->sock);\n  __Pyx_DECREF(__pyx_v_self->sock);\n  __pyx_v_self->sock = __pyx_v_sock;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":185\n *     def __init__(self, sock, bufsize):\n *         self.sock = sock\n *         super(BufferedSocketReader, self).__init__(bufsize)             # <<<<<<<<<<<<<<\n * \n *     def read_into_buffer(self):\n */\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader));\n  __Pyx_GIVEREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader));\n  __Pyx_INCREF(((PyObject *)__pyx_v_self));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_self));\n  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_bufsize) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_bufsize);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 185, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":183\n *     cdef object sock\n * \n *     def __init__(self, sock, bufsize):             # <<<<<<<<<<<<<<\n *         self.sock = sock\n *         super(BufferedSocketReader, self).__init__(bufsize)\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedSocketReader.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 245,
        "code": "gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tunsigned char *buf = NULL;\n\tunsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL;\n\tuint32 row, y, nrow, rowstoread;\n\ttmsize_t pos;\n\ttmsize_t scanline;\n\tuint32 rowsperstrip, offset_row;\n\tuint32 imagewidth = img->width;\n\ttmsize_t stripsize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\n\tstripsize = TIFFStripSize(tif);  \n\tbufsize = _TIFFMultiplySSize(tif,alpha?4:3,stripsize, \"gtStripSeparate\");\n\tif (bufsize == 0) {\n\t\treturn (0);\n\t}\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tscanline = TIFFScanlineSize(tif);  \n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\toffset_row = row + img->row_offset;\n                if( buf == NULL )\n                {\n                    if (_TIFFReadEncodedStripAndAllocBuffer(\n                            tif, TIFFComputeStrip(tif, offset_row, 0),\n                            (void**) &buf, bufsize,\n                            ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n                        && (buf == NULL || img->stoponerr))\n                    {\n                            ret = 0;\n                            break;\n                    }\n                    p0 = buf;\n                    if( colorchannels == 1 )\n                    {\n                        p2 = p1 = p0;\n                        pa = (alpha?(p0+3*stripsize):NULL);\n                    }\n                    else\n                    {\n                        p1 = p0 + stripsize;\n                        p2 = p1 + stripsize;\n                        pa = (alpha?(p2+stripsize):NULL);\n                    }\n                }\n\t\telse if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),\n\t\t    p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),\n                                            p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),\n                                            p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (alpha)\n\t\t{\n\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels),\n\t\t\t    pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t\t    && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,\n\t\t    p2 + pos, (alpha?(pa+pos):NULL));\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-17546"
    },
    {
        "index": 246,
        "code": "void ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n                         struct ndpi_flow_struct* flow) {\n  struct ndpi_packet_struct* packet = &flow->packet;\n  const u_int8_t * ovpn_payload = packet->payload;\n  const u_int8_t * session_remote;\n  u_int8_t opcode;\n  u_int8_t alen;\n  int8_t hmac_size;\n  int8_t failed = 0;\n\n  if(packet->payload_packet_len >= 40) {\n    // skip openvpn TCP transport packet size\n    if(packet->tcp != NULL)\n      ovpn_payload += 2;\n\n    opcode = ovpn_payload[0] & P_OPCODE_MASK;\n\n    if(packet->udp) {\n#ifdef DEBUG\n      printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",\n\t     flow->num_processed_pkts,\n\t     opcode, check_pkid_and_detect_hmac_size(ovpn_payload),\n\t     htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);\t   \n#endif\n      \n      if(\n\t (flow->num_processed_pkts == 1)\n\t && (\n\t     ((packet->payload_packet_len == 112)\n\t      && ((opcode == 168) || (opcode == 192))\n\t      )\n\t     || ((packet->payload_packet_len == 80)\n\t\t && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))\n\t     )) {\n\tNDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n    }\n    \n    if(flow->ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && (opcode == P_CONTROL_HARD_RESET_CLIENT_V1 ||\n\t\t\t\t    opcode == P_CONTROL_HARD_RESET_CLIENT_V2)) {\n      if(check_pkid_and_detect_hmac_size(ovpn_payload) > 0) {\n        memcpy(flow->ovpn_session_id, ovpn_payload+1, 8);\n\n        NDPI_LOG_DBG2(ndpi_struct,\n\t\t \"session key: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t flow->ovpn_session_id[0], flow->ovpn_session_id[1], flow->ovpn_session_id[2], flow->ovpn_session_id[3],\n\t\t flow->ovpn_session_id[4], flow->ovpn_session_id[5], flow->ovpn_session_id[6], flow->ovpn_session_id[7]);\n      }\n    } else if(flow->ovpn_counter >= 1 && flow->ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT &&\n            (opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2)) {\n\n      hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);\n\n      if(hmac_size > 0) {\n        alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];\n        if (alen > 0) {\n\t  session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;\n\n          if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n\t    NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  } else {\n            NDPI_LOG_DBG2(ndpi_struct,\n\t\t   \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t   session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n\t\t   session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n            failed = 1;\n          }\n        } else\n          failed = 1;\n      } else\n        failed = 1;\n    } else\n      failed = 1;\n\n    flow->ovpn_counter++;\n    \n    if(failed) {\n      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15473"
    },
    {
        "index": 247,
        "code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\n\t/* Set the default value for *ret_username */\n\t*ret_username = NULL;\n\n\t/*\n\t * Set the initial value for username - this is a buffer holds\n\t * the user name.\n\t */\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\n\t/*\n\t * The user_input is guaranteed to be terminated by a null character.\n\t */\n\tptr = user_input;\n\n\t/* Skip all the leading whitespaces if there are any. */\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\n\tif (*ptr == '\\0') {\n\t\t/*\n\t\t * We should never get here since the user_input we got\n\t\t * in pam_get_user() is not all whitespaces nor just \"\\0\".\n\t\t */\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\t/*\n\t * username will be the first string we get from user_input\n\t * - we skip leading whitespaces and ignore trailing whitespaces\n\t */\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\t/* ret_username will be freed in pam_get_user(). */\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-27678"
    },
    {
        "index": 248,
        "code": "static bool set_sockaddr(sockaddr_storage &sa_storage, req::ptr<Socket> sock,\n                         const String& addr, int port,\n                         struct sockaddr *&sa_ptr, size_t &sa_size) {\n  // Always zero it out:\n  // - fields are added over time; zeroing it out is future-proofing; for\n  //   example, sockaddr_in6 did not originally include sin6_scope_id or\n  //   sin6_flowinfo.\n  // - required for all on MacOS for correct behavior\n  // - on Linux, required for sockaddr_un to deal with buggy sun_path readers\n  //   (they should look at the length)\n  memset(&sa_storage, 0, sizeof(struct sockaddr_storage));\n  struct sockaddr *sock_type = (struct sockaddr*) &sa_storage;\n  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {\n        // Linux supports 3 kinds of unix sockets; behavior of this struct\n        // is in `man 7 unix`; relevant parts:\n        // - unnamed: 0-length path. As paths are not required to be\n        //   null-terminated, this needs to be undicated by the size.\n        //   These might be created by `socketpair()`, for eaxmple.\n        // - pathname (common): nothing strange. struct size technically\n        //   indicates length, but null terminators are usually set. This\n        //   does matter if addr.length() == size of the char array though\n        // - abstract: these have a meaningful name, but start with `\\0`\n        //\n        // Setting sa_size to indicate a 0-length path is required to\n        // distinguish between unnamed and abstract.\n        sa_size = offsetof(struct sockaddr_un, sun_path);\n      }\n#endif\n\n#endif // ifdef _MSC_VER\n    }\n    break;\n  case AF_INET:\n    {\n      struct sockaddr_in *sa = (struct sockaddr_in *)sock_type;\n      sa->sin_family = AF_INET;\n      sa->sin_port = htons((unsigned short) port);\n      if (!php_set_inet_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in);\n    }\n    break;\n  case AF_INET6:\n    {\n      struct sockaddr_in6 *sa = (struct sockaddr_in6 *)sock_type;\n      sa->sin6_family = AF_INET6;\n      sa->sin6_port = htons((unsigned short) port);\n      if (!php_set_inet6_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in6);\n    }\n    break;\n  default:\n    raise_warning(\"unsupported socket type '%d', must be \"\n                    \"AF_UNIX, AF_INET, or AF_INET6\", sock->getType());\n    return false;\n  }\n#ifdef __APPLE__\n  // This field is not in the relevant standards, not defined on Linux, but is\n  // technically required on MacOS (and other BSDs) according to the man pages:\n  // - `man 4 netintro` covers the base sa_len\n  // - `man 4 unix` and `man 4 inet6` cover AF_UNIX sun_len and AF_INET6\n  //    sin6_len\n  // - ... At least MacOS Catalina includes the wrong `man 4 inet`. Look at the\n  //   (Net|Free|Open)BSD `man 4 inet` instead.\n  //   The MacOS man page says it starts with `sin_family`, which would conflict\n  //   with the base sockaddr definition. `sin_len` is actually the first field\n  //   in the header file, matching `sa_len`.\n  sa_ptr->sa_len = sa_size;\n#endif\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 249,
        "code": "int64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n  }\n  m_cursor += length;\n  return length;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 250,
        "code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n\n    return BSON_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 251,
        "code": "static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 252,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->inputs->size == kInputNum);\n  TF_LITE_ENSURE(context, node->outputs->size == kOutputNum);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputData);\n  const TfLiteTensor* prev_activation =\n      GetInput(context, node, kInputPrevActivation);\n  const TfLiteTensor* weights = GetInput(context, node, kInputWeights);\n  const TfLiteTensor* bias = GetInput(context, node, kInputBiases);\n  const TfLiteTensor* prev_state = GetInput(context, node, kInputPrevState);\n\n  TF_LITE_ENSURE_EQ(context, input->dims->size, 2);\n  const int num_batches = input->dims->data[0];\n  const int input_depth = input->dims->data[1];\n\n  TF_LITE_ENSURE_EQ(context, prev_activation->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, prev_activation->dims->data[0], num_batches);\n  const int activation_depth = prev_activation->dims->data[1];\n  const int total_depth = input_depth + activation_depth;\n\n  TF_LITE_ENSURE_EQ(context, weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, weights->dims->data[0], 4 * activation_depth);\n  TF_LITE_ENSURE_EQ(context, weights->dims->data[1], total_depth);\n\n  TF_LITE_ENSURE_EQ(context, bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, bias->dims->data[0], 4 * activation_depth);\n\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->data[0], num_batches);\n  TF_LITE_ENSURE_EQ(context, prev_state->dims->data[1], activation_depth);\n\n  TfLiteTensor* activation_out = GetOutput(context, node, kOutputActivation);\n  TfLiteTensor* state_out = GetOutput(context, node, kOutputState);\n  TfLiteTensor* concat_temp = GetOutput(context, node, kOutputConcatTemp);\n  TfLiteTensor* activation_temp =\n      GetOutput(context, node, kOutputActivationTemp);\n\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(\n                                 context, activation_out,\n                                 TfLiteIntArrayCopy(prev_activation->dims)));\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, state_out,\n                                     TfLiteIntArrayCopy(prev_state->dims)));\n\n  TfLiteIntArray* concat_temp_size = TfLiteIntArrayCreate(2);\n  concat_temp_size->data[0] = num_batches;\n  concat_temp_size->data[1] = total_depth;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, concat_temp, concat_temp_size));\n  TfLiteIntArray* activation_temp_size = TfLiteIntArrayCreate(2);\n  activation_temp_size->data[0] = num_batches;\n  activation_temp_size->data[1] = 4 * activation_depth;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, activation_temp,\n                                                   activation_temp_size));\n\n  // Set the state tensors as persistent.\n  for (auto index : {kInputPrevActivation, kInputPrevState}) {\n    TfLiteTensor* tensor = &context->tensors[node->inputs->data[index]];\n    tensor->allocation_type = kTfLiteArenaRwPersistent;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 253,
        "code": "TypedValue HHVM_FUNCTION(substr_compare,\n                         const String& main_str,\n                         const String& str,\n                         int offset,\n                         int length /* = INT_MAX */,\n                         bool case_insensitivity /* = false */) {\n  int s1_len = main_str.size();\n  int s2_len = str.size();\n\n  if (length <= 0) {\n    raise_warning(\"The length must be greater than zero\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (offset < 0) {\n    offset = s1_len + offset;\n    if (offset < 0) offset = 0;\n  }\n\n  if (offset >= s1_len) {\n    raise_warning(\"The start position cannot exceed initial string length\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  int cmp_len = s1_len - offset;\n  if (cmp_len < s2_len) cmp_len = s2_len;\n  if (cmp_len > length) cmp_len = length;\n\n  const char *s1 = main_str.data();\n  if (case_insensitivity) {\n    return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len));\n  }\n  return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 254,
        "code": "MONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n\n    int first_chunk;\n    int last_chunk;\n    int total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n\n    return size;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 255,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  static const int kOutputUniqueTensor = 0;\n  static const int kOutputIndexTensor = 1;\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 2);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output_unique_tensor =\n      GetOutput(context, node, kOutputUniqueTensor);\n  TfLiteTensor* output_index_tensor =\n      GetOutput(context, node, kOutputIndexTensor);\n\n  // The op only supports 1D input.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TfLiteIntArray* output_index_shape = TfLiteIntArrayCopy(input->dims);\n  // The unique values are determined during evaluation, so we don't know yet\n  // the size of the output tensor.\n  SetTensorToDynamic(output_unique_tensor);\n  return context->ResizeTensor(context, output_index_tensor,\n                               output_index_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 256,
        "code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-18750"
    },
    {
        "index": 257,
        "code": "bool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n  // padding is d x 2 tensor, where d is the dimension of input.\n  const TfLiteTensor* padding = GetInput(context, node, 1);\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 258,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter___init__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *__pyx_v_self, PyObject *__pyx_v_sock, PyObject *__pyx_v_bufsize) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":67\n * \n *     def __init__(self, sock, bufsize):\n *         self.sock = sock             # <<<<<<<<<<<<<<\n *         super(BufferedSocketWriter, self).__init__(bufsize)\n * \n */\n  __Pyx_INCREF(__pyx_v_sock);\n  __Pyx_GIVEREF(__pyx_v_sock);\n  __Pyx_GOTREF(__pyx_v_self->sock);\n  __Pyx_DECREF(__pyx_v_self->sock);\n  __pyx_v_self->sock = __pyx_v_sock;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":68\n *     def __init__(self, sock, bufsize):\n *         self.sock = sock\n *         super(BufferedSocketWriter, self).__init__(bufsize)             # <<<<<<<<<<<<<<\n * \n *     cpdef write_into_stream(self):\n */\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter));\n  __Pyx_GIVEREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter));\n  __Pyx_INCREF(((PyObject *)__pyx_v_self));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_self));\n  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 68, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_bufsize) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_bufsize);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":66\n *     cdef object sock\n * \n *     def __init__(self, sock, bufsize):             # <<<<<<<<<<<<<<\n *         self.sock = sock\n *         super(BufferedSocketWriter, self).__init__(bufsize)\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedSocketWriter.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 259,
        "code": "SpeechRecognitionManagerImpl::SpeechRecognitionManagerImpl(\n    media::AudioSystem* audio_system,\n    MediaStreamManager* media_stream_manager)\n    : audio_system_(audio_system),\n      media_stream_manager_(media_stream_manager),\n      primary_session_id_(kSessionIDInvalid),\n      last_session_id_(kSessionIDInvalid),\n      is_dispatching_event_(false),\n       delegate_(GetContentClient()\n                     ->browser()\n                     ->CreateSpeechRecognitionManagerDelegate()),\n       weak_factory_(this) {\n   DCHECK(!g_speech_recognition_manager_impl);\n   g_speech_recognition_manager_impl = this;\n\n  frame_deletion_observer_.reset(new FrameDeletionObserver(\n      base::BindRepeating(&SpeechRecognitionManagerImpl::AbortSessionImpl,\n                          weak_factory_.GetWeakPtr())));\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 260,
        "code": "static Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), //TODO: extra\n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[100];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 261,
        "code": "strncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Allocate buffer for MBS.\n\t * We need this allocation here since it is possible that\n\t * as->s is still NULL.\n\t */\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\t/* Re-allocate buffer for MBS. */\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\n\t\t/*\n\t\t * As libarchive 2.x, translates the UTF-8 characters into\n\t\t * wide-characters in the assumption that WCS is Unicode.\n\t\t */\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\n\t\ts += n;\n\t\tlen -= n;\n\t\t/*\n\t\t * Translates the wide-character into the current locale MBS.\n\t\t */\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21674"
    },
    {
        "index": 262,
        "code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-36143"
    },
    {
        "index": 263,
        "code": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-40564"
    },
    {
        "index": 266,
        "code": "static bool php_openssl_validate_iv(\n    String piv,\n    int iv_required_len,\n    String& out,\n    EVP_CIPHER_CTX* cipher_ctx,\n    const php_openssl_cipher_mode* mode) {\n  if (cipher_ctx == nullptr || mode == nullptr) {\n    return false;\n  }\n\n  /* Best case scenario, user behaved */\n  if (piv.size() == iv_required_len) {\n    out = std::move(piv);\n    return true;\n  }\n\n  if (mode->is_aead) {\n    if (EVP_CIPHER_CTX_ctrl(\n            cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) {\n      raise_warning(\n          \"Setting of IV length for AEAD mode failed, the expected length is \"\n          \"%d bytes\",\n          iv_required_len);\n      return false;\n    }\n    out = std::move(piv);\n    return true;\n  }\n\n  String s = String(iv_required_len, ReserveString);\n  char* iv_new = s.mutableData();\n  memset(iv_new, 0, iv_required_len);\n\n  if (piv.size() <= 0) {\n    /* BC behavior */\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  if (piv.size() < iv_required_len) {\n    raise_warning(\"IV passed is only %d bytes long, cipher \"\n                  \"expects an IV of precisely %d bytes, padding with \\\\0\",\n                  piv.size(), iv_required_len);\n    memcpy(iv_new, piv.data(), piv.size());\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  raise_warning(\"IV passed is %d bytes long which is longer than the %d \"\n                \"expected by selected cipher, truncating\", piv.size(),\n                iv_required_len);\n  memcpy(iv_new, piv.data(), iv_required_len);\n  s.setSize(iv_required_len);\n  out = std::move(s);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 268,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 269,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params =\n      reinterpret_cast<TfLiteUnidirectionalSequenceLSTMParams*>(\n          node->builtin_data);\n  const OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const bool is_layer_norm_lstm = op_data->is_layer_norm_lstm;\n  const bool time_major = params->time_major;\n  const TfLiteTensor* input = GetInput(context, node, lstm::full::kInputTensor);\n\n  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, lstm::full::kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, lstm::full::kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, lstm::full::kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, lstm::full::kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, lstm::full::kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, lstm::full::kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, lstm::full::kForgetGateBiasTensor);\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, lstm::full::kCellGateBiasTensor);\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, lstm::full::kOutputGateBiasTensor);\n\n  const TfLiteTensor* projection_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor);\n\n  // Index the scratch buffers pointers to the global scratch buffer.\n  TfLiteTensor* scratch_buffer = GetTemporary(context, node, kScratchBuffer);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, lstm::full::kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state =\n      GetVariableInput(context, node, lstm::full::kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetOptionalInputTensor(\n                context, node, lstm::full::kInputLayerNormCoefficientsTensor)\n          : nullptr;\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetInput(context, node,\n                     lstm::full::kForgetLayerNormCoefficientsTensor)\n          : nullptr;\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetInput(context, node,\n                     lstm::full::kCellLayerNormCoefficientsTensor)\n          : nullptr;\n  const TfLiteTensor* output_layer_norm_coefficients =\n      is_layer_norm_lstm\n          ? GetInput(context, node,\n                     lstm::full::kOutputLayerNormCoefficientsTensor)\n          : nullptr;\n\n  TfLiteTensor* output = GetOutput(context, node, lstm::full::kOutputTensor);\n\n  // Copy out the LSTM specific params so they can be passed in the function.\n  TfLiteLSTMParams lstm_params;\n  lstm_params.activation = params->activation;\n  lstm_params.cell_clip = params->cell_clip;\n  lstm_params.proj_clip = params->proj_clip;\n  lstm_params.asymmetric_quantize_inputs = params->asymmetric_quantize_inputs;\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n          cell_to_input_weights, cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*aux_input_to_forget_weights=*/nullptr,\n          /*aux_input_to_cell_weights=*/nullptr,\n          /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n          forget_gate_bias, cell_gate_bias, output_gate_bias,\n          projection_weights, projection_bias, &lstm_params,\n          /*forward_sequence=*/true, time_major,\n          /*output_offset=*/0, scratch_buffer, output_state, cell_state,\n          output);\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n      TfLiteTensor* row_sums = GetTemporary(context, node, kRowSums);\n      const int row_sums_size = row_sums->dims->data[0];\n      return lstm_eval::EvalHybrid(\n          input, input_to_input_weights,\n          /*input_to_input_weights_ledger*/ nullptr, input_to_forget_weights,\n          /*input_to_forget_weights_ledger*/ nullptr, input_to_cell_weights,\n          /*input_to_cell_weights_ledger*/ nullptr, input_to_output_weights,\n          /*input_to_output_weights_ledger*/ nullptr,\n          recurrent_to_input_weights,\n          /*recurrent_to_input_weights_ledger*/ nullptr,\n          recurrent_to_forget_weights,\n          /*recurrent_to_forget_weights_ledger*/ nullptr,\n          recurrent_to_cell_weights,\n          /*recurrent_to_cell_weights_ledger*/ nullptr,\n          recurrent_to_output_weights,\n          /*recurrent_to_output_weights_ledger*/ nullptr, cell_to_input_weights,\n          cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*aux_input_to_forget_weights=*/nullptr,\n          /*aux_input_to_cell_weights=*/nullptr,\n          /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n          forget_gate_bias, cell_gate_bias, output_gate_bias,\n          projection_weights, /*projection_weights_ledger*/ nullptr,\n          projection_bias, &lstm_params,\n          /*forward_sequence=*/true, time_major,\n          /*output_offset=*/0, scratch_buffer,\n          GetTemporary(context, node, kInputScalingFactors),\n          /*aux_input_sf=*/nullptr,\n          GetTemporary(context, node, kOutputStateScalingFactors),\n          GetTemporary(context, node, kProductScalingFactors),\n          GetTemporary(context, node, kRecoveredCellWeights),\n          GetTemporary(context, node, kInputQuantized),\n          /*aux_input_quantized=*/nullptr,\n          GetTemporary(context, node, kOutputStateQuantized),\n          GetTemporary(context, node, kCellStateQuantized), output_state,\n          cell_state, GetTemporary(context, node, kAccumScratch), output,\n          GetTemporary(context, node, kInputZeroPoints),\n          /*aux_input_zp=*/nullptr,\n          GetTemporary(context, node, kOutputStateZeroPoints), row_sums,\n          row_sums_size, &op_data->compute_row_sums,\n          CpuBackendContext::GetFromContext(context));\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s is not currently supported.\",\n                         TfLiteTypeGetName(input_to_output_weights->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 270,
        "code": "\n    Comment[nch] = '\\0'; // Null terminate\n\n\n\n    if (ShowTags){\n\n        printf(\"COM marker comment: %s\\n\",Comment);\n\n    }\n\n\n\n    strcpy(ImageInfo.Comments,Comment);\n\n}\n\n\n\n \n\n//--------------------------------------------------------------------------\n\n// Process a SOFn marker.  This is useful for the image dimensions\n\n//--------------------------------------------------------------------------\n\nstatic void process_SOFn (const uchar * Data, int marker)\n\n{\n\n    int data_precision, num_components;\n\n\n\n    data_precision = Data[2];\n\n    ImageInfo.Height = Get16m(Data+3);\n\n    ImageInfo.Width = Get16m(Data+5);\n\n    num_components = Data[7];\n\n\n\n    if (num_components == 3){\n\n        ImageInfo.IsColor = 1;\n\n    }else{\n\n        ImageInfo.IsColor = 0;\n\n    }\n\n\n\n    ImageInfo.Process = marker;\n\n\n\n    if (ShowTags){\n\n        printf(\"JPEG image is %uw * %uh, %d color components, %d bits per sample\\n\",\n\n                   ImageInfo.Width, ImageInfo.Height, num_components, data_precision);\n\n    }\n\n}\n\n\n\n\n\n//--------------------------------------------------------------------------\n\n// Check sections array to see if it needs to be increased in size.\n\n//--------------------------------------------------------------------------\n\nstatic void CheckSectionsAllocated(void)\n\n{\n\n    if (SectionsRead > SectionsAllocated){\n\n        ErrFatal(\"allocation screwup\");\n\n    }\n\n    if (SectionsRead >= SectionsAllocated){\n\n        SectionsAllocated += SectionsAllocated/2;\n\n        Sections = (Section_t *)realloc(Sections, sizeof(Section_t)*SectionsAllocated);\n\n        if (Sections == NULL){\n\n            ErrFatal(\"could not allocate data for entire image\");\n\n        }\n\n    }\n\n}\n\n\n\n\n\n//--------------------------------------------------------------------------\n\n// Parse the marker stream until SOS or EOI is seen;\n\n//--------------------------------------------------------------------------\n\nint ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\n\n{\n\n    int a;\n\n    int HaveCom = FALSE;\n\n\n\n    a = fgetc(infile);\n\n\n\n    if (a != 0xff || fgetc(infile) != M_SOI){\n\n        return FALSE;\n\n    }\n\n\n\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\n\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\n\n\n\n    for(;;){\n\n        int itemlen;\n\n        int prev;\n\n        int marker = 0;\n\n        int ll,lh, got;\n\n        uchar * Data;\n\n\n\n        CheckSectionsAllocated();\n\n\n\n        prev = 0;\n\n        for (a=0;;a++){\n\n            marker = fgetc(infile);\n\n            if (marker != 0xff && prev == 0xff) break;\n\n            if (marker == EOF){\n\n                ErrFatal(\"Unexpected end of file\");\n\n            }\n\n            prev = marker;\n\n        }\n\n\n\n        if (a > 10){\n\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\n\n        }\n\n\n\n        Sections[SectionsRead].Type = marker;\n\n  \n\n        // Read the length of the section.\n\n        lh = fgetc(infile);\n\n        ll = fgetc(infile);\n\n        if (lh == EOF || ll == EOF){\n\n            ErrFatal(\"Unexpected end of file\");\n\n        }\n\n\n\n        itemlen = (lh << 8) | ll;\n\n\n\n        if (itemlen < 2){\n\n            ErrFatal(\"invalid marker\");\n\n        }\n\n\n\n        Sections[SectionsRead].Size = itemlen;\n\n\n\n        Data = (uchar *)malloc(itemlen);\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26208"
    },
    {
        "index": 271,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  OpContext op_context(context, node);\n  if (IsConstantTensor(op_context.input) && op_data->float_input_initialized) {\n    return kTfLiteOk;\n  }\n\n  // Dequantize the input\n  TfLiteTensor* dequantized = GetTemporary(context, node, /*index=*/0);\n  auto status = builtin::dequantize::DequantizeImpl<kernel_type>(\n      context, node, op_context.input, dequantized);\n  if (status != kTfLiteOk) {\n    return status;\n  }\n\n  if (IsConstantTensor(op_context.input)) {\n    op_data->float_input_initialized = true;\n  }\n\n  // If the tolerance is very small, we only display the stats of the diff.\n  if (op_data->tolerance < 0.1) {\n    std::vector<double> diffs, temp;\n    diffs.reserve(NumElements(dequantized));\n    temp.reserve(NumElements(dequantized));\n    for (int i = 0; i < NumElements(op_context.ref); ++i) {\n      float dequant = GetTensorData<float>(dequantized)[i];\n      float reference = GetTensorData<float>(op_context.ref)[i];\n      diffs.push_back(dequant - reference);\n    }\n    double mean =\n        std::accumulate(diffs.begin(), diffs.end(), 0.0) / diffs.size();\n    double max_diff = 0.0;\n    std::transform(diffs.begin(), diffs.end(), temp.begin(),\n                   [mean, &max_diff](double x) {\n                     max_diff = std::max(max_diff, std::abs(x));\n                     return x - mean;\n                   });\n    double sq_sum =\n        std::inner_product(temp.begin(), temp.end(), temp.begin(), 0.0);\n    double std = std::sqrt(sq_sum / diffs.size());\n    TF_LITE_KERNEL_LOG(\n        context,\n        \"std: %f, mean: %f, max_diff: %f (scale: %f, zero_point: %d).\\n\", std,\n        mean, max_diff, op_context.input->params.scale,\n        op_context.input->params.zero_point);\n    return kTfLiteOk;\n  }\n\n  // Verify the dequantized output.\n  auto max_diff = op_data->tolerance * op_context.input->params.scale;\n  for (int i = 0; i < NumElements(op_context.ref); ++i) {\n    int32_t value = GetQuantizedValue(op_context, i);\n    float dequant = GetTensorData<float>(dequantized)[i];\n    float reference = GetTensorData<float>(op_context.ref)[i];\n    float diff = std::abs(reference - dequant);\n    if (diff > max_diff) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Mismatch: %f is quantized to %d with (%f, %d). \"\n          \"abs(%f - %f) = %f > %f (tolerance) range percentage %f.\\n\",\n          reference, value, op_context.input->params.scale,\n          op_context.input->params.zero_point, reference, dequant, diff,\n          max_diff, op_data->tolerance);\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 272,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_19current_buffer_size_2__set__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v_value) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  Py_ssize_t __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__set__\", 0);\n  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_value); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 11, __pyx_L1_error)\n  __pyx_v_self->current_buffer_size = __pyx_t_1;\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.current_buffer_size.__set__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 273,
        "code": "Network::FilterStatus Filter::onNewConnection() {\n  if (config_->maxDownstreamConnectionDuration()) {\n    connection_duration_timer_ = read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onMaxDownstreamConnectionDuration(); });\n    connection_duration_timer_->enableTimer(config_->maxDownstreamConnectionDuration().value());\n  }\n  return initializeUpstreamConnection();\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43826"
    },
    {
        "index": 274,
        "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 275,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims = GetInput(context, node, kDimsTensor);\n  const TfLiteTensor* value = GetInput(context, node, kValueTensor);\n\n  // Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  // Make sure the 1st input tensor is int32 or int64.\n  const auto dtype = dims->type;\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  // Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 276,
        "code": "TfLiteStatus CheckInputTensorDimensions(TfLiteContext* context,\n                                        TfLiteNode* node, int n_input,\n                                        int n_output, int n_cell,\n                                        bool is_layer_norm_lstm) {\n  const auto* params = reinterpret_cast<TfLiteLSTMParams*>(node->builtin_data);\n\n  // Making sure clipping parameters have valid values.\n  // == 0 means no clipping\n  //  > 0 means clipping\n  TF_LITE_ENSURE(context, params->cell_clip >= 0);\n  TF_LITE_ENSURE(context, params->proj_clip >= 0);\n\n  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kInputToInputWeightsTensor);\n  if (input_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->data[1], n_input);\n  }\n\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, lstm::full::kInputToForgetWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->data[1], n_input);\n\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, lstm::full::kInputToCellWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->data[1], n_input);\n\n  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kRecurrentToInputWeightsTensor);\n  if (recurrent_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->data[0],\n                      n_cell);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->data[1],\n                      n_output);\n  }\n\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, lstm::full::kRecurrentToForgetWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->data[0],\n                    n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->data[1],\n                    n_output);\n\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, lstm::full::kRecurrentToCellWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->data[1],\n                    n_output);\n\n  // We make sure the input-gate's parameters are either both present (regular\n  // LSTM) or not at all (CIFG-LSTM).\n  const bool cifg_weights_all_or_none =\n      ((input_to_input_weights != nullptr) &&\n       (recurrent_to_input_weights != nullptr)) ||\n      ((input_to_input_weights == nullptr) &&\n       (recurrent_to_input_weights == nullptr));\n  TF_LITE_ENSURE(context, cifg_weights_all_or_none == true);\n\n  const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToInputWeightsTensor);\n  if (cell_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights->dims->data[0], n_cell);\n  }\n\n  const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToForgetWeightsTensor);\n  if (cell_to_forget_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights->dims->data[0], n_cell);\n  }\n\n  const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kCellToOutputWeightsTensor);\n  if (cell_to_output_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights->dims->data[0], n_cell);\n  }\n\n  // Making sure the peephole weights are there all or none.\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  const bool peephole_weights_all_or_none =\n      ((cell_to_input_weights != nullptr || use_cifg) &&\n       (cell_to_forget_weights != nullptr) &&\n       (cell_to_output_weights != nullptr)) ||\n      ((cell_to_input_weights == nullptr) &&\n       (cell_to_forget_weights == nullptr) &&\n       (cell_to_output_weights == nullptr));\n  TF_LITE_ENSURE(context, peephole_weights_all_or_none == true);\n\n  // Make sure the input gate bias is present only when not a CIFG-LSTM.\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kInputGateBiasTensor);\n  if (use_cifg) {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias, nullptr);\n  } else {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, input_gate_bias->dims->data[0], n_cell);\n  }\n\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, lstm::full::kForgetGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias->dims->data[0], n_cell);\n\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, lstm::full::kCellGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->dims->data[0], n_cell);\n\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, lstm::full::kOutputGateBiasTensor);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias->dims->data[0], n_cell);\n\n  const TfLiteTensor* projection_weights = GetOptionalInputTensor(\n      context, node, lstm::full::kProjectionWeightsTensor);\n  if (projection_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->data[0], n_output);\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->data[1], n_cell);\n  }\n\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor);\n  if (projection_bias != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_bias->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, projection_bias->dims->data[0], n_output);\n  }\n\n  // Making sure the projection tensors are consistent:\n  // 1) If projection weight is not present, then projection bias should not be\n  // present.\n  // 2) If projection weight is present, then projection bias is optional.\n  // TODO(ghodrat): make sure this is correct.\n  const bool projecton_tensors_consistent =\n      ((projection_weights != nullptr) || (projection_bias == nullptr));\n  TF_LITE_ENSURE(context, projecton_tensors_consistent == true);\n\n  if (is_layer_norm_lstm) {\n    const TfLiteTensor* input_layer_norm_coefficients = GetOptionalInputTensor(\n        context, node, lstm::full::kInputLayerNormCoefficientsTensor);\n    if (use_cifg) {\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients, nullptr);\n    } else {\n      TF_LITE_ENSURE(context, input_layer_norm_coefficients != nullptr);\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients->dims->size, 1);\n      TF_LITE_ENSURE_EQ(context, input_layer_norm_coefficients->dims->data[0],\n                        n_cell);\n      TF_LITE_ENSURE_TYPES_EQ(context, input_layer_norm_coefficients->type,\n                              kTfLiteFloat32);\n    }\n\n    const TfLiteTensor* forget_layer_norm_coefficients =\n        GetInput(context, node, lstm::full::kForgetLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, forget_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, forget_layer_norm_coefficients->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, forget_layer_norm_coefficients->dims->data[0],\n                      n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, forget_layer_norm_coefficients->type,\n                            kTfLiteFloat32);\n\n    const TfLiteTensor* cell_layer_norm_coefficients =\n        GetInput(context, node, lstm::full::kCellLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, cell_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, cell_layer_norm_coefficients->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_layer_norm_coefficients->dims->data[0],\n                      n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_layer_norm_coefficients->type,\n                            kTfLiteFloat32);\n\n    const TfLiteTensor* output_layer_norm_coefficients =\n        GetInput(context, node, lstm::full::kOutputLayerNormCoefficientsTensor);\n    TF_LITE_ENSURE(context, output_layer_norm_coefficients != nullptr);\n    TF_LITE_ENSURE_EQ(context, output_layer_norm_coefficients->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, output_layer_norm_coefficients->dims->data[0],\n                      n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, output_layer_norm_coefficients->type,\n                            kTfLiteFloat32);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 277,
        "code": "int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n            \n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 278,
        "code": "bool logToUSDT(const Array& bt) {\n  std::lock_guard<std::mutex> lock(usdt_mutex);\n\n  memset(&bt_slab, 0, sizeof(bt_slab));\n\n  int i = 0;\n  IterateVNoInc(\n    bt.get(),\n    [&](TypedValue tv) -> bool {\n\n      if (i >= strobelight::kMaxStackframes) {\n        return true;\n      }\n\n      assertx(isArrayLikeType(type(tv)));\n      ArrayData* bt_frame = val(tv).parr;\n      strobelight::backtrace_frame_t* frame = &bt_slab.frames[i];\n\n      auto const line = bt_frame->get(s_line.get());\n      if (line.is_init()) {\n        assertx(isIntType(type(line)));\n        frame->line = val(line).num;\n      }\n\n      auto const file_name = bt_frame->get(s_file.get());\n      if (file_name.is_init()) {\n        assertx(isStringType(type(file_name)));\n        strncpy(frame->file_name,\n                val(file_name).pstr->data(),\n                std::min(val(file_name).pstr->size(), strobelight::kFileNameMax));\n        frame->file_name[strobelight::kFileNameMax - 1] = '\\0';\n      }\n\n      auto const class_name = bt_frame->get(s_class.get());\n      if (class_name.is_init()) {\n        assertx(isStringType(type(class_name)));\n        strncpy(frame->class_name,\n                val(class_name).pstr->data(),\n                std::min(val(class_name).pstr->size(), strobelight::kClassNameMax));\n        frame->class_name[strobelight::kClassNameMax - 1] = '\\0';\n      }\n\n      auto const function_name = bt_frame->get(s_function.get());\n      if (function_name.is_init()) {\n        assertx(isStringType(type(function_name)));\n        strncpy(frame->function,\n                val(function_name).pstr->data(),\n                std::min(val(function_name).pstr->size(),\n                         strobelight::kFunctionMax));\n        frame->function[strobelight::kFunctionMax - 1] = '\\0';\n      }\n\n      i++;\n      return false;\n    }\n  );\n  bt_slab.len = i;\n\n  // Allow BPF to read the now-formatted stacktrace\n  FOLLY_SDT_WITH_SEMAPHORE(hhvm, hhvm_stack, &bt_slab);\n\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 279,
        "code": "exif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Parsing %i byte(s) EXIF data...\\n\", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Found EXIF header at start.\");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", _(\"EXIF marker not found.\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"We have to deal with %i byte(s) of EXIF data.\",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"EXIF header not found.\"));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Found EXIF header.\");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \"II\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \"MM\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"Unknown encoding.\"));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \n\t\t  \"IFD 0 at %i.\", (int) offset);\n\n\t/* Sanity check the offset, being careful about overflow */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"IFD 1 at %i.\", (int) offset);\n\n\t\t/* Sanity check. */\n\t\tif (offset > ds || offset + 6 > ds) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", \"Bogus offset of IFD1.\");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-9278"
    },
    {
        "index": 280,
        "code": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-35963"
    },
    {
        "index": 281,
        "code": "Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse)\n{\n    Jsi_RC rc = JSI_OK;\n    if (interp->typeCheck.all==0) {\n        if (!argCodes ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))\n            return JSI_OK;\n    }\n\n    Jsi_CmdSpec *spec = func->cmdSpec;\n    Jsi_ScopeStrs *ss = func->argnames;\n    if (ss==NULL && spec == NULL)\n        return JSI_OK;\n    int i, minArgs, maxArgs, mis = 0, varargs = 0;\n    char nbuf[100];\n    if (func->type == FC_BUILDIN) {\n        varargs =  (spec->maxArgs<0);\n        maxArgs = spec->maxArgs + func->callflags.bits.addargs;\n        minArgs = spec->minArgs + func->callflags.bits.addargs;\n    } else {\n        varargs = ss->varargs;\n        minArgs = (ss->firstDef>0 ? ss->firstDef-1 : ss->count);\n        maxArgs = ss->count;\n        mis = (argc != ss->count);\n        if (func->retType == 0 && ss && ss->typeCnt == 0 && interp->typeCheck.all==0)\n            return JSI_OK;\n    }\n    if (varargs) {\n        if (argc >= minArgs)\n            return JSI_OK;\n        mis = (argc<minArgs);\n    } else \n        mis = (argc<minArgs || argc>maxArgs);\n    if (mis) {\n        if (varargs)\n            snprintf(nbuf, sizeof(nbuf), \"%d or more\", minArgs);\n        else if (maxArgs > minArgs)\n            snprintf(nbuf, sizeof(nbuf), \"%d-%d\", minArgs, maxArgs);\n        else\n            snprintf(nbuf, sizeof(nbuf), \"%d\", maxArgs);\n        if (line)\n            interp->parseLine = line;\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        Jsi_DString dStr = {};\n        Jsi_FuncObjToString(interp, func, &dStr, 2);\n        if (isParse)\n            Jsi_LogWarn(\"got %d args, expected %s, calling %s\", argc, nbuf, Jsi_DSValue(&dStr));\n        else\n            rc = Jsi_LogType(\"got %d args, expected %s, calling %s\", argc, nbuf, Jsi_DSValue(&dStr));\n        jsi_TypeMismatch(interp);\n        Jsi_DSFree(&dStr);\n        if (line)\n            interp->parseLine = NULL;\n        return rc;\n    }\n    if (argCodes && argCodes->code_len>=argc) {\n        int cl = argCodes->code_len;\n        int aind=argc-1;\n        for (i=cl-1; rc == JSI_OK && i>=0 && aind>=0; i--,aind--) {\n            Jsi_ttype atyp = JSI_TT_ANY;\n            switch (argCodes->codes[i].op) {\n                case OP_PUSHSTR: atyp=JSI_TT_STRING; break;\n                case OP_PUSHNUM: atyp=JSI_TT_NUMBER; break;\n                case OP_PUSHBOO: atyp=JSI_TT_BOOLEAN; break;\n                case OP_PUSHFUN: atyp=JSI_TT_FUNCTION; break;\n                case OP_PUSHTHS: atyp=JSI_TT_OBJECT; break;\n                case OP_PUSHREG: atyp=JSI_TT_REGEXP; break;\n                case OP_PUSHUND: atyp=JSI_TT_VOID; break;\n                case OP_PUSHNULL: atyp=JSI_TT_NULL; break;\n                case OP_PUSHARG: atyp=JSI_TT_ARRAY; break;\n                case OP_SUBSCRIPT: i++; break;\n                case OP_ARRAY: atyp=JSI_TT_ARRAY; i=jsiPopArgs(argCodes, i); break;\n                case OP_OBJECT: atyp=JSI_TT_OBJECT; i=jsiPopArgs(argCodes, i); break;\n                default: break;\n            }\n            if (atyp == JSI_TT_ANY) continue;\n            rc = jsi_StaticArgTypeCheck(interp, atyp, \"for argument\", name, aind+1, func, line);  \n        }\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 282,
        "code": "TfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  // Inputs Tensor (dtype depends on quantization):\n  // [0] = Input\n  // [1] = Axis\n  const TfLiteTensor* input = GetInput(context, node, 0);\n\n  // Outputs Tensor (dtype depends on quantization):\n  // [0] = Output\n\n  // Validate number of inputs and outputs\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n\n  // Validate axis type\n  const TfLiteTensor* axis = GetInput(context, node, 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, axis->type, kTfLiteInt32);\n\n  if (input->type == kTfLiteInt8) {\n    OpData* data = static_cast<OpData*>(node->user_data);\n    const TfLiteTensor* output = GetOutput(context, node, 0);\n    const double real_multiplier = static_cast<double>(input->params.scale) /\n                                   static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &data->shift);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 283,
        "code": "bool logToUSDT(const Array& bt) {\n  std::lock_guard<std::mutex> lock(usdt_mutex);\n\n  memset(&bt_slab, 0, sizeof(bt_slab));\n\n  int i = 0;\n  IterateVNoInc(\n    bt.get(),\n    [&](TypedValue tv) -> bool {\n\n      if (i >= strobelight::kMaxStackframes) {\n        return true;\n      }\n\n      assertx(isArrayLikeType(type(tv)));\n      ArrayData* bt_frame = val(tv).parr;\n      strobelight::backtrace_frame_t* frame = &bt_slab.frames[i];\n\n      auto const line = bt_frame->get(s_line.get());\n      if (line.is_init()) {\n        assertx(isIntType(type(line)));\n        frame->line = val(line).num;\n      }\n\n      auto const file_name = bt_frame->get(s_file.get());\n      if (file_name.is_init()) {\n        assertx(isStringType(type(file_name)));\n        strncpy(frame->file_name,\n                val(file_name).pstr->data(),\n                std::min(val(file_name).pstr->size(), strobelight::kFileNameMax));\n        frame->file_name[strobelight::kFileNameMax - 1] = '\\0';\n      }\n\n      auto const class_name = bt_frame->get(s_class.get());\n      if (class_name.is_init()) {\n        assertx(isStringType(type(class_name)));\n        strncpy(frame->class_name,\n                val(class_name).pstr->data(),\n                std::min(val(class_name).pstr->size(), strobelight::kClassNameMax));\n        frame->class_name[strobelight::kClassNameMax - 1] = '\\0';\n      }\n\n      auto const function_name = bt_frame->get(s_function.get());\n      if (function_name.is_init()) {\n        assertx(isStringType(type(function_name)));\n        strncpy(frame->function,\n                val(function_name).pstr->data(),\n                std::min(val(function_name).pstr->size(),\n                         strobelight::kFunctionMax));\n        frame->function[strobelight::kFunctionMax - 1] = '\\0';\n      }\n\n      i++;\n      return false;\n    }\n  );\n  bt_slab.len = i;\n\n  // Allow BPF to read the now-formatted stacktrace\n  FOLLY_SDT_WITH_SEMAPHORE(hhvm, hhvm_stack, &bt_slab);\n\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 284,
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_b (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_b (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = {0};\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; // XXX this depends on asm->mininstrsize\n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t// faster ^C\n\t\treturn;\n\t}\n\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tr_sys_perror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\t//this is necessary for the hook to read the id of analop\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\t//eprintf (\"Analyzing ESIL refs from 0x%\"PFMT64x\" - 0x%\"PFMT64x\"\\n\", addr, end);\n\t// TODO: backup/restore register state before/after analysis\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t// disabled because it causes some tests to fail\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\n\t\t/* realign address if needed */\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; //   XXX dupe in op.size below\n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\t// i += 2\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\t//we need to check again i because buf+i may goes beyond its boundaries\n\t\t//because of i+= minopsize - 1\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t//  those require write support\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %-4d %s\\n\", cur, snv, si->name);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\t//todo were doing less filtering up top because we can't match against 80 on all platforms\n\t\t\t\t// might get too many of this path now..\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %d\\n\", cur, snv);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\t// looks like ^C is handled by esil_parse !!!!\n\t\t//r_anal_esil_dumpstack (ESIL);\n\t\t//r_anal_esil_stack_free (ESIL);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t// arm64\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t/* TODO: test if this is valid for other archs too */\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\t/* This code is known to work on Thumb, ARM and ARM64 */\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\t// HACK avoid format string inside string used later as format\n\t\t\t\t\t\t\t\t// string crashes disasm inside agf under some conditions.\n\t\t\t\t\t\t\t\t// https://github.com/radareorg/radare2/issues/6937\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n// analyze function here\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\t// restore register\n\tr_reg_arena_pop (core->anal->reg);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1284"
    },
    {
        "index": 285,
        "code": "TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  // Only the Pie path supports quantized models and float inputs/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/1);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/2);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/3);\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/4);\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;\n    op_params.quantized_activation_min = data->output_activation_min;\n    op_params.quantized_activation_max = data->output_activation_max;\n    op_params.lhs_cacheable = IsConstantTensor(filter);\n    op_params.rhs_cacheable = IsConstantTensor(input);\n    switch (output->type) {\n      case kTfLiteUInt8:\n        if (kernel_type == kReference) {\n          reference_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<uint8_t>(output));\n        } else {\n          optimized_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<uint8_t>(output),\n              CpuBackendContext::GetFromContext(context));\n        }\n        break;\n      case kTfLiteInt8:\n        FullyConnectedInt8<kernel_type>(\n            data, input, filter, bias, output,\n            CpuBackendContext::GetFromContext(context));\n        break;\n      case kTfLiteInt16:\n        if (input->type == kTfLiteInt16) {\n          FullyConnectedInt16<kernel_type>(data, input, filter, bias, output);\n        } else if (kernel_type == kReference) {\n          reference_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<int16_t>(output));\n        } else {\n          optimized_ops::FullyConnected(\n              op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n              GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n              GetTensorShape(bias), GetTensorData<int32_t>(bias),\n              GetTensorShape(output), GetTensorData<int16_t>(output),\n              CpuBackendContext::GetFromContext(context));\n        }\n        break;\n      default:\n        context->ReportError(context,\n                             \"Quantized FullyConnected expects output data \"\n                             \"type uint8, int8 or int16\");\n        return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 286,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteL2NormParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context, NumDimensions(input) <= 4);\n\n  TF_LITE_ENSURE(context, output->type == kTfLiteFloat32 ||\n                              output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.scale, (1. / 128.));\n    if (output->type == kTfLiteUInt8) {\n      TF_LITE_ENSURE_EQ(context, output->params.zero_point, 128);\n    }\n    if (output->type == kTfLiteInt8) {\n      TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n    }\n  }\n\n  // TODO(ahentz): For some reason our implementations don't support\n  // activations.\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 287,
        "code": "static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 info_length, pos, desc_len, evt_type, nb_es,i;\n\tu32 nb_sections;\n\tu32 data_size;\n\tu32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\tGF_Err e = GF_OK;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\tnb_es = 0;\n\n\t/*skip if already received but no update detected (eg same data) */\n\tif ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t\treturn;\n\t}\n\n\tif (pmt->sec->demux_restarted) {\n\t\tpmt->sec->demux_restarted = 0;\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {\n\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\tpmt->program->metadata_pointer_descriptor = metapd;\n\t\t\t\t} else {\n\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\tgf_m2ts_metadata_pointer_descriptor_del(metapd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));\n\t\t\t}\n\t\t\tfirst_loop_len += 2 + len;\n\t\t}\n\t}\n\tif (data_size <= 4 + info_length) return;\n\tdata += 4 + info_length;\n\tdata_size -= 4 + info_length;\n\tpos = 0;\n\n\t/* count de number of program related PMT received */\n\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\tGF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\tif(prog->pmt_pid == pmt->pid) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;\n\twhile (pos<data_size) {\n\t\tGF_M2TS_PES *pes = NULL;\n\t\tGF_M2TS_SECTION_ES *ses = NULL;\n\t\tGF_M2TS_ES *es = NULL;\n\t\tBool inherit_pcr = 0;\n\t\tu32 pid, stream_type, reg_desc_format;\n\n\t\tstream_type = data[0];\n\t\tpid = ((data[1] & 0x1f) << 8) | data[2];\n\t\tdesc_len = ((data[3] & 0xf) << 8) | data[4];\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));\n\t\tswitch (stream_type) {\n\n\t\t/* PES */\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_DCII:\n\t\tcase GF_M2TS_VIDEO_MPEG4:\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_MVCD:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\tinherit_pcr = 1;\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_DTS:\n\t\tcase GF_M2TS_MHAS_MAIN:\n\t\tcase GF_M2TS_MHAS_AUX:\n\t\tcase GF_M2TS_SUBTITLE_DVB:\n\t\tcase GF_M2TS_METADATA_PES:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tif (inherit_pcr)\n\t\t\t\tpes->flags |= GF_M2TS_INHERIT_PCR;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\t/* Sections */\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\t/* carriage of ISO_IEC_14496 data in sections */\n\t\t\tif (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {\n\t\t\t\t/*MPEG-4 sections need to be fully checked: if one section is lost, this means we lost\n\t\t\t\tone SL packet in the AU so we must wait for the complete section again*/\n\t\t\t\tses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);\n\t\t\t\t/*create OD container*/\n\t\t\t\tif (!pmt->program->additional_ods) {\n\t\t\t\t\tpmt->program->additional_ods = gf_list_new();\n\t\t\t\t\tts->has_4on2 = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_13818_6_ANNEX_A:\n\t\tcase GF_M2TS_13818_6_ANNEX_B:\n\t\tcase GF_M2TS_13818_6_ANNEX_C:\n\t\tcase GF_M2TS_13818_6_ANNEX_D:\n\t\tcase GF_M2TS_PRIVATE_SECTION:\n\t\tcase GF_M2TS_QUALITY_SEC:\n\t\tcase GF_M2TS_MORE_SEC:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\tes->pid = pid;\n\t\t\tes->service_id = pmt->program->number;\n\t\t\tif (stream_type == GF_M2TS_PRIVATE_SECTION) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_QUALITY_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_MORE_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));\n\t\t\t}\n\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t//ses->sec->service_id = pmt->program->number;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_MPE_SECTIONS:\n\t\t\tif (! ts->prefix_present) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));\n#ifdef GPAC_ENABLE_MPE\n\t\t\t\tes = gf_dvb_mpe_section_new();\n\t\t\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\t\t\t((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\t//GF_LOG(/*GF_LOG_WARNING*/GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (es) {\n\t\t\tes->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;\n\t\t\tes->program = pmt->program;\n\t\t\tes->pid = pid;\n\t\t\tes->component_tag = -1;\n\t\t}\n\n\t\tpos += 5;\n\t\tdata += 5;\n\n\t\twhile (desc_len) {\n\t\t\tu8 tag = data[0];\n\t\t\tu32 len = data[1];\n\t\t\tif (es) {\n\t\t\t\tswitch (tag) {\n\t\t\t\tcase GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:\n\t\t\t\t\tif (pes)\n\t\t\t\t\t\tpes->lang = GF_4CC(' ', data[2], data[3], data[4]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_MPEG4_SL_DESCRIPTOR:\n\t\t\t\t\tes->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];\n\t\t\t\t\tes->flags |= GF_M2TS_ES_IS_SL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_REGISTRATION_DESCRIPTOR:\n\t\t\t\t\treg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);\n\t\t\t\t\t/*cf http://www.smpte-ra.org/mpegreg/mpegreg.html*/\n\t\t\t\t\tswitch (reg_desc_format) {\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_AC3:\n\t\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_AC3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_VC1:\n\t\t\t\t\t\tes->stream_type = GF_M2TS_VIDEO_VC1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_GPAC:\n\t\t\t\t\t\tif (len==8) {\n\t\t\t\t\t\t\tes->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);\n\t\t\t\t\t\t\tes->flags |= GF_M2TS_GPAC_CODEC_ID;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_EAC3_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_EC3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tu32 id = data[2]<<8 | data[3];\n\t\t\t\t\tif ((id == 0xB) && ses && !ses->sec) {\n\t\t\t\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:\n\t\t\t\t\tif (pes) {\n\t\t\t\t\t\tpes->sub.language[0] = data[2];\n\t\t\t\t\t\tpes->sub.language[1] = data[3];\n\t\t\t\t\t\tpes->sub.language[2] = data[4];\n\t\t\t\t\t\tpes->sub.type = data[5];\n\t\t\t\t\t\tpes->sub.composition_page_id = (data[6]<<8) | data[7];\n\t\t\t\t\t\tpes->sub.ancillary_page_id = (data[8]<<8) | data[9];\n\t\t\t\t\t}\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_SUBTITLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tes->component_tag = data[2];\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_TELETEXT_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_TELETEXT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_VBI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_HIERARCHY_DESCRIPTOR:\n\t\t\t\t\tif (pes) {\n\t\t\t\t\t\tu8 hierarchy_embedded_layer_index;\n\t\t\t\t\t\tGF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);\n\t\t\t\t\t\t/*u32 skip = */gf_bs_read_int(hbs, 16);\n\t\t\t\t\t\t/*u8 res1 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 temp_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 spatial_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 quality_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 hierarchy_type = */gf_bs_read_int(hbs, 4);\n\t\t\t\t\t\t/*u8 res2 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_layer_index = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 tref_not_present = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 res3 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\thierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 res4 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_channel = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\tgf_bs_del(hbs);\n\n\t\t\t\t\t\tpes->depends_on_pid = 1+hierarchy_embedded_layer_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_METADATA_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tGF_BitStream *metadatad_bs;\n\t\t\t\t\tGF_M2TS_MetadataDescriptor *metad;\n\t\t\t\t\tmetadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);\n\t\t\t\t\tmetad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);\n\t\t\t\t\tgf_bs_del(metadatad_bs);\n\t\t\t\t\tif (metad->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t\t        metad->format_identifier == GF_M2TS_META_ID3) {\n\t\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\t\tif (pes) {\n\t\t\t\t\t\t\tpes->metadata_descriptor = metad;\n\t\t\t\t\t\t\tpes->stream_type = GF_M2TS_METADATA_ID3_HLS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\t\tgf_m2ts_metadata_descriptor_del(metad);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata += len+2;\n\t\t\tpos += len+2;\n\t\t\tif (desc_len < len+2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc_len-=len+2;\n\t\t}\n\n\t\tif (es && !es->stream_type) {\n\t\t\tgf_free(es);\n\t\t\tes = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t}\n\n\t\tif (!es) continue;\n\n\t\tif (ts->ess[pid]) {\n\t\t\t//this is component reuse across programs, overwrite the previously declared stream ...\n\t\t\tif (status & GF_M2TS_TABLE_FOUND) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );\n\n\t\t\t\t//add stream to program but don't reassign the pid table until the stream is playing (>GF_M2TS_PES_FRAMING_SKIP)\n\t\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\t\tnb_es++;\n\t\t\t\t//skip assignment below\n\t\t\t\tes = NULL;\n\t\t\t}\n\t\t\t/*watchout for pmt update - FIXME this likely won't work in most cases*/\n\t\t\telse {\n\n\t\t\t\tGF_M2TS_ES *o_es = ts->ess[es->pid];\n\n\t\t\t\tif ((o_es->stream_type == es->stream_type)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))\n\t\t\t\t        && (o_es->mpeg4_es_id == es->mpeg4_es_id)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)\n\t\t\t\t   ) {\n\t\t\t\t\tgf_free(es);\n\t\t\t\t\tes = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tgf_m2ts_es_del(o_es, ts);\n\t\t\t\t\tts->ess[es->pid] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\t\t}\n\n\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {\n\t\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 2;\n\t\t\t\telse es->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_es) {\n\t\tu32 i;\n\n\t\t//translate hierarchy descriptors indexes into PIDs - check whether the PMT-index rules are the same for HEVC\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *an_es = NULL;\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (!es->depends_on_pid) continue;\n\n\t\t\t//fixeme we are not always assured that hierarchy_layer_index matches the stream index...\n\t\t\t//+1 is because our first stream is the PMT\n\t\t\tan_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);\n\t\t\tif (an_es) {\n\t\t\t\tes->depends_on_pid = an_es->pid;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));\n\t\t\t\tes->depends_on_pid = 0;\n\t\t\t}\n\t\t}\n\n\t\tevt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;\n\t\tif (ts->on_event) ts->on_event(ts, evt_type, pmt->program);\n\t} else {\n\t\t/* if we found no new ES it's simply a repeat of the PMT */\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-19481"
    },
    {
        "index": 288,
        "code": "TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n\n  TF_LITE_ENSURE(context, !params->table_name.empty());\n  TF_LITE_ENSURE(context, (params->key_dtype == kTfLiteInt64 &&\n                           params->value_dtype == kTfLiteString) ||\n                              (params->key_dtype == kTfLiteString &&\n                               params->value_dtype == kTfLiteInt64));\n\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor->type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, resource_handle_tensor, outputSize);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 289,
        "code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15214"
    },
    {
        "index": 290,
        "code": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending_unlocked;\n \t} else {\n \t\tstatus = count;\n \t}\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\nrelease_write_pending_unlocked:\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-14763"
    },
    {
        "index": 291,
        "code": "char *jsiLNhints(const char *buf, int *color, int *bold) {\n    int i, len = Jsi_Strlen(buf);\n    for (i=0; jsiFilePreCmds[i]; i++)\n        if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;\n    if (jsiFilePreCmds[i]) {\n        const char *ce = buf+len-1, *cp = \"('<file>\";\n        if ((*ce =='\\'' || *ce =='\\\"') && buf[len-2]=='(') cp+=2;\n        else if (*ce=='(') cp++;\n        else return NULL;\n        \n        *color = 35;\n        *bold = 0;\n        return (char*)cp;\n    }\n    return NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 292,
        "code": "int mongo_env_close_socket( int socket ) {\n#ifdef _WIN32\n    return closesocket( socket );\n#else\n    return close( socket );\n#endif\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 293,
        "code": "static Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 294,
        "code": "Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts)\n{\n    int rc = 0;\n    Jsi_Interp* interp = NULL;\n    int argc = 0, first = 1;\n    char **argv = NULL;\n    if (opts) {\n        interp = opts->interp;\n        argc = opts->argc;\n        argv = opts->argv;\n    }\n    if (!interp)\n        interp = Jsi_InterpNew(opts);\n    if (!interp)\n        return NULL;\n    Jsi_InterpOnDelete(interp, &jsi_InterpDelete, (void*)&jsi_InterpDelete);\n    argc -= interp->iskips;\n    argv += interp->iskips;\n\n#ifndef NO_JAZ\n    /* Mount zip at end of executable */\n    Jsi_Value *v = Jsi_Executable(interp);\n    const char *exeFile = (v?Jsi_ValueString(interp, v, NULL):NULL);\n    int jsFound = 0;\n    if (v && (argc != 2 || Jsi_Strcmp(argv[1], \"--nozvfs\"))) {\n        rc = Jsi_EvalZip(interp, exeFile, JSI_ZVFS_DIR, &jsFound);\n        if (rc == JSI_OK) {\n            interp->selfZvfs = 1;\n            if (!jsFound) {\n#if (JSI__FILESYS && JSI__ZVFS)\n                fprintf(stderr, \"warning: no main.jsi or autoload.jsi\\n\");\n#endif\n            }\n            if (jsi_deleted)\n                return jsi_DoExit(interp, jsi_exitCode);\n            else if (rc != 0) {\n                fprintf(stderr, \"Error\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        }\n    }\n#endif\n    const char *ext = NULL, *ai1, *iext = (argc<=1?NULL:Jsi_Strrchr(argv[1], '.'));\n    if (interp->selfZvfs && iext && Jsi_Strcmp(iext,\".fossil\")==0) {\n        rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n        goto done;\n    }\n    Jsi_ShiftArgs(interp, NULL);\n    if (argc <= 1) {\n        if (interp->opts.no_interactive && !interp->interactive)\n            return interp;\n        rc = Jsi_Interactive(interp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n        goto done;\n    }\n    ai1 = argv[1];\n    if ((!Jsi_Strcmp(ai1, \"-help\") || !Jsi_Strcmp(ai1, \"-h\")) && argc<=3) {\n        if (argc>2) {\n            if (Jsi_PkgRequire(interp, \"Help\", 0)>=0) {\n                char tbuf[BUFSIZ];\n                snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", argv[2]);\n                Jsi_RC rc = Jsi_EvalString(interp, tbuf, 0);\n                const char *hstr = Jsi_ValueToString(interp, interp->retValue, NULL);\n                if (rc == JSI_OK)\n                    puts(hstr);\n                return jsi_DoExit(interp, 1);\n            }\n        }\n        dohelp:\n        puts(\"USAGE:\\n  jsish [PREFIX-OPTS] [COMMAND-OPTS|FILE] ...\\n\"\n          \"\\nPREFIX-OPTS:\\n\"\n          \"  --C FILE\\tOption file of config options.\\n\"\n          \"  --F\\t\\tTrace all function calls and returns.\\n\"\n          \"  --I OPT:VAL\\tInterp option: equivalent to Interp.conf({OPT:VAL}).\\n\"\n          \"  --L PATH\\tSet safeMode to \\\"lockdown\\\" using PATH for safe(Read/Write)Dirs.\\n\"\n          \"  --T OPT\\tTypecheck option: equivalent to \\\"use OPT\\\".\\n\"\n          \"  --U\\t\\tDisplay unittest output, minus pass/fail compare.\\n\"\n          \"  --V\\t\\tSame as --U, but adds file and line number to output.\\n\"\n          \"\\nCOMMAND-OPTS:\\n\"\n          \"  -a\\t\\tArchive: mount an archive (zip, sqlar or fossil repo) and run module.\\n\"\n          \"  -c\\t\\tCData: generate .c or JSON output from a .jsc description.\\n\"\n          \"  -d\\t\\tDebug: console script debugger.\\n\"\n          \"  -e CODE ...\\tEvaluate javascript CODE.\\n\"\n          \"  -g\\t\\tGendeep: generate html output from markdeep source.\\n\"\n          \"  -h ?CMD?\\tHelp: show help for jsish or its commands.\\n\"\n          \"  -m\\t\\tModule: utility create/manage/invoke a Module.\\n\"\n          \"  -s\\t\\tSafe: runs script in safe sub-interp.\\n\"\n          \"  -u\\t\\tUnitTest: test script file(s) or directories .js/.jsi files.\\n\"\n          \"  -w\\t\\tWget: web client to download file from url.\\n\"\n          \"  -v\\t\\tVersion: show version detail: add an arg to show only X.Y.Z\\n\"\n          \"  -z\\t\\tZip: append/manage zip files at end of executable.\\n\"\n          \"  -D\\t\\tDebugUI: web-gui script debugger.\\n\"\n          \"  -J\\t\\tJSpp: preprocess javascript for web.\\n\"\n          \"  -S\\t\\tSqliteUI: web-gui for sqlite database file.\\n\"\n          \"  -W\\t\\tWebsrv: web server to serve out content.\\n\"\n          \"\\nInterp options may also be set via the confFile.'\\n\"\n           );\n        return jsi_DoExit(interp, 1);\n    }\n    if (!Jsi_Strcmp(ai1, \"-version\"))\n        ai1 = \"-v\";\n    if (ai1[0] == '-') {\n        switch (ai1[1]) {\n            case 'a':\n                rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'c':\n                rc = Jsi_EvalString(interp, \"runModule('Cdata');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'd':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('Debug');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'D':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('DebugUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'e':\n                if (argc < 3)\n                    rc = Jsi_LogError(\"missing argument\");\n                else {\n                    rc = Jsi_EvalString(interp, argv[2], JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n                    if (rc == JSI_OK && argc>3) {\n                        first += 2;\n                        Jsi_ShiftArgs(interp, NULL);\n                        Jsi_ShiftArgs(interp, NULL);\n                        goto dofile;\n                    }\n                }\n                break;\n            case 'g':\n                rc = Jsi_EvalString(interp, \"runModule('GenDeep');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'h':\n                goto dohelp;\n            case 'J':\n                rc = Jsi_EvalString(interp, \"runModule('Jspp');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'm':\n                if (argc <= 2 || argv[2][0] == '-')\n                    rc = Jsi_EvalString(interp, \"runModule('Module');\", JSI_EVAL_ISMAIN);\n                else {\n                    Jsi_DString dStr = {}, eStr = {};\n                    const char *cps, *cpe;\n                    cps = Jsi_Strrchr(argv[2], '/');\n                    if (cps) cps++; else cps = argv[2];\n                    cpe = Jsi_Strrchr(cps, '.');\n                    int len = (cpe?cpe-cps:(int)Jsi_Strlen(cps));\n                    if (cpe)\n                        Jsi_DSPrintf(&dStr, \"source(\\\"%s\\\");\", argv[2]);\n                    else\n                        Jsi_DSPrintf(&dStr, \"require(\\\"%s\\\");\", argv[2]);\n                    Jsi_DSPrintf(&dStr, \"puts(runModule(\\\"%.*s\\\",console.args.slice(1)));\", len, cps);\n                    rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_NOSKIPBANG);\n                    Jsi_DSFree(&dStr);\n                    Jsi_DSFree(&eStr);\n                }\n                break;\n            case 's':\n                rc = Jsi_EvalString(interp, \"runModule('Safe');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'S':\n                rc = Jsi_EvalString(interp, \"runModule('SqliteUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'u':\n                rc = Jsi_EvalString(interp, \"exit(runModule('UnitTest'));\", JSI_EVAL_ISMAIN);\n                break;\n            case 'v': {\n                char str[200] = \"\\n\";\n                    \n                Jsi_Value* fval = Jsi_ValueNewStringKey(interp, \"/zvfs/lib/sourceid.txt\");\n                if (!Jsi_Access(interp, fval, R_OK)) {\n                    Jsi_Channel chan = Jsi_Open(interp, fval, \"r\");\n                    if (chan)\n                        Jsi_Read(interp, chan, str, sizeof(str));\n                }\n                if (argc>2)\n                    printf(\"%u.%u.%u\\n\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n                else \n                    printf(\"%u.%u.%u %.\" JSI_VERFMT_LEN JSI_NUMGFMT \" %s\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE, Jsi_Version(), str);\n                return jsi_DoExit(interp, 1);\n            }\n            case 'w':\n                rc = Jsi_EvalString(interp, \"runModule('Wget');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'W':\n                rc = Jsi_EvalString(interp, \"runModule('Websrv');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'z':\n                rc = Jsi_EvalString(interp, \"runModule('Zip');\", JSI_EVAL_ISMAIN);\n                break;\n            default:\n                puts(\"usage: jsish [  --C FILE | --I OPT:VAL | --L PATH | --T OPT | --U | --V | --F ] | -e STRING |\\n\\t\"\n                \"| -a | -c | -d | -D | -h | -m | -s | -S | -u | -v | -w | -W | -z | FILE ...\\nUse -help for long help.\");\n                return jsi_DoExit(interp, 1);\n        }\n    } else {\ndofile:\n        ext = Jsi_Strrchr(argv[first], '.');\n\n        /* Support running \"main.jsi\" from a zip file. */\n        if (ext && (Jsi_Strcmp(ext,\".zip\")==0 ||Jsi_Strcmp(ext,\".jsz\")==0 ) ) {\n            rc = Jsi_EvalZip(interp, argv[first], NULL, &jsFound);\n            if (rc<0) {\n                fprintf(stderr, \"zip mount failed\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n            if (!(jsFound&JSI_ZIP_MAIN)) {\n                fprintf(stderr, \"main.jsi not found\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        } else if (ext && !Jsi_Strcmp(ext,\".jsc\")) {\n            Jsi_DString dStr = {};\n            Jsi_DSPrintf(&dStr, \"console.args.unshift('%s'); runModule('CData');\", argv[first]);\n            rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n            Jsi_DSFree(&dStr);\n\n        } else {\n            if (argc>1) {\n                jsi_vf = Jsi_ValueNewStringKey(interp, argv[first]);\n                Jsi_IncrRefCount(interp, jsi_vf);\n            }\n            rc = Jsi_EvalFile(interp, jsi_vf, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX|JSI_EVAL_ISMAIN);\n            if (jsi_vf) {\n                Jsi_DecrRefCount(interp, jsi_vf);\n                jsi_vf = NULL;\n            }\n\n        }\n    }\n    if (jsi_deleted) //TODO: rationalize jsi_deleted, jsi_exitCode, etc\n        return jsi_DoExit(rc==JSI_EXIT?NULL:interp, jsi_exitCode);\n    if (rc == 0) {\n        /* Skip output from an ending semicolon which evaluates to undefined */\n        Jsi_Value *ret = Jsi_ReturnValue(interp);\n        if (!Jsi_ValueIsType(interp, ret, JSI_VT_UNDEF)) {\n            Jsi_DString dStr = {};\n            fputs(Jsi_ValueGetDString(interp, ret, &dStr, 0), stdout);\n            Jsi_DSFree(&dStr);\n            fputs(\"\\n\", stdout);\n        }\n    } else {\n        if (!interp->parent && !interp->isHelp)\n            fputs(\"ERROR\\n\", stderr);\n        return jsi_DoExit(interp, 1);\n    }\n\ndone:\n    if (rc == JSI_EXIT) {\n        if (opts)\n            opts->exitCode = jsi_exitCode;\n        return NULL;\n    }\n    if (jsi_deleted == 0 && interp->opts.auto_delete) {\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    return interp;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 295,
        "code": "s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tu32 nal_hdr;\n\tAVCSliceInfo n_state;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tnal_hdr = gf_bs_read_u8(bs);\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tavc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_IDR_SLICE:\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret < 0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t\t((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t\t&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t\t(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert(avc->s_info.sps);\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (avc->s_info.sps->poc_type == 1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tavc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tavc->last_ps_idx = (s32) gf_bs_read_ue(bs);\n\t\tif (avc->last_ps_idx < 0) return -1;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice)\n\t\tavc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-40565"
    },
    {
        "index": 296,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 2);\n\n  const TfLiteTensor* lookup = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(lookup), 1);\n  TF_LITE_ENSURE_EQ(context, lookup->type, kTfLiteInt32);\n\n  const TfLiteTensor* key = GetInput(context, node, 1);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(key), 1);\n  TF_LITE_ENSURE_EQ(context, key->type, kTfLiteInt32);\n\n  const TfLiteTensor* value = GetInput(context, node, 2);\n  TF_LITE_ENSURE(context, NumDimensions(value) >= 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(key, 0),\n                    SizeOfDimension(value, 0));\n  if (value->type == kTfLiteString) {\n    TF_LITE_ENSURE_EQ(context, NumDimensions(value), 1);\n  }\n\n  TfLiteTensor* hits = GetOutput(context, node, 1);\n  TF_LITE_ENSURE_EQ(context, hits->type, kTfLiteUInt8);\n  TfLiteIntArray* hitSize = TfLiteIntArrayCreate(1);\n  hitSize->data[0] = SizeOfDimension(lookup, 0);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, value->type, output->type);\n\n  TfLiteStatus status = kTfLiteOk;\n  if (output->type != kTfLiteString) {\n    TfLiteIntArray* outputSize = TfLiteIntArrayCreate(NumDimensions(value));\n    outputSize->data[0] = SizeOfDimension(lookup, 0);\n    for (int i = 1; i < NumDimensions(value); i++) {\n      outputSize->data[i] = SizeOfDimension(value, i);\n    }\n    status = context->ResizeTensor(context, output, outputSize);\n  }\n  if (context->ResizeTensor(context, hits, hitSize) != kTfLiteOk) {\n    status = kTfLiteError;\n  }\n  return status;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 297,
        "code": "void ndpi_search_h323(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n\n  NDPI_LOG_DBG(ndpi_struct, \"search H323\\n\");\n\n  /*\n    The TPKT protocol is used by ISO 8072 (on port 102)\n    and H.323. So this check below is to avoid ambiguities\n  */\n  if((packet->tcp != NULL) && (packet->tcp->dest != ntohs(102))) {\n    NDPI_LOG_DBG2(ndpi_struct, \"calculated dport over tcp\\n\");\n\n    /* H323  */\n    if(packet->payload_packet_len >= 4\n       && (packet->payload[0] == 0x03)\n       && (packet->payload[1] == 0x00)) {\n\tstruct tpkt *t = (struct tpkt*)packet->payload;\n\tu_int16_t len = ntohs(t->len);\n\n\tif(packet->payload_packet_len == len) {\n\t  /*\n\t    We need to check if this packet is in reality\n\t    a RDP (Remote Desktop) packet encapsulated on TPTK\n\t   */\n\n\t  if(packet->payload[4] == (packet->payload_packet_len - sizeof(struct tpkt) - 1)) {\n\t    /* ISO 8073/X.224 */\n\t    if((packet->payload[5] == 0xE0 /* CC Connect Request */)\n\t       || (packet->payload[5] == 0xD0 /* CC Connect Confirm */)) {\n\t      NDPI_LOG_INFO(ndpi_struct, \"found RDP\\n\");\n\t      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_RDP, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\n\t  flow->l4.tcp.h323_valid_packets++;\n\n\t  if(flow->l4.tcp.h323_valid_packets >= 2) {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\t  }\n\t} else {\n\t  /* This is not H.323 */\n\t  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n\t  return;\n\t}\n      }\n  } else if(packet->udp != NULL) {\n    sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculated dport over udp\\n\");\n\n    if(packet->payload_packet_len >= 6 && packet->payload[0] == 0x80 && packet->payload[1] == 0x08 &&\n       (packet->payload[2] == 0xe7 || packet->payload[2] == 0x26) &&\n       packet->payload[4] == 0x00 && packet->payload[5] == 0x00)\n      {\n\tNDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n    /* H323  */\n    if(sport == 1719 || dport == 1719)\n      {\n        if(packet->payload[0] == 0x16 && packet->payload[1] == 0x80 && packet->payload[4] == 0x06 && packet->payload[5] == 0x00)\n\t  {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  }\n        else if(packet->payload_packet_len >= 20 && packet->payload_packet_len <= 117)\n\t  {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  }\n        else\n\t  {\n\t    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n\t    return;\n\t  }\n      }\n  }\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15472"
    },
    {
        "index": 298,
        "code": "get_user_commands(expand_T *xp UNUSED, int idx)\n{\n    // In cmdwin, the alternative buffer should be used.\n    buf_T *buf =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\tcurbuf;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 299,
        "code": "netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check and process the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-38206"
    },
    {
        "index": 300,
        "code": "free_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    vim_free(buf->b_p_vsts_array);\n    buf->b_p_vsts_array = NULL;\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    clear_string_option(&buf->b_p_sua);\n#endif\n    clear_string_option(&buf->b_p_ft);\n#ifdef FEAT_CINDENT\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n#endif\n#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)\n    clear_string_option(&buf->b_p_cinw);\n#endif\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n#ifdef FEAT_TEXTOBJ\n    clear_string_option(&buf->b_p_qe);\n#endif\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n#ifdef FEAT_LISP\n    clear_string_option(&buf->b_p_lw);\n#endif\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0443"
    },
    {
        "index": 301,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Check type and shape of the input tensor\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 2);\n  if (input->type != kTfLiteFloat32) {\n    context->ReportError(context,\n                         \"Type '%s' for input is not supported by rfft2d.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n  // Check type and shape of the fft_length tensor\n  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const RuntimeShape fft_length_shape = GetTensorShape(fft_length);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(fft_length), 1);\n  TF_LITE_ENSURE_EQ(context, fft_length_shape.Dims(0), 2);\n  if (fft_length->type != kTfLiteInt32) {\n    context->ReportError(context,\n                         \"Type '%s' for fft_length is not supported by rfft2d.\",\n                         TfLiteTypeGetName(fft_length->type));\n    return kTfLiteError;\n  }\n\n  // Setup temporary tensors for fft computation.\n  TF_LITE_ENSURE_STATUS(InitTemporaryTensors(context, node));\n\n  // Set output type\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = kTfLiteComplex64;\n\n  // Exit early if fft_length is a non-const tensor. Set output tensor and\n  // temporary tensors to dynamic, so that their tensor sizes can be determined\n  // in Eval.\n  if (!IsConstantTensor(fft_length)) {\n    TfLiteTensor* fft_integer_working_area =\n        GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n    TfLiteTensor* fft_double_working_area =\n        GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n    SetTensorToDynamic(fft_integer_working_area);\n    SetTensorToDynamic(fft_double_working_area);\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  TF_LITE_ENSURE_STATUS(ResizeOutputandTemporaryTensors(context, node));\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 302,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedreader_14BufferedReader_9read_strings(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  Py_ssize_t __pyx_v_n_items;\n  PyObject *__pyx_v_encoding = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_strings (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n_items,&__pyx_n_s_encoding,0};\n    PyObject* values[2] = {0,0};\n    values[1] = ((PyObject *)Py_None);\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_items)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (kw_args > 0) {\n          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_encoding);\n          if (value) { values[1] = value; kw_args--; }\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"read_strings\") < 0)) __PYX_ERR(0, 62, __pyx_L3_error)\n      }\n    } else {\n      switch (PyTuple_GET_SIZE(__pyx_args)) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n    }\n    __pyx_v_n_items = __Pyx_PyIndex_AsSsize_t(values[0]); if (unlikely((__pyx_v_n_items == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 62, __pyx_L3_error)\n    __pyx_v_encoding = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"read_strings\", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 62, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read_strings\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *)__pyx_v_self), __pyx_v_n_items, __pyx_v_encoding);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 303,
        "code": "ALWAYS_INLINE String serialize_impl(const Variant& value,\n                                    const SerializeOptions& opts) {\n  switch (value.getType()) {\n    case KindOfClass:\n    case KindOfLazyClass:\n    case KindOfPersistentString:\n    case KindOfString: {\n      auto const str =\n        isStringType(value.getType()) ? value.getStringData() :\n        isClassType(value.getType()) ? classToStringHelper(value.toClassVal()) :\n        lazyClassToStringHelper(value.toLazyClassVal());\n      auto const size = str->size();\n      if (size >= RuntimeOption::MaxSerializedStringSize) {\n        throw Exception(\"Size of serialized string (%d) exceeds max\", size);\n      }\n      StringBuffer sb;\n      sb.append(\"s:\");\n      sb.append(size);\n      sb.append(\":\\\"\");\n      sb.append(str->data(), size);\n      sb.append(\"\\\";\");\n      return sb.detach();\n    }\n    case KindOfResource:\n      return s_Res;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfFunc:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentDArray:\n    case KindOfDArray:\n    case KindOfPersistentVArray:\n    case KindOfVArray:\n    case KindOfDouble:\n    case KindOfObject:\n    case KindOfClsMeth:\n    case KindOfRClsMeth:\n    case KindOfRFunc:\n    case KindOfRecord:\n      break;\n  }\n  VariableSerializer vs(VariableSerializer::Type::Serialize);\n  if (opts.keepDVArrays)        vs.keepDVArrays();\n  if (opts.forcePHPArrays)      vs.setForcePHPArrays();\n  if (opts.warnOnHackArrays)    vs.setHackWarn();\n  if (opts.warnOnPHPArrays)     vs.setPHPWarn();\n  if (opts.ignoreLateInit)      vs.setIgnoreLateInit();\n  if (opts.serializeProvenanceAndLegacy) vs.setSerializeProvenanceAndLegacy();\n  // Keep the count so recursive calls to serialize() embed references properly.\n  return vs.serialize(value, true, true);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 304,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE(context, node->inputs->size > 0);\n\n  // The first input is the condition.\n  const TfLiteTensor* cond = GetInput(context, node, 0);\n  // Currently only bool is supported.\n  // TODO(ycling): Support other types since TensorFlow also support\n  // non-bool types as condition.\n  TF_LITE_ENSURE_EQ(context, cond->type, kTfLiteBool);\n  TF_LITE_ENSURE_EQ(context, NumElements(cond), 1);\n\n  // The first input of the node is the condition. The rest of inputs are\n  // passed to the branch subgraphs. Therefore, the number of subgraph inputs\n  // will be the number of node inputs - 1.\n  int num_inputs = node->inputs->size - 1;\n  int num_outputs = node->outputs->size;\n\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->then_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->else_subgraph_index < subgraphs->size());\n\n  Subgraph* then_subgraph = (*subgraphs)[op_data->then_subgraph_index].get();\n  Subgraph* else_subgraph = (*subgraphs)[op_data->else_subgraph_index].get();\n\n  for (auto* subgraph : {then_subgraph, else_subgraph}) {\n    TF_LITE_ENSURE_EQ(context, num_inputs, subgraph->inputs().size());\n    TF_LITE_ENSURE_EQ(context, num_outputs, subgraph->outputs().size());\n  }\n\n  bool has_dynamic_output_tensors = false;\n  for (auto* subgraph : {then_subgraph, else_subgraph}) {\n    for (int i = 0; i < num_inputs; ++i) {\n      // The first input of the node is the condition. The indices of the inputs\n      // passed to the subgraphs are offset by 1.\n      const TfLiteTensor* input = GetInput(context, node, i + 1);\n      std::vector<int> dims(input->dims->data,\n                            input->dims->data + input->dims->size);\n      subgraph->ResizeInputTensor(i, dims);\n      TfLiteTensor* subgraph_input = subgraph->tensor(subgraph->inputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, subgraph_input->type);\n    }\n    // Note: The `Prepare` function is responsible to run `AllocateTensors` on\n    // both subgraphs. It's intentionally not to break out of the loop when\n    // finding a dynamic output tensor.\n    TF_LITE_ENSURE_OK(context, subgraph->AllocateTensors());\n    has_dynamic_output_tensors |= subgraph->HasDynamicTensors();\n  }\n\n  if (!has_dynamic_output_tensors) {\n    for (int i = 0; i < num_outputs; ++i) {\n      TfLiteTensor* then_output =\n          then_subgraph->tensor(then_subgraph->outputs()[i]);\n      TfLiteTensor* else_output =\n          else_subgraph->tensor(else_subgraph->outputs()[i]);\n      // If the 2 subgraphs have static but different output shapes, the output\n      // tensors of the IF op have dynamic sizes.\n      if (!TfLiteIntArrayEqual(then_output->dims, else_output->dims)) {\n        has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i < num_outputs; ++i) {\n    TfLiteTensor* output = GetOutput(context, node, i);\n    if (has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      // When there's no dynamic output tensors, the 2 subgraph has exactly\n      // the same static sized outputs.\n      TfLiteTensor* then_output =\n          then_subgraph->tensor(then_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(then_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 305,
        "code": "static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){\n  int nBytes = sizeof(char *)*(2+pTable->nModuleArg);\n   char **azModuleArg;\n   azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);\n   if( azModuleArg==0 ){\n     sqlite3DbFree(db, zArg);\n  }else{\n    int i = pTable->nModuleArg++;\n    azModuleArg[i] = zArg;\n    azModuleArg[i+1] = 0;\n    pTable->azModuleArg = azModuleArg;\n  }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5827"
    },
    {
        "index": 306,
        "code": "static int jsi_wscallback_http(struct lws *wsi,\n                         enum lws_callback_reasons reason, void *user,\n                         void *in, size_t len)\n{\n    struct lws_context *context = lws_get_context(wsi);\n    const char *inPtr = (char*)in;\n    char client_name[128], client_ip[128];\n    const char *res = \"\";\n#ifdef EXTERNAL_POLL\n    int m;\n    int fd = (int)(long)user;\n#endif\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj *)lws_context_user(context);\n    if (!cmdPtr) {\n        fprintf(stderr, \"bad ws context\\n\");\n        return -1;\n    }\n    jsi_wsPss *pss = NULL;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Value* callPtr = NULL;\n    int rc = 0, deflt = 0;\n\n    WSSIGASSERT(cmdPtr, OBJ);\n    if (Jsi_InterpGone(interp))\n        cmdPtr->deleted = 1;\n\n    if (cmdPtr->debug>=128)\n        fprintf(stderr, \"HTTP CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n\n    switch (reason) {\n#ifndef EXTERNAL_POLL\n    case LWS_CALLBACK_GET_THREAD_ID:\n    case LWS_CALLBACK_UNLOCK_POLL:\n    case LWS_CALLBACK_PROTOCOL_INIT:\n    case LWS_CALLBACK_ADD_POLL_FD:\n    case LWS_CALLBACK_DEL_POLL_FD:\n    case LWS_CALLBACK_CHANGE_MODE_POLL_FD:\n    case LWS_CALLBACK_LOCK_POLL:\n        return rc;\n#else\n        /*\n         * callbacks for managing the external poll() array appear in\n         * protocol 0 callback\n         */\n\n    case LWS_CALLBACK_ADD_POLL_FD:\n\n        if (jsi_wsnum_pollfds >= max_poll_elements) {\n            lwsl_err(\"LWS_CALLBACK_ADD_POLL_FD: too many sockets to track\\n\");\n            return 1;\n        }\n\n        fd_lookup[fd] = jsi_wsnum_pollfds;\n        jsi_wspollfds[jsi_wsnum_pollfds].fd = fd;\n        jsi_wspollfds[jsi_wsnum_pollfds].events = (int)(long)len;\n        jsi_wspollfds[jsi_wsnum_pollfds++].revents = 0;\n        break;\n\n    case LWS_CALLBACK_DEL_POLL_FD:\n        if (!--jsi_wsnum_pollfds)\n            break;\n        m = fd_lookup[fd];\n        /* have the last guy take up the vacant slot */\n        jsi_wspollfds[m] = jsi_wspollfds[jsi_wsnum_pollfds];\n        fd_lookup[jsi_wspollfds[jsi_wsnum_pollfds].fd] = m;\n        break;\n\n#endif\n\n    default:\n        deflt = 1;\n        break;\n\n    }\n\n    if (deflt && cmdPtr->debug>16 && cmdPtr->debug<128) {\n        fprintf(stderr, \"HTTP CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n    }\n\n    switch (reason) {\n    case LWS_CALLBACK_WSI_DESTROY:\n        break;\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    // Handle GET file download in client mode.\n    case LWS_CALLBACK_RECEIVE_CLIENT_HTTP: {\n        char buffer[1024 + LWS_PRE];\n        char *px = buffer + LWS_PRE;\n        int lenx = sizeof(buffer) - LWS_PRE;\n\n        if (lws_http_client_read(wsi, &px, &lenx) < 0)\n            return -1;\n        break;\n    }\n    case LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ:\n        if (jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 0) != JSI_OK)\n            rc = 1;\n        break;\n\n    case LWS_CALLBACK_COMPLETED_CLIENT_HTTP:\n        if (jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 1) != JSI_OK)\n            rc = 1;\n        break;\n\n    case LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER:\n        if (cmdPtr->post) {\n            unsigned char **p = (unsigned char **)in, *end = (*p) + len;\n            int n = 0;\n            char buf[100];\n            Jsi_ValueString(interp, cmdPtr->post, &n);\n            snprintf(buf, sizeof(buf), \"%d\", n);\n\n            if (lws_add_http_header_by_token(wsi,\n                    WSI_TOKEN_HTTP_CONTENT_LENGTH,\n                    (unsigned char *)buf, 2, p, end))\n                return -1;\n            if (lws_add_http_header_by_token(wsi,\n                    WSI_TOKEN_HTTP_CONTENT_TYPE,\n                    (unsigned char *)\"application/x-www-form-urlencoded\", 33, p, end))\n                return -1;\n\n            /* inform lws we have http body to send */\n            lws_client_http_body_pending(wsi, 1);\n            lws_callback_on_writable(wsi);\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_HTTP_WRITEABLE: {\n        int n = 0;\n        char *cps = Jsi_ValueString(interp, cmdPtr->post, &n);\n        char *buf = (char*)Jsi_Calloc(1, LWS_PRE + n + 1);\n        Jsi_Strcpy(buf + LWS_PRE, cps);\n        n = lws_write(wsi, (unsigned char *)&buf[LWS_PRE], strlen(&buf[LWS_PRE]), LWS_WRITE_HTTP);\n        Jsi_Free(buf);\n        if (n < 0)\n            return -1;\n        /* we only had one thing to send, so inform lws we are done\n         * if we had more to send, call lws_callback_on_writable(wsi);\n         * and just return 0 from callback.  On having sent the last\n         * part, call the below api instead.*/\n        lws_client_http_body_pending(wsi, 0);\n        break;\n    }\n#endif\n\n    case LWS_CALLBACK_FILTER_NETWORK_CONNECTION:\n        break;\n    case LWS_CALLBACK_PROTOCOL_INIT:\n        break;\n    case LWS_CALLBACK_CLOSED_HTTP:\n        if (cmdPtr->debug>2)\n            fprintf(stderr, \"CLOSED\\n\");\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (pss)\n            jsi_wsdeletePss(pss);\n        break;\n    case LWS_CALLBACK_WSI_CREATE:\n        break;\n\n    case LWS_CALLBACK_CONFIRM_EXTENSION_OKAY:\n        break;\n\n    case LWS_CALLBACK_FILTER_HTTP_CONNECTION:\n        if (cmdPtr->debug>1)\n            fprintf(stderr, \"FILTER CONNECTION: %s\\n\", inPtr);\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n        Jsi_DSSet(&pss->url, inPtr);\n        jsi_wsgetUriArgValue(interp, wsi, &pss->query, &pss->queryObj);\n\n        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {\n            pss->clientName = cmdPtr->clientName;\n            pss->clientIP = cmdPtr->clientIP;\n        }\n\n        Jsi_DSSetLength(&pss->dHdrs, 0);\n        pss->hdrNum = jsi_wsGetHeaders(pss, wsi, &pss->dHdrs, pss->hdrSz, sizeof(pss->hdrSz)/sizeof(int));\n\n        if (cmdPtr->onFilter && !cmdPtr->deleted) {\n            // 4 args: ws, id, url, bool\n            int killcon = 0, n = 0;\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10], *ret = Jsi_ValueNew1(interp);\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)in, len);\n            vargs[n++] = Jsi_ValueNewBoolean(interp, 1);\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onFilter, vpargs, &ret, NULL);\n            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr, \"WS:KILLING CONNECTION: %p\\n\", pss);\n                killcon = 1;\n            }\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n            if (killcon)\n                return 1;\n        }\n        break;\n\n    case LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED:\n        client_name[0] = 0;\n        client_ip[0] = 0;\n        lws_get_peer_addresses(wsi, lws_get_socket_fd(wsi), client_name,\n                                         sizeof(client_name), client_ip, sizeof(client_ip));\n        if (client_name[0])\n            cmdPtr->clientName = Jsi_KeyAdd(interp, client_name);\n        if (client_ip[0])\n            cmdPtr->clientIP = Jsi_KeyAdd(interp, client_ip);\n\n        if (cmdPtr->clientName || cmdPtr->clientIP) {\n            const char *loname = cmdPtr->localhostName;\n            if (!loname) loname = \"localhost\";\n            cmdPtr->instCtx = context;\n            if (cmdPtr->debug>1)\n                fprintf(stderr,  \"Received network connect from %s (%s)\\n\",\n                     cmdPtr->clientName, cmdPtr->clientIP);\n#ifndef __WIN32\n            if (cmdPtr->local && (cmdPtr->clientName && Jsi_Strcmp(cmdPtr->clientName, loname))) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr,  \"Dropping non-localhost connection\\n\");\n                return 1;\n            }\n#endif\n        }\n\n        if (cmdPtr->maxConnects && cmdPtr->stats.connectCnt>=cmdPtr->maxConnects) {\n            if (cmdPtr->debug>1)\n                fprintf(stderr, \"maxConnects exceeded: rejecting connection <%p>\\n\", user);\n            rc = -1;\n        }\n        /* if we returned non-zero from here, we kill the connection */\n        break;\n\n    case LWS_CALLBACK_HTTP:\n    {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        if (cmdPtr->debug)\n            fprintf(stderr, \"HTTP GET: %s\\n\", inPtr);\n        rc = jsi_wsHttp(interp, cmdPtr, wsi, user, context, inPtr, &dStr, pss);\n        Jsi_DSFree(&dStr);\n        if (rc<0)\n            return -1;\n        if (rc==1) {\n            goto try_to_reuse;\n        }\n        break;\n    }\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    case LWS_CALLBACK_HTTP_BODY: {\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (!pss) break;\n        callPtr = (pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n        if (cmdPtr->maxUpload<=0 || !callPtr) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"Upload disabled: maxUpload=%d, onUpload=%p\\n\", cmdPtr->maxUpload, callPtr);\n            return -1;\n        }\n\n        if (!pss->spa) {\n            /* create the POST argument parser */\n            if (!pss->paramv) {\n                if (cmdPtr->formParams && cmdPtr->formParams != jsi_wsparam_str)\n                    Jsi_SplitStr(cmdPtr->formParams, &pss->paramc, &pss->paramv, \",\", &pss->paramDS);\n                else {\n                    pss->paramv = (typeof(pss->paramv))jsi_wsparam_names;\n                    pss->paramc = ARRAY_SIZE(jsi_wsparam_names);\n                }\n            }\n            pss->spa = lws_spa_create(wsi, (const char*const*)pss->paramv,\n                pss->paramc, 4096, jsi_wsFileUploadCB, pss);\n            if (!pss->spa)\n                    return -1;\n\n            pss->filename[0] = '\\0';\n            pss->file_length = 0;\n        }\n\n        cmdPtr->stats.uploadLast = pss->stats.uploadLast = time(NULL);\n\n        /* let it parse the POST data */\n        if (lws_spa_process(pss->spa, inPtr, len))\n                return -1;\n\n\n        if (!pss->stats.uploadStart) {\n            cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = 0;\n            cmdPtr->stats.uploadStart = pss->stats.uploadStart = time(NULL);\n            cmdPtr->stats.uploadCnt++;\n            pss->stats.uploadCnt++;\n        }\n        break;\n    }\n\n    case LWS_CALLBACK_HTTP_BODY_COMPLETION:\n        if (!pss) {\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n            callPtr = (pss&&pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n        }\n        if (pss && pss->spa)\n            lws_spa_finalize(pss->spa);\n        res = Jsi_DSValue(&pss->resultStr);\n        if (!res[0]) {\n            if (!pss->resultCode)\n                res = \"<html><body>Upload complete</body></html>\";\n            else\n                res = \"<html><body>Upload error</body></html>\";\n        }\n        jsi_wsServeString(pss, wsi, res, pss->resultCode==JSI_OK?0:500, NULL, NULL);\n        if (cmdPtr->maxUpload<=0 || !callPtr) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"Upload disabled: maxUpload=%d, onUpload=%p\\n\", cmdPtr->maxUpload, callPtr);\n            return -1;\n        }\n        cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = time(NULL);\n        lws_return_http_status(wsi, HTTP_STATUS_OK, NULL);\n        goto try_to_reuse;\n\n    case LWS_CALLBACK_HTTP_DROP_PROTOCOL:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (pss && pss->spa) {\n            lws_spa_destroy(pss->spa);\n            pss->spa = NULL;\n        }\n        break;\n#endif\n\n    case LWS_CALLBACK_HTTP_FILE_COMPLETION:\n        goto try_to_reuse;\n\n    case LWS_CALLBACK_HTTP_WRITEABLE: {\n        lwsl_info(\"LWS_CALLBACK_HTTP_WRITEABLE\\n\");\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n\n        if (!pss || !pss->fop_fd)\n            goto try_to_reuse;\n\n        /*\n         * we can send more of whatever it is we were sending\n         */\n        int sent = 0;\n        unsigned char buffer[JSI_BUFSIZ*10 + LWS_PRE];\n        do {\n            int n = sizeof(buffer) - LWS_PRE;\n            int m = lws_get_peer_write_allowance(wsi);\n            if (m == 0)\n                goto later;\n\n            if (m != -1 && m < n)\n                n = m;\n\n            lws_filepos_t amount = 0;\n            n = lws_vfs_file_read(pss->fop_fd, &amount, buffer + LWS_PRE, n);\n            if (n < 0) {\n                lwsl_err(\"problem reading file\\n\");\n                goto bail;\n            }\n            n = (int)amount;\n            if (n == 0)\n                goto penultimate;\n            /*\n             * To support HTTP2, must take care about preamble space\n             *\n             * identification of when we send the last payload frame\n             * is handled by the library itself if you sent a\n             * content-length header\n             */\n            m = jsi_wswrite(pss, wsi, buffer + LWS_PRE, n, LWS_WRITE_HTTP);\n            if (m < 0) {\n                lwsl_err(\"write failed\\n\");\n                /* write failed, close conn */\n                goto bail;\n            }\n            if (m) /* while still active, extend timeout */\n                lws_set_timeout(wsi, PENDING_TIMEOUT_HTTP_CONTENT, 5);\n            sent += m;\n\n        } while (!lws_send_pipe_choked(wsi) && (sent < 500 * 1024 * 1024));\nlater:\n        lws_callback_on_writable(wsi);\n        break;\npenultimate:\n        lws_vfs_file_close(&pss->fop_fd);\n        goto try_to_reuse;\n\nbail:\n        lws_vfs_file_close(&pss->fop_fd);\n        rc = -1;\n        goto doret;\n    }\n\n    default:\n        break;\n    }\n\n    goto doret;\n\ntry_to_reuse:\n    if (lws_http_transaction_completed(wsi))\n         rc = -1;\n    else\n        rc = 0;\n    goto doret;\n\ndoret:\n    if (cmdPtr->debug>2)\n        fprintf(stderr, \"<---HTTP RET = %d\\n\", rc);\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 307,
        "code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-40576"
    },
    {
        "index": 308,
        "code": "TypedValue HHVM_FUNCTION(substr_compare,\n                         const String& main_str,\n                         const String& str,\n                         int offset,\n                         int length /* = INT_MAX */,\n                         bool case_insensitivity /* = false */) {\n  int s1_len = main_str.size();\n  int s2_len = str.size();\n\n  if (length <= 0) {\n    raise_warning(\"The length must be greater than zero\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (offset < 0) {\n    offset = s1_len + offset;\n    if (offset < 0) offset = 0;\n  }\n\n  if (offset >= s1_len) {\n    raise_warning(\"The start position cannot exceed initial string length\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  int cmp_len = s1_len - offset;\n  if (cmp_len < s2_len) cmp_len = s2_len;\n  if (cmp_len > length) cmp_len = length;\n\n  const char *s1 = main_str.data();\n  if (case_insensitivity) {\n    return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len));\n  }\n  return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 309,
        "code": "mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4110"
    },
    {
        "index": 310,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n             output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(context,\n                         \"Mul only supports FLOAT32, INT32 and quantized UINT8,\"\n                         \" INT8 and INT16 now, got %d.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 311,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_6read_one(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  unsigned char __pyx_v_rv;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_one\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":54\n * \n *     def read_one(self):\n *         if self.position == self.current_buffer_size:             # <<<<<<<<<<<<<<\n *             self.read_into_buffer()\n *             self.position = 0\n */\n  __pyx_t_1 = ((__pyx_v_self->position == __pyx_v_self->current_buffer_size) != 0);\n  if (__pyx_t_1) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":55\n *     def read_one(self):\n *         if self.position == self.current_buffer_size:\n *             self.read_into_buffer()             # <<<<<<<<<<<<<<\n *             self.position = 0\n * \n */\n    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_read_into_buffer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 55, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n      if (likely(__pyx_t_4)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":56\n *         if self.position == self.current_buffer_size:\n *             self.read_into_buffer()\n *             self.position = 0             # <<<<<<<<<<<<<<\n * \n *         rv = self.buffer[self.position]\n */\n    __pyx_v_self->position = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":54\n * \n *     def read_one(self):\n *         if self.position == self.current_buffer_size:             # <<<<<<<<<<<<<<\n *             self.read_into_buffer()\n *             self.position = 0\n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":58\n *             self.position = 0\n * \n *         rv = self.buffer[self.position]             # <<<<<<<<<<<<<<\n *         self.position += 1\n *         return rv\n */\n  __pyx_t_5 = __Pyx_GetItemInt_ByteArray(__pyx_v_self->buffer, __pyx_v_self->position, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 1, 1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 58, __pyx_L1_error)\n  __pyx_v_rv = __pyx_t_5;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":59\n * \n *         rv = self.buffer[self.position]\n *         self.position += 1             # <<<<<<<<<<<<<<\n *         return rv\n * \n */\n  __pyx_v_self->position = (__pyx_v_self->position + 1);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":60\n *         rv = self.buffer[self.position]\n *         self.position += 1\n *         return rv             # <<<<<<<<<<<<<<\n * \n *     def read_strings(self, Py_ssize_t n_items, encoding=None):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_2 = __Pyx_PyInt_From_unsigned_char(__pyx_v_rv); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 60, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_r = __pyx_t_2;\n  __pyx_t_2 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":53\n *         return rv\n * \n *     def read_one(self):             # <<<<<<<<<<<<<<\n *         if self.position == self.current_buffer_size:\n *             self.read_into_buffer()\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read_one\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 312,
        "code": "  void writeStats(Array& /*ret*/) override {\n    fprintf(stderr, \"writeStats start\\n\");\n    // RetSame: the return value is the same instance every time\n    // HasThis: call has a this argument\n    // AllSame: all returns were the same data even though args are different\n    // MemberCount: number of different arg sets (including this)\n    fprintf(stderr, \"Count Function MinSerLen MaxSerLen RetSame HasThis \"\n            \"AllSame MemberCount\\n\");\n    for (auto& me : m_memos) {\n      if (me.second.m_ignore) continue;\n      if (me.second.m_count == 1) continue;\n      int min_ser_len = 999999999;\n      int max_ser_len = 0;\n      int count = 0;\n      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),\n              min_ser_len, max_ser_len,\n              me.second.m_ret_tv_same ? \" true\" : \"false\",\n              me.second.m_has_this ? \" true\" : \"false\",\n              all_same ? \" true\" : \"false\",\n              member_count\n             );\n    }\n    fprintf(stderr, \"writeStats end\\n\");\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 313,
        "code": "static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)\n{\n    Py_VISIT(m->func_closure);\n    Py_VISIT(m->func.m_module);\n    Py_VISIT(m->func_dict);\n    Py_VISIT(m->func_name);\n    Py_VISIT(m->func_qualname);\n    Py_VISIT(m->func_doc);\n    Py_VISIT(m->func_globals);\n    Py_VISIT(m->func_code);\n    Py_VISIT(m->func_classobj);\n    Py_VISIT(m->defaults_tuple);\n    Py_VISIT(m->defaults_kwdict);\n    if (m->defaults) {\n        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);\n        int i;\n        for (i = 0; i < m->defaults_pyobjects; i++)\n            Py_VISIT(pydefaults[i]);\n    }\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 314,
        "code": "void RuntimeOption::Load(\n  IniSetting::Map& ini, Hdf& config,\n  const std::vector<std::string>& iniClis /* = std::vector<std::string>() */,\n  const std::vector<std::string>& hdfClis /* = std::vector<std::string>() */,\n  std::vector<std::string>* messages /* = nullptr */,\n  std::string cmd /* = \"\" */) {\n  ARRPROV_USE_RUNTIME_LOCATION_FORCE();\n\n  // Intialize the memory manager here because various settings and\n  // initializations that we do here need it\n  tl_heap.getCheck();\n\n  // Get the ini (-d) and hdf (-v) strings, which may override some\n  // of options that were set from config files. We also do these\n  // now so we can override Tier.*.[machine | tier | cpu] on the\n  // command line, along with any fields within a Tier (e.g.,\n  // CoreFileSize)\n  for (auto& istr : iniClis) {\n    Config::ParseIniString(istr, ini);\n  }\n  for (auto& hstr : hdfClis) {\n    Config::ParseHdfString(hstr, config);\n  }\n\n  // See if there are any Tier-based overrides\n  auto m = getTierOverwrites(ini, config);\n  if (messages) *messages = std::move(m);\n\n  // RelativeConfigs can be set by commandline flags and tier overwrites, they\n  // may also contain tier overwrites. They are, however, only included once, so\n  // relative configs may not specify other relative configs which must to be\n  // loaded. If RelativeConfigs is modified while loading configs an error is\n  // raised, but we defer doing so until the logger is initialized below. If a\n  // relative config cannot be found it is silently skipped (this is to allow\n  // configs to be conditionally applied to scripts based on their location). By\n  // reading the \"hhvm.relative_configs\" ini setting at runtime it is possible\n  // to determine which configs were actually loaded.\n  std::string relConfigsError;\n  Config::Bind(s_RelativeConfigs, ini, config, \"RelativeConfigs\");\n  if (!cmd.empty() && !s_RelativeConfigs.empty()) {\n    String strcmd(cmd, CopyString);\n    Process::InitProcessStatics();\n    auto const currentDir = Process::CurrentWorkingDirectory.data();\n    std::vector<std::string> newConfigs;\n    auto const original = s_RelativeConfigs;\n    for (auto& str : original) {\n      if (str.empty()) continue;\n\n      std::string fullpath;\n      auto const found = FileUtil::runRelative(\n        str, strcmd, currentDir,\n        [&] (const String& f) {\n          if (access(f.data(), R_OK) == 0) {\n            fullpath = f.toCppString();\n            FTRACE_MOD(Trace::watchman_autoload, 3, \"Parsing {}\\n\", fullpath);\n            Config::ParseConfigFile(fullpath, ini, config);\n            return true;\n          }\n          return false;\n        }\n      );\n      if (found) newConfigs.emplace_back(std::move(fullpath));\n    }\n    if (!newConfigs.empty()) {\n      auto m2 = getTierOverwrites(ini, config);\n      if (messages) *messages = std::move(m2);\n      if (s_RelativeConfigs != original) {\n        relConfigsError = folly::sformat(\n          \"RelativeConfigs node was modified while loading configs from [{}] \"\n          \"to [{}]\",\n          folly::join(\", \", original),\n          folly::join(\", \", s_RelativeConfigs)\n        );\n      }\n    }\n    s_RelativeConfigs.swap(newConfigs);\n  } else {\n    s_RelativeConfigs.clear();\n  }\n\n  // Then get the ini and hdf cli strings again, in case the tier overwrites\n  // overrode any non-tier based command line option we set. The tier-based\n  // command line overwrites will already have been set in the call above.\n  // This extra call is for the other command line options that may have been\n  // overridden by a tier, but shouldn't have been.\n  for (auto& istr : iniClis) {\n    Config::ParseIniString(istr, ini);\n  }\n  for (auto& hstr : hdfClis) {\n    Config::ParseHdfString(hstr, config);\n  }\n\n  Config::Bind(PidFile, ini, config, \"PidFile\", \"www.pid\");\n  Config::Bind(DeploymentId, ini, config, \"DeploymentId\");\n\n  {\n    static std::string deploymentIdOverride;\n    Config::Bind(deploymentIdOverride, ini, config, \"DeploymentIdOverride\");\n    if (!deploymentIdOverride.empty()) {\n      RuntimeOption::DeploymentId = deploymentIdOverride;\n    }\n  }\n\n  {\n    // Config ID\n    Config::Bind(ConfigId, ini, config, \"ConfigId\", 0);\n    auto configIdCounter = ServiceData::createCounter(\"vm.config.id\");\n    configIdCounter->setValue(ConfigId);\n  }\n\n  {\n    // Logging\n    auto setLogLevel = [](const std::string& value) {\n      // ini parsing treats \"None\" as \"\"\n      if (value == \"None\" || value == \"\") {\n        Logger::LogLevel = Logger::LogNone;\n      } else if (value == \"Error\") {\n        Logger::LogLevel = Logger::LogError;\n      } else if (value == \"Warning\") {\n        Logger::LogLevel = Logger::LogWarning;\n      } else if (value == \"Info\") {\n        Logger::LogLevel = Logger::LogInfo;\n      } else if (value == \"Verbose\") {\n        Logger::LogLevel = Logger::LogVerbose;\n      } else {\n        return false;\n      }\n      return true;\n    };\n    auto str = Config::GetString(ini, config, \"Log.Level\");\n    if (!str.empty()) {\n      setLogLevel(str);\n    }\n    IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                     \"hhvm.log.level\", IniSetting::SetAndGet<std::string>(\n      setLogLevel,\n      []() {\n        switch (Logger::LogLevel) {\n          case Logger::LogNone:\n            return \"None\";\n          case Logger::LogError:\n            return \"Error\";\n          case Logger::LogWarning:\n            return \"Warning\";\n          case Logger::LogInfo:\n            return \"Info\";\n          case Logger::LogVerbose:\n            return \"Verbose\";\n        }\n        return \"\";\n      }\n    ));\n\n    Config::Bind(Logger::UseLogFile, ini, config, \"Log.UseLogFile\", true);\n    Config::Bind(LogFile, ini, config, \"Log.File\");\n    Config::Bind(LogFileSymLink, ini, config, \"Log.SymLink\");\n    Config::Bind(LogFilePeriodMultiplier, ini,\n                 config, \"Log.PeriodMultiplier\", 0);\n    if (Logger::UseLogFile && RuntimeOption::ServerExecutionMode()) {\n      RuntimeOption::ErrorLogs[Logger::DEFAULT] =\n        ErrorLogFileData(LogFile, LogFileSymLink, LogFilePeriodMultiplier);\n    }\n    if (Config::GetBool(ini, config, \"Log.AlwaysPrintStackTraces\")) {\n      Logger::SetTheLogger(Logger::DEFAULT, new ExtendedLogger());\n      ExtendedLogger::EnabledByDefault = true;\n    }\n\n    Config::Bind(Logger::LogHeader, ini, config, \"Log.Header\");\n    Config::Bind(Logger::LogNativeStackTrace, ini, config,\n                 \"Log.NativeStackTrace\", true);\n    Config::Bind(Logger::UseSyslog, ini, config, \"Log.UseSyslog\", false);\n    Config::Bind(Logger::UseRequestLog, ini, config, \"Log.UseRequestLog\",\n                 false);\n    Config::Bind(Logger::AlwaysEscapeLog, ini, config, \"Log.AlwaysEscapeLog\",\n                 true);\n    Config::Bind(Logger::UseCronolog, ini, config, \"Log.UseCronolog\", false);\n    Config::Bind(Logger::MaxMessagesPerRequest, ini,\n                 config, \"Log.MaxMessagesPerRequest\", -1);\n    Config::Bind(LogFileFlusher::DropCacheChunkSize, ini,\n                 config, \"Log.DropCacheChunkSize\", 1 << 20);\n    Config::Bind(RuntimeOption::LogHeaderMangle, ini, config,\n                 \"Log.HeaderMangle\", 0);\n    Config::Bind(AlwaysLogUnhandledExceptions, ini,\n                 config, \"Log.AlwaysLogUnhandledExceptions\",\n                 true);\n    Config::Bind(NoSilencer, ini, config, \"Log.NoSilencer\");\n    Config::Bind(RuntimeErrorReportingLevel, ini,\n                 config, \"Log.RuntimeErrorReportingLevel\",\n                 static_cast<int>(ErrorMode::HPHP_ALL));\n    Config::Bind(ForceErrorReportingLevel, ini,\n                 config, \"Log.ForceErrorReportingLevel\", 0);\n    Config::Bind(AccessLogDefaultFormat, ini, config,\n                 \"Log.AccessLogDefaultFormat\", \"%h %l %u %t \\\"%r\\\" %>s %b\");\n\n    auto parseLogs = [] (const Hdf &config, const IniSetting::Map& ini,\n                         const std::string &name,\n                         std::map<std::string, AccessLogFileData> &logs) {\n      auto parse_logs_callback = [&] (const IniSetting::Map &ini_pl,\n                                      const Hdf &hdf_pl,\n                                      const std::string &ini_pl_key) {\n        string logName = hdf_pl.exists() && !hdf_pl.isEmpty()\n                       ? hdf_pl.getName()\n                       : ini_pl_key;\n        string fname = Config::GetString(ini_pl, hdf_pl, \"File\", \"\", false);\n        if (!fname.empty()) {\n          string symlink = Config::GetString(ini_pl, hdf_pl, \"SymLink\", \"\",\n                                             false);\n          string format = Config::GetString(ini_pl, hdf_pl, \"Format\",\n                                            AccessLogDefaultFormat, false);\n          auto periodMultiplier = Config::GetUInt16(ini_pl, hdf_pl,\n                                                    \"PeriodMultiplier\",\n                                                    0, false);\n          logs[logName] = AccessLogFileData(fname, symlink,\n                                            format, periodMultiplier);\n\n\n        }\n      };\n      Config::Iterate(parse_logs_callback, ini, config, name);\n    };\n\n    parseLogs(config, ini, \"Log.Access\", AccessLogs);\n    RPCLogs = AccessLogs;\n    parseLogs(config, ini, \"Log.RPC\", RPCLogs);\n\n    Config::Bind(AdminLogFormat, ini, config, \"Log.AdminLog.Format\",\n                 \"%h %t %s %U\");\n    Config::Bind(AdminLogFile, ini, config, \"Log.AdminLog.File\");\n    Config::Bind(AdminLogSymLink, ini, config, \"Log.AdminLog.SymLink\");\n  }\n  {\n    // Error Handling\n\n    Config::Bind(ErrorUpgradeLevel, ini, config, \"ErrorHandling.UpgradeLevel\",\n                 0);\n    Config::Bind(MaxSerializedStringSize, ini,\n                 config, \"ErrorHandling.MaxSerializedStringSize\",\n                 64 * 1024 * 1024);\n    Config::Bind(CallUserHandlerOnFatals, ini,\n                 config, \"ErrorHandling.CallUserHandlerOnFatals\", false);\n    Config::Bind(ThrowExceptionOnBadMethodCall, ini,\n                 config, \"ErrorHandling.ThrowExceptionOnBadMethodCall\", true);\n    Config::Bind(LogNativeStackOnOOM, ini,\n                 config, \"ErrorHandling.LogNativeStackOnOOM\", false);\n    Config::Bind(NoInfiniteRecursionDetection, ini,\n                 config, \"ErrorHandling.NoInfiniteRecursionDetection\");\n    Config::Bind(NoticeFrequency, ini, config, \"ErrorHandling.NoticeFrequency\",\n                 1);\n    Config::Bind(WarningFrequency, ini, config,\n                 \"ErrorHandling.WarningFrequency\", 1);\n  }\n\n  // If we generated errors while loading RelativeConfigs report those now that\n  // error reporting is initialized\n  if (!relConfigsError.empty()) Logger::Error(relConfigsError);\n\n  {\n    if (Config::GetInt64(ini, config, \"ResourceLimit.CoreFileSizeOverride\")) {\n      setResourceLimit(RLIMIT_CORE, ini,  config,\n                       \"ResourceLimit.CoreFileSizeOverride\");\n    } else {\n      setResourceLimit(RLIMIT_CORE, ini, config, \"ResourceLimit.CoreFileSize\");\n    }\n    setResourceLimit(RLIMIT_NOFILE, ini, config, \"ResourceLimit.MaxSocket\");\n    setResourceLimit(RLIMIT_DATA, ini, config, \"ResourceLimit.RSS\");\n    // These don't have RuntimeOption::xxx bindings, but we still want to be\n    // able to use ini_xxx functionality on them; so directly bind to a local\n    // static via Config::Bind.\n    static int64_t s_core_file_size_override, s_core_file_size, s_rss = 0;\n    static int32_t s_max_socket = 0;\n    Config::Bind(s_core_file_size_override, ini, config,\n                 \"ResourceLimit.CoreFileSizeOverride\", 0);\n    Config::Bind(s_core_file_size, ini, config, \"ResourceLimit.CoreFileSize\",\n                 0);\n    Config::Bind(s_max_socket, ini, config, \"ResourceLimit.MaxSocket\", 0);\n    Config::Bind(s_rss, ini, config, \"ResourceLimit.RSS\", 0);\n\n    Config::Bind(SocketDefaultTimeout, ini, config,\n                 \"ResourceLimit.SocketDefaultTimeout\", 60);\n    Config::Bind(MaxSQLRowCount, ini, config, \"ResourceLimit.MaxSQLRowCount\",\n                 0);\n    Config::Bind(SerializationSizeLimit, ini, config,\n                 \"ResourceLimit.SerializationSizeLimit\", StringData::MaxSize);\n    Config::Bind(HeapSizeMB, ini, config, \"ResourceLimit.HeapSizeMB\",\n                 HeapSizeMB);\n    Config::Bind(HeapResetCountBase, ini, config,\n                 \"ResourceLimit.HeapResetCountBase\", HeapResetCountBase);\n    Config::Bind(HeapResetCountMultiple, ini, config,\n                 \"ResourceLimit.HeapResetCountMultiple\",\n                 HeapResetCountMultiple);\n    Config::Bind(HeapLowWaterMark , ini, config,\n                 \"ResourceLimit.HeapLowWaterMark\", HeapLowWaterMark);\n    Config::Bind(HeapHighWaterMark , ini, config,\n                 \"ResourceLimit.HeapHighWaterMark\",HeapHighWaterMark);\n  }\n  {\n    // PHPisms\n    Config::Bind(DisableCallUserFunc, ini, config,\n                 \"Hack.Lang.Phpism.DisableCallUserFunc\",\n                 DisableCallUserFunc);\n    Config::Bind(DisableCallUserFuncArray, ini, config,\n                 \"Hack.Lang.Phpism.DisableCallUserFuncArray\",\n                 DisableCallUserFuncArray);\n    Config::Bind(DisableAssert, ini, config,\n                 \"Hack.Lang.Phpism.DisableAssert\",\n                 DisableAssert);\n    Config::Bind(DisableNontoplevelDeclarations, ini, config,\n                 \"Hack.Lang.Phpism.DisableNontoplevelDeclarations\",\n                 DisableNontoplevelDeclarations);\n    Config::Bind(DisableStaticClosures, ini, config,\n                 \"Hack.Lang.Phpism.DisableStaticClosures\",\n                 DisableStaticClosures);\n    Config::Bind(DisableConstant, ini, config,\n                 \"Hack.Lang.Phpism.DisableConstant\",\n                 DisableConstant);\n  }\n  {\n    // Repo\n    auto repoModeToStr = [](RepoMode mode) {\n      switch (mode) {\n        case RepoMode::Closed:\n          return \"--\";\n        case RepoMode::ReadOnly:\n          return \"r-\";\n        case RepoMode::ReadWrite:\n          return \"rw\";\n      }\n\n      always_assert(false);\n      return \"\";\n    };\n\n    auto parseRepoMode = [&](const std::string& repoModeStr, const char* type, RepoMode defaultMode) {\n      if (repoModeStr.empty()) {\n        return defaultMode;\n      }\n      if (repoModeStr == \"--\") {\n        return RepoMode::Closed;\n      }\n      if (repoModeStr == \"r-\") {\n        return RepoMode::ReadOnly;\n      }\n      if (repoModeStr == \"rw\") {\n        return RepoMode::ReadWrite;\n      }\n\n      Logger::Error(\"Bad config setting: Repo.%s.Mode=%s\",\n                    type, repoModeStr.c_str());\n      return RepoMode::ReadWrite;\n    };\n\n    // Local Repo\n    static std::string repoLocalMode;\n    Config::Bind(repoLocalMode, ini, config, \"Repo.Local.Mode\", repoModeToStr(RepoLocalMode));\n    RepoLocalMode = parseRepoMode(repoLocalMode, \"Local\", RepoMode::ReadOnly);\n\n    // Repo.Local.Path\n    Config::Bind(RepoLocalPath, ini, config, \"Repo.Local.Path\");\n    if (RepoLocalPath.empty()) {\n      const char* HHVM_REPO_LOCAL_PATH = getenv(\"HHVM_REPO_LOCAL_PATH\");\n      if (HHVM_REPO_LOCAL_PATH != nullptr) {\n        RepoLocalPath = HHVM_REPO_LOCAL_PATH;\n      }\n    }\n\n    // Central Repo\n    static std::string repoCentralMode;\n    Config::Bind(repoCentralMode, ini, config, \"Repo.Central.Mode\", repoModeToStr(RepoCentralMode));\n    RepoCentralMode = parseRepoMode(repoCentralMode, \"Central\", RepoMode::ReadWrite);\n\n    // Repo.Central.Path\n    Config::Bind(RepoCentralPath, ini, config, \"Repo.Central.Path\");\n    Config::Bind(RepoCentralFileMode, ini, config, \"Repo.Central.FileMode\");\n    Config::Bind(RepoCentralFileUser, ini, config, \"Repo.Central.FileUser\");\n    Config::Bind(RepoCentralFileGroup, ini, config, \"Repo.Central.FileGroup\");\n\n    Config::Bind(RepoAllowFallbackPath, ini, config, \"Repo.AllowFallbackPath\",\n                 RepoAllowFallbackPath);\n\n    replacePlaceholders(RepoLocalPath);\n    replacePlaceholders(RepoCentralPath);\n\n    Config::Bind(RepoJournal, ini, config, \"Repo.Journal\", RepoJournal);\n    Config::Bind(RepoCommit, ini, config, \"Repo.Commit\",\n                 RepoCommit);\n    Config::Bind(RepoDebugInfo, ini, config, \"Repo.DebugInfo\", RepoDebugInfo);\n    Config::Bind(RepoLitstrLazyLoad, ini, config, \"Repo.LitstrLazyLoad\",\n                 RepoLitstrLazyLoad);\n    Config::Bind(RepoAuthoritative, ini, config, \"Repo.Authoritative\",\n                 RepoAuthoritative);\n    Config::Bind(RepoLocalReadaheadRate, ini, config,\n                 \"Repo.LocalReadaheadRate\", 0);\n    Config::Bind(RepoLocalReadaheadConcurrent, ini, config,\n                 \"Repo.LocalReadaheadConcurrent\", false);\n    Config::Bind(RepoBusyTimeoutMS, ini, config,\n                 \"Repo.BusyTimeoutMS\", RepoBusyTimeoutMS);\n  }\n\n  if (use_jemalloc) {\n    // HHProf\n    Config::Bind(HHProfEnabled, ini, config, \"HHProf.Enabled\", false);\n    Config::Bind(HHProfActive, ini, config, \"HHProf.Active\", false);\n    Config::Bind(HHProfAccum, ini, config, \"HHProf.Accum\", false);\n    Config::Bind(HHProfRequest, ini, config, \"HHProf.Request\", false);\n  }\n  {\n    // Eval\n    Config::Bind(EnableHipHopSyntax, ini, config, \"Eval.EnableHipHopSyntax\",\n                 EnableHipHopSyntax);\n    Config::Bind(EnableShortTags, ini, config, \"Eval.EnableShortTags\", true);\n    Config::Bind(EnableXHP, ini, config, \"Eval.EnableXHP\", EnableXHP);\n    Config::Bind(TimeoutsUseWallTime, ini, config, \"Eval.TimeoutsUseWallTime\",\n                 true);\n    Config::Bind(CheckFlushOnUserClose, ini, config,\n                 \"Eval.CheckFlushOnUserClose\", true);\n    Config::Bind(EvalInitialNamedEntityTableSize, ini, config,\n                 \"Eval.InitialNamedEntityTableSize\",\n                 EvalInitialNamedEntityTableSize);\n    Config::Bind(EvalInitialStaticStringTableSize, ini, config,\n                 \"Eval.InitialStaticStringTableSize\",\n                 EvalInitialStaticStringTableSize);\n\n    static std::string jitSerdesMode;\n    Config::Bind(jitSerdesMode, ini, config, \"Eval.JitSerdesMode\", \"Off\");\n\n    EvalJitSerdesMode = [&] {\n      #define X(x) if (jitSerdesMode == #x) return JitSerdesMode::x\n      X(Serialize);\n      X(SerializeAndExit);\n      X(Deserialize);\n      X(DeserializeOrFail);\n      X(DeserializeOrGenerate);\n      X(DeserializeAndDelete);\n      X(DeserializeAndExit);\n      #undef X\n      return JitSerdesMode::Off;\n    }();\n    Config::Bind(EvalJitSerdesFile, ini, config,\n                 \"Eval.JitSerdesFile\", EvalJitSerdesFile);\n    // DumpPreciseProfileData defaults to true only when we can possibly write\n    // profile data to disk.  It can be set to false to avoid the performance\n    // penalty of only running the interpreter during retranslateAll.  We will\n    // assume that DumpPreciseProfileData implies (JitSerdesMode::Serialize ||\n    // JitSerdesMode::SerializeAndExit), to avoid checking too many flags in a\n    // few places.  The config file should never need to explicitly set\n    // DumpPreciseProfileData to true.\n    auto const couldDump = !EvalJitSerdesFile.empty() &&\n      (isJitSerializing() ||\n       (EvalJitSerdesMode == JitSerdesMode::DeserializeOrGenerate));\n    Config::Bind(DumpPreciseProfData, ini, config,\n                 \"Eval.DumpPreciseProfData\", couldDump);\n    Config::Bind(ProfDataTTLHours, ini, config,\n                 \"Eval.ProfDataTTLHours\", ProfDataTTLHours);\n    Config::Bind(ProfDataTag, ini, config, \"Eval.ProfDataTag\", ProfDataTag);\n\n    Config::Bind(CheckSymLink, ini, config, \"Eval.CheckSymLink\", true);\n    Config::Bind(TrustAutoloaderPath, ini, config,\n                 \"Eval.TrustAutoloaderPath\", false);\n\n#define F(type, name, defaultVal) \\\n    Config::Bind(Eval ## name, ini, config, \"Eval.\"#name, defaultVal);\n    EVALFLAGS()\n#undef F\n\n    if (EvalJitSerdesModeForceOff) EvalJitSerdesMode = JitSerdesMode::Off;\n    if (!EvalEnableReusableTC) EvalReusableTCPadding = 0;\n    if (numa_num_nodes <= 1) {\n      EvalEnableNuma = false;\n    }\n\n    Config::Bind(ServerForkEnabled, ini, config,\n                 \"Server.Forking.Enabled\", ServerForkEnabled);\n    Config::Bind(ServerForkLogging, ini, config,\n                 \"Server.Forking.LogForkAttempts\", ServerForkLogging);\n    if (!ServerForkEnabled && ServerExecutionMode()) {\n      // Only use hugetlb pages when we don't fork().\n      low_2m_pages(EvalMaxLowMemHugePages);\n      high_2m_pages(EvalMaxHighArenaHugePages);\n    }\n    s_enable_static_arena =\n      Config::GetBool(ini, config, \"Eval.UseTLStaticArena\", true);\n\n    replacePlaceholders(EvalHackCompilerExtractPath);\n    replacePlaceholders(EvalHackCompilerFallbackPath);\n    replacePlaceholders(EvalEmbeddedDataExtractPath);\n    replacePlaceholders(EvalEmbeddedDataFallbackPath);\n\n    if (!jit::mcgen::retranslateAllEnabled()) {\n      EvalJitWorkerThreads = 0;\n      if (EvalJitSerdesMode != JitSerdesMode::Off) {\n        if (ServerMode) {\n          Logger::Warning(\"Eval.JitSerdesMode reset from \" + jitSerdesMode +\n                          \" to off, becasue JitRetranslateAll isn't enabled.\");\n        }\n        EvalJitSerdesMode = JitSerdesMode::Off;\n      }\n      EvalJitSerdesFile.clear();\n      DumpPreciseProfData = false;\n    }\n    EvalJitPGOUseAddrCountedCheck &= addr_encodes_persistency;\n    HardwareCounter::Init(EvalProfileHWEnable,\n                          url_decode(EvalProfileHWEvents.data(),\n                                     EvalProfileHWEvents.size()).toCppString(),\n                          false,\n                          EvalProfileHWExcludeKernel,\n                          EvalProfileHWFastReads,\n                          EvalProfileHWExportInterval);\n\n    Config::Bind(EnableIntrinsicsExtension, ini,\n                 config, \"Eval.EnableIntrinsicsExtension\",\n                 EnableIntrinsicsExtension);\n    Config::Bind(RecordCodeCoverage, ini, config, \"Eval.RecordCodeCoverage\");\n    if (EvalJit && RecordCodeCoverage) {\n      throw std::runtime_error(\"Code coverage is not supported with \"\n        \"Eval.Jit=true\");\n    }\n    Config::Bind(DisableSmallAllocator, ini, config,\n                 \"Eval.DisableSmallAllocator\", DisableSmallAllocator);\n    SetArenaSlabAllocBypass(DisableSmallAllocator);\n    EvalSlabAllocAlign = folly::nextPowTwo(EvalSlabAllocAlign);\n    EvalSlabAllocAlign = std::min(EvalSlabAllocAlign,\n                                  decltype(EvalSlabAllocAlign){4096});\n\n    if (RecordCodeCoverage) CheckSymLink = true;\n    Config::Bind(CodeCoverageOutputFile, ini, config,\n                 \"Eval.CodeCoverageOutputFile\");\n    // NB: after we know the value of RepoAuthoritative.\n    Config::Bind(EnableArgsInBacktraces, ini, config,\n                 \"Eval.EnableArgsInBacktraces\", !RepoAuthoritative);\n    Config::Bind(EvalAuthoritativeMode, ini, config, \"Eval.AuthoritativeMode\",\n                 false);\n\n    Config::Bind(CheckCLIClientCommands, ini, config, \"Eval.CheckCLIClientCommands\", 1);\n    if (RepoAuthoritative) {\n      EvalAuthoritativeMode = true;\n    }\n    {\n      // Debugger (part of Eval)\n      Config::Bind(EnableHphpdDebugger, ini, config,\n                   \"Eval.Debugger.EnableDebugger\");\n      Config::Bind(EnableDebuggerColor, ini, config,\n                   \"Eval.Debugger.EnableDebuggerColor\", true);\n      Config::Bind(EnableDebuggerPrompt, ini, config,\n                   \"Eval.Debugger.EnableDebuggerPrompt\", true);\n      Config::Bind(EnableDebuggerServer, ini, config,\n                   \"Eval.Debugger.EnableDebuggerServer\");\n      Config::Bind(EnableDebuggerUsageLog, ini, config,\n                   \"Eval.Debugger.EnableDebuggerUsageLog\");\n      Config::Bind(DebuggerServerIP, ini, config, \"Eval.Debugger.IP\");\n      Config::Bind(DebuggerServerPort, ini, config, \"Eval.Debugger.Port\", 8089);\n      Config::Bind(DebuggerDisableIPv6, ini, config,\n                   \"Eval.Debugger.DisableIPv6\", false);\n      Config::Bind(DebuggerDefaultSandboxPath, ini, config,\n                   \"Eval.Debugger.DefaultSandboxPath\");\n      Config::Bind(DebuggerStartupDocument, ini, config,\n                   \"Eval.Debugger.StartupDocument\");\n      Config::Bind(DebuggerSignalTimeout, ini, config,\n                   \"Eval.Debugger.SignalTimeout\", 1);\n      Config::Bind(DebuggerDefaultRpcPort, ini, config,\n                   \"Eval.Debugger.RPC.DefaultPort\", 8083);\n      DebuggerDefaultRpcAuth =\n        Config::GetString(ini, config, \"Eval.Debugger.RPC.DefaultAuth\");\n      Config::Bind(DebuggerRpcHostDomain, ini, config,\n                   \"Eval.Debugger.RPC.HostDomain\");\n      Config::Bind(DebuggerDefaultRpcTimeout, ini, config,\n                   \"Eval.Debugger.RPC.DefaultTimeout\", 30);\n      Config::Bind(DebuggerAuthTokenScriptBin, ini, config,\n                   \"Eval.Debugger.Auth.TokenScriptBin\");\n      Config::Bind(DebuggerSessionAuthScriptBin, ini, config,\n                   \"Eval.Debugger.Auth.SessionAuthScriptBin\");\n    }\n  }\n  {\n    // CodeCache\n    using jit::CodeCache;\n    Config::Bind(CodeCache::AHotSize, ini, config, \"Eval.JitAHotSize\",\n                 ahotDefault());\n    Config::Bind(CodeCache::ASize, ini, config, \"Eval.JitASize\", 60 << 20);\n    Config::Bind(CodeCache::AProfSize, ini, config, \"Eval.JitAProfSize\",\n                 RuntimeOption::EvalJitPGO ? (64 << 20) : 0);\n    Config::Bind(CodeCache::AColdSize, ini, config, \"Eval.JitAColdSize\",\n                 24 << 20);\n    Config::Bind(CodeCache::AFrozenSize, ini, config, \"Eval.JitAFrozenSize\",\n                 40 << 20);\n    Config::Bind(CodeCache::ABytecodeSize, ini, config,\n                 \"Eval.JitABytecodeSize\", 0);\n    Config::Bind(CodeCache::GlobalDataSize, ini, config,\n                 \"Eval.JitGlobalDataSize\", CodeCache::ASize >> 2);\n\n    Config::Bind(CodeCache::MapTCHuge, ini, config, \"Eval.MapTCHuge\",\n                 hugePagesSoundNice());\n\n    Config::Bind(CodeCache::TCNumHugeHotMB, ini, config,\n                 \"Eval.TCNumHugeHotMB\", 64);\n    Config::Bind(CodeCache::TCNumHugeMainMB, ini, config,\n                 \"Eval.TCNumHugeMainMB\", 16);\n    Config::Bind(CodeCache::TCNumHugeColdMB, ini, config,\n                 \"Eval.TCNumHugeColdMB\", 4);\n\n    Config::Bind(CodeCache::AutoTCShift, ini, config, \"Eval.JitAutoTCShift\", 1);\n  }\n  {\n    // Hack Language\n    Config::Bind(CheckIntOverflow, ini, config,\n                 \"Hack.Lang.CheckIntOverflow\", 0);\n    Config::Bind(StrictArrayFillKeys, ini, config,\n                 \"Hack.Lang.StrictArrayFillKeys\", HackStrictOption::ON);\n\n    Config::Bind(LookForTypechecker, ini, config,\n                 \"Hack.Lang.LookForTypechecker\", false);\n\n    // If you turn off LookForTypechecker, you probably want to turn this off\n    // too -- basically, make the two look like the same option to external\n    // users, unless you really explicitly want to set them differently for\n    // some reason.\n    Config::Bind(AutoTypecheck, ini, config, \"Hack.Lang.AutoTypecheck\",\n                 LookForTypechecker);\n    Config::Bind(EnableClassLevelWhereClauses, ini, config,\n                 \"Hack.Lang.EnableClassLevelWhereClauses\",\n                 false);\n  }\n  {\n    // Options for PHP7 features which break BC. (Features which do not break\n    // BC don't need options here and can just always be turned on.)\n    //\n    // NB that the \"PHP7.all\" option is intended to be only a master switch;\n    // all runtime behavior gating should be based on sub-options (that's why\n    // it's a file static not a static member of RuntimeOption). Also don't\n    // forget to update mangleUnitPHP7Options if needed.\n    //\n    // TODO: we may eventually want to make an option which specifies\n    // directories or filenames to exclude from PHP7 behavior, and so checking\n    // these may want to be per-file. We originally planned to do this from the\n    // get-go, but threading that through turns out to be kind of annoying and\n    // of questionable value, so just doing this for now.\n    Config::Bind(s_PHP7_master, ini, config, \"PHP7.all\", s_PHP7_default);\n    Config::Bind(PHP7_EngineExceptions, ini, config, \"PHP7.EngineExceptions\",\n                 s_PHP7_master);\n    Config::Bind(PHP7_NoHexNumerics, ini, config, \"PHP7.NoHexNumerics\",\n                 s_PHP7_master);\n    Config::Bind(PHP7_Builtins, ini, config, \"PHP7.Builtins\", s_PHP7_master);\n    Config::Bind(PHP7_Substr, ini, config, \"PHP7.Substr\",\n                 s_PHP7_master);\n    Config::Bind(PHP7_DisallowUnsafeCurlUploads, ini, config,\n                 \"PHP7.DisallowUnsafeCurlUploads\", s_PHP7_master);\n  }\n  {\n    // Server\n    Config::Bind(Host, ini, config, \"Server.Host\");\n    Config::Bind(DefaultServerNameSuffix, ini, config,\n                 \"Server.DefaultServerNameSuffix\");\n    Config::Bind(AlwaysDecodePostDataDefault, ini, config,\n                 \"Server.AlwaysDecodePostDataDefault\",\n                 AlwaysDecodePostDataDefault);\n    Config::Bind(ServerType, ini, config, \"Server.Type\", ServerType);\n    Config::Bind(ServerIP, ini, config, \"Server.IP\");\n    Config::Bind(ServerFileSocket, ini, config, \"Server.FileSocket\");\n\n#ifdef FACEBOOK\n    //Do not cause slowness on startup -- except for Facebook\n    if (GetServerPrimaryIPv4().empty() && GetServerPrimaryIPv6().empty()) {\n      throw std::runtime_error(\"Unable to resolve the server's \"\n          \"IPv4 or IPv6 address\");\n    }\n#endif\n\n    Config::Bind(ServerPort, ini, config, \"Server.Port\", 80);\n    Config::Bind(ServerBacklog, ini, config, \"Server.Backlog\", 128);\n    Config::Bind(ServerConnectionLimit, ini, config,\n                 \"Server.ConnectionLimit\", 0);\n    Config::Bind(ServerThreadCount, ini, config, \"Server.ThreadCount\",\n                 Process::GetCPUCount() * 2);\n    Config::Bind(ServerQueueCount, ini, config, \"Server.QueueCount\",\n                 ServerThreadCount);\n    Config::Bind(ServerIOThreadCount, ini, config,\n                 \"Server.IOThreadCount\", 1);\n    Config::Bind(ServerLegacyBehavior, ini, config, \"Server.LegacyBehavior\",\n                 ServerLegacyBehavior);\n    Config::Bind(ServerHugeThreadCount, ini, config,\n                 \"Server.HugeThreadCount\", 0);\n    Config::Bind(ServerHugeStackKb, ini, config, \"Server.HugeStackSizeKb\", 384);\n    Config::Bind(ServerLoopSampleRate, ini, config,\n                 \"Server.LoopSampleRate\", 0);\n    Config::Bind(ServerWarmupThrottleRequestCount, ini, config,\n                 \"Server.WarmupThrottleRequestCount\",\n                 ServerWarmupThrottleRequestCount);\n    Config::Bind(ServerWarmupThrottleThreadCount, ini, config,\n                 \"Server.WarmupThrottleThreadCount\",\n                 Process::GetCPUCount());\n    Config::Bind(ServerThreadDropCacheTimeoutSeconds, ini, config,\n                 \"Server.ThreadDropCacheTimeoutSeconds\", 0);\n    if (Config::GetBool(ini, config, \"Server.ThreadJobLIFO\")) {\n      ServerThreadJobLIFOSwitchThreshold = 0;\n    }\n    Config::Bind(ServerThreadJobLIFOSwitchThreshold, ini, config,\n                 \"Server.ThreadJobLIFOSwitchThreshold\",\n                 ServerThreadJobLIFOSwitchThreshold);\n    Config::Bind(ServerThreadJobMaxQueuingMilliSeconds, ini, config,\n                 \"Server.ThreadJobMaxQueuingMilliSeconds\", -1);\n    Config::Bind(ServerThreadDropStack, ini, config, \"Server.ThreadDropStack\");\n    Config::Bind(ServerHttpSafeMode, ini, config, \"Server.HttpSafeMode\");\n    Config::Bind(ServerStatCache, ini, config, \"Server.StatCache\", false);\n    Config::Bind(ServerFixPathInfo, ini, config, \"Server.FixPathInfo\", false);\n    Config::Bind(ServerAddVaryEncoding, ini, config, \"Server.AddVaryEncoding\",\n                 ServerAddVaryEncoding);\n    Config::Bind(ServerLogSettingsOnStartup, ini, config,\n                 \"Server.LogSettingsOnStartup\", false);\n    Config::Bind(ServerLogReorderProps, ini, config,\n                 \"Server.LogReorderProps\", false);\n    Config::Bind(ServerWarmupConcurrently, ini, config,\n                 \"Server.WarmupConcurrently\", false);\n    Config::Bind(ServerDedupeWarmupRequests, ini, config,\n                 \"Server.DedupeWarmupRequests\", false);\n    Config::Bind(ServerWarmupThreadCount, ini, config,\n                 \"Server.WarmupThreadCount\", ServerWarmupThreadCount);\n    Config::Bind(ServerExtendedWarmupThreadCount, ini, config,\n                 \"Server.ExtendedWarmup.ThreadCount\",\n                 ServerExtendedWarmupThreadCount);\n    Config::Bind(ServerExtendedWarmupDelaySeconds, ini, config,\n                 \"Server.ExtendedWarmup.DelaySeconds\",\n                 ServerExtendedWarmupDelaySeconds);\n    Config::Bind(ServerExtendedWarmupRepeat, ini, config,\n                 \"Server.ExtendedWarmup.Repeat\", ServerExtendedWarmupRepeat);\n    Config::Bind(ServerWarmupRequests, ini, config, \"Server.WarmupRequests\");\n    Config::Bind(ServerExtendedWarmupRequests, ini, config,\n                 \"Server.ExtendedWarmup.Requests\");\n    Config::Bind(ServerCleanupRequest, ini, config, \"Server.CleanupRequest\");\n    Config::Bind(ServerInternalWarmupThreads, ini, config,\n                 \"Server.InternalWarmupThreads\", 0);  // 0 = skip\n    Config::Bind(ServerHighPriorityEndPoints, ini, config,\n                 \"Server.HighPriorityEndPoints\");\n    Config::Bind(ServerExitOnBindFail, ini, config, \"Server.ExitOnBindFail\",\n                 false);\n\n    Config::Bind(RequestTimeoutSeconds, ini, config,\n                 \"Server.RequestTimeoutSeconds\", 0);\n    Config::Bind(MaxRequestAgeFactor, ini, config, \"Server.MaxRequestAgeFactor\",\n                 0);\n    Config::Bind(PspTimeoutSeconds, ini, config, \"Server.PspTimeoutSeconds\", 0);\n    Config::Bind(PspCpuTimeoutSeconds, ini, config,\n                 \"Server.PspCpuTimeoutSeconds\", 0);\n    Config::Bind(RequestMemoryMaxBytes, ini, config,\n                 \"Server.RequestMemoryMaxBytes\", (16LL << 30)); // 16GiB\n    RequestInfo::setOOMKillThreshold(\n      Config::GetUInt64(ini, config, \"Server.RequestMemoryOOMKillBytes\",\n                        128ULL << 20));\n    Config::Bind(RequestHugeMaxBytes, ini, config,\n                 \"Server.RequestHugeMaxBytes\", (24LL << 20));\n    Config::Bind(ServerGracefulShutdownWait, ini,\n                 config, \"Server.GracefulShutdownWait\", 0);\n    Config::Bind(ServerHarshShutdown, ini, config, \"Server.HarshShutdown\",\n                 true);\n    Config::Bind(ServerKillOnTimeout, ini, config, \"Server.KillOnTimeout\",\n                 true);\n    Config::Bind(ServerEvilShutdown, ini, config, \"Server.EvilShutdown\", true);\n    Config::Bind(ServerPreShutdownWait, ini, config,\n                 \"Server.PreShutdownWait\", 0);\n    Config::Bind(ServerShutdownListenWait, ini, config,\n                 \"Server.ShutdownListenWait\", 0);\n    Config::Bind(ServerShutdownEOMWait, ini, config,\n                 \"Server.ShutdownEOMWait\", 0);\n    Config::Bind(ServerPrepareToStopTimeout, ini, config,\n                 \"Server.PrepareToStopTimeout\", 240);\n    Config::Bind(ServerPartialPostStatusCode, ini, config,\n                 \"Server.PartialPostStatusCode\", -1);\n    Config::Bind(StopOldServer, ini, config, \"Server.StopOld\", false);\n    Config::Bind(OldServerWait, ini, config, \"Server.StopOldWait\", 30);\n    Config::Bind(ServerRSSNeededMb, ini, config, \"Server.RSSNeededMb\", 4096);\n    Config::Bind(ServerCriticalFreeMb, ini, config,\n                 \"Server.CriticalFreeMb\", 512);\n    Config::Bind(CacheFreeFactor, ini, config, \"Server.CacheFreeFactor\", 50);\n    if (CacheFreeFactor > 100) CacheFreeFactor = 100;\n    if (CacheFreeFactor < 0) CacheFreeFactor = 0;\n\n    Config::Bind(ServerNextProtocols, ini, config, \"Server.SSLNextProtocols\");\n    Config::Bind(ServerEnableH2C, ini, config, \"Server.EnableH2C\");\n    extern bool g_brotliUseLocalArena;\n    Config::Bind(g_brotliUseLocalArena, ini, config,\n                 \"Server.BrotliUseLocalArena\", g_brotliUseLocalArena);\n    Config::Bind(BrotliCompressionEnabled, ini, config,\n                 \"Server.BrotliCompressionEnabled\", -1);\n    Config::Bind(BrotliChunkedCompressionEnabled, ini, config,\n                 \"Server.BrotliChunkedCompressionEnabled\", -1);\n    Config::Bind(BrotliCompressionLgWindowSize, ini, config,\n                 \"Server.BrotliCompressionLgWindowSize\", 20);\n    Config::Bind(BrotliCompressionMode, ini, config,\n                 \"Server.BrotliCompressionMode\", 0);\n    Config::Bind(BrotliCompressionQuality, ini, config,\n                 \"Server.BrotliCompressionQuality\", 6);\n    Config::Bind(ZstdCompressionEnabled, ini, config,\n                 \"Server.ZstdCompressionEnabled\", -1);\n    Config::Bind(ZstdCompressor::s_useLocalArena, ini, config,\n                 \"Server.ZstdUseLocalArena\", ZstdCompressor::s_useLocalArena);\n    Config::Bind(ZstdCompressionLevel, ini, config,\n                 \"Server.ZstdCompressionLevel\", 3);\n    Config::Bind(ZstdChecksumRate, ini, config,\n                \"Server.ZstdChecksumRate\", 0);\n    Config::Bind(GzipCompressionLevel, ini, config,\n                 \"Server.GzipCompressionLevel\", 3);\n    Config::Bind(GzipMaxCompressionLevel, ini, config,\n                 \"Server.GzipMaxCompressionLevel\", 9);\n    Config::Bind(GzipCompressor::s_useLocalArena, ini, config,\n                 \"Server.GzipUseLocalArena\", GzipCompressor::s_useLocalArena);\n    Config::Bind(EnableKeepAlive, ini, config, \"Server.EnableKeepAlive\", true);\n    Config::Bind(ExposeHPHP, ini, config, \"Server.ExposeHPHP\", true);\n    Config::Bind(ExposeXFBServer, ini, config, \"Server.ExposeXFBServer\", false);\n    Config::Bind(ExposeXFBDebug, ini, config, \"Server.ExposeXFBDebug\", false);\n    Config::Bind(XFBDebugSSLKey, ini, config, \"Server.XFBDebugSSLKey\", \"\");\n    Config::Bind(ConnectionTimeoutSeconds, ini, config,\n                 \"Server.ConnectionTimeoutSeconds\", -1);\n    Config::Bind(EnableOutputBuffering, ini, config,\n                 \"Server.EnableOutputBuffering\");\n    Config::Bind(OutputHandler, ini, config, \"Server.OutputHandler\");\n    Config::Bind(ImplicitFlush, ini, config, \"Server.ImplicitFlush\");\n    Config::Bind(EnableEarlyFlush, ini, config, \"Server.EnableEarlyFlush\",\n                 true);\n    Config::Bind(ForceChunkedEncoding, ini, config,\n                 \"Server.ForceChunkedEncoding\");\n    Config::Bind(MaxPostSize, ini, config, \"Server.MaxPostSize\", 100);\n    MaxPostSize <<= 20;\n    Config::Bind(AlwaysPopulateRawPostData, ini, config,\n                 \"Server.AlwaysPopulateRawPostData\", false);\n    Config::Bind(TakeoverFilename, ini, config, \"Server.TakeoverFilename\");\n    Config::Bind(ExpiresActive, ini, config, \"Server.ExpiresActive\", true);\n    Config::Bind(ExpiresDefault, ini, config, \"Server.ExpiresDefault\", 2592000);\n    if (ExpiresDefault < 0) ExpiresDefault = 2592000;\n    Config::Bind(DefaultCharsetName, ini, config, \"Server.DefaultCharsetName\",\n                 \"\");\n    Config::Bind(RequestBodyReadLimit, ini, config,\n                 \"Server.RequestBodyReadLimit\", -1);\n    Config::Bind(EnableSSL, ini, config, \"Server.EnableSSL\");\n    Config::Bind(SSLPort, ini, config, \"Server.SSLPort\", 443);\n    Config::Bind(SSLCertificateFile, ini, config, \"Server.SSLCertificateFile\");\n    Config::Bind(SSLCertificateKeyFile, ini, config,\n                 \"Server.SSLCertificateKeyFile\");\n    Config::Bind(SSLCertificateDir, ini, config, \"Server.SSLCertificateDir\");\n    Config::Bind(SSLTicketSeedFile, ini, config, \"Server.SSLTicketSeedFile\");\n    Config::Bind(TLSDisableTLS1_2, ini, config, \"Server.TLSDisableTLS1_2\",\n                 false);\n    Config::Bind(TLSClientCipherSpec, ini, config,\n                 \"Server.TLSClientCipherSpec\");\n    Config::Bind(EnableSSLWithPlainText, ini, config,\n                 \"Server.EnableSSLWithPlainText\");\n    Config::Bind(SSLClientAuthLevel, ini, config,\n                 \"Server.SSLClientAuthLevel\", 0);\n    if (SSLClientAuthLevel < 0) SSLClientAuthLevel = 0;\n    if (SSLClientAuthLevel > 2) SSLClientAuthLevel = 2;\n    Config::Bind(SSLClientCAFile, ini, config, \"Server.SSLClientCAFile\", \"\");\n    if (!SSLClientAuthLevel) {\n      SSLClientCAFile = \"\";\n    } else if (SSLClientCAFile.empty()) {\n      throw std::runtime_error(\n          \"SSLClientCAFile is required to enable client auth\");\n    }\n\n    Config::Bind(ClientAuthAclIdentity, ini, config,\n                 \"Server.ClientAuthAclIdentity\", \"\");\n    Config::Bind(ClientAuthAclAction, ini, config,\n                 \"Server.ClientAuthAclAction\", \"\");\n    Config::Bind(ClientAuthFailClose, ini, config,\n                 \"Server.ClientAuthFailClose\", false);\n\n    Config::Bind(ClientAuthLogSampleBase, ini, config,\n                 \"Server.ClientAuthLogSampleBase\", 100);\n    if (ClientAuthLogSampleBase < 1) {\n      ClientAuthLogSampleBase = 1;\n    }\n\n    Config::Bind(SSLClientAuthLoggingSampleRatio, ini, config,\n                 \"Server.SSLClientAuthLoggingSampleRatio\", 0);\n    if (SSLClientAuthLoggingSampleRatio < 0) {\n      SSLClientAuthLoggingSampleRatio = 0;\n    }\n    if (SSLClientAuthLoggingSampleRatio > ClientAuthLogSampleBase) {\n      SSLClientAuthLoggingSampleRatio = ClientAuthLogSampleBase;\n    }\n\n    Config::Bind(ClientAuthSuccessLogSampleRatio, ini, config,\n                 \"Server.ClientAuthSuccessLogSampleRatio\", 0);\n    if (ClientAuthSuccessLogSampleRatio <\n          SSLClientAuthLoggingSampleRatio) {\n      ClientAuthSuccessLogSampleRatio = SSLClientAuthLoggingSampleRatio;\n    }\n    if (ClientAuthSuccessLogSampleRatio > ClientAuthLogSampleBase) {\n      ClientAuthSuccessLogSampleRatio = ClientAuthLogSampleBase;\n    }\n\n    Config::Bind(ClientAuthFailureLogSampleRatio, ini, config,\n                 \"Server.ClientAuthFailureLogSampleRatio\", 0);\n    if (ClientAuthFailureLogSampleRatio <\n          SSLClientAuthLoggingSampleRatio) {\n      ClientAuthFailureLogSampleRatio = SSLClientAuthLoggingSampleRatio;\n    }\n    if (ClientAuthFailureLogSampleRatio > ClientAuthLogSampleBase) {\n      ClientAuthFailureLogSampleRatio = ClientAuthLogSampleBase;\n    }\n\n    // SourceRoot has been default to: Process::GetCurrentDirectory() + '/'\n    auto defSourceRoot = SourceRoot;\n    Config::Bind(SourceRoot, ini, config, \"Server.SourceRoot\", SourceRoot);\n    SourceRoot = FileUtil::normalizeDir(SourceRoot);\n    if (SourceRoot.empty()) {\n      SourceRoot = defSourceRoot;\n    }\n    FileCache::SourceRoot = SourceRoot;\n\n    Config::Bind(IncludeSearchPaths, ini, config, \"Server.IncludeSearchPaths\");\n    for (unsigned int i = 0; i < IncludeSearchPaths.size(); i++) {\n      IncludeSearchPaths[i] = FileUtil::normalizeDir(IncludeSearchPaths[i]);\n    }\n    IncludeSearchPaths.insert(IncludeSearchPaths.begin(), \".\");\n\n    Config::Bind(AutoloadEnabled, ini, config, \"Autoload.Enabled\", false);\n    Config::Bind(AutoloadDBPath, ini, config, \"Autoload.DBPath\");\n\n    Config::Bind(FileCache, ini, config, \"Server.FileCache\");\n    Config::Bind(DefaultDocument, ini, config, \"Server.DefaultDocument\",\n                 \"index.php\");\n    Config::Bind(GlobalDocument, ini, config, \"Server.GlobalDocument\");\n    Config::Bind(ErrorDocument404, ini, config, \"Server.ErrorDocument404\");\n    normalizePath(ErrorDocument404);\n    Config::Bind(ForbiddenAs404, ini, config, \"Server.ForbiddenAs404\");\n    Config::Bind(ErrorDocument500, ini, config, \"Server.ErrorDocument500\");\n    normalizePath(ErrorDocument500);\n    Config::Bind(FatalErrorMessage, ini, config, \"Server.FatalErrorMessage\");\n    FontPath = FileUtil::normalizeDir(\n      Config::GetString(ini, config, \"Server.FontPath\"));\n    Config::Bind(EnableStaticContentFromDisk, ini, config,\n                 \"Server.EnableStaticContentFromDisk\", true);\n    Config::Bind(EnableOnDemandUncompress, ini, config,\n                 \"Server.EnableOnDemandUncompress\", true);\n    Config::Bind(EnableStaticContentMMap, ini, config,\n                 \"Server.EnableStaticContentMMap\", true);\n    if (EnableStaticContentMMap) {\n      EnableOnDemandUncompress = true;\n    }\n    Config::Bind(Utf8izeReplace, ini, config, \"Server.Utf8izeReplace\", true);\n\n    Config::Bind(RequestInitFunction, ini, config,\n                 \"Server.RequestInitFunction\");\n    Config::Bind(RequestInitDocument, ini, config,\n                 \"Server.RequestInitDocument\");\n    Config::Bind(SafeFileAccess, ini, config, \"Server.SafeFileAccess\");\n    Config::Bind(AllowedDirectories, ini, config, \"Server.AllowedDirectories\");\n    Config::Bind(WhitelistExec, ini, config, \"Server.WhitelistExec\");\n    Config::Bind(WhitelistExecWarningOnly, ini, config,\n                 \"Server.WhitelistExecWarningOnly\");\n    Config::Bind(AllowedExecCmds, ini, config, \"Server.AllowedExecCmds\");\n    Config::Bind(UnserializationWhitelistCheck, ini, config,\n                 \"Server.UnserializationWhitelistCheck\", false);\n    Config::Bind(UnserializationWhitelistCheckWarningOnly, ini, config,\n                 \"Server.UnserializationWhitelistCheckWarningOnly\", true);\n    Config::Bind(UnserializationBigMapThreshold, ini, config,\n                 \"Server.UnserializationBigMapThreshold\", 1 << 16);\n    Config::Bind(AllowedFiles, ini, config, \"Server.AllowedFiles\");\n    Config::Bind(ForbiddenFileExtensions, ini, config,\n                 \"Server.ForbiddenFileExtensions\");\n    Config::Bind(LockCodeMemory, ini, config, \"Server.LockCodeMemory\", false);\n    Config::Bind(MaxArrayChain, ini, config, \"Server.MaxArrayChain\", INT_MAX);\n    if (MaxArrayChain != INT_MAX) {\n      // MixedArray needs a higher threshold to avoid false-positives.\n      // (and we always use MixedArray)\n      MaxArrayChain *= 2;\n    }\n\n    Config::Bind(WarnOnCollectionToArray, ini, config,\n                 \"Server.WarnOnCollectionToArray\", false);\n    Config::Bind(UseDirectCopy, ini, config, \"Server.UseDirectCopy\", false);\n    Config::Bind(AlwaysUseRelativePath, ini, config,\n                 \"Server.AlwaysUseRelativePath\", false);\n    {\n      // Server Upload\n      Config::Bind(UploadMaxFileSize, ini, config,\n                   \"Server.Upload.UploadMaxFileSize\", 100);\n      UploadMaxFileSize <<= 20;\n      Config::Bind(UploadTmpDir, ini, config, \"Server.Upload.UploadTmpDir\",\n                   \"/tmp\");\n      Config::Bind(EnableFileUploads, ini, config,\n                   \"Server.Upload.EnableFileUploads\", true);\n      Config::Bind(MaxFileUploads, ini, config, \"Server.Upload.MaxFileUploads\",\n                   20);\n      Config::Bind(EnableUploadProgress, ini, config,\n                   \"Server.Upload.EnableUploadProgress\");\n      Config::Bind(Rfc1867Freq, ini, config, \"Server.Upload.Rfc1867Freq\",\n                   256 * 1024);\n      if (Rfc1867Freq < 0) Rfc1867Freq = 256 * 1024;\n      Config::Bind(Rfc1867Prefix, ini, config, \"Server.Upload.Rfc1867Prefix\",\n                   \"vupload_\");\n      Config::Bind(Rfc1867Name, ini, config, \"Server.Upload.Rfc1867Name\",\n                   \"video_ptoken\");\n    }\n    Config::Bind(ImageMemoryMaxBytes, ini, config,\n                 \"Server.ImageMemoryMaxBytes\", 0);\n    if (ImageMemoryMaxBytes == 0) {\n      ImageMemoryMaxBytes = UploadMaxFileSize * 2;\n    }\n    Config::Bind(LightProcessFilePrefix, ini, config,\n                 \"Server.LightProcessFilePrefix\", \"./lightprocess\");\n    Config::Bind(LightProcessCount, ini, config,\n                 \"Server.LightProcessCount\", 0);\n    Config::Bind(ForceServerNameToHeader, ini, config,\n                 \"Server.ForceServerNameToHeader\");\n    Config::Bind(AllowDuplicateCookies, ini, config,\n                 \"Server.AllowDuplicateCookies\", false);\n    Config::Bind(PathDebug, ini, config, \"Server.PathDebug\", false);\n    Config::Bind(ServerUser, ini, config, \"Server.User\", \"\");\n    Config::Bind(AllowRunAsRoot, ini, config, \"Server.AllowRunAsRoot\", false);\n  }\n\n  VirtualHost::SortAllowedDirectories(AllowedDirectories);\n  {\n    auto vh_callback = [] (const IniSettingMap &ini_vh, const Hdf &hdf_vh,\n                           const std::string &ini_vh_key) {\n      if (VirtualHost::IsDefault(ini_vh, hdf_vh, ini_vh_key)) {\n        VirtualHost::GetDefault().init(ini_vh, hdf_vh, ini_vh_key);\n        VirtualHost::GetDefault().addAllowedDirectories(AllowedDirectories);\n      } else {\n        auto host = std::make_shared<VirtualHost>(ini_vh, hdf_vh, ini_vh_key);\n        host->addAllowedDirectories(AllowedDirectories);\n        VirtualHosts.push_back(host);\n      }\n    };\n    // Virtual Hosts have to be iterated in order. Because only the first\n    // one that matches in the VirtualHosts vector gets applied and used.\n    // Hdf's and ini (via Variant arrays) internal storage handles ordering\n    // naturally (as specified top to bottom in the file and left to right on\n    // the command line.\n    Config::Iterate(vh_callback, ini, config, \"VirtualHost\");\n    LowestMaxPostSize = VirtualHost::GetLowestMaxPostSize();\n  }\n  {\n    // IpBlocks\n    IpBlocks = std::make_shared<IpBlockMap>(ini, config);\n  }\n  {\n    ReadSatelliteInfo(ini, config, SatelliteServerInfos,\n                      XboxPassword, XboxPasswords);\n  }\n  {\n    // Xbox\n    Config::Bind(XboxServerThreadCount, ini, config,\n                 \"Xbox.ServerInfo.ThreadCount\", 10);\n    Config::Bind(XboxServerMaxQueueLength, ini, config,\n                 \"Xbox.ServerInfo.MaxQueueLength\", INT_MAX);\n    if (XboxServerMaxQueueLength < 0) XboxServerMaxQueueLength = INT_MAX;\n    Config::Bind(XboxServerInfoMaxRequest, ini, config,\n                 \"Xbox.ServerInfo.MaxRequest\", 500);\n    Config::Bind(XboxServerInfoDuration, ini, config,\n                 \"Xbox.ServerInfo.MaxDuration\", 120);\n    Config::Bind(XboxServerInfoReqInitFunc, ini, config,\n                 \"Xbox.ServerInfo.RequestInitFunction\", \"\");\n    Config::Bind(XboxServerInfoReqInitDoc, ini, config,\n                 \"Xbox.ServerInfo.RequestInitDocument\", \"\");\n    Config::Bind(XboxServerInfoAlwaysReset, ini, config,\n                 \"Xbox.ServerInfo.AlwaysReset\", false);\n    Config::Bind(XboxServerLogInfo, ini, config, \"Xbox.ServerInfo.LogInfo\",\n                 false);\n    Config::Bind(XboxProcessMessageFunc, ini, config, \"Xbox.ProcessMessageFunc\",\n                 \"xbox_process_message\");\n  }\n  {\n    // Pagelet Server\n    Config::Bind(PageletServerThreadCount, ini, config,\n                 \"PageletServer.ThreadCount\", 0);\n    Config::Bind(PageletServerHugeThreadCount, ini, config,\n                 \"PageletServer.HugeThreadCount\", 0);\n    Config::Bind(PageletServerThreadDropStack, ini, config,\n                 \"PageletServer.ThreadDropStack\");\n    Config::Bind(PageletServerThreadDropCacheTimeoutSeconds, ini, config,\n                 \"PageletServer.ThreadDropCacheTimeoutSeconds\", 0);\n    Config::Bind(PageletServerQueueLimit, ini, config,\n                 \"PageletServer.QueueLimit\", 0);\n  }\n  {\n    // Static File\n\n    hphp_string_imap<std::string> staticFileDefault;\n    staticFileDefault[\"css\"] = \"text/css\";\n    staticFileDefault[\"gif\"] = \"image/gif\";\n    staticFileDefault[\"html\"] = \"text/html\";\n    staticFileDefault[\"jpeg\"] = \"image/jpeg\";\n    staticFileDefault[\"jpg\"] = \"image/jpeg\";\n    staticFileDefault[\"mp3\"] = \"audio/mpeg\";\n    staticFileDefault[\"png\"] = \"image/png\";\n    staticFileDefault[\"tif\"] = \"image/tiff\";\n    staticFileDefault[\"tiff\"] = \"image/tiff\";\n    staticFileDefault[\"txt\"] = \"text/plain\";\n    staticFileDefault[\"zip\"] = \"application/zip\";\n\n    Config::Bind(StaticFileExtensions, ini, config, \"StaticFile.Extensions\",\n                 staticFileDefault);\n\n    auto matches_callback = [](const IniSettingMap& ini_m, const Hdf& hdf_m,\n                               const std::string& /*ini_m_key*/) {\n      FilesMatches.push_back(std::make_shared<FilesMatch>(ini_m, hdf_m));\n    };\n    Config::Iterate(matches_callback, ini, config, \"StaticFile.FilesMatch\");\n  }\n  {\n    // PhpFile\n    Config::Bind(PhpFileExtensions, ini, config, \"PhpFile.Extensions\");\n  }\n  {\n    // Admin Server\n    Config::Bind(AdminServerIP, ini, config, \"AdminServer.IP\", ServerIP);\n    Config::Bind(AdminServerPort, ini, config, \"AdminServer.Port\", 0);\n    Config::Bind(AdminThreadCount, ini, config, \"AdminServer.ThreadCount\", 1);\n    Config::Bind(AdminServerEnableSSLWithPlainText, ini, config,\n                 \"AdminServer.EnableSSLWithPlainText\", false);\n    Config::Bind(AdminServerStatsNeedPassword, ini, config,\n                 \"AdminServer.StatsNeedPassword\", AdminServerStatsNeedPassword);\n    AdminPassword = Config::GetString(ini, config, \"AdminServer.Password\");\n    AdminPasswords = Config::GetSet(ini, config, \"AdminServer.Passwords\");\n    HashedAdminPasswords =\n      Config::GetSet(ini, config, \"AdminServer.HashedPasswords\");\n  }\n  {\n    // Proxy\n    Config::Bind(ProxyOriginRaw, ini, config, \"Proxy.Origin\");\n    Config::Bind(ProxyPercentageRaw, ini, config, \"Proxy.Percentage\", 0);\n    Config::Bind(ProxyRetry, ini, config, \"Proxy.Retry\", 3);\n    Config::Bind(UseServeURLs, ini, config, \"Proxy.ServeURLs\");\n    Config::Bind(ServeURLs, ini, config, \"Proxy.ServeURLs\");\n    Config::Bind(UseProxyURLs, ini, config, \"Proxy.ProxyURLs\");\n    Config::Bind(ProxyURLs, ini, config, \"Proxy.ProxyURLs\");\n    Config::Bind(ProxyPatterns, ini, config, \"Proxy.ProxyPatterns\");\n  }\n  {\n    // Http\n    Config::Bind(HttpDefaultTimeout, ini, config, \"Http.DefaultTimeout\", 30);\n    Config::Bind(HttpSlowQueryThreshold, ini, config, \"Http.SlowQueryThreshold\",\n                 5000);\n  }\n  {\n    // Debug\n\n    Config::Bind(NativeStackTrace, ini, config, \"Debug.NativeStackTrace\");\n    StackTrace::Enabled = NativeStackTrace;\n    Config::Bind(ServerErrorMessage, ini, config, \"Debug.ServerErrorMessage\");\n    Config::Bind(RecordInput, ini, config, \"Debug.RecordInput\");\n    Config::Bind(ClearInputOnSuccess, ini, config, \"Debug.ClearInputOnSuccess\",\n                 true);\n    Config::Bind(ProfilerOutputDir, ini, config, \"Debug.ProfilerOutputDir\",\n                 \"/tmp\");\n    Config::Bind(CoreDumpEmail, ini, config, \"Debug.CoreDumpEmail\");\n    Config::Bind(CoreDumpReport, ini, config, \"Debug.CoreDumpReport\", true);\n    if (CoreDumpReport) {\n      install_crash_reporter();\n    }\n    // Binding default dependenant on whether we are using an OSS build or\n    // not, and that is set at initialization time of CoreDumpReportDirectory.\n    Config::Bind(CoreDumpReportDirectory, ini, config,\n                 \"Debug.CoreDumpReportDirectory\", CoreDumpReportDirectory);\n    std::ostringstream stack_trace_stream;\n    stack_trace_stream << CoreDumpReportDirectory << \"/stacktrace.\"\n                       << (int64_t)getpid() << \".log\";\n    StackTraceFilename = stack_trace_stream.str();\n\n    Config::Bind(StackTraceTimeout, ini, config, \"Debug.StackTraceTimeout\", 0);\n    Config::Bind(RemoteTraceOutputDir, ini, config,\n                 \"Debug.RemoteTraceOutputDir\", \"/tmp\");\n    Config::Bind(TraceFunctions, ini, config,\n                 \"Debug.TraceFunctions\", TraceFunctions);\n  }\n  {\n    // Stats\n    Config::Bind(EnableStats, ini, config, \"Stats.Enable\",\n                 false); // main switch\n    Config::Bind(EnableAPCStats, ini, config, \"Stats.APC\", false);\n    Config::Bind(EnableWebStats, ini, config, \"Stats.Web\");\n    Config::Bind(EnableMemoryStats, ini, config, \"Stats.Memory\");\n    Config::Bind(EnableSQLStats, ini, config, \"Stats.SQL\");\n    Config::Bind(EnableSQLTableStats, ini, config, \"Stats.SQLTable\");\n    Config::Bind(EnableNetworkIOStatus, ini, config, \"Stats.NetworkIO\");\n    Config::Bind(StatsXSL, ini, config, \"Stats.XSL\");\n    Config::Bind(StatsXSLProxy, ini, config, \"Stats.XSLProxy\");\n    Config::Bind(StatsSlotDuration, ini, config, \"Stats.SlotDuration\", 10 * 60);\n    Config::Bind(StatsMaxSlot, ini, config, \"Stats.MaxSlot\",\n                 12 * 6); // 12 hours\n    StatsSlotDuration = std::max(1u, StatsSlotDuration);\n    StatsMaxSlot = std::max(2u, StatsMaxSlot);\n    Config::Bind(EnableHotProfiler, ini, config, \"Stats.EnableHotProfiler\",\n                 true);\n    Config::Bind(ProfilerTraceBuffer, ini, config, \"Stats.ProfilerTraceBuffer\",\n                 2000000);\n    Config::Bind(ProfilerTraceExpansion, ini, config,\n                 \"Stats.ProfilerTraceExpansion\", 1.2);\n    Config::Bind(ProfilerMaxTraceBuffer, ini, config,\n                 \"Stats.ProfilerMaxTraceBuffer\", 0);\n    Config::Bind(TrackPerUnitMemory, ini, config,\n                 \"Stats.TrackPerUnitMemory\", false);\n  }\n  {\n    Config::Bind(ServerVariables, ini, config, \"ServerVariables\");\n    Config::Bind(EnvVariables, ini, config, \"EnvVariables\");\n  }\n  {\n    // Sandbox\n    Config::Bind(SandboxMode, ini, config, \"Sandbox.SandboxMode\");\n    Config::Bind(SandboxPattern, ini, config, \"Sandbox.Pattern\");\n    SandboxPattern = format_pattern(SandboxPattern, true);\n    Config::Bind(SandboxHome, ini, config, \"Sandbox.Home\");\n    Config::Bind(SandboxFallback, ini, config, \"Sandbox.Fallback\");\n    Config::Bind(SandboxConfFile, ini, config, \"Sandbox.ConfFile\");\n    Config::Bind(SandboxFromCommonRoot, ini, config, \"Sandbox.FromCommonRoot\");\n    Config::Bind(SandboxDirectoriesRoot, ini, config,\n                 \"Sandbox.DirectoriesRoot\");\n    Config::Bind(SandboxLogsRoot, ini, config, \"Sandbox.LogsRoot\");\n    Config::Bind(SandboxServerVariables, ini, config,\n                 \"Sandbox.ServerVariables\");\n    Config::Bind(SandboxDefaultUserFile, ini, config,\n                 \"Sandbox.DefaultUserFile\");\n    Config::Bind(SandboxHostAlias, ini, config, \"Sandbox.HostAlias\");\n  }\n  {\n    // Mail\n    Config::Bind(SendmailPath, ini, config, \"Mail.SendmailPath\",\n                 \"/usr/lib/sendmail -t -i\");\n    Config::Bind(MailForceExtraParameters, ini, config,\n                 \"Mail.ForceExtraParameters\");\n  }\n  {\n    // Preg\n    Config::Bind(PregBacktraceLimit, ini, config, \"Preg.BacktraceLimit\",\n                 1000000);\n    Config::Bind(PregRecursionLimit, ini, config, \"Preg.RecursionLimit\",\n                 100000);\n    Config::Bind(EnablePregErrorLog, ini, config, \"Preg.ErrorLog\", true);\n  }\n  {\n    // SimpleXML\n    Config::Bind(SimpleXMLEmptyNamespaceMatchesAll, ini, config,\n                 \"SimpleXML.EmptyNamespaceMatchesAll\", false);\n  }\n#ifdef FACEBOOK\n  {\n    // Fb303Server\n    Config::Bind(EnableFb303Server, ini, config, \"Fb303Server.Enable\",\n                 EnableFb303Server);\n    Config::Bind(Fb303ServerPort, ini, config, \"Fb303Server.Port\", 0);\n    Config::Bind(Fb303ServerIP, ini, config, \"Fb303Server.IP\");\n    Config::Bind(Fb303ServerThreadStackSizeMb, ini, config,\n                 \"Fb303Server.ThreadStackSizeMb\", 8);\n    Config::Bind(Fb303ServerWorkerThreads, ini, config,\n                 \"Fb303Server.WorkerThreads\", 1);\n    Config::Bind(Fb303ServerPoolThreads, ini, config, \"Fb303Server.PoolThreads\",\n                 1);\n  }\n#endif\n\n  {\n    // Xenon\n    Config::Bind(XenonPeriodSeconds, ini, config, \"Xenon.Period\", 0.0);\n    Config::Bind(XenonRequestFreq, ini, config, \"Xenon.RequestFreq\", 1);\n    Config::Bind(XenonForceAlwaysOn, ini, config, \"Xenon.ForceAlwaysOn\", false);\n  }\n  {\n    // Strobelight\n    Config::Bind(StrobelightEnabled, ini, config, \"Strobelight.Enabled\", false);\n  }\n  {\n    // Profiling\n    Config::Bind(SetProfileNullThisObject, ini, config,\n                 \"SetProfile.NullThisObject\", true);\n  }\n  {\n    // We directly read zend.assertions here, so that we can get its INI value\n    // in order to know how we should emit bytecode. We don't actually Bind the\n    // option here though, since its runtime value can be changed and is per\n    // request. (We prevent its value from changing at runtime between values\n    // that would affect byecode emission.)\n    Variant v;\n    bool b = IniSetting::GetSystem(\"zend.assertions\", v);\n    if (b) RuntimeOption::AssertEmitted = v.toInt64() >= 0;\n  }\n\n  Config::Bind(TzdataSearchPaths, ini, config, \"TzdataSearchPaths\");\n\n  Config::Bind(CustomSettings, ini, config, \"CustomSettings\");\n\n  // Run initializers depedent on options, e.g., resizing atomic maps/vectors.\n  refineStaticStringTableSize();\n  InitFiniNode::ProcessPostRuntimeOptions();\n\n  // **************************************************************************\n  //                                  DANGER\n  //\n  // Do not bind any PHP_INI_ALL or PHP_INI_USER settings here! These settings\n  // are process-wide, while those need to be thread-local since they are\n  // per-request. They should go into RequestInjectionData. Getting this wrong\n  // will cause subtle breakage -- in particular, it probably will not show up\n  // in CLI mode, since everything there tends to be single theaded.\n  //\n  // Per-dir INI settings are bound here, but that seems really questionable\n  // since they can change per request too. TODO(#7757602) this should be\n  // investigated.\n  // **************************************************************************\n\n  // Enables the hotfixing of a bug that occurred with D1797805 where\n  // per request user settings (like upload_max_filesize) were not able to be\n  // accessed on a server request any longer. The longer term fix is in review\n  // D2099778, but we want that to simmer in Master for a while and we need\n  // a hotfix for our current 3.6 LTS (Github Issue #4993)\n  Config::Bind(EnableZendIniCompat, ini, config, \"Eval.EnableZendIniCompat\",\n               true);\n  // Language and Misc Configuration Options\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_ONLY, \"expose_php\",\n                   &RuntimeOption::ExposeHPHP);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_PERDIR,\n                   \"auto_prepend_file\", &RuntimeOption::AutoPrependFile);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_PERDIR,\n                   \"auto_append_file\", &RuntimeOption::AutoAppendFile);\n\n  // Data Handling\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_PERDIR,\n                   \"post_max_size\",\n                   IniSetting::SetAndGet<int64_t>(\n                     nullptr,\n                     []() {\n                       return VirtualHost::GetMaxPostSize();\n                     }\n                   ),\n                   &RuntimeOption::MaxPostSize);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_PERDIR,\n                   \"always_populate_raw_post_data\",\n                   &RuntimeOption::AlwaysPopulateRawPostData);\n\n  // Paths and Directories\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"doc_root\", &RuntimeOption::SourceRoot);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"sendmail_path\", &RuntimeOption::SendmailPath);\n\n  // FastCGI\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_ONLY,\n                   \"pid\", &RuntimeOption::PidFile);\n\n  // File Uploads\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"file_uploads\", \"true\",\n                   &RuntimeOption::EnableFileUploads);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"upload_tmp_dir\", &RuntimeOption::UploadTmpDir);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_PERDIR,\n                   \"upload_max_filesize\",\n                   IniSetting::SetAndGet<std::string>(\n                     [](const std::string& value) {\n                       return ini_on_update(\n                         value, RuntimeOption::UploadMaxFileSize);\n                     },\n                     []() {\n                       return convert_long_to_bytes(\n                         VirtualHost::GetUploadMaxFileSize());\n                     }\n                   ));\n  // Filesystem and Streams Configuration Options\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"allow_url_fopen\",\n                   IniSetting::SetAndGet<std::string>(\n                     [](const std::string& /*value*/) { return false; },\n                     []() { return \"1\"; }));\n\n  // HPHP specific\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_NONE,\n                   \"hphp.compiler_id\",\n                   IniSetting::SetAndGet<std::string>(\n                     [](const std::string& /*value*/) { return false; },\n                     []() { return compilerId().begin(); }));\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_NONE,\n                   \"hphp.compiler_version\",\n                   IniSetting::SetAndGet<std::string>(\n                     [](const std::string& /*value*/) { return false; },\n                     []() { return getHphpCompilerVersion(); }));\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_NONE,\n                   \"hphp.cli_server_api_version\",\n                   IniSetting::SetAndGet<uint64_t>(\n                     [](const uint64_t /*value*/) { return false; },\n                     []() { return cli_server_api_version(); }));\n  IniSetting::Bind(\n    IniSetting::CORE, IniSetting::PHP_INI_NONE, \"hphp.build_id\",\n    IniSetting::SetAndGet<std::string>(\n      [](const std::string& /*value*/) { return false; }, nullptr),\n    &RuntimeOption::BuildId);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"notice_frequency\",\n                   &RuntimeOption::NoticeFrequency);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_SYSTEM,\n                   \"warning_frequency\",\n                   &RuntimeOption::WarningFrequency);\n  IniSetting::Bind(IniSetting::CORE, IniSetting::PHP_INI_ONLY,\n                   \"hhvm.build_type\",\n                   IniSetting::SetAndGet<std::string>(\n    [](const std::string&) {\n      return false;\n    },\n    []() {\n      return s_hhvm_build_type.c_str();\n    }\n  ));\n\n  // Extensions\n  Config::Bind(RuntimeOption::ExtensionDir, ini, config, \"extension_dir\",\n               RuntimeOption::ExtensionDir, false);\n  Config::Bind(RuntimeOption::DynamicExtensionPath, ini,\n               config, \"DynamicExtensionPath\",\n               RuntimeOption::DynamicExtensionPath);\n  Config::Bind(RuntimeOption::Extensions, ini, config, \"extensions\");\n  Config::Bind(RuntimeOption::DynamicExtensions, ini,\n               config, \"DynamicExtensions\");\n\n  ExtensionRegistry::moduleLoad(ini, config);\n  initialize_apc();\n\n  if (TraceFunctions.size()) Trace::ensureInit(getTraceOutputFile());\n\n  // arrprov is only for dvarrays. It should be off if HADVAs is on.\n  if (RO::EvalHackArrDVArrs) {\n    RO::EvalArrayProvenance = false;\n    RO::EvalLogArrayProvenance = false;\n  }\n\n  // Bespoke array-likes\n\n  // We don't support provenance for bespoke array-likes, so don't construct\n  // any at runtime if we're logging provenance instrumentation results.\n  if (RO::EvalBespokeArrayLikeMode > 0 &&\n      (RO::EvalArrayProvenance || RO::EvalLogArrayProvenance)) {\n    RO::EvalBespokeArrayLikeMode = 0;\n  }\n\n  // If we're going to construct bespoke array-likes at runtime, ensure that\n  // we JIT checks for these types as well. We support JIT-ing these checks\n  // even if there are no runtime bespokes as way to test our guard logic.\n  if (RO::EvalBespokeArrayLikeMode == 0) {\n    specializeVanillaDestructors();\n    bespoke::setLoggingEnabled(false);\n  } else {\n    bespoke::setLoggingEnabled(true);\n  }\n\n  // Hack Array Compats\n\n  if (!RuntimeOption::EvalEmitClsMethPointers) {\n    RuntimeOption::EvalIsCompatibleClsMethType = false;\n  }\n\n  if (RuntimeOption::EvalArrayProvenance) {\n    RuntimeOption::EvalJitForceVMRegSync = true;\n  }\n\n  // we need to maintain an invariant that PureEnforceCalls >= RxEnforceCalls...\n  // We can't be stricter on rx than on pure, as that would break rx assumptions\n  RuntimeOption::EvalPureEnforceCalls = std::max(\n    RuntimeOption::EvalPureEnforceCalls, RuntimeOption::EvalRxEnforceCalls);\n  RuntimeOption::EvalPureVerifyBody = std::max(\n    RuntimeOption::EvalPureVerifyBody, RuntimeOption::EvalRxVerifyBody);\n\n  // Initialize defaults for repo-specific parser configuration options.\n  RepoOptions::setDefaults(config, ini);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 315,
        "code": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tif (insn_bitness == 32) {\n\t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Upon reaching here, src_known is true and\n\t\t * umax_val is equal to umin_val.\n\t\t */\n\t\tdst_reg->smin_value >>= umin_val;\n\t\tdst_reg->smax_value >>= umin_val;\n\t\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);\n\n\t\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t\t * dst_reg var_off to refine the result.\n\t\t */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 316,
        "code": "\n   rtxErrAddStrParm (pctxt, errtext);\n\n\n\n   return RTERR_NOTSUPP;\n\n}\n\n\n\nstatic int cborElemNameToJson (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt)\n\n{\n\n   char* pElemName = 0;\n\n   OSOCTET ub;\n\n   int ret;\n\n\n\n   /* Read byte from stream */\n\n   ret = rtxReadBytes (pCborCtxt, &ub, 1);\n\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n\n\n   /* Decode element name (note: only string type is currently supported) */\n\n   ret = rtCborDecDynUTF8Str (pCborCtxt, ub, &pElemName);\n\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n\n\n   /* Encode map element name as string */\n\n   ret = rtJsonEncStringValue (pJsonCtxt, (const OSUTF8CHAR*)pElemName);\n\n   rtxMemFreePtr (pCborCtxt, pElemName);\n\n   if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n\n\n   OSRTSAFEPUTCHAR (pJsonCtxt, ':');\n\n\n\n   return 0;\n\n}\n\n\n\nstatic int cbor2json (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt)\n\n{\n\n   int ret = 0;\n\n   OSOCTET tag, ub;\n\n\n\n   /* Read byte from stream */\n\n   ret = rtxReadBytes (pCborCtxt, &ub, 1);\n\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n   tag = ub >> 5;\n\n\n\n   /* Switch on tag value */\n\n   switch (tag) {\n\n   case OSRTCBOR_UINT: {\n\n      OSUINTTYPE value;\n\n      ret = rtCborDecUInt (pCborCtxt, ub, &value);\n\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n\n\n      /* Encode JSON */\n\n#ifndef _NO_INT64_SUPPORT\n\n      ret = rtJsonEncUInt64Value (pJsonCtxt, value);\n\n#else\n\n      ret = rtJsonEncUIntValue (pJsonCtxt, value);\n\n#endif\n\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n      break;\n\n   }\n\n   case OSRTCBOR_NEGINT: {\n\n      OSINTTYPE value;\n\n      ret = rtCborDecInt (pCborCtxt, ub, &value);\n\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n\n\n      /* Encode JSON */\n\n#ifndef _NO_INT64_SUPPORT\n\n      ret = rtJsonEncInt64Value (pJsonCtxt, value);\n\n#else\n\n      ret = rtJsonEncIntValue (pJsonCtxt, value);\n\n#endif\n\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n      break;\n\n   }\n\n   case OSRTCBOR_BYTESTR: {\n\n      OSDynOctStr64 byteStr;\n\n      ret = rtCborDecDynByteStr (pCborCtxt, ub, &byteStr);\n\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n\n\n      /* Encode JSON */\n\n      ret = rtJsonEncHexStr (pJsonCtxt, byteStr.numocts, byteStr.data);\n\n      rtxMemFreePtr (pCborCtxt, byteStr.data);\n\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-24753"
    },
    {
        "index": 317,
        "code": "std::string formatStaticString(StringData* str) {\n  return folly::sformat(\n      \"----\\n{} bytes\\n{}\\n\", str->size(), str->toCppString());\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 318,
        "code": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n {\n \tstruct dwc3\t\t\t*dwc = dep->dwc;\n \n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n \n \tif (req->trb)\n \t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n \n \treq->trb = NULL;\n \ttrace_dwc3_gadget_giveback(req);\n \n \tspin_unlock(&dwc->lock);\n \tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n \tspin_lock(&dwc->lock);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-14763"
    },
    {
        "index": 319,
        "code": "static void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[200];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 320,
        "code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-41689"
    },
    {
        "index": 322,
        "code": "bool Decoder::canSplitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitBb,\n\t\tstd::set<llvm::BasicBlock*>& newFncStarts)\n{\n\tnewFncStarts.insert(splitBb);\n\n\tauto* f = splitBb->getParent();\n\tauto fAddr = getFunctionAddress(f);\n\n\tauto fSzIt = _fnc2sz.find(f);\n\tif (fSzIt != _fnc2sz.end())\n\t{\n\t\tif (fAddr <= addr && addr < (fAddr+fSzIt->second))\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"!CAN S: addr cond @ \" << addr << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstd::set<Address> fncStarts;\n\tfncStarts.insert(fAddr);\n\tfncStarts.insert(addr);\n\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << fAddr << std::endl;\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << addr << std::endl;\n\n\tbool changed = true;\n\twhile (changed)\n\t{\n\t\tchanged = false;\n\t\tfor (BasicBlock& b : *f)\n\t\t{\n//\t\t\tAddress bAddr = getBasicBlockAddress(&b);\n\t\t\tAddress bAddr;\n\t\t\t// TODO: shitty\n\t\t\tBasicBlock* bPrev = &b;\n\t\t\twhile (bAddr.isUndefined() && bPrev)\n\t\t\t{\n\t\t\t\tbAddr = getBasicBlockAddress(bPrev);\n\t\t\t\tbPrev = bPrev->getPrevNode();\n\t\t\t}\n\t\t\tif (bAddr.isUndefined())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto up = fncStarts.upper_bound(bAddr);\n\t\t\t--up;\n\t\t\tAddress bFnc = *up;\n\n\t\t\tfor (auto* p : predecessors(&b))\n\t\t\t{\n//\t\t\t\tAddress pAddr = getBasicBlockAddress(p);\n\t\t\t\tAddress pAddr;\n\t\t\t\t// TODO: shitty\n\t\t\t\tBasicBlock* pPrev = p;\n\t\t\t\twhile (pAddr.isUndefined() && pPrev)\n\t\t\t\t{\n\t\t\t\t\tpAddr = getBasicBlockAddress(pPrev);\n\t\t\t\t\tpPrev = pPrev->getPrevNode();\n\t\t\t\t}\n\t\t\t\tif (pAddr.isUndefined())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto up = fncStarts.upper_bound(pAddr);\n\t\t\t\t--up;\n\t\t\t\tAddress pFnc = *up;\n\n\t\t\t\tif (bFnc != pFnc)\n\t\t\t\t{\n\t\t\t\t\tif (!canSplitFunctionOn(&b))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged |= newFncStarts.insert(&b).second;\n\t\t\t\t\tchanged |= fncStarts.insert(bAddr).second;\n\n\t\t\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << bAddr << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-23907"
    },
    {
        "index": 323,
        "code": "MONGO_EXPORT void gridfile_write_buffer( gridfile *gfile, const char *data,\n        gridfs_offset length ) {\n\n    int bytes_left = 0;\n    int data_partial_len = 0;\n    int chunks_to_write = 0;\n    char *buffer;\n    bson *oChunk;\n    gridfs_offset to_write = length + gfile->pending_len;\n\n    if ( to_write < DEFAULT_CHUNK_SIZE ) { /* Less than one chunk to write */\n        if( gfile->pending_data ) {\n            gfile->pending_data = ( char * )bson_realloc( ( void * )gfile->pending_data, gfile->pending_len + to_write );\n            memcpy( gfile->pending_data + gfile->pending_len, data, length );\n        }\n        else if ( to_write > 0 ) {\n            gfile->pending_data = ( char * )bson_malloc( to_write );\n            memcpy( gfile->pending_data, data, length );\n        }\n        gfile->pending_len += length;\n\n    }\n    else {   /* At least one chunk of data to write */\n        chunks_to_write = to_write / DEFAULT_CHUNK_SIZE;\n        bytes_left = to_write % DEFAULT_CHUNK_SIZE;\n\n        /* If there's a pending chunk to be written, we need to combine\n         * the buffer provided up to DEFAULT_CHUNK_SIZE.\n         */\n        if ( gfile->pending_len > 0 ) {\n            data_partial_len = DEFAULT_CHUNK_SIZE - gfile->pending_len;\n            buffer = ( char * )bson_malloc( DEFAULT_CHUNK_SIZE );\n            memcpy( buffer, gfile->pending_data, gfile->pending_len );\n            memcpy( buffer + gfile->pending_len, data, data_partial_len );\n\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, buffer, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += data_partial_len;\n\n            chunks_to_write--;\n\n            bson_free( buffer );\n        }\n\n        while( chunks_to_write > 0 ) {\n            oChunk = chunk_new( gfile->id, gfile->chunk_num, data, DEFAULT_CHUNK_SIZE );\n            mongo_insert( gfile->gfs->client, gfile->gfs->chunks_ns, oChunk, NULL );\n            chunk_free( oChunk );\n            gfile->chunk_num++;\n            chunks_to_write--;\n            gfile->length += DEFAULT_CHUNK_SIZE;\n            data += DEFAULT_CHUNK_SIZE;\n        }\n\n        bson_free( gfile->pending_data );\n\n        /* If there are any leftover bytes, store them as pending data. */\n        if( bytes_left == 0 )\n            gfile->pending_data = NULL;\n        else {\n            gfile->pending_data = ( char * )bson_malloc( bytes_left );\n            memcpy( gfile->pending_data, data, bytes_left );\n        }\n\n        gfile->pending_len = bytes_left;\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 324,
        "code": "Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    /* TODO: array[\"1\"] also extern the length of array */\n    \n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        //obj->clearProto = 1;\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22874"
    },
    {
        "index": 325,
        "code": "may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n{\n    char_u *retp = p;\n\n    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))\n\t\t\t\t\t\t       && eap->getline != NULL)\n    {\n\tgarray_T    ga;\n\tchar_u\t    *line = NULL;\n\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tif (ga_add_string(&ga, p) == FAIL)\n\t    return retp;\n\n\t// If the argument ends in \"}\" it must have been concatenated already\n\t// for ISN_EXEC.\n\tif (p[STRLEN(p) - 1] != '}')\n\t    // Read lines between '{' and '}'.  Does not support nesting or\n\t    // here-doc constructs.\n\t    for (;;)\n\t    {\n\t\tvim_free(line);\n\t\tif ((line = eap->getline(':', eap->cookie,\n\t\t\t\t\t   0, GETLINE_CONCAT_CONTBAR)) == NULL)\n\t\t{\n\t\t    emsg(_(e_missing_rcurly));\n\t\t    break;\n\t\t}\n\t\tif (ga_add_string(&ga, line) == FAIL)\n\t\t    break;\n\t\tif (*skipwhite(line) == '}')\n\t\t    break;\n\t    }\n\tvim_free(line);\n\tretp = *tofree = ga_concat_strings(&ga, \"\\n\");\n\tga_clear_strings(&ga);\n\t*flags |= UC_VIM9;\n    }\n    return retp;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 326,
        "code": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  // Update the connecting flag before processing the event because we may start a new connection\n  // attempt in initializeUpstreamConnection.\n  bool connecting = connecting_;\n  connecting_ = false;\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43826"
    },
    {
        "index": 327,
        "code": "int mongo_env_sock_init( void ) {\n    return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 328,
        "code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  // Create a top level function that will never be executed, because:\n  // 1. IRGen assumes the first function always has global scope\n  // 2. It serves as the root for dummy functions for lexical data\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n\n  // Save the top-level context, but ensure it doesn't outlive what it is\n  // pointing to.\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n\n  // We restore scoping information in two separate ways:\n  // 1. By adding them to ExternalScopes for resolution here\n  // 2. By adding dummy functions for lexical scoping debug info later\n  //\n  // Instruction selection determines the delta between the ExternalScope\n  // and the dummy function chain, so we add the ExternalScopes with\n  // positive depth.\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n\n  // If lazyData->closureAlias is specified, we must create an alias binding\n  // between originalName (which must be valid) and the variable identified by\n  // closureAlias.\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n\n    // NOTE: the closureAlias target must exist and must be a Variable.\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n\n    // Re-create the alias.\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 329,
        "code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n\n  // packet is truncated... further inspection is not needed\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n\n  str = (char*)&packet->payload[offset+5];\n\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n\n  // check string is printable\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n\n  return(is_printable);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15474"
    },
    {
        "index": 330,
        "code": "static uint32_t sn_coap_parser_options_parse_uint(uint8_t **packet_data_pptr, uint8_t option_len)\n{\n    uint32_t value = 0;\n    while (option_len--) {\n        value <<= 8;\n        value |= *(*packet_data_pptr)++;\n    }\n    return value;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12887"
    },
    {
        "index": 331,
        "code": "  TfLiteRegistration OkOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n    // Set output size to the input size in OkOp::Prepare(). Code exists to have\n    // a framework in Prepare. The input and output tensors are not used.\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 332,
        "code": "static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 333,
        "code": "Variant HHVM_METHOD(XMLReader, expand,\n                    const Variant& basenode /* = null */) {\n  auto* data = Native::data<XMLReader>(this_);\n  req::ptr<XMLDocumentData> doc;\n  xmlDocPtr docp = nullptr;\n  SYNC_VM_REGS_SCOPED();\n\n  if (!basenode.isNull()) {\n    auto dombasenode = Native::data<DOMNode>(basenode.toObject());\n    doc = dombasenode->doc();\n    docp = doc->docp();\n    if (docp == nullptr) {\n      raise_warning(\"Invalid State Error\");\n      return false;\n    }\n  }\n\n  if (data->m_ptr) {\n    xmlNodePtr node = xmlTextReaderExpand(data->m_ptr);\n    if (node == nullptr) {\n      raise_warning(\"An Error Occurred while expanding\");\n      return false;\n    } else {\n      xmlNodePtr nodec = xmlDocCopyNode(node, docp, 1);\n      if (nodec == nullptr) {\n        raise_notice(\"Cannot expand this node type\");\n        return false;\n      } else {\n        return php_dom_create_object(nodec, doc);\n      }\n    }\n  }\n\n  raise_warning(\"Load Data before trying to read\");\n  return false;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 334,
        "code": "tgs_build_reply(astgs_request_t priv,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_context context = priv->context;\n    krb5_kdc_configuration *config = priv->config;\n    KDC_REQ *req = &priv->req;\n    KDC_REQ_BODY *b = &priv->req.req_body;\n    const char *from = priv->from;\n    krb5_error_code ret, ret2;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *tgt_realm = /* Realm of TGT issuer */\n        krb5_principal_get_realm(context, krbtgt->entry.principal);\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /*\n     * The canonicalize KDC option is passed as a hint to the backend, but\n     * can typically be ignored. Per RFC 6806, names are not canonicalized\n     * in response to a TGS request (although we make an exception, see\n     * force-canonicalize below).\n     */\n    if (b->kdc_options.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 4,\n\t\t    \"No second ticket present in user-to-user request\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"No second ticket present in user-to-user request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 4,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tret = krb5_unparse_name(context, p, &tpn);\n\tif (ret)\n\t\tgoto out;\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user service principal (TGS) unknown\");\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user enctype not supported\");\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT decrypt failure\");\n\t    goto out;\n        }\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"User-to-user TGT expired or invalid\");\n\t    goto out;\n        }\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &priv->sname);\n    if (ret)\n\tgoto out;\n    spn = priv->sname;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &priv->cname);\n    if (ret)\n\tgoto out;\n    cpn = priv->cname;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 4,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp,\n                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | flags,\n\t\t\tNULL, NULL, &server);\n    priv->server = server;\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", spn);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Target not found here\");\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(priv->sname);\n        priv->sname = NULL;\n\tret = krb5_unparse_name(context, sp, &priv->sname);\n\tif (ret)\n\t    goto out;\n\tspn = priv->sname;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret2 = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                         req_rlm, TRUE, &capath, &num_capath);\n                if (ret2) {\n                    ret = ret2;\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"No trusted path from client realm to ours\");\n                    goto out;\n                }\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(priv->sname);\n                priv->sname = NULL;\n                ret = krb5_unparse_name(context, sp, &priv->sname);\n                if (ret)\n                    goto out;\n                spn = priv->sname;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(priv->sname);\n                priv->sname = NULL;\n\t\tret = krb5_unparse_name(context, sp, &priv->sname);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\t\tspn = priv->sname;\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 3,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Service principal unknown\");\n\tgoto out;\n    }\n\n    /*\n     * RFC 6806 notes that names MUST NOT be changed in the response to\n     * a TGS request. Hence we ignore the setting of the canonicalize\n     * KDC option. However, for legacy interoperability we do allow the\n     * backend to override this by setting the force-canonicalize HDB\n     * flag in the server entry.\n     */\n    if (server->entry.flags.force_canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"No matching enctypes for 2nd ticket\");\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(priv, krb5_principal_is_krbtgt(context, sp)\n\t\t\t\t\t\t\t     ? KFE_IS_TGS : 0,\n\t\t\t\t  b->etype.val, b->etype.len, &etype, NULL,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 4,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Enctype not supported\");\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authorization data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"No key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 4,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 4,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n        _kdc_audit_addreason((kdc_request_t)priv, \"Request with wrong TGT\");\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 4,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n        _kdc_audit_addreason((kdc_request_t)priv,\n                             \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    {\n        krb5_data verified_cas;\n\n        /*\n         * If the client doesn't exist in the HDB but has a TGT and it's\n         * obtained with PKINIT then we assume it's a synthetic client -- that\n         * is, a client whose name was vouched for by a CA using a PKINIT SAN,\n         * but which doesn't exist in the HDB proper.  We'll allow such a\n         * client to do TGT requests even though normally we'd reject all\n         * clients that don't exist in the HDB.\n         */\n        ret = krb5_ticket_get_authorization_data_type(context, ticket,\n                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n                                                      &verified_cas);\n        if (ret == 0) {\n            krb5_data_free(&verified_cas);\n            flags |= HDB_F_SYNTHETIC_OK;\n        }\n    }\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    flags &= ~HDB_F_SYNTHETIC_OK;\n    priv->client = client;\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 4, \"Client no longer in database: %s\",\n\t\t    cpn);\n            _kdc_audit_addreason((kdc_request_t)priv, \"Client no longer in HDB\");\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 4, \"Client not found in database: %s\", msg);\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client does not exist\");\n\tkrb5_free_error_message(context, msg);\n    } else if (ret == 0 &&\n               (client->entry.flags.invalid || !client->entry.flags.client)) {\n        _kdc_audit_addreason((kdc_request_t)priv, \"Client has invalid bit set\");\n        kdc_log(context, config, 4, \"Client has invalid bit set\");\n        ret = KRB5KDC_ERR_POLICY;\n        goto out;\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"PAC check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n        _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath check failed\");\n\tkdc_log(context, config, 4,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    struct astgs_request_desc imp_req;\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"Failed to decode PA-S4U2Self\");\n\t\tkdc_log(context, config, 4, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    if (!krb5_checksum_is_keyed(context, self.cksum.cksumtype)) {\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"PA-S4U2Self with unkeyed checksum\");\n\t\tkdc_log(context, config, 4, \"Reject PA-S4U2Self with unkeyed checksum\");\n\t\tret = KRB5KRB_AP_ERR_INAPP_CKSUM;\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 4, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Allow HMAC_MD5 checksum with any key type */\n\t    if (self.cksum.cksumtype == CKSUMTYPE_HMAC_MD5) {\n\t\tstruct krb5_crypto_iov iov;\n\t\tunsigned char csdata[16];\n\t\tChecksum cs;\n\n\t\tcs.checksum.length = sizeof(csdata);\n\t\tcs.checksum.data = &csdata;\n\n\t\tiov.data.data = datack.data;\n\t\tiov.data.length = datack.length;\n\t\tiov.flags = KRB5_CRYPTO_TYPE_DATA;\n\n\t\tret = _krb5_HMAC_MD5_checksum(context, NULL, &crypto->key,\n\t\t\t\t\t      KRB5_KU_OTHER_CKSUM, &iov, 1,\n\t\t\t\t\t      &cs);\n\t\tif (ret == 0 &&\n\t\t    krb5_data_ct_cmp(&cs.checksum, &self.cksum.checksum) != 0)\n\t\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t    }\n\t    else {\n\t\tret = krb5_verify_checksum(context,\n\t\t\t\t\t   crypto,\n\t\t\t\t\t   KRB5_KU_OTHER_CKSUM,\n\t\t\t\t\t   datack.data,\n\t\t\t\t\t   datack.length,\n\t\t\t\t\t   &self.cksum);\n\t    }\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self checksum failed\");\n\t\tkdc_log(context, config, 4,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n            /*\n             * Note no HDB_F_SYNTHETIC_OK -- impersonating non-existent clients\n             * is probably not desirable!\n             */\n\t    ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\tNULL, &s4u2self_impersonated_clientdb,\n\t\t\t\t&s4u2self_impersonated_client);\n\t    if (ret) {\n\t\tconst char *msg;\n\n\t\t/*\n\t\t * If the client belongs to the same realm as our krbtgt, it\n\t\t * should exist in the local database.\n\t\t *\n\t\t */\n\n\t\tif (ret == HDB_ERR_NOENTRY)\n\t\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\tmsg = krb5_get_error_message(context, ret);\n                _kdc_audit_addreason((kdc_request_t)priv,\n                                     \"S4U2Self principal to impersonate not found\");\n\t\tkdc_log(context, config, 2,\n\t\t\t\"S4U2Self principal to impersonate %s not found in database: %s\",\n\t\t\ttpn, msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    /* Ignore require_pwchange and pw_end attributes (as Windows does),\n\t     * since S4U2Self is not password authentication. */\n\t    s4u2self_impersonated_client->entry.flags.require_pwchange = FALSE;\n\t    free(s4u2self_impersonated_client->entry.pw_end);\n\t    s4u2self_impersonated_client->entry.pw_end = NULL;\n\n\t    imp_req = *priv;\n\t    imp_req.client = s4u2self_impersonated_client;\n\t    imp_req.client_princ = tp;\n\n\t    ret = kdc_check_flags(&imp_req, FALSE);\n\t    if (ret)\n\t\tgoto out; /* kdc_check_flags() calls _kdc_audit_addreason() */\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n                    _kdc_audit_addreason((kdc_request_t)priv,\n                                         \"KRB5SignedPath missing\");\n\t\t    kdc_log(context, config, 4, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 4, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 4, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation or if the impersonate client is disallowed\n\t     * forwardable, remove the forwardable flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation &&\n\t\ts4u2self_impersonated_client->entry.flags.forwardable) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 4, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.cname_in_addl_tkt\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n            _kdc_audit_addreason((kdc_request_t)priv, \"KRB5SignedPath missing\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Failed to decrypt constrained delegation ticket\");\n\t    kdc_log(context, config, 4,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n        _kdc_audit_addkv((kdc_request_t)priv, 0, \"impersonatee\", \"%s\", tpn);\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Missing forwardable flag on ticket for constrained delegation\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation not allowed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket expired or invalid\");\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket PAC check failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 4,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"KRB5SignedPath check failed\");\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 4,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n            _kdc_audit_addreason((kdc_request_t)priv,\n                                 \"Constrained delegation ticket not signed\");\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 4, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(priv, FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n        _kdc_audit_addreason((kdc_request_t)priv, \"Inconsistent request\");\n\tkdc_log(context, config, 4, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if (!_kdc_check_addresses(priv, tgt->caddr, from_addr)) {\n        if (config->check_ticket_addresses) {\n            ret = KRB5KRB_AP_ERR_BADADDR;\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n            kdc_log(context, config, 4, \"Request from wrong address\");\n            _kdc_audit_addreason((kdc_request_t)priv, \"Request from wrong address\");\n            goto out;\n        } else if (config->warn_ticket_addresses) {\n            _kdc_audit_addkv((kdc_request_t)priv, 0, \"wrongaddr\", \"yes\");\n        }\n    }\n\n    /* check local and per-principal anonymous ticket issuance policy */\n    if (is_anon_tgs_request_p(b, tgt)) {\n\tret = _kdc_check_anon_policy(priv);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 3,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n            _kdc_audit_addreason((kdc_request_t)priv, \"Referral build failed\");\n\t    kdc_log(context, config, 4,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 4,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(priv,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t client,\n\t\t\t cp,\n                         tgt_realm,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-3671"
    },
    {
        "index": 335,
        "code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  /* number of arguments */\n  int nextra = actual - nfixparams;  /* number of extra arguments */\n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  /* copy function to the top of the stack */\n  setobjs2s(L, L->top++, ci->func);\n  /* move fixed parameters to the top of the stack */\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  /* erase original parameter (for GC) */\n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 336,
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tconst char *pcname;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; // XXX this depends on asm->mininstrsize\n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t// faster ^C\n\t\treturn;\n\t}\n\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *spname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (!spname) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\t//this is necessary for the hook to read the id of analop\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\t//eprintf (\"Analyzing ESIL refs from 0x%\"PFMT64x\" - 0x%\"PFMT64x\"\\n\", addr, end);\n\t// TODO: backup/restore register state before/after analysis\n\tpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!pcname || !*pcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t// disabled because it causes some tests to fail\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\n\t\t/* realign address if needed */\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n#if 1\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n#endif\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; //   XXX dupe in op.size below\n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\t// i += 2\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\t//we need to check again i because buf+i may goes beyond its boundaries\n\t\t//because of i+= minopsize - 1\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t//  those require write support\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %-4d %s\\n\", cur, snv, si->name);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\t//todo were doing less filtering up top because we can't match against 80 on all platforms\n\t\t\t\t// might get too many of this path now..\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %d\\n\", cur, snv);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\t// looks like ^C is handled by esil_parse !!!!\n\t\t//r_anal_esil_dumpstack (ESIL);\n\t\t//r_anal_esil_stack_free (ESIL);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t// arm64\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t/* TODO: test if this is valid for other archs too */\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\t/* This code is known to work on Thumb, ARM and ARM64 */\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\t// HACK avoid format string inside string used later as format\n\t\t\t\t\t\t\t\t// string crashes disasm inside agf under some conditions.\n\t\t\t\t\t\t\t\t// https://github.com/radareorg/radare2/issues/6937\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n// analyze function here\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\t// restore register\n\tr_reg_arena_pop (core->anal->reg);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0849"
    },
    {
        "index": 337,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* axis = GetInput(context, node, kAxisTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(axis), 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= NumElements(axis));\n\n  if (input->type != kTfLiteInt32 && input->type != kTfLiteFloat32 &&\n      input->type != kTfLiteUInt8 && input->type != kTfLiteInt16 &&\n      input->type != kTfLiteInt64 && input->type != kTfLiteBool) {\n    context->ReportError(context, \"Type '%s' is not supported by reverse.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n  if (axis->type != kTfLiteInt32) {\n    context->ReportError(context, \"Axis Type '%s' is not supported by reverse.\",\n                         TfLiteTypeGetName(axis->type));\n    return kTfLiteError;\n  }\n\n  // TODO(renjieliu): support multi-axis case.\n  if (NumElements(axis) > 1) {\n    context->ReportError(context, \"Current does not support more than 1 axis.\");\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input->dims);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 338,
        "code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 339,
        "code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37638"
    },
    {
        "index": 340,
        "code": "static inline void vga_set_mem_top(struct vc_data *c)\n{\n\twrite_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-28097"
    },
    {
        "index": 341,
        "code": "exif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-9278"
    },
    {
        "index": 342,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedSocketReader__set_state(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  int __pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedSocketReader__set_state\", 0);\n\n  /* \"(tree fragment)\":12\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedSocketReader__set_state(BufferedSocketReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]             # <<<<<<<<<<<<<<\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (!(likely(PyByteArray_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"bytearray\", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->__pyx_base.buffer);\n  __Pyx_DECREF(__pyx_v___pyx_result->__pyx_base.buffer);\n  __pyx_v___pyx_result->__pyx_base.buffer = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.current_buffer_size = __pyx_t_2;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.position = __pyx_t_2;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->sock);\n  __Pyx_DECREF(__pyx_v___pyx_result->sock);\n  __pyx_v___pyx_result->sock = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedSocketReader__set_state(BufferedSocketReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(1, 13, __pyx_L1_error)\n  }\n  __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_4 = ((__pyx_t_2 > 4) != 0);\n  if (__pyx_t_4) {\n  } else {\n    __pyx_t_3 = __pyx_t_4;\n    goto __pyx_L4_bool_binop_done;\n  }\n  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_5 = (__pyx_t_4 != 0);\n  __pyx_t_3 = __pyx_t_5;\n  __pyx_L4_bool_binop_done:;\n  if (__pyx_t_3) {\n\n    /* \"(tree fragment)\":14\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])             # <<<<<<<<<<<<<<\n */\n    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    if (unlikely(__pyx_v___pyx_state == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(1, 14, __pyx_L1_error)\n    }\n    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_8 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {\n      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);\n      if (likely(__pyx_t_8)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);\n        __Pyx_INCREF(__pyx_t_8);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_7, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);\n    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n    /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedSocketReader__set_state(BufferedSocketReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  }\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_BufferedSocketReader__set_state(<BufferedSocketReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedSocketReader__set_state(BufferedSocketReader __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedSocketReader__set_state\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 343,
        "code": "bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: '~': zero extending 'unsigned int' to 'upx_uint64_t' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack(\"PT_NOTEs too big; try '--force-execve'\");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = NULL;\n        shstrtab = NULL;\n        if (e_shnum) {\n            unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);\n            if (e_shstrndx) {\n                if (e_shnum <= e_shstrndx) {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);\n                    throwCantPack(msg);\n                }\n                sec_strndx = &shdri[e_shstrndx];\n                unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);\n                if ((u32_t)file_size <= sh_offset) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad .e_shstrndx->sh_offset %#x\", sh_offset);\n                    throwCantPack(msg);\n                }\n                shstrtab = (char const *)(sh_offset + file_image);\n            }\n            sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                unsigned const sh_link = get_te32(&sec_dynsym->sh_link);\n                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#x\", sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= sh_name  // FIXME: weak\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrndx\");\n                }\n            }\n        }\n\n        Elf32_Phdr const *pload_x0(0);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            if (!pload_x0\n            &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)\n            ) {\n                pload_x0 = phdr;\n            }\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) {\n                // not explicitly PIE main program\n                if (Elf32_Ehdr::EM_ARM == e_machine  // Android is common\n                &&  !opt->o_unix.android_shlib  // but not explicit\n                ) {\n                    opt->info_mode++;\n                    info(\"note: use --android-shlib if appropriate\");\n                    opt->info_mode--;\n                }\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        unsigned user_init_ava = get_te32(&shdr->sh_addr);\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        if ((u32_t)file_size <= user_init_off) {\n                            char msg[70]; snprintf(msg, sizeof(msg),\n                                \"bad Elf32_Shdr[%d].sh_offset %#x\",\n                                -1+ e_shnum - j, user_init_off);\n                            throwCantPack(msg);\n                        }\n                        // Check that &file_image[user_init_off] has\n                        // *_RELATIVE relocation, and fetch user_init_va.\n                        // If Elf32_Rela then the actual value is in Rela.r_addend.\n                        int z_rel = dt_table[Elf32_Dyn::DT_REL];\n                        int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ];\n                        if (z_rel && z_rsz) {\n                            unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val);\n                            Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off];\n                            unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val);\n                            Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp);\n                            for (; rp < last; ++rp) {\n                                unsigned r_va = get_te32(&rp->r_offset);\n                                if (r_va == user_init_ava) { // found the Elf32_Rel\n                                    unsigned r_info = get_te32(&rp->r_info);\n                                    unsigned r_type = ELF32_R_TYPE(r_info);\n                                    if (Elf32_Ehdr::EM_ARM == e_machine\n                                    &&  R_ARM_RELATIVE == r_type) {\n                                        user_init_va = get_te32(&file_image[user_init_off]);\n                                    }\n                                    else {\n                                        char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"bad relocation %#x DT_INIT_ARRAY[0]\",\n                                            r_info);\n                                        throwCantPack(msg);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        unsigned const p_filesz = get_te32(&pload_x0->p_filesz);\n                        if (!((user_init_va - xct_va) < p_filesz)) {\n                            // Not in executable portion of first executable PT_LOAD.\n                            if (0==user_init_va && opt->o_unix.android_shlib) {\n                                // Android allows (0 ==> skip) ?\n                                upx_dt_init = 0;  // force steal of 'extra' DT_NULL\n                                // XXX: FIXME: depends on SHT_DYNAMIC coming later\n                            }\n                            else {\n                                char msg[70]; snprintf(msg, sizeof(msg),\n                                    \"bad init address %#x in Elf32_Shdr[%d].%#x\\n\",\n                                    (unsigned)user_init_va, -1+ e_shnum - j, user_init_off);\n                                throwCantPack(msg);\n                            }\n                        }\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEEDED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#x above stub\", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-27788"
    },
    {
        "index": 344,
        "code": "update_search_stat(\n    int\t\t\tdirc,\n    pos_T\t\t*pos,\n    pos_T\t\t*cursor_pos,\n    searchstat_T\t*stat,\n    int\t\t\trecompute,\n    int\t\t\tmaxcount,\n    long\t\ttimeout UNUSED)\n{\n    int\t\t    save_ws = p_ws;\n    int\t\t    wraparound = FALSE;\n    pos_T\t    p = (*pos);\n    static pos_T    lastpos = {0, 0, 0};\n    static int\t    cur = 0;\n    static int\t    cnt = 0;\n    static int\t    exact_match = FALSE;\n    static int\t    incomplete = 0;\n    static int\t    last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    static int\t    chgtick = 0;\n    static char_u   *lastpat = NULL;\n    static buf_T    *lbuf = NULL;\n#ifdef FEAT_RELTIME\n    proftime_T  start;\n#endif\n\n    vim_memset(stat, 0, sizeof(searchstat_T));\n\n    if (dirc == 0 && !recompute && !EMPTY_POS(lastpos))\n    {\n\tstat->cur = cur;\n\tstat->cnt = cnt;\n\tstat->exact_match = exact_match;\n\tstat->incomplete = incomplete;\n\tstat->last_maxcount = last_maxcount;\n\treturn;\n    }\n    last_maxcount = maxcount;\n\n    wraparound = ((dirc == '?' && LT_POS(lastpos, p))\n\t       || (dirc == '/' && LT_POS(p, lastpos)));\n\n    // If anything relevant changed the count has to be recomputed.\n    // MB_STRNICMP ignores case, but we should not ignore case.\n    // Unfortunately, there is no MB_STRNICMP function.\n    // XXX: above comment should be \"no MB_STRCMP function\" ?\n    if (!(chgtick == CHANGEDTICK(curbuf)\n\t&& MB_STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0\n\t&& STRLEN(lastpat) == STRLEN(spats[last_idx].pat)\n\t&& EQUAL_POS(lastpos, *cursor_pos)\n\t&& lbuf == curbuf) || wraparound || cur < 0\n\t    || (maxcount > 0 && cur > maxcount) || recompute)\n    {\n\tcur = 0;\n\tcnt = 0;\n\texact_match = FALSE;\n\tincomplete = 0;\n\tCLEAR_POS(&lastpos);\n\tlbuf = curbuf;\n    }\n\n    if (EQUAL_POS(lastpos, *cursor_pos) && !wraparound\n\t\t&& (dirc == 0 || dirc == '/' ? cur < cnt : cur > 0))\n\tcur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;\n    else\n    {\n\tint\tdone_search = FALSE;\n\tpos_T\tendpos = {0, 0, 0};\n\n\tp_ws = FALSE;\n#ifdef FEAT_RELTIME\n\tif (timeout > 0)\n\t    profile_setlimit(timeout, &start);\n#endif\n\twhile (!got_int && searchit(curwin, curbuf, &lastpos, &endpos,\n\t\t\t FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST, NULL) != FAIL)\n\t{\n\t    done_search = TRUE;\n#ifdef FEAT_RELTIME\n\t    // Stop after passing the time limit.\n\t    if (timeout > 0 && profile_passed_limit(&start))\n\t    {\n\t\tincomplete = 1;\n\t\tbreak;\n\t    }\n#endif\n\t    cnt++;\n\t    if (LTOREQ_POS(lastpos, p))\n\t    {\n\t\tcur = cnt;\n\t\tif (LT_POS(p, endpos))\n\t\t    exact_match = TRUE;\n\t    }\n\t    fast_breakcheck();\n\t    if (maxcount > 0 && cnt > maxcount)\n\t    {\n\t\tincomplete = 2;    // max count exceeded\n\t\tbreak;\n\t    }\n\t}\n\tif (got_int)\n\t    cur = -1; // abort\n\tif (done_search)\n\t{\n\t    vim_free(lastpat);\n\t    lastpat = vim_strsave(spats[last_idx].pat);\n\t    chgtick = CHANGEDTICK(curbuf);\n\t    lbuf = curbuf;\n\t    lastpos = p;\n\t}\n    }\n    stat->cur = cur;\n    stat->cnt = cnt;\n    stat->exact_match = exact_match;\n    stat->incomplete = incomplete;\n    stat->last_maxcount = last_maxcount;\n    p_ws = save_ws;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1968"
    },
    {
        "index": 345,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_6write(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_data) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"write\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write(__pyx_v_self, __pyx_v_data, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.write\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 346,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_2__defaults__(CYTHON_UNUSED PyObject *__pyx_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  __Pyx_RefNannySetupContext(\"__defaults__\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_INCREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_encoding);\n  __Pyx_GIVEREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_encoding);\n  PyTuple_SET_ITEM(__pyx_t_1, 0, __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_encoding);\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 22, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n  __Pyx_INCREF(Py_None);\n  __Pyx_GIVEREF(Py_None);\n  PyTuple_SET_ITEM(__pyx_t_2, 1, Py_None);\n  __pyx_t_1 = 0;\n  __pyx_r = __pyx_t_2;\n  __pyx_t_2 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.__defaults__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 347,
        "code": "static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)\n{\n    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;\n    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {\n        Py_INCREF(func);\n        return func;\n    }\n    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {\n        if (type == NULL)\n            type = (PyObject *)(Py_TYPE(obj));\n        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));\n    }\n    if (obj == Py_None)\n        obj = NULL;\n    return __Pyx_PyMethod_New(func, obj, type);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 348,
        "code": "TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n\n  OpData* data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  data->input_zero_point = input->params.zero_point;\n  return CalculateArithmeticOpData(context, node, data);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 349,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  auto* params = reinterpret_cast<TfLiteShapeParams*>(node->builtin_data);\n  switch (params->out_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:\n      context->ReportError(context, \"Unknown shape output data type: %d\",\n                           params->out_type);\n      return kTfLiteError;\n  }\n\n  // By design, the input shape is always known at the time of Prepare, even\n  // if the preceding op that generates |input| is dynamic. Thus, we can\n  // always compute the shape immediately, without waiting for Eval.\n  SetTensorToPersistentRo(output);\n\n  // Shape always produces a 1-dimensional output tensor, where each output\n  // element is the length of the corresponding input tensor's dimension.\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(1);\n  output_size->data[0] = NumDimensions(input);\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_size));\n\n  TFLITE_DCHECK_EQ(NumDimensions(output), 1);\n  TFLITE_DCHECK_EQ(SizeOfDimension(output, 0), NumDimensions(input));\n\n  // Immediately propagate the known shape to the output tensor. This allows\n  // downstream ops that rely on the value to use it during prepare.\n  switch (output->type) {\n    case kTfLiteInt32:\n      ExtractShape(input, GetTensorData<int32_t>(output));\n      break;\n    case kTfLiteInt64:\n      ExtractShape(input, GetTensorData<int64_t>(output));\n      break;\n    default:\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 350,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader_2read_into_buffer(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  Py_ssize_t __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_into_buffer\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":188\n * \n *     def read_into_buffer(self):\n *         self.current_buffer_size = self.sock.recv_into(self.buffer)             # <<<<<<<<<<<<<<\n * \n *         if self.current_buffer_size == 0:\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->sock, __pyx_n_s_recv_into); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_self->__pyx_base.buffer) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_self->__pyx_base.buffer);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_4 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_4 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 188, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_self->__pyx_base.current_buffer_size = __pyx_t_4;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":190\n *         self.current_buffer_size = self.sock.recv_into(self.buffer)\n * \n *         if self.current_buffer_size == 0:             # <<<<<<<<<<<<<<\n *             raise EOFError('Unexpected EOF while reading bytes')\n * \n */\n  __pyx_t_5 = ((__pyx_v_self->__pyx_base.current_buffer_size == 0) != 0);\n  if (unlikely(__pyx_t_5)) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":191\n * \n *         if self.current_buffer_size == 0:\n *             raise EOFError('Unexpected EOF while reading bytes')             # <<<<<<<<<<<<<<\n * \n * \n */\n    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_EOFError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_Raise(__pyx_t_1, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __PYX_ERR(0, 191, __pyx_L1_error)\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":190\n *         self.current_buffer_size = self.sock.recv_into(self.buffer)\n * \n *         if self.current_buffer_size == 0:             # <<<<<<<<<<<<<<\n *             raise EOFError('Unexpected EOF while reading bytes')\n * \n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":187\n *         super(BufferedSocketReader, self).__init__(bufsize)\n * \n *     def read_into_buffer(self):             # <<<<<<<<<<<<<<\n *         self.current_buffer_size = self.sock.recv_into(self.buffer)\n * \n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedSocketReader.read_into_buffer\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 351,
        "code": "nv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1898"
    },
    {
        "index": 352,
        "code": "MONGO_EXPORT bson_bool_t bson_iterator_more( const bson_iterator *i ) {\n    return *( i->cur );\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 353,
        "code": "Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n   // if (func && func->strict)\n    //    frame.strict = 1;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n        /*if (interp->framePtr->Sp != oldSp) //TODO: at some point after memory refs???\n            Jsi_LogBug(\"Stack not balance after execute script\");*/\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 354,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader_4__reduce_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *__pyx_v_self) {\n  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.current_buffer_size, self.position, self.sock)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.current_buffer_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.position); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_INCREF(__pyx_v_self->__pyx_base.buffer);\n  __Pyx_GIVEREF(__pyx_v_self->__pyx_base.buffer);\n  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self->__pyx_base.buffer);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);\n  __Pyx_INCREF(__pyx_v_self->sock);\n  __Pyx_GIVEREF(__pyx_v_self->sock);\n  PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_v_self->sock);\n  __pyx_t_1 = 0;\n  __pyx_t_2 = 0;\n  __pyx_v_state = ((PyObject*)__pyx_t_3);\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":6\n *     cdef bint use_setstate\n *     state = (self.buffer, self.current_buffer_size, self.position, self.sock)\n *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<\n *     if _dict is not None:\n *         state += (_dict,)\n */\n  __pyx_t_3 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_v__dict = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":7\n *     state = (self.buffer, self.current_buffer_size, self.position, self.sock)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n  __pyx_t_4 = (__pyx_v__dict != Py_None);\n  __pyx_t_5 = (__pyx_t_4 != 0);\n  if (__pyx_t_5) {\n\n    /* \"(tree fragment)\":8\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *         state += (_dict,)             # <<<<<<<<<<<<<<\n *         use_setstate = True\n *     else:\n */\n    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(__pyx_v__dict);\n    __Pyx_GIVEREF(__pyx_v__dict);\n    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v__dict);\n    __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_2));\n    __pyx_t_2 = 0;\n\n    /* \"(tree fragment)\":9\n *     if _dict is not None:\n *         state += (_dict,)\n *         use_setstate = True             # <<<<<<<<<<<<<<\n *     else:\n *         use_setstate = self.buffer is not None or self.sock is not None\n */\n    __pyx_v_use_setstate = 1;\n\n    /* \"(tree fragment)\":7\n *     state = (self.buffer, self.current_buffer_size, self.position, self.sock)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n    goto __pyx_L3;\n  }\n\n  /* \"(tree fragment)\":11\n *         use_setstate = True\n *     else:\n *         use_setstate = self.buffer is not None or self.sock is not None             # <<<<<<<<<<<<<<\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, None), state\n */\n  /*else*/ {\n    __pyx_t_4 = (__pyx_v_self->__pyx_base.buffer != ((PyObject*)Py_None));\n    __pyx_t_6 = (__pyx_t_4 != 0);\n    if (!__pyx_t_6) {\n    } else {\n      __pyx_t_5 = __pyx_t_6;\n      goto __pyx_L4_bool_binop_done;\n    }\n    __pyx_t_6 = (__pyx_v_self->sock != Py_None);\n    __pyx_t_4 = (__pyx_t_6 != 0);\n    __pyx_t_5 = __pyx_t_4;\n    __pyx_L4_bool_binop_done:;\n    __pyx_v_use_setstate = __pyx_t_5;\n  }\n  __pyx_L3:;\n\n  /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.buffer is not None or self.sock is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, None), state\n *     else:\n */\n  __pyx_t_5 = (__pyx_v_use_setstate != 0);\n  if (__pyx_t_5) {\n\n    /* \"(tree fragment)\":13\n *         use_setstate = self.buffer is not None or self.sock is not None\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, None), state             # <<<<<<<<<<<<<<\n *     else:\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_BufferedSocketRea); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_251251440);\n    __Pyx_GIVEREF(__pyx_int_251251440);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_251251440);\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    PyTuple_SET_ITEM(__pyx_t_3, 2, Py_None);\n    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_GIVEREF(__pyx_t_2);\n    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);\n    __pyx_t_2 = 0;\n    __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_1;\n    __pyx_t_1 = 0;\n    goto __pyx_L0;\n\n    /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.buffer is not None or self.sock is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, None), state\n *     else:\n */\n  }\n\n  /* \"(tree fragment)\":15\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, None), state\n *     else:\n *         return __pyx_unpickle_BufferedSocketReader, (type(self), 0xef9caf0, state)             # <<<<<<<<<<<<<<\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedSocketReader__set_state(self, __pyx_state)\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_BufferedSocketRea); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_251251440);\n    __Pyx_GIVEREF(__pyx_int_251251440);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_251251440);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_state);\n    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_1);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);\n    __pyx_t_1 = 0;\n    __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"(tree fragment)\":1\n * def __reduce_cython__(self):             # <<<<<<<<<<<<<<\n *     cdef tuple state\n *     cdef object _dict\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedSocketReader.__reduce_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_state);\n  __Pyx_XDECREF(__pyx_v__dict);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 355,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, GetInput(context, node, 0)->type,\n                          kTfLiteString);\n  TF_LITE_ENSURE_TYPES_EQ(context, GetOutput(context, node, 0)->type,\n                          kTfLiteString);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 356,
        "code": "   std::unique_ptr<FakeMediaStreamUIProxy> CreateMockUI(bool expect_started) {\n     std::unique_ptr<MockMediaStreamUIProxy> fake_ui =\n         std::make_unique<MockMediaStreamUIProxy>();\n     if (expect_started)\n       EXPECT_CALL(*fake_ui, MockOnStarted(_));\n     return fake_ui;\n  }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 357,
        "code": "static int __Pyx_modinit_type_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_type_import_code\", 0);\n  /*--- Type import code ---*/\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"type\", \n  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000\n  sizeof(PyTypeObject),\n  #else\n  sizeof(PyHeapTypeObject),\n  #endif\n  __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 8, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"bool\", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(3, 8, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"complex\", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(4, 15, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_RefNannyFinishContext();\n  return 0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 358,
        "code": "static int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    uint8_t previous_option_number = 0;\n    int8_t  ret_status             = 0;\n    uint16_t message_left          = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                                    packet_data_start_ptr,\n                                                                    packet_len,\n                                                                    0);\n\n    /*  Parse token, if exists  */\n    dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n\n    if (dst_coap_msg_ptr->token_len) {\n        int8_t ptr_check_result;\n        if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n            tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n            return -1;\n        }\n\n        ptr_check_result = sn_coap_parser_check_packet_ptr(*packet_data_pptr, packet_data_start_ptr, packet_len, dst_coap_msg_ptr->token_len);\n        if (0 != ptr_check_result) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n\n        dst_coap_msg_ptr->token_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n\n        if (dst_coap_msg_ptr->token_ptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n            return -1;\n        }\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      dst_coap_msg_ptr->token_len);\n    }\n\n    /* Loop all Options */\n    while (message_left && (**packet_data_pptr != 0xff)) {\n        /* Get option length WITHOUT extensions */\n        uint16_t option_len = (**packet_data_pptr & 0x0F);\n        /* Get option number WITHOUT extensions */\n        uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, 1);\n\n        int8_t    option_parse_result;\n        /* Add possible option delta extension */\n        option_parse_result = parse_ext_option(&option_number,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n        /* Add previous option to option delta and get option number */\n        option_number += previous_option_number;\n\n        /* Add possible option length extension to resolve full length of the option */\n        option_parse_result = parse_ext_option(&option_len,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n\n        /* * * Parse option itself * * */\n        /* Some options are handled independently in own functions */\n        previous_option_number = option_number;\n        /* Allocate options_list_ptr if needed */\n        switch (option_number) {\n            case COAP_OPTION_MAX_AGE:\n            case COAP_OPTION_PROXY_URI:\n            case COAP_OPTION_ETAG:\n            case COAP_OPTION_URI_HOST:\n            case COAP_OPTION_LOCATION_PATH:\n            case COAP_OPTION_URI_PORT:\n            case COAP_OPTION_LOCATION_QUERY:\n            case COAP_OPTION_OBSERVE:\n            case COAP_OPTION_URI_QUERY:\n            case COAP_OPTION_BLOCK2:\n            case COAP_OPTION_BLOCK1:\n            case COAP_OPTION_ACCEPT:\n            case COAP_OPTION_SIZE1:\n            case COAP_OPTION_SIZE2:\n                if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                    return -1;\n                }\n                break;\n        }\n\n        if (message_left < option_len){\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr would overflow when parsing options!\");\n            return -1;\n        }\n\n        /* Parse option */\n        switch (option_number) {\n            case COAP_OPTION_CONTENT_FORMAT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_MAX_AGE:\n                if (option_len > 4) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_PROXY_URI:\n                if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_ETAG:\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                             message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                             (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                             COAP_OPTION_ETAG, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_HOST:\n                if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_PATH:\n                if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                             COAP_OPTION_LOCATION_PATH, option_len);\n                if (ret_status <0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_PORT:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                             COAP_OPTION_LOCATION_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_URI_PATH:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                             COAP_OPTION_URI_PATH, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_OBSERVE:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_URI_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                             COAP_OPTION_URI_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_BLOCK2:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_BLOCK1:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_ACCEPT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE1:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE2:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            default:\n                tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                return -1;\n        }\n\n        /* Check for overflow */\n        if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n            return -1;\n        }\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      0);\n    }\n    return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12887"
    },
    {
        "index": 360,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), data->num);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, NumElements(input) > 0);\n  int axis = data->axis;\n  if (axis < 0) {\n    axis += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, 0 <= axis && axis < NumDimensions(input));\n  if (input->type != kTfLiteInt32 && input->type != kTfLiteFloat32 &&\n      input->type != kTfLiteUInt8 && input->type != kTfLiteInt8 &&\n      input->type != kTfLiteInt16 && input->type != kTfLiteBool) {\n    context->ReportError(context, \"Type '%s' is not supported by unpack.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n  const TfLiteIntArray* input_shape = input->dims;\n  // Num should be equal to the shape[axis].\n  // Resize outputs. rank will be R - 1.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int o = 0;\n  for (int index = 0; index < NumDimensions(input); ++index) {\n    if (index != axis) {\n      output_shape->data[o++] = input_shape->data[index];\n    }\n  }\n\n  TF_LITE_ENSURE_EQ(context, data->num, input_shape->data[axis]);\n  for (int i = 0; i < data->num; ++i) {\n    TfLiteIntArray* copied_output_shape = TfLiteIntArrayCopy(output_shape);\n    TfLiteTensor* output = GetOutput(context, node, i);\n    TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n    // Guarantee input/output quantization params match as we do not support\n    // rescaling of unpacked quantized tensors.\n    TF_LITE_ENSURE_EQ(context, input->params.zero_point,\n                      output->params.zero_point);\n    TF_LITE_ENSURE_EQ(context, input->params.scale, output->params.scale);\n    TF_LITE_ENSURE_OK(\n        context, context->ResizeTensor(context, output, copied_output_shape));\n  }\n\n  TfLiteIntArrayFree(output_shape);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 361,
        "code": "String HHVM_FUNCTION(ldap_escape,\n                     const String& value,\n                     const String& ignores /* = \"\" */,\n                     int flags /* = 0 */) {\n  char esc[256] = {};\n\n  if (flags & k_LDAP_ESCAPE_FILTER) { // llvm.org/bugs/show_bug.cgi?id=18389\n    esc['*'*1u] = esc['('*1u] = esc[')'*1u] = esc['\\0'*1u] = esc['\\\\'*1u] = 1;\n  }\n\n  if (flags & k_LDAP_ESCAPE_DN) {\n    esc[','*1u] = esc['='*1u] = esc['+'*1u] = esc['<'*1u] = esc['\\\\'*1u] = 1;\n    esc['>'*1u] = esc[';'*1u] = esc['\"'*1u] = esc['#'*1u] = 1;\n  }\n\n  if (!flags) {\n    memset(esc, 1, sizeof(esc));\n  }\n\n  for (int i = 0; i < ignores.size(); i++) {\n    esc[(unsigned char)ignores[i]] = 0;\n  }\n\n  char hex[] = \"0123456789abcdef\";\n\n  String result(3 * value.size(), ReserveString);\n  char *rdata = result.get()->mutableData(), *r = rdata;\n\n  for (int i = 0; i < value.size(); i++) {\n    auto c = (unsigned char)value[i];\n    if (esc[c]) {\n      *r++ = '\\\\';\n      *r++ = hex[c >> 4];\n      *r++ = hex[c & 0xf];\n    } else {\n      *r++ = c;\n    }\n  }\n\n  result.setSize(r - rdata);\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 362,
        "code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tkfree(llcp_sock->service_name);\n\t\tllcp_sock->service_name = NULL;\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-38208"
    },
    {
        "index": 363,
        "code": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n        s->scan_lines_per_block = 32;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(&s->gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);\n        }\n        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < s->ymin; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-35965"
    },
    {
        "index": 364,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // TODO(ahentz): Our current implementations rely on the inputs being 4D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);\n\n  TF_LITE_ENSURE_EQ(context, size->type, kTfLiteInt32);\n  // ResizeBilinear creates a float tensor even when the input is made of\n  // integers.\n  output->type = input->type;\n\n  if (!IsConstantTensor(size)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  // Ensure params are valid.\n  auto* params =\n      reinterpret_cast<TfLiteResizeBilinearParams*>(node->builtin_data);\n  if (params->half_pixel_centers && params->align_corners) {\n    context->ReportError(\n        context, \"If half_pixel_centers is True, align_corners must be False.\");\n    return kTfLiteError;\n  }\n\n  return ResizeOutputTensor(context, input, size, output);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 365,
        "code": "static inline int kvx_is_tca_opcode(ut32 x) {\n\tunsigned major = ((x)>>24) & 0x1F;\n\treturn (major > 1) && (major < 8);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0849"
    },
    {
        "index": 366,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_4write_into_stream(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"write_into_stream\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write_into_stream(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.write_into_stream\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 367,
        "code": "void jsi_code_decode(Jsi_Interp *interp, jsi_OpCode *op, int currentip, char *buf, int bsiz)\n{\n    if (_JSICASTINT(op->op) < 0 || op->op >= OP_LASTOP) {\n        snprintf(buf, bsiz, \"Bad opcode[%d] at %d\", op->op, currentip);\n    }\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%d#%d\", currentip, op->Line);\n    snprintf(buf, bsiz, \"%-8s %s \", nbuf, jsi_op_names[op->op]);\n\n    int sl = Jsi_Strlen(buf);\n    char *bp = buf + sl;\n    bsiz -= sl;\n    if (op->op == OP_PUSHBOO || op->op == OP_FCALL || op->op == OP_EVAL ||\n        op->op == OP_POP || op->op == OP_ASSIGN ||\n        op->op == OP_RET || op->op == OP_NEWFCALL ||\n        op->op == OP_DELETE || op->op == OP_CHTHIS ||\n        op->op == OP_OBJECT || op->op == OP_ARRAY ||\n        op->op == OP_SHF ||\n        op->op == OP_INC || op->op == OP_DEC) snprintf(bp, bsiz, \"%\" PRId64, (Jsi_Wide)(uintptr_t)op->data);\n    else if (op->op == OP_PUSHNUM) Jsi_NumberDtoA(interp, *((Jsi_Number *)op->data), bp, bsiz, 0);\n    else if (op->op == OP_PUSHVSTR) {\n        Jsi_String *ss = (Jsi_String*)op->data;\n        snprintf(bp, bsiz, \"\\\"%s\\\"\", ss->str);\n    } else if (op->op == OP_PUSHSTR || op->op == OP_LOCAL ||\n             op->op == OP_SCATCH) snprintf(bp, bsiz, \"\\\"%s\\\"\", op->data ? (char*)op->data:\"(NoCatch)\");\n    else if (op->op == OP_PUSHVAR) snprintf(bp, bsiz, \"var: \\\"%s\\\"\", ((jsi_FastVar *)op->data)->varname);\n    else if (op->op == OP_PUSHFUN) snprintf(bp, bsiz, \"func: 0x%\" PRIx64, (Jsi_Wide)(uintptr_t)op->data);\n    else if (op->op == OP_JTRUE || op->op == OP_JFALSE ||\n             op->op == OP_JTRUE_NP || op->op == OP_JFALSE_NP ||\n             op->op == OP_JMP) snprintf(bp, bsiz, \"{%\" PRIu64 \"}\\t#%\" PRIu64 \"\", (Jsi_Wide)(uintptr_t)op->data, (Jsi_Wide)((uintptr_t)currentip + (uintptr_t)op->data));\n    else if (op->op == OP_JMPPOP) {\n        jsi_JmpPopInfo *jp = (jsi_JmpPopInfo*)op->data;\n        snprintf(bp, bsiz, \"{%d},%d\\t#%d\", jp->off, jp->topop, currentip + jp->off);\n    }\n    else if (op->op == OP_STRY) {\n        jsi_TryInfo *t = (jsi_TryInfo *)op->data;\n        snprintf(bp, bsiz, \"{try:%d, catch:%d, final:%d}\", t->trylen, t->catchlen, t->finallen);\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 368,
        "code": "static void __Pyx_AddTraceback(const char *funcname, int c_line,\n                               int py_line, const char *filename) {\n    PyCodeObject *py_code = 0;\n    PyFrameObject *py_frame = 0;\n    PyThreadState *tstate = __Pyx_PyThreadState_Current;\n    if (c_line) {\n        c_line = __Pyx_CLineForTraceback(tstate, c_line);\n    }\n    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);\n    if (!py_code) {\n        py_code = __Pyx_CreateCodeObjectForTraceback(\n            funcname, c_line, py_line, filename);\n        if (!py_code) goto bad;\n        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);\n    }\n    py_frame = PyFrame_New(\n        tstate,            /*PyThreadState *tstate,*/\n        py_code,           /*PyCodeObject *code,*/\n        __pyx_d,    /*PyObject *globals,*/\n        0                  /*PyObject *locals*/\n    );\n    if (!py_frame) goto bad;\n    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);\n    PyTraceBack_Here(py_frame);\nbad:\n    Py_XDECREF(py_code);\n    Py_XDECREF(py_frame);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 369,
        "code": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * ~ in the substitute pattern is replaced with the old pattern.\n     * We do it here once to avoid it to be replaced over and over again.\n     * But don't do it when it starts with \"\\=\", then it's an expression.\n     */\n    if (!(sub[0] == '\\\\' && sub[1] == '='))\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0413"
    },
    {
        "index": 370,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_write_into_stream(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v_self, int __pyx_skip_dispatch) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  __Pyx_RefNannySetupContext(\"write_into_stream\", 0);\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overridden in Python */\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {\n      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      #endif\n      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_write_into_stream); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_3write_into_stream)) {\n        __Pyx_XDECREF(__pyx_r);\n        __Pyx_INCREF(__pyx_t_1);\n        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;\n        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {\n          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n          if (likely(__pyx_t_4)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n            __Pyx_INCREF(__pyx_t_4);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_3, function);\n          }\n        }\n        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 84, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_2);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __pyx_r = __pyx_t_2;\n        __pyx_t_2 = 0;\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n        goto __pyx_L0;\n      }\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));\n      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {\n        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n      }\n      #endif\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    }\n    #endif\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":85\n * \n *     cpdef write_into_stream(self):\n *         self.compressor.write(             # <<<<<<<<<<<<<<\n *             PyBytes_FromStringAndSize(self.buffer, self.position)\n *         )\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->compressor, __pyx_n_s_write); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":86\n *     cpdef write_into_stream(self):\n *         self.compressor.write(\n *             PyBytes_FromStringAndSize(self.buffer, self.position)             # <<<<<<<<<<<<<<\n *         )\n *         self.position = 0\n */\n  __pyx_t_3 = PyBytes_FromStringAndSize(__pyx_v_self->__pyx_base.buffer, __pyx_v_self->__pyx_base.position); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":88\n *             PyBytes_FromStringAndSize(self.buffer, self.position)\n *         )\n *         self.position = 0             # <<<<<<<<<<<<<<\n * \n *     def flush(self):\n */\n  __pyx_v_self->__pyx_base.position = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":84\n *         super(CompressedBufferedWriter, self).__init__(bufsize)\n * \n *     cpdef write_into_stream(self):             # <<<<<<<<<<<<<<\n *         self.compressor.write(\n *             PyBytes_FromStringAndSize(self.buffer, self.position)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.write_into_stream\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 371,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n\n  const auto* params = static_cast<const TfLiteSVDFParams*>(node->builtin_data);\n\n  // Validate Tensor Inputs (dtype depends on quantization):\n  // [0] = Input, {2, batch_size, input_size}\n  // [1] = Weights Feature, {2, num_filters, input_size}\n  // [2] = Weights Time, {2, num_filters, memory_size}\n  // [3] = Bias (optional), {1, num_units}\n  // [4] = Activation State (variable),\n  //         {2, batch_size, memory_size * num_filters}\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* weights_feature =\n      GetInput(context, node, kWeightsFeatureTensor);\n  const TfLiteTensor* weights_time =\n      GetInput(context, node, kWeightsTimeTensor);\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  const TfLiteTensor* activation_state =\n      GetInput(context, node, kInputActivationStateTensor);\n\n  // Define input constants based on input tensor definition above:\n  const int rank = params->rank;\n  const int input_size = input->dims->data[1];\n  const int batch_size = input->dims->data[0];\n  const int num_filters = weights_feature->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n  const int num_units = num_filters / rank;\n  const int memory_size = weights_time->dims->data[1];\n\n  // Validate Input Tensor:\n  TF_LITE_ENSURE(context,\n                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 2);\n\n  // Validate Tensor Output:\n  // [0] = float/int8_t, {2, batch_size, num_units}\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(output), 2);\n  TF_LITE_ENSURE_EQ(context, output->dims->data[0], batch_size);\n  TF_LITE_ENSURE_EQ(context, output->dims->data[1], num_units);\n\n  // Validate Weights Feature Input Tensor:\n  TF_LITE_ENSURE_EQ(context, NumDimensions(weights_feature), 2);\n  TF_LITE_ENSURE_EQ(context, weights_feature->dims->data[1], input_size);\n\n  // Validate Weights Time Input Tensor:\n  TF_LITE_ENSURE_EQ(context, NumDimensions(weights_time), 2);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[1], memory_size);\n\n  // Validate Optional Bias Input Tensor:\n  if (bias != nullptr) {\n    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n  }\n\n  // Validate Activation State Input Tensor:\n  TF_LITE_ENSURE_EQ(context, NumDimensions(activation_state), 2);\n  TF_LITE_ENSURE_EQ(context, activation_state->dims->data[0], batch_size);\n  TF_LITE_ENSURE_EQ(context, activation_state->dims->data[1],\n                    memory_size * num_filters);\n  // Since is_variable is not part of TFLiteEvalTensor, check is_variable here.\n  TF_LITE_ENSURE_EQ(context, activation_state->is_variable, true);\n\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, weights_feature->type, kTfLiteInt8);\n    TF_LITE_ENSURE_EQ(context, weights_time->type, kTfLiteInt16);\n    TF_LITE_ENSURE_EQ(context, activation_state->type, kTfLiteInt16);\n    if (bias != nullptr) {\n      TF_LITE_ENSURE_EQ(context, bias->type, kTfLiteInt32);\n    }\n\n    TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteInt8);\n\n    const double effective_scale_1 = static_cast<double>(\n        input->params.scale * weights_feature->params.scale /\n        activation_state->params.scale);\n    const double effective_scale_2 =\n        static_cast<double>(activation_state->params.scale *\n                            weights_time->params.scale / output->params.scale);\n\n    // TODO(b/162018098): Use TF_LITE_ENSURE_NEAR when it is ready.\n    TF_LITE_ENSURE(\n        context,\n        std::abs(static_cast<double>(bias->params.scale) -\n                 static_cast<double>(activation_state->params.scale *\n                                     weights_time->params.scale)) < 1e-5);\n\n    QuantizeMultiplier(effective_scale_1, &(data->effective_scale_1_a),\n                       &(data->effective_scale_1_b));\n    QuantizeMultiplier(effective_scale_2, &(data->effective_scale_2_a),\n                       &(data->effective_scale_2_b));\n\n    data->input_zero_point = input->params.zero_point;\n    data->output_zero_point = output->params.zero_point;\n\n    TFLITE_DCHECK(context->RequestScratchBufferInArena != nullptr);\n\n    const TfLiteStatus scratch_status = context->RequestScratchBufferInArena(\n        context, batch_size * num_filters * sizeof(int32_t),\n        &(data->scratch_tensor_index));\n    TF_LITE_ENSURE_OK(context, scratch_status);\n\n    const TfLiteStatus scratch_output_status =\n        context->RequestScratchBufferInArena(\n            context, batch_size * num_units * sizeof(int32_t),\n            &(data->scratch_output_tensor_index));\n    TF_LITE_ENSURE_OK(context, scratch_output_status);\n  } else {\n    TF_LITE_ENSURE_EQ(context, weights_feature->type, kTfLiteFloat32);\n    TF_LITE_ENSURE_EQ(context, weights_time->type, kTfLiteFloat32);\n    TF_LITE_ENSURE_EQ(context, activation_state->type, kTfLiteFloat32);\n    if (bias != nullptr) {\n      TF_LITE_ENSURE_EQ(context, bias->type, kTfLiteFloat32);\n    }\n    TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n\n    TFLITE_DCHECK(context->RequestScratchBufferInArena != nullptr);\n    const TfLiteStatus scratch_status = context->RequestScratchBufferInArena(\n        context, batch_size * num_filters * sizeof(float),\n        &(data->scratch_tensor_index));\n    TF_LITE_ENSURE_OK(context, scratch_status);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 372,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMfccParams*>(node->user_data);\n\n  const TfLiteTensor* input_wav = GetInput(context, node, kInputTensorWav);\n  const TfLiteTensor* input_rate = GetInput(context, node, kInputTensorRate);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  const int32 sample_rate = *GetTensorData<int>(input_rate);\n\n  const int spectrogram_channels = input_wav->dims->data[2];\n  const int spectrogram_samples = input_wav->dims->data[1];\n  const int audio_channels = input_wav->dims->data[0];\n\n  internal::Mfcc mfcc;\n  mfcc.set_upper_frequency_limit(params->upper_frequency_limit);\n  mfcc.set_lower_frequency_limit(params->lower_frequency_limit);\n  mfcc.set_filterbank_channel_count(params->filterbank_channel_count);\n  mfcc.set_dct_coefficient_count(params->dct_coefficient_count);\n\n  mfcc.Initialize(spectrogram_channels, sample_rate);\n\n  const float* spectrogram_flat = GetTensorData<float>(input_wav);\n  float* output_flat = GetTensorData<float>(output);\n\n  for (int audio_channel = 0; audio_channel < audio_channels; ++audio_channel) {\n    for (int spectrogram_sample = 0; spectrogram_sample < spectrogram_samples;\n         ++spectrogram_sample) {\n      const float* sample_data =\n          spectrogram_flat +\n          (audio_channel * spectrogram_samples * spectrogram_channels) +\n          (spectrogram_sample * spectrogram_channels);\n      std::vector<double> mfcc_input(sample_data,\n                                     sample_data + spectrogram_channels);\n      std::vector<double> mfcc_output;\n      mfcc.Compute(mfcc_input, &mfcc_output);\n      TF_LITE_ENSURE_EQ(context, params->dct_coefficient_count,\n                        mfcc_output.size());\n      float* output_data = output_flat +\n                           (audio_channel * spectrogram_samples *\n                            params->dct_coefficient_count) +\n                           (spectrogram_sample * params->dct_coefficient_count);\n      for (int i = 0; i < params->dct_coefficient_count; ++i) {\n        output_data[i] = mfcc_output[i];\n      }\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 373,
        "code": "void AdminRequestHandler::handleRequest(Transport *transport) {\n  transport->addHeader(\"Content-Type\", \"text/plain\");\n  std::string cmd = transport->getCommand();\n\n  do {\n    if (cmd == \"\" || cmd == \"help\") {\n      string usage =\n        \"/stop:            stop the web server\\n\"\n        \"    instance-id   optional, if specified, instance ID has to match\\n\"\n        \"/oom-kill:        abort all requests whose memory usage exceed\\n\"\n        \"                  Server.RequestMemoryOOMKillBytes\\n\"\n        \"/free-mem:        ask allocator to release unused memory to system\\n\"\n        \"/prepare-to-stop: ask the server to prepare for stopping\\n\"\n        \"/flush-profile:   flush profiling counters (in -fprofile-gen builds)\\n\"\n        \"/flush-logs:      trigger batching log-writers to flush all content\\n\"\n        \"/translate:       translate hex encoded stacktrace in 'stack' param\\n\"\n        \"    stack         required, stack trace to translate\\n\"\n        \"    build-id      optional, if specified, build ID has to match\\n\"\n        \"    bare          optional, whether to display frame ordinates\\n\"\n        \"/build-id:        returns build id that's passed in from command line\"\n        \"\\n\"\n        \"/instance-id:     instance id that's passed in from command line\\n\"\n        \"/compiler-id:     returns the compiler id that built this app\\n\"\n        \"/config-id:       returns the config id passed in from command line\\n\"\n        \"/repo-schema:     return the repo schema id used by this app\\n\"\n        \"/ini-get-all:     dump all settings as JSON\\n\"\n        \"/check-load:      how many threads are actively handling requests\\n\"\n        \"/check-queued:    how many http requests are queued waiting to be\\n\"\n        \"                  handled\\n\"\n        \"/check-health:    return json containing basic load/usage stats\\n\"\n        \"/check-ev:        how many http requests are active by libevent\\n\"\n        \"/check-pl-load:   how many pagelet threads are actively handling\\n\"\n        \"                  requests\\n\"\n        \"/check-pl-queued: how many pagelet requests are queued waiting to\\n\"\n        \"                  be handled\\n\"\n        \"/check-sql:       report SQL table statistics\\n\"\n        \"/check-sat        how many satellite threads are actively handling\\n\"\n        \"                  requests and queued waiting to be handled\\n\"\n        \"/status.xml:      show server status in XML\\n\"\n        \"/status.json:     show server status in JSON\\n\"\n        \"/status.html:     show server status in HTML\\n\"\n\n        \"/rqtrace-stats:   show aggregate request trace stats in JSON\\n\"\n\n        \"/memory.xml:      show memory status in XML\\n\"\n        \"/memory.json:     show memory status in JSON\\n\"\n        \"/memory.html:     show memory status in HTML\\n\"\n\n        \"/statcache-clear: clear the stat cache entries\\n\"\n\n        \"/stats-on:        main switch: enable server stats\\n\"\n        \"/stats-off:       main switch: disable server stats\\n\"\n        \"/stats-clear:     clear all server stats\\n\"\n\n        \"/stats-web:       turn on/off server page stats (CPU and gen time)\\n\"\n        \"/stats-mem:       turn on/off memory statistics\\n\"\n        \"/stats-sql:       turn on/off SQL statistics\\n\"\n        \"/stats-mutex:     turn on/off mutex statistics\\n\"\n        \"    sampling      optional, default 1000\\n\"\n\n        \"/stats.keys:      list all available keys\\n\"\n        \"    from          optional, <timestamp>, or <-n> second ago\\n\"\n        \"    to            optional, <timestamp>, or <-n> second ago\\n\"\n        \"/stats.kvp:       show server stats in key-value pairs\\n\"\n        \"    from          optional, <timestamp>, or <-n> second ago\\n\"\n        \"    to            optional, <timestamp>, or <-n> second ago\\n\"\n        \"    agg           optional, aggragation: *, url, code\\n\"\n        \"    keys          optional, <key>,<key/hit>,<key/sec>,<:regex:>\\n\"\n        \"    url           optional, only stats of this page or URL\\n\"\n        \"    code          optional, only stats of pages returning this code\\n\"\n\n        \"/xenon-snap:      generate a Xenon snapshot, which is logged later\\n\"\n        \"/hugepage:        show stats about hugepage usage\\n\"\n        \"/jit-des-info:    show information about deserialized profile data\\n\"\n\n        \"/const-ss:        get const_map_size\\n\"\n        \"/static-strings:  get number of static strings\\n\"\n        \"/static-strings-rds: ... that correspond to defined constants\\n\"\n        \"/dump-static-strings: dump static strings to /tmp/static_strings\\n\"\n        \"/random-static-strings: return randomly selected static strings\\n\"\n        \"    count         number of strings to return, default 1\\n\"\n        \"/dump-apc:        dump all current value in APC to /tmp/apc_dump\\n\"\n        \"/dump-apc-prefix: dump a key prefix contents from APC to\\n\"\n        \"                  /tmp/apc_dump_prefix\\n\"\n        \"    prefix        required, the prefix to dump\\n\"\n        \"    count         optional, the number of keys to dump, default 1\\n\"\n        \"/dump-apc-info:   show basic APC stats\\n\"\n        \"/dump-apc-meta:   dump meta information for all objects in APC to\\n\"\n        \"                  /tmp/apc_dump_meta\\n\"\n        \"/advise-out-apc:  forcibly madvise out APC prime data\\n\"\n        \"/random-apc:      dump the key and size of a random APC entry\\n\"\n        \"    count         number of entries to return\\n\"\n        \"/treadmill:       dump treadmill information\\n\"\n\n        \"/pcre-cache-size: get pcre cache map size\\n\"\n        \"/dump-pcre-cache: dump cached pcre's to /tmp/pcre_cache\\n\"\n        \"/dump-array-info: dump array tracer info to /tmp/array_tracer_dump\\n\"\n\n        \"/invalidate-units: remove specified files from the unit cache\\n\"\n        \"    path           absolute path of files to invalidate\\n\"\n\n        \"/start-stacktrace-profiler: set enable_stacktrace_profiler to true\\n\"\n        \"/relocate:        relocate translations\\n\"\n        \"    random        optional, default false, relocate random subset\\n\"\n        \"       all        optional, default false, relocate all translations\\n\"\n        \"      time        optional, default 20 (seconds)\\n\"\n#ifdef HPHP_TRACE\n        \"/trace-request:   write trace for next request(s) to \"\n        + RuntimeOption::getTraceOutputFile() + \"\\n\"\n        \"    spec          module:level,... spec; see hphp/util/trace.h\\n\"\n        \"    count         optional, total requests to trace (default: 1)\\n\"\n        \"    url           optional, trace only if URL contains \\'url\\'\\n\"\n#endif\n#ifdef GOOGLE_CPU_PROFILER\n        \"/prof-cpu-on:     turn on CPU profiler\\n\"\n        \"/prof-cpu-off:    turn off CPU profiler\\n\"\n#endif\n#ifdef EXECUTION_PROFILER\n        \"/prof-exe:        returns sampled execution profile\\n\"\n#endif\n        \"/vm-tcspace:      show space used by translator caches\\n\"\n        \"/vm-tcaddr:       show addresses of translation cache sections\\n\"\n        \"/vm-dump-tc:      dump translation cache to /tmp/tc_dump_a and\\n\"\n        \"                  /tmp/tc_dump_astub\\n\"\n        \"/vm-namedentities:show size of the NamedEntityTable\\n\"\n        \"/proxy:           set up request proxy\\n\"\n        \"    origin        URL to proxy requests to\\n\"\n        \"    percentage    percentage of requests to proxy\\n\"\n        \"/load-factor:     get or set load factor\\n\"\n        \"    set           optional, set new load factor (default 1.0,\\n\"\n        \"                  valid range [-1.0, 10.0])\\n\"\n        \"/queue-discount:  get/set how much we discount the queue-length \\n\"\n        \"    set           optional, set discount value (default 0,\\n\"\n        \"                  valid range [0, 10000])\\n\"\n        \"/warmup-status:   Describes state of JIT warmup.\\n\"\n        \"                  Returns empty string if warmed up.\\n\"\n        ;\n#ifdef USE_TCMALLOC\n        if (MallocExtensionInstance) {\n          usage.append(\n              \"/tcmalloc-stats:  get internal tcmalloc stats\\n\"\n              \"/tcmalloc-set-tc: set max mem tcmalloc thread-cache can use\\n\"\n          );\n        }\n#endif\n\n#ifdef USE_JEMALLOC\n        if (mallctl) {\n          usage.append(\n              \"/jemalloc-stats:  get internal jemalloc stats\\n\"\n              \"/jemalloc-stats-print:\\n\"\n              \"                  get comprehensive jemalloc stats in\\n\"\n              \"                  human-readable form\\n\"\n              \"/jemalloc-prof-activate:\\n\"\n              \"                  activate heap profiling\\n\"\n              \"/jemalloc-prof-deactivate:\\n\"\n              \"                  deactivate heap profiling\\n\"\n              \"/jemalloc-prof-dump:\\n\"\n              \"                  dump heap profile\\n\"\n              \"    file          optional, filesystem path\\n\"\n              \"/jemalloc-prof-request:\\n\"\n              \"                  dump thread-local heap profile in\\n\"\n              \"                  the next request that runs\\n\"\n              \"    file          optional, filesystem path\\n\"\n          );\n#ifdef ENABLE_HHPROF\n          usage.append(\n              \"/hhprof/start:    start profiling\\n\"\n              \"    requestType   \\\"all\\\" or \\\"next\\\"*\\n\"\n              \"    url           profile next matching url for \\\"next\\\"\\n\"\n              \"    lgSample      lg sample rate\\n\"\n              \"    profileType   \\\"current\\\"* or \\\"cumulative\\\"\\n\"\n              \"/hhprof/status:   configuration and current dump status\\n\"\n              \"/hhprof/stop:     stop profiling\\n\"\n              \"/pprof/cmdline:   program command line\\n\"\n              \"/pprof/heap:      heap dump\\n\"\n              \"/pprof/symbol:    symbol lookup\\n\"\n          );\n#endif // ENABLE_HHPROF\n        }\n#endif // USE_JEMALLOC\n\n      AdminCommandExt::iterate([&](AdminCommandExt* ace) {\n        usage.append(ace->usage());\n        return false;\n      });\n\n      transport->sendString(usage);\n      break;\n    }\n\n    bool needs_password = (cmd != \"build-id\") && (cmd != \"compiler-id\") &&\n                          (cmd != \"instance-id\") && (cmd != \"flush-logs\") &&\n                          (cmd != \"warmup-status\") && (cmd != \"config-id\")\n#if defined(ENABLE_HHPROF) && defined(USE_JEMALLOC)\n                          && (mallctl == nullptr || (\n                                 (cmd != \"hhprof/start\")\n                              && (cmd != \"hhprof/status\")\n                              && (cmd != \"hhprof/stop\")\n                              && (cmd != \"pprof/cmdline\")\n                              && (cmd != \"pprof/heap\")\n                              && (cmd != \"pprof/symbol\")))\n#endif\n                          ;\n    // When configured, we allow read-only stats to be read without a password.\n    if (needs_password && !RuntimeOption::AdminServerStatsNeedPassword) {\n      if ((strncmp(cmd.c_str(), \"memory.\", 7) == 0) ||\n          (strncmp(cmd.c_str(), \"stats.\", 6) == 0) ||\n          (strncmp(cmd.c_str(), \"check-\", 6) == 0) ||\n          (strncmp(cmd.c_str(), \"static-strings\", 14) == 0) ||\n          cmd == \"hugepage\" || cmd == \"pcre-cache-size\" ||\n          cmd == \"vm-tcspace\" || cmd == \"vm-tcaddr\" ||\n          cmd == \"vm-namedentities\" || cmd == \"jemalloc-stats\") {\n        needs_password = false;\n      }\n    }\n\n    if (needs_password && !RuntimeOption::HashedAdminPasswords.empty()) {\n      bool matched = false;\n#ifdef HAVE_CRYPTO_PWHASH_STR\n      const auto password = transport->getParam(\"auth\");\n      for (const std::string& hash : RuntimeOption::HashedAdminPasswords) {\n        if (crypto_pwhash_str_verify(hash.data(),\n                                     password.data(),\n                                     password.size()) == 0) {\n          matched = true;\n          break;\n        }\n      }\n#endif\n      if (!matched) {\n        transport->sendString(\"Unauthorized\", 401);\n        break;\n      }\n    } else if (needs_password && !RuntimeOption::AdminPasswords.empty()) {\n      std::set<std::string>::const_iterator iter =\n        RuntimeOption::AdminPasswords.find(transport->getParam(\"auth\"));\n      if (iter == RuntimeOption::AdminPasswords.end()) {\n        transport->sendString(\"Unauthorized\", 401);\n        break;\n      }\n    } else {\n      if (needs_password && !RuntimeOption::AdminPassword.empty() &&\n          RuntimeOption::AdminPassword != transport->getParam(\"auth\")) {\n        transport->sendString(\"Unauthorized\", 401);\n        break;\n      }\n    }\n\n    if (cmd == \"stop\") {\n      string instanceId = transport->getParam(\"instance-id\");\n      if (!instanceId.empty() && instanceId != RuntimeOption::InstanceId) {\n        transport->sendString(\"Instance ID doesn't match.\", 500);\n        break;\n      }\n\n      transport->sendString(\"OK\\n\");\n      Logger::Info(\"Got admin port stop request from %s\",\n                   transport->getRemoteHost());\n      HttpServer::Server->stop();\n      break;\n    }\n    if (cmd == \"oom-kill\") {\n      Logger::Info(\"Invoking OOM killer upon admin port request from %s\",\n                   transport->getRemoteHost());\n      auto const server = HttpServer::Server->getPageServer();\n      RequestInfo::InvokeOOMKiller(server->getActiveWorker());\n      transport->sendString(\"OOM killer invoked\");\n      break;\n    }\n    if (cmd == \"free-mem\") {\n      const auto before = Process::GetMemUsageMb();\n      std::string errStr;\n      if (purge_all(&errStr)) {\n        const auto after = Process::GetMemUsageMb();\n        transport->sendString(\n          folly::sformat(\"Purged {} -> {} MB RSS\", before, after).c_str());\n      } else {\n        transport->sendString(errStr.c_str(), 500);\n      }\n      break;\n    }\n    if (cmd == \"prepare-to-stop\") {\n      Logger::Info(\"Got admin port prepare-to-stop request from %s\",\n                   transport->getRemoteHost());\n      MemInfo info, newInfo;\n      Process::GetMemoryInfo(info);\n      HttpServer::PrepareToStop();\n\n      // We may consider purge_all() here, too.  But since requests\n      // are still coming in, it may not be very useful, and has some\n      // performance penalties.\n\n      // TODO: evaluate the effect of sync() and uncomment if\n      // desirable.  It is blocking and can take some time, so do it\n      // in a separate thread.\n      // std::thread t{sync};\n      // t.detach();\n\n      transport->sendString(\"OK\\n\");\n      Process::GetMemoryInfo(newInfo);\n      Logger::FInfo(\"free/cached/buffer {}/{}/{} -> {}/{}/{}\",\n                    info.freeMb, info.cachedMb, info.buffersMb,\n                    newInfo.freeMb, newInfo.cachedMb, newInfo.buffersMb);\n      break;\n    }\n    if (cmd == \"flush-profile\") {\n      HttpServer::ProfileFlush();\n      // send the response *after* flushing, so the caller knows the\n      // data has been updated.\n      transport->sendString(\"OK\\n\");\n      break;\n    }\n    if (cmd == \"flush-logs\") {\n      transport->sendString(\"OK\\n\");\n      Logger::FlushAll();\n      HttpRequestHandler::GetAccessLog().flushAllWriters();\n      AdminRequestHandler::GetAccessLog().flushAllWriters();\n      RPCRequestHandler::GetAccessLog().flushAllWriters();\n      break;\n    }\n    if (cmd == \"set-log-level\") {\n      string result(\"OK\\n\");\n      string level = transport->getParam(\"level\");\n      if (level == \"None\") {\n        Logger::LogLevel = Logger::LogNone;\n      } else if (level == \"Error\") {\n        Logger::LogLevel = Logger::LogError;\n      } else if (level == \"Warning\") {\n        Logger::LogLevel = Logger::LogWarning;\n      } else if (level == \"Info\") {\n        Logger::LogLevel = Logger::LogInfo;\n      } else if (level == \"Verbose\") {\n        Logger::LogLevel = Logger::LogVerbose;\n      } else {\n        result = \"Failed to set log level\\n\";\n      }\n\n      transport->sendString(result);\n      break;\n    }\n#ifdef HPHP_TRACE\n    if (cmd == \"trace-request\") {\n      Trace::ensureInit(RuntimeOption::getTraceOutputFile());\n      // Just discard any existing task.\n      delete s_traceTask.exchange(\n        new TraceTask{transport->getParam(\"spec\"),\n                      transport->getParam(\"url\"),\n                      std::max(transport->getInt64Param(\"count\"), 1ll)},\n        std::memory_order_acq_rel);\n      transport->sendString(\"OK\\n\");\n      break;\n    }\n#endif\n    if (cmd == \"build-id\") {\n      transport->sendString(RuntimeOption::BuildId, 200);\n      break;\n    }\n    if (cmd == \"instance-id\") {\n      transport->sendString(RuntimeOption::InstanceId, 200);\n      break;\n    }\n    if (cmd == \"compiler-id\") {\n      transport->sendString(compilerId().begin(), 200);\n      break;\n    }\n    if (cmd == \"config-id\") {\n      transport->sendString(std::to_string(RuntimeOption::ConfigId), 200);\n      break;\n    }\n    if (cmd == \"repo-schema\") {\n      transport->sendString(repoSchemaId().begin(), 200);\n      break;\n    }\n    if (cmd == \"translate\") {\n      string buildId = transport->getParam(\"build-id\");\n      if (!buildId.empty() && buildId != RuntimeOption::BuildId) {\n        transport->sendString(\"Build ID doesn't match.\", 500);\n        break;\n      }\n\n      string translated = translate_stack(transport->getParam(\"stack\").c_str(),\n                                          transport->getParam(\"bare\").empty());\n      transport->sendString(translated);\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"check\", 5) == 0 &&\n        handleCheckRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"status\", 6) == 0 &&\n        handleStatusRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(),\"memory\", 6) == 0 &&\n        handleMemoryRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"stats\", 5) == 0 &&\n        handleStatsRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"prof\", 4) == 0 &&\n        handleProfileRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"dump-apc\", 8) == 0 &&\n        handleDumpCacheRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"invalidate-units\", 16) == 0 &&\n        handleInvalidateUnitRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"xenon-snap\", 10) == 0) {\n      static int64_t s_lastSampleTime = 0;\n      auto const current = TimeStamp::Current();\n      if (current > s_lastSampleTime) {\n        s_lastSampleTime = current;\n        Xenon::getInstance().surpriseAll();\n      }\n      transport->sendString(\"a Xenon sample will be collected\\n\", 200);\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"hugepage\", 9) == 0) {\n#if USE_JEMALLOC_EXTENT_HOOKS\n      std::string msg =\n        folly::sformat(\"{} 1G huge pages active\\n\", num_1g_pages());\n      if (auto a = alloc::lowArena()) {\n        msg += a->reportStats();\n      }\n      if (auto a = alloc::highArena()) {\n        msg += a->reportStats();\n      }\n      transport->sendString(msg, 200);\n#else\n      transport->sendString(\"\", 200);\n#endif\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"jit-des-info\", 13) == 0) {\n      if (!jit::ProfData::wasDeserialized()) {\n        transport->sendString(\"\", 200);\n        break;\n      }\n      auto msg = folly::sformat(\"{}:{}\",\n                                jit::ProfData::buildHost()->slice(),\n                                jit::ProfData::buildTime());\n      transport->sendString(msg, 200);\n    }\n\n    if (strncmp(cmd.c_str(), \"const-ss\", 8) == 0 &&\n        handleConstSizeRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"static-strings\", 14) == 0 &&\n        handleStaticStringsRequest(cmd, transport)) {\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"dump-static-strings\", 19) == 0) {\n      auto filename = transport->getParam(\"file\");\n      if (filename == \"\") filename = \"/tmp/static_strings\";\n      handleDumpStaticStringsRequest(cmd, filename);\n      transport->sendString(\"OK\\n\");\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"random-static-strings\", 21) == 0) {\n      handleRandomStaticStringsRequest(cmd, transport);\n      break;\n    }\n    if (strncmp(cmd.c_str(), \"vm-\", 3) == 0 &&\n        handleVMRequest(cmd, transport)) {\n      break;\n    }\n    if (cmd == \"proxy\") {\n      handleProxyRequest(cmd, transport);\n      break;\n    }\n\n    if (cmd == \"statcache-clear\") {\n      StatCache::clearCache();\n      break;\n    }\n\n    if (cmd == \"pcre-cache-size\") {\n      std::ostringstream size;\n      size << preg_pcre_cache_size() << endl;\n      transport->sendString(size.str());\n      break;\n    }\n\n    if (cmd == \"dump-pcre-cache\") {\n      auto filename = transport->getParam(\"file\");\n      if (filename == \"\") filename = \"/tmp/pcre_cache\";\n      pcre_dump_cache(filename);\n      transport->sendString(\"OK\\n\");\n      break;\n    }\n\n    if (cmd == \"start-stacktrace-profiler\") {\n      enable_stacktrace_profiler = true;\n      transport->sendString(\"OK\\n\");\n      break;\n    }\n\n    if (cmd == \"warmup-status\") {\n      transport->sendString(jit::tc::warmupStatusString());\n      break;\n    }\n\n    if (cmd == \"advise-out-apc\") {\n      if (!apcExtension::Enable) {\n        transport->sendString(\"No APC\\n\");\n        break;\n      }\n      apc_advise_out();\n      transport->sendString(\"Done\\n\");\n      break;\n    }\n\n    if (strncmp(cmd.c_str(), \"random-apc\", 10) == 0 &&\n        handleRandomApcRequest(cmd, transport)) {\n      break;\n    }\n    if (cmd == \"treadmill\") {\n      transport->sendString(Treadmill::dumpTreadmillInfo());\n      break;\n    }\n\n    if (cmd == \"load-factor\") {\n      auto const factorStr = transport->getParam(\"set\");\n      if (factorStr.empty()) {\n        std::ostringstream oss;\n        oss << std::fixed << std::setprecision(3)\n            << HttpServer::LoadFactor.load();\n        transport->sendString(oss.str());\n        break;\n      }\n      double factor = 1.0;\n      if (sscanf(factorStr.c_str(), \"%lf\", &factor) < 1 ||\n          factor > 10 || factor < -1) {\n        transport->sendString(\"Invalid load factor spec: \" + factorStr, 400);\n        break;\n      }\n      HttpServer::LoadFactor.store(factor, std::memory_order_relaxed);\n      transport->sendString(folly::sformat(\"Load factor updated to {}\\n\",\n                                           factor));\n      Logger::Info(\"Load factor updated to %lf\", factor);\n      break;\n    }\n    if (cmd == \"queue-discount\") {\n      auto const discountStr = transport->getParam(\"set\");\n      if (discountStr.empty()) {\n        transport->sendString(folly::to<string>(\n          HttpServer::QueueDiscount.load(std::memory_order_relaxed)));\n        break;\n      }\n      int queue_discount = 0;\n      if (sscanf(discountStr.c_str(), \"%d\", &queue_discount) < 1 ||\n          queue_discount > 10000 || queue_discount < 0) {\n        transport->sendString(\"Invalid queue discount spec: \" +\n          discountStr, 400);\n        break;\n      }\n      HttpServer::QueueDiscount.store(queue_discount,\n        std::memory_order_relaxed);\n      transport->sendString(folly::sformat(\"Queue Discount updated to {}\\n\",\n        queue_discount));\n      Logger::Info(\"Queue Discount updated to %d\", queue_discount);\n      break;\n    }\n    if (cmd == \"ini-get-all\") {\n      auto out = IniSetting::GetAllAsJSON();\n      transport->sendString(out.c_str());\n      break;\n    }\n\n    if (cmd == \"numa-info\") {\n      std::ostringstream out;\n#ifdef HAVE_NUMA\n      out << \"use_numa: \" << use_numa << endl;\n      out << \"numa_num_nodes: \" << numa_num_nodes << endl;\n      out << \"numa_node_mask: \" << numa_node_mask << endl;\n      out << \"numa_node_set: \" << numa_node_set << endl;\n#else\n      out << \"HAVE_NUMA not defined\" << endl;\n#endif\n      transport->sendString(out.str());\n      break;\n    }\n\n#ifdef USE_JEMALLOC\n    assertx(mallctlnametomib && mallctlbymib);\n    if (cmd == \"jemalloc-stats\") {\n      // jemalloc stats update is periodically triggered in the\n      // host-health-monitor thread.\n      uint32_t error = 0;\n\n      auto call_mallctl = [&](const char* statName) {\n        size_t value = 0;\n        if (mallctlRead<size_t, true>(statName, &value) != 0) {\n          error = 1;\n        }\n        return value;\n      };\n      size_t allocated = call_mallctl(\"stats.allocated\");\n      size_t active = call_mallctl(\"stats.active\");\n      size_t mapped = call_mallctl(\"stats.mapped\");\n\n#if USE_JEMALLOC_EXTENT_HOOKS\n      size_t low_mapped = 0;\n      // The low range [1G, 4G) is divided into two ranges, and shared by 3\n      // arenas.\n      low_mapped += alloc::getRange(alloc::AddrRangeClass::VeryLow).used();\n      low_mapped += alloc::getRange(alloc::AddrRangeClass::Low).used();\n#else\n      size_t low_mapped = call_mallctl(\n          folly::sformat(\"stats.arenas.{}.mapped\",\n                         low_arena).c_str());\n#endif\n      std::ostringstream stats;\n      stats << \"<jemalloc-stats>\" << endl;\n      stats << \"  <allocated>\" << allocated << \"</allocated>\" << endl;\n      stats << \"  <active>\" << active << \"</active>\" << endl;\n      stats << \"  <mapped>\" << mapped << \"</mapped>\" << endl;\n      stats << \"  <low_mapped>\" << low_mapped << \"</low_mapped>\" << endl;\n      stats << \"</jemalloc-stats>\" << endl;\n      transport->sendString(stats.str());\n      break;\n    }\n    if (cmd == \"jemalloc-stats-print\") {\n      malloc_write mwo;\n\n      malloc_write_init(&mwo);\n      malloc_stats_print(malloc_write_cb, (void *)&mwo, \"\");\n      if (mwo.oom) {\n        malloc_write_fini(&mwo);\n        transport->sendString(\"OOM\\n\");\n        break;\n      }\n\n      transport->sendString(mwo.s == nullptr ? \"\" : mwo.s);\n      malloc_write_fini(&mwo);\n      break;\n    }\n    if (cmd == \"jemalloc-prof-activate\") {\n      if (jemalloc_pprof_enable()) {\n        transport->sendString(\"Error in mallctl(\\\"prof.active\\\", true)\\n\");\n      } else {\n        transport->sendString(\"OK\\n\");\n      }\n      break;\n    }\n    if (cmd == \"jemalloc-prof-deactivate\") {\n      if (jemalloc_pprof_disable()) {\n        transport->sendString(\"Error in mallctl(\\\"prof.active\\\", false)\\n\");\n      } else {\n        transport->sendString(\"OK\\n\");\n      }\n      break;\n    }\n    if (cmd == \"jemalloc-prof-dump\") {\n      string f = transport->getParam(\"file\");\n      if (jemalloc_pprof_dump(f, true)) {\n        transport->sendString(\"Error in mallctl(\\\"prof.dump\\\", \" + f + \")\\n\");\n      } else {\n        transport->sendString(\"OK\\n\");\n      }\n      break;\n    }\n    if (cmd == \"jemalloc-prof-request\") {\n      auto f = transport->getParam(\"file\");\n      bool success = MemoryManager::triggerProfiling(f);\n\n      if (success) {\n        transport->sendString(\"OK\\n\");\n      } else {\n        transport->sendString(\"Request profiling already triggered\\n\");\n      }\n      break;\n    }\n#ifdef ENABLE_HHPROF\n    if (cmd == \"hhprof/start\") {\n      HHProf::HandleHHProfStart(transport);\n      break;\n    }\n    if (cmd == \"hhprof/status\") {\n      HHProf::HandleHHProfStatus(transport);\n      break;\n    }\n    if (cmd == \"hhprof/stop\") {\n      HHProf::HandleHHProfStop(transport);\n      break;\n    }\n    if (cmd == \"pprof/cmdline\") {\n      HHProf::HandlePProfCmdline(transport);\n      break;\n    }\n    if (cmd == \"pprof/heap\") {\n      HHProf::HandlePProfHeap(transport);\n      break;\n    }\n    if (cmd == \"pprof/symbol\") {\n      HHProf::HandlePProfSymbol(transport);\n      break;\n    }\n#endif // ENABLE_HHPROF\n#endif // USE_JEMALLOC\n\n    if (cmd == \"rqtrace-stats\") {\n      std::stringstream out;\n      bool first = true;\n      out << \"{\" << endl;\n      auto appendStat =\n        [&](folly::StringPiece name, folly::StringPiece kind, int64_t value) {\n          out << folly::format(\n            \"{} \\\"{}_{}\\\":{}\\n\", first ? \"\" : \",\", name, kind, value);\n          first = false;\n        };\n      rqtrace::visit_process_stats(\n        [&] (const StringData* name, rqtrace::EventStats stats) {\n          appendStat(name->data(), \"duration\", stats.total_duration);\n          appendStat(name->data(), \"count\", stats.total_count);\n        }\n      );\n      out << \"}\" << endl;\n      transport->sendString(out.str());\n      break;\n    }\n\n    if (AdminCommandExt::iterate([&](AdminCommandExt* ace) {\n          return ace->handleRequest(transport);\n       })) {\n      break;\n    }\n\n    transport->sendString(\"Unknown command: \" + cmd + \"\\n\", 404);\n  } while (0);\n  transport->onSendEnd();\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 374,
        "code": "TfLiteStatus ReverseSequenceImpl(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* seq_lengths_tensor =\n      GetInput(context, node, kSeqLengthsTensor);\n  const TS* seq_lengths = GetTensorData<TS>(seq_lengths_tensor);\n\n  auto* params =\n      reinterpret_cast<TfLiteReverseSequenceParams*>(node->builtin_data);\n  int seq_dim = params->seq_dim;\n  int batch_dim = params->batch_dim;\n\n  TF_LITE_ENSURE(context, seq_dim >= 0);\n  TF_LITE_ENSURE(context, batch_dim >= 0);\n  TF_LITE_ENSURE(context, seq_dim != batch_dim);\n  TF_LITE_ENSURE(context, seq_dim < NumDimensions(input));\n  TF_LITE_ENSURE(context, batch_dim < NumDimensions(input));\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(seq_lengths_tensor, 0),\n                    SizeOfDimension(input, batch_dim));\n  for (int i = 0; i < NumDimensions(seq_lengths_tensor); ++i) {\n    TF_LITE_ENSURE(context, seq_lengths[i] <= SizeOfDimension(input, seq_dim));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  reference_ops::ReverseSequence<T, TS>(\n      seq_lengths, seq_dim, batch_dim, GetTensorShape(input),\n      GetTensorData<T>(input), GetTensorShape(output),\n      GetTensorData<T>(output));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 375,
        "code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  // Step 1: Determine the total uncompressed size. This requires serializing\n  // non-memcopyable tensors, which we save to use again later.\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      // Some datatypes can be memcopied, allowing us to save two copies\n      // (AsProtoTensorContent and SerializeToArray).\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n\n  // Step 2: Write the tensor data to a buffer, and compress that buffer.\n  // We use tstring for access to resize_uninitialized.\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  // Position in `uncompressed` to write the next component.\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37637"
    },
    {
        "index": 376,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_6String_3write_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_items = 0;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"write_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 1); __PYX_ERR(0, 26, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 2); __PYX_ERR(0, 26, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"write_items\") < 0)) __PYX_ERR(0, 26, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_items = values[1];\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 26, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.String.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_6String_2write_items(__pyx_self, __pyx_v_self, __pyx_v_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 377,
        "code": "std::unique_ptr<BytecodeModule> BytecodeModuleGenerator::generate() {\n  assert(\n      valid_ &&\n      \"BytecodeModuleGenerator::generate() cannot be called more than once\");\n  valid_ = false;\n\n  assert(\n      functionIDMap_.getElements().size() == functionGenerators_.size() &&\n      \"Missing functions.\");\n\n  auto kinds = stringTable_.getStringKinds();\n  auto hashes = stringTable_.getIdentifierHashes();\n\n  BytecodeOptions bytecodeOptions;\n  bytecodeOptions.staticBuiltins = options_.staticBuiltinsEnabled;\n  bytecodeOptions.cjsModulesStaticallyResolved = !cjsModulesStatic_.empty();\n  std::unique_ptr<BytecodeModule> BM{new BytecodeModule(\n      functionGenerators_.size(),\n      std::move(kinds),\n      std::move(hashes),\n      stringTable_.acquireStringTable(),\n      stringTable_.acquireStringStorage(),\n      regExpTable_.getEntryList(),\n      regExpTable_.getBytecodeBuffer(),\n      entryPointIndex_,\n      std::move(arrayBuffer_),\n      std::move(objKeyBuffer_),\n      std::move(objValBuffer_),\n      cjsModuleOffset_,\n      std::move(cjsModules_),\n      std::move(cjsModulesStatic_),\n      bytecodeOptions)};\n\n  DebugInfoGenerator debugInfoGen{std::move(filenameTable_)};\n\n  const uint32_t strippedFunctionNameId =\n      options_.stripFunctionNames ? getStringID(kStrippedFunctionName) : 0;\n  auto functions = functionIDMap_.getElements();\n  std::shared_ptr<Context> contextIfNeeded;\n  for (unsigned i = 0, e = functions.size(); i < e; ++i) {\n    auto *F = functions[i];\n    auto &BFG = *functionGenerators_[F];\n\n    uint32_t functionNameId = options_.stripFunctionNames\n        ? strippedFunctionNameId\n        : getStringID(functions[i]->getOriginalOrInferredName().str());\n\n    std::unique_ptr<BytecodeFunction> func = BFG.generateBytecodeFunction(\n        F->getDefinitionKind(),\n        F->getKind(),\n        F->isStrictMode(),\n        F->getExpectedParamCountIncludingThis(),\n        F->getFunctionScope()->getVariables().size(),\n        functionNameId);\n\n#ifndef HERMESVM_LEAN\n    if (F->getParent()\n            ->shareContext()\n            ->allowFunctionToStringWithRuntimeSource() ||\n        F->isLazy()) {\n      auto context = F->getParent()->shareContext();\n      assert(\n          (!contextIfNeeded || contextIfNeeded.get() == context.get()) &&\n          \"Different instances of Context seen\");\n      contextIfNeeded = context;\n      BM->setFunctionSourceRange(i, F->getSourceRange());\n    }\n#endif\n\n    if (F->isLazy()) {\n#ifdef HERMESVM_LEAN\n      llvm_unreachable(\"Lazy support compiled out\");\n#else\n      auto lazyData = llvh::make_unique<LazyCompilationData>();\n      lazyData->parentScope = F->getLazyScope();\n      lazyData->nodeKind = F->getLazySource().nodeKind;\n      lazyData->bufferId = F->getLazySource().bufferId;\n      lazyData->originalName = F->getOriginalOrInferredName();\n      lazyData->closureAlias = F->getLazyClosureAlias()\n          ? F->getLazyClosureAlias()->getName()\n          : Identifier();\n      lazyData->strictMode = F->isStrictMode();\n      func->setLazyCompilationData(std::move(lazyData));\n#endif\n    }\n\n    if (BFG.hasDebugInfo()) {\n      uint32_t sourceLocOffset = debugInfoGen.appendSourceLocations(\n          BFG.getSourceLocation(), i, BFG.getDebugLocations());\n      uint32_t lexicalDataOffset = debugInfoGen.appendLexicalData(\n          BFG.getLexicalParentID(), BFG.getDebugVariableNames());\n      func->setDebugOffsets({sourceLocOffset, lexicalDataOffset});\n    }\n    BM->setFunction(i, std::move(func));\n  }\n\n  BM->setContext(contextIfNeeded);\n\n  BM->setDebugInfo(debugInfoGen.serializeWithMove());\n  return BM;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 378,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (output->type) {\n    case kTfLiteInt32: {\n      // TensorFlow does not support negative for int32.\n      TF_LITE_ENSURE_OK(context, CheckValue(context, input2));\n      PowImpl<int32_t>(input1, input2, output, data->requires_broadcast);\n      break;\n    }\n    case kTfLiteFloat32: {\n      PowImpl<float>(input1, input2, output, data->requires_broadcast);\n      break;\n    }\n    default: {\n      context->ReportError(context, \"Unsupported data type: %d\", output->type);\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 379,
        "code": "static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n       // obj->arrCnt++;\n    }\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22874"
    },
    {
        "index": 380,
        "code": "static int mongo_read_response( mongo *conn, mongo_reply **reply ) {\n    mongo_header head; /* header from network */\n    mongo_reply_fields fields; /* header from network */\n    mongo_reply *out;  /* native endian */\n    unsigned int len;\n    int res;\n\n    mongo_env_read_socket( conn, &head, sizeof( head ) );\n    mongo_env_read_socket( conn, &fields, sizeof( fields ) );\n\n    bson_little_endian32( &len, &head.len );\n\n    if ( len < sizeof( head )+sizeof( fields ) || len > 64*1024*1024 )\n        return MONGO_READ_SIZE_ERROR;  /* most likely corruption */\n\n    out = ( mongo_reply * )bson_malloc( len );\n\n    out->head.len = len;\n    bson_little_endian32( &out->head.id, &head.id );\n    bson_little_endian32( &out->head.responseTo, &head.responseTo );\n    bson_little_endian32( &out->head.op, &head.op );\n\n    bson_little_endian32( &out->fields.flag, &fields.flag );\n    bson_little_endian64( &out->fields.cursorID, &fields.cursorID );\n    bson_little_endian32( &out->fields.start, &fields.start );\n    bson_little_endian32( &out->fields.num, &fields.num );\n\n    res = mongo_env_read_socket( conn, &out->objs, len-sizeof( head )-sizeof( fields ) );\n    if( res != MONGO_OK ) {\n        bson_free( out );\n        return res;\n    }\n\n    *reply = out;\n\n    return MONGO_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 381,
        "code": "TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,\n                                      TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  *data->invoke_count += 1;\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const uint8_t* input_data = GetTensorData<uint8_t>(input);\n  int size = NumElements(input->dims);\n\n  uint8_t* sorting_buffer = reinterpret_cast<uint8_t*>(\n      context->GetScratchBuffer(context, data->sorting_buffer));\n  // Copy inputs data to the sorting buffer. We don't want to mutate the input\n  // tensor as it might be used by a another node.\n  for (int i = 0; i < size; i++) {\n    sorting_buffer[i] = input_data[i];\n  }\n\n  // In place insertion sort on `sorting_buffer`.\n  for (int i = 1; i < size; i++) {\n    for (int j = i; j > 0 && sorting_buffer[j] < sorting_buffer[j - 1]; j--) {\n      std::swap(sorting_buffer[j], sorting_buffer[j - 1]);\n    }\n  }\n\n  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);\n  uint8_t* median_data = GetTensorData<uint8_t>(median);\n  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);\n  int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);\n\n  median_data[0] = sorting_buffer[size / 2];\n  invoke_count_data[0] = *data->invoke_count;\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 382,
        "code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15212"
    },
    {
        "index": 383,
        "code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 384,
        "code": "find_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = ml_get(lnum);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = ml_get(++lnum);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = ml_get(lnum);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1968"
    },
    {
        "index": 385,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    const double real_multiplier =\n        input1->params.scale / (input2->params.scale * output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 386,
        "code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    ValidateInputs(true /* is save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n\n    const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n    const int num_tensors = static_cast<int>(tensor_names.NumElements());\n    const string& prefix_string = prefix.scalar<tstring>()();\n    const auto& tensor_names_flat = tensor_names.flat<tstring>();\n    const auto& shape_and_slices_flat = shape_and_slices.flat<tstring>();\n\n    BundleWriter writer(Env::Default(), prefix_string);\n    OP_REQUIRES_OK(context, writer.status());\n    VLOG(1) << \"BundleWriter, prefix_string: \" << prefix_string;\n\n    for (int i = 0; i < num_tensors; ++i) {\n      const string& tensor_name = tensor_names_flat(i);\n      const Tensor& tensor = context->input(i + kFixedInputs);\n      VLOG(2) << \"Starting save of \" << tensor_name;\n\n      if (!shape_and_slices_flat(i).empty()) {\n        const string& shape_spec = shape_and_slices_flat(i);\n        TensorShape shape;\n        TensorSlice slice(tensor.dims());\n        TensorShape slice_shape;\n\n        OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                    shape_spec, &shape, &slice, &slice_shape));\n        OP_REQUIRES(context, slice_shape.IsSameSize(tensor.shape()),\n                    errors::InvalidArgument(\"Slice in shape_and_slice \"\n                                            \"specification does not match the \"\n                                            \"shape of the tensor to  save: \",\n                                            shape_spec, \", tensor: \",\n                                            tensor.shape().DebugString()));\n\n        OP_REQUIRES_OK(context,\n                       writer.AddSlice(tensor_name, shape, slice, tensor));\n      } else {\n        OP_REQUIRES_OK(context, writer.Add(tensor_name, tensor));\n      }\n\n      if (VLOG_IS_ON(5)) {\n        if (tensor.dtype() == DT_FLOAT) {\n          const float* t_data = tensor.flat<float>().data();\n          float min = std::numeric_limits<float>::infinity();\n          float max = -std::numeric_limits<float>::infinity();\n          double avg = 0.0;\n          for (int i = 0; i < tensor.NumElements(); ++i) {\n            if (t_data[i] < min) min = t_data[i];\n            if (t_data[i] > max) max = t_data[i];\n            avg += t_data[i];\n          }\n          VLOG(5) << \" min \" << min << \" max \" << max << \" avg \"\n                  << avg / tensor.NumElements() << \" total elts \"\n                  << tensor.NumElements();\n        }\n      }\n\n      VLOG(2) << \"Done save of \" << tensor_name;\n    }\n    OP_REQUIRES_OK(context, writer.Finish());\n    VLOG(1) << \"Done BundleWriter, prefix_string: \" << prefix_string;\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37648"
    },
    {
        "index": 387,
        "code": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-14147"
    },
    {
        "index": 388,
        "code": "get_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\t// In cmdwin, the alternative buffer should be used.\n\tbuf_T *buf =\n#ifdef FEAT_CMDWIN\n\t\t    is_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\t\t    curbuf;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0696"
    },
    {
        "index": 389,
        "code": "void DragController::PerformDrag(DragData* drag_data, LocalFrame& local_root) {\n  DCHECK(drag_data);\n  document_under_mouse_ =\n      local_root.DocumentAtPoint(LayoutPoint(drag_data->ClientPosition()));\n  std::unique_ptr<UserGestureIndicator> gesture = Frame::NotifyUserActivation(\n      document_under_mouse_ ? document_under_mouse_->GetFrame() : nullptr,\n      UserGestureToken::kNewGesture);\n  if ((drag_destination_action_ & kDragDestinationActionDHTML) &&\n      document_is_handling_drag_) {\n    bool prevented_default = false;\n    if (local_root.View()) {\n      DataTransfer* data_transfer =\n          CreateDraggingDataTransfer(kDataTransferReadable, drag_data);\n      data_transfer->SetSourceOperation(\n          drag_data->DraggingSourceOperationMask());\n      EventHandler& event_handler = local_root.GetEventHandler();\n      prevented_default = event_handler.PerformDragAndDrop(\n                              CreateMouseEvent(drag_data), data_transfer) !=\n                          WebInputEventResult::kNotHandled;\n      if (!prevented_default) {\n        const LayoutPoint point = local_root.View()->RootFrameToContents(\n            LayoutPoint(drag_data->ClientPosition()));\n        const HitTestResult result = event_handler.HitTestResultAtPoint(point);\n        prevented_default |=\n            IsHTMLPlugInElement(*result.InnerNode()) &&\n            ToHTMLPlugInElement(result.InnerNode())->CanProcessDrag();\n      }\n\n      data_transfer->SetAccessPolicy(kDataTransferNumb);\n    }\n    if (prevented_default) {\n      document_under_mouse_ = nullptr;\n      CancelDrag();\n      return;\n    }\n  }\n\n  if ((drag_destination_action_ & kDragDestinationActionEdit) &&\n      ConcludeEditDrag(drag_data)) {\n    document_under_mouse_ = nullptr;\n    return;\n  }\n\n  document_under_mouse_ = nullptr;\n\n  if (OperationForLoad(drag_data, local_root) != kDragOperationNone) {\n    if (page_->GetSettings().GetNavigateOnDragDrop()) {\n      ResourceRequest resource_request(drag_data->AsURL());\n       resource_request.SetRequestorOrigin(\n           SecurityOrigin::Create(KURL(drag_data->AsURL())));\n       page_->MainFrame()->Navigate(FrameLoadRequest(nullptr, resource_request));\n     }\n \n    local_root.GetEventHandler().ClearDragState();\n  }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5790"
    },
    {
        "index": 390,
        "code": "bool logToUSDT(const Array& bt) {\n  std::lock_guard<std::mutex> lock(usdt_mutex);\n\n  memset(&bt_slab, 0, sizeof(bt_slab));\n\n  int i = 0;\n  IterateVNoInc(\n    bt.get(),\n    [&](TypedValue tv) -> bool {\n\n      if (i >= strobelight::kMaxStackframes) {\n        return true;\n      }\n\n      assertx(isArrayLikeType(type(tv)));\n      ArrayData* bt_frame = val(tv).parr;\n      strobelight::backtrace_frame_t* frame = &bt_slab.frames[i];\n\n      auto const line = bt_frame->get(s_line.get());\n      if (line.is_init()) {\n        assertx(isIntType(type(line)));\n        frame->line = val(line).num;\n      }\n\n      auto const file_name = bt_frame->get(s_file.get());\n      if (file_name.is_init()) {\n        assertx(isStringType(type(file_name)));\n        strncpy(frame->file_name,\n                val(file_name).pstr->data(),\n                std::min(val(file_name).pstr->size(), strobelight::kFileNameMax));\n        frame->file_name[strobelight::kFileNameMax - 1] = '\\0';\n      }\n\n      auto const class_name = bt_frame->get(s_class.get());\n      if (class_name.is_init()) {\n        assertx(isStringType(type(class_name)));\n        strncpy(frame->class_name,\n                val(class_name).pstr->data(),\n                std::min(val(class_name).pstr->size(), strobelight::kClassNameMax));\n        frame->class_name[strobelight::kClassNameMax - 1] = '\\0';\n      }\n\n      auto const function_name = bt_frame->get(s_function.get());\n      if (function_name.is_init()) {\n        assertx(isStringType(type(function_name)));\n        strncpy(frame->function,\n                val(function_name).pstr->data(),\n                std::min(val(function_name).pstr->size(),\n                         strobelight::kFunctionMax));\n        frame->function[strobelight::kFunctionMax - 1] = '\\0';\n      }\n\n      i++;\n      return false;\n    }\n  );\n  bt_slab.len = i;\n\n  // Allow BPF to read the now-formatted stacktrace\n  FOLLY_SDT_WITH_SEMAPHORE(hhvm, hhvm_stack, &bt_slab);\n\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 391,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* lookup = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(lookup), 1);\n  TF_LITE_ENSURE_EQ(context, lookup->type, kTfLiteInt32);\n\n  const TfLiteTensor* value = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, NumDimensions(value) >= 2);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(NumDimensions(value));\n\n  outputSize->data[0] = SizeOfDimension(lookup, 0);\n  outputSize->data[1] = SizeOfDimension(value, 1);\n  for (int i = 2; i < NumDimensions(value); i++) {\n    outputSize->data[i] = SizeOfDimension(value, i);\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 392,
        "code": "void UnicodeStringTest::TestUnicodeStringInsertAppendToSelf() {\n    IcuTestErrorCode status(*this, \"TestUnicodeStringAppendToSelf\");\n\n    // Test append operation\n    UnicodeString str(u\"foo \");\n    str.append(str);\n    str.append(str);\n    str.append(str);\n    assertEquals(\"\", u\"foo foo foo foo foo foo foo foo \", str);\n\n    // Test append operation with readonly alias to start\n    str = UnicodeString(TRUE, u\"foo \", 4);\n    str.append(str);\n    str.append(str);\n    str.append(str);\n    assertEquals(\"\", u\"foo foo foo foo foo foo foo foo \", str);\n\n    // Test append operation with aliased substring\n    str = u\"abcde\";\n    UnicodeString sub = str.tempSubString(1, 2);\n    str.append(sub);\n    assertEquals(\"\", u\"abcdebc\", str);\n\n    // Test append operation with double-aliased substring\n    str = UnicodeString(TRUE, u\"abcde\", 5);\n    sub = str.tempSubString(1, 2);\n    str.append(sub);\n    assertEquals(\"\", u\"abcdebc\", str);\n\n    // Test insert operation\n    str = u\"a-*b\";\n    str.insert(2, str);\n    str.insert(4, str);\n    str.insert(8, str);\n    assertEquals(\"\", u\"a-a-a-a-a-a-a-a-*b*b*b*b*b*b*b*b\", str);\n\n    // Test insert operation with readonly alias to start\n    str = UnicodeString(TRUE, u\"a-*b\", 4);\n    str.insert(2, str);\n    str.insert(4, str);\n    str.insert(8, str);\n    assertEquals(\"\", u\"a-a-a-a-a-a-a-a-*b*b*b*b*b*b*b*b\", str);\n\n    // Test insert operation with aliased substring\n    str = u\"abcde\";\n    sub = str.tempSubString(1, 3);\n    str.insert(2, sub);\n    assertEquals(\"\", u\"abbcdcde\", str);\n\n    // Test insert operation with double-aliased substring\n    str = UnicodeString(TRUE, u\"abcde\", 5);\n    sub = str.tempSubString(1, 3);\n    str.insert(2, sub);\n    assertEquals(\"\", u\"abbcdcde\", str);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-10531"
    },
    {
        "index": 393,
        "code": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-20276"
    },
    {
        "index": 394,
        "code": "TEST_P(LocalJwksIntegrationTest, FilterStateRequirement) {\n  // A config with metadata rules.\n  const std::string auth_filter_conf = R\"(\n  providers:\n    example_provider:\n      issuer: https://example.com\n      audiences:\n      - example_service\n  filter_state_rules:\n    name: jwt_selector\n    requires:\n      example_provider:\n        provider_name: example_provider\n)\";\n\n  config_helper_.prependFilter(getAuthFilterConfig(auth_filter_conf, true));\n  config_helper_.prependFilter(absl::StrCat(\"name: \", HeaderToFilterStateFilterName));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  struct TestCase {\n    std::vector<std::pair<std::string, std::string>> extra_headers;\n    std::string expected_status;\n  };\n\n  const TestCase test_cases[] = {\n      // Case1: not set metadata, so Jwt is not required, expect 200\n      {\n          // Empty extra headers\n          {},\n          \"200\",\n      },\n\n      // Case2: requirement is set in the metadata, but missing token, expect 401\n      {\n          // selector header, but not token header\n          {\n              {\"jwt_selector\", \"example_provider\"},\n          },\n          \"401\",\n      },\n\n      // Case 3: requirement is set in the metadata, token is good, expect 200\n      {\n          // selector header, and token header\n          {\n              {\"jwt_selector\", \"example_provider\"},\n              {\"Authorization\", \"Bearer \" + std::string(GoodToken)},\n          },\n          \"200\",\n      },\n  };\n\n  for (const auto& test : test_cases) {\n    Http::TestRequestHeaderMapImpl headers{\n        {\":method\", \"GET\"},\n        {\":path\", \"/foo\"},\n        {\":scheme\", \"http\"},\n        {\":authority\", \"host\"},\n    };\n    for (const auto& h : test.extra_headers) {\n      headers.addCopy(h.first, h.second);\n    }\n    auto response = codec_client_->makeHeaderOnlyRequest(headers);\n\n    if (test.expected_status == \"200\") {\n      waitForNextUpstreamRequest();\n      upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n    }\n\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(test.expected_status, response->headers().getStatusValue());\n  }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-43824"
    },
    {
        "index": 395,
        "code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tvc_scrolldelta_helper(c, lines, vga_rolled_over, (void *)vga_vram_base,\n\t\t\tvga_vram_size);\n\tvga_set_mem_top(c);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-28097"
    },
    {
        "index": 396,
        "code": "static int __Pyx_modinit_type_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_type_import_code\", 0);\n  /*--- Type import code ---*/\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"type\", \n  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000\n  sizeof(PyTypeObject),\n  #else\n  sizeof(PyHeapTypeObject),\n  #endif\n  __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(1, 9, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 8, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"bool\", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(2, 8, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"complex\", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(3, 15, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_RefNannyFinishContext();\n  return 0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 397,
        "code": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-44108"
    },
    {
        "index": 398,
        "code": "MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-16587"
    },
    {
        "index": 399,
        "code": "R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0139"
    },
    {
        "index": 400,
        "code": "static Jsi_RC CDataStructDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_RC rc = JSI_OK;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *eval = NULL, *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc, clen = 0, arrCnt=0;\n    Jsi_DString fStr = {};\n    char **argv = NULL, *cmt, *eq, *cp, *ce, *cpval, ocp;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        eq = Jsi_Strchr(fstr, '=');\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\";\"), &fStr);\n        Jsi_DSFree(&tStr);\n        if (!cmt && argc>0 && !argv[argc-1][0])\n            argc--;\n        if (eq) {\n            eval = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, eval);\n        }\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (argc>200)\n        return Jsi_LogError(\"too many fields: %d>200\", argc);\n    Jsi_StructSpec *sl, *sf, recs[argc+2];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc+1;\n    sf = recs;\n    SIGINIT(sl, OPTS_STRUCT);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, StructOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid struct name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"struct already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        Jsi_Number numVal = 0;\n        bool bVal, isbitset = 0;\n        Jsi_Value *inival = NULL;\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        if (!argv) {\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n            if (!val || Jsi_OptionsProcess(interp, StructFieldOptions, sf, val, 0) < 0) {\n                rc = JSI_ERROR;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(sf->name) || !sf->type) {\n                rc = Jsi_LogError(\"invalid struct field name: %s\", sf->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(interp, val, \"init\", 0) && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n        } else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n                cp = Jsi_Strchr(argv[i], ';'); \n                if (cp) *cp = 0;\n            }\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                if (!eval)\n                    goto bail;\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                int cplen = Jsi_Strlen(cp);\n                if (cplen>1 && (cp[0] == '\\'' || cp[0] == '\"') && cp[0] == cp[cplen-1]) {\n                    cpval = cp+1;\n                    cp[cplen-1] = 0;\n                    inival = Jsi_ValueNewStringDup(interp, cpval);\n                }\n                else if (Jsi_GetDouble(interp, cp, &numVal) == JSI_OK)\n                    inival = Jsi_ValueNewNumber(interp, numVal);\n                else if (Jsi_GetBool(interp, cp, &bVal) == JSI_OK)\n                    inival = Jsi_ValueNewBoolean(interp, bVal);\n                else\n                    inival = Jsi_ValueNewStringDup(interp, cp);\n            }\n            cp = argv[i];\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && !isspace(*ce)) ce++;\n            ocp = *ce;\n            if (!ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            *ce = 0;\n            sf->type = Jsi_TypeLookup(interp, cp);\n            *ce = ocp;\n            if (!sf->type) {\n                rc = Jsi_LogError(\"unknown type: %s\", argv[i]);\n                goto bail;\n            }\n            if (!inival && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n\n            cp = ce+1;\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && (isalnum(*ce) || *ce == '_')) ce++;\n            ocp = *ce;\n            *ce = 0;\n            if (!*cp) {\n                rc = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            sf->name = Jsi_KeyAdd(interp, cp);\n            if (ocp) {\n                ce++;\n                clen = Jsi_Strlen(ce);\n            }\n            if (ocp == '@') {\n                isbitset = 1;\n            } else\n            if (ocp == ':') {\n                int bsiz = -1;\n                if (Jsi_GetInt(interp, ce, &bsiz,10) != JSI_OK || bsiz<=0 || bsiz>64) {\n                    rc = Jsi_LogError(\"bad bit size: %s\", ce);\n                    goto bail;\n                }\n                sf->bits = bsiz;\n            } else if (ocp == '[' && clen>1 && ce[clen-1]==']') {\n                int asiz = -1;\n                ce[clen-1] = 0;\n                if (Jsi_GetInt(interp, ce, &asiz, 10) != JSI_OK || asiz<=0) {\n                    rc = Jsi_LogError(\"bad size: %s\", cp);\n                    goto bail;\n                }\n                sf->arrSize = asiz;\n            } else if (ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            val = NULL;            \n        }\n        if (inival) {\n            Jsi_Value *sval = Jsi_ValueNewObj(interp, NULL);\n            Jsi_ValueInsert(interp, sval, \"init\", inival, 0);\n            Jsi_ValueArraySet(interp, eval, sval, i);\n        }\n        bool isEnum = (sf->type && (sf->type->flags&jsi_CTYP_ENUM));\n        if (isbitset) {\n            if (!isEnum) {\n                rc = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            sf->flags |= JSI_OPT_BITSET_ENUM;\n        }\n        if (sf->arrSize) {\n            if (sf->arrSize>MAX_ARRAY_LIST) {\n                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, MAX_ARRAY_LIST);\n                goto bail;\n            }\n            if (sf->bits || isEnum) {\n                rc = Jsi_LogError(\"array of %s unsupported\", (sf->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            arrCnt++;\n        }\n    }\n    recs[argc].id = JSI_OPTION_END;\n    rc = jsi_csSetupStruct(interp, sl, recs, recs, argc, &st, arrCnt);\n    if (rc != JSI_OK || !st) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sl = jsi_csGetStructSpec(st->extData);\n    sf = jsi_csGetFieldSpec(sl->extData);\n    if (vstr)\n        flds = eval;\n    for (i = 0; i<argc && flds; i++) {\n        val = Jsi_ValueArrayIndex(interp, flds, i);\n        if (val && Jsi_OptionsProcess(interp, StructFieldOptions, sf+i, val, JSI_OPT_PASS2) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n    }\nbail:\n    if (eval)\n        Jsi_DecrRefCount(interp, eval);\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_HashEntryDelete(st->hPtr);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22874"
    },
    {
        "index": 401,
        "code": "spell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (*skipwhite(line) == NUL)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-2042"
    },
    {
        "index": 402,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeNearestNeighborParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }\n\n  tflite::ResizeNearestNeighborParams op_params;\n  op_params.align_corners = params->align_corners;\n  op_params.half_pixel_centers = params->half_pixel_centers;\n\n  if (output->type == kTfLiteFloat32) {\n    reference_ops::ResizeNearestNeighbor(\n        op_params, GetTensorShape(input), GetTensorData<int32>(input),\n        GetTensorShape(size), GetTensorData<int32>(size),\n        GetTensorShape(output), GetTensorData<int32>(output));\n  } else if (output->type == kTfLiteUInt8) {\n    if (kernel_type == kReference) {\n      reference_ops::ResizeNearestNeighbor(\n          op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(size), GetTensorData<int32>(size),\n          GetTensorShape(output), GetTensorData<uint8_t>(output));\n    }\n    if (kernel_type == kGenericOptimized || kernel_type == kNeonOptimized) {\n      optimized_ops::ResizeNearestNeighbor(\n          op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(size), GetTensorData<int32>(size),\n          GetTensorShape(output), GetTensorData<uint8_t>(output));\n    }\n  } else if (output->type == kTfLiteInt8) {\n    reference_ops::ResizeNearestNeighbor(\n        op_params, GetTensorShape(input), GetTensorData<int8_t>(input),\n        GetTensorShape(size), GetTensorData<int32>(size),\n        GetTensorShape(output), GetTensorData<int8_t>(output));\n  } else if (output->type == kTfLiteInt16) {\n    reference_ops::ResizeNearestNeighbor(\n        op_params, GetTensorShape(input), GetTensorData<int16_t>(input),\n        GetTensorShape(size), GetTensorData<int32>(size),\n        GetTensorShape(output), GetTensorData<int16_t>(output));\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context, \"Output type is %s, requires float, uint8, int8 or int16.\",\n        TfLiteTypeGetName(output->type));\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 403,
        "code": " MediaStreamDispatcherHost::~MediaStreamDispatcherHost() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.CloseAllBindings();\n   CancelAllRequests();\n }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 404,
        "code": "static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        \n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 405,
        "code": "TEST(SegmentSumOpModelTest, Float32Test_ThreeDimensions) {\n  SegmentSumOpModel<float> model({TensorType_FLOAT32, {3, 2, 1}},\n                                 {TensorType_INT32, {3}});\n  model.PopulateTensor<float>(model.data(), {1, 2, 3, 4, 5, 6});\n  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 0, 1});\n  model.Invoke();\n  EXPECT_THAT(model.GetOutput(), ElementsAreArray({4.0f, 6.0f, 5.0f, 6.0f}));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAreArray({2, 2, 1}));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15212"
    },
    {
        "index": 406,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_read_items(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, Py_ssize_t __pyx_v_n_items, PyObject *__pyx_v_buf) {\n  Py_ssize_t __pyx_v_i;\n  Py_ssize_t __pyx_v_length;\n  PyObject *__pyx_v_data = NULL;\n  char *__pyx_v_data_ptr;\n  PyObject *__pyx_v_items = NULL;\n  PyObject *__pyx_v_item = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  char *__pyx_t_6;\n  Py_ssize_t __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  __Pyx_RefNannySetupContext(\"read_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":120\n *     def read_items(self, Py_ssize_t n_items, buf):\n *         cdef Py_ssize_t i\n *         cdef Py_ssize_t length = self.length             # <<<<<<<<<<<<<<\n *         data = buf.read(length * n_items)\n *         cdef char* data_ptr = PyBytes_AsString(data)\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 120, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 120, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v_length = __pyx_t_2;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":121\n *         cdef Py_ssize_t i\n *         cdef Py_ssize_t length = self.length\n *         data = buf.read(length * n_items)             # <<<<<<<<<<<<<<\n *         cdef char* data_ptr = PyBytes_AsString(data)\n * \n */\n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 121, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyInt_FromSsize_t((__pyx_v_length * __pyx_v_n_items)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 121, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_t_5 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);\n    if (likely(__pyx_t_5)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n      __Pyx_INCREF(__pyx_t_5);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_3, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 121, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_v_data = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":122\n *         cdef Py_ssize_t length = self.length\n *         data = buf.read(length * n_items)\n *         cdef char* data_ptr = PyBytes_AsString(data)             # <<<<<<<<<<<<<<\n * \n *         items = PyTuple_New(n_items)\n */\n  __pyx_t_6 = PyBytes_AsString(__pyx_v_data); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(0, 122, __pyx_L1_error)\n  __pyx_v_data_ptr = __pyx_t_6;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":124\n *         cdef char* data_ptr = PyBytes_AsString(data)\n * \n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n *         for i in range(n_items):\n *             item = PyBytes_FromStringAndSize(&data_ptr[i * length], length)\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 124, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":125\n * \n *         items = PyTuple_New(n_items)\n *         for i in range(n_items):             # <<<<<<<<<<<<<<\n *             item = PyBytes_FromStringAndSize(&data_ptr[i * length], length)\n *             Py_INCREF(item)\n */\n  __pyx_t_2 = __pyx_v_n_items;\n  __pyx_t_7 = __pyx_t_2;\n  for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {\n    __pyx_v_i = __pyx_t_8;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":126\n *         items = PyTuple_New(n_items)\n *         for i in range(n_items):\n *             item = PyBytes_FromStringAndSize(&data_ptr[i * length], length)             # <<<<<<<<<<<<<<\n *             Py_INCREF(item)\n *             PyTuple_SET_ITEM(items, i, item)\n */\n    __pyx_t_1 = PyBytes_FromStringAndSize((&(__pyx_v_data_ptr[(__pyx_v_i * __pyx_v_length)])), __pyx_v_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_XDECREF_SET(__pyx_v_item, ((PyObject*)__pyx_t_1));\n    __pyx_t_1 = 0;\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":127\n *         for i in range(n_items):\n *             item = PyBytes_FromStringAndSize(&data_ptr[i * length], length)\n *             Py_INCREF(item)             # <<<<<<<<<<<<<<\n *             PyTuple_SET_ITEM(items, i, item)\n *         return items\n */\n    Py_INCREF(__pyx_v_item);\n\n    /* \"clickhouse_driver/columns/stringcolumn.pyx\":128\n *             item = PyBytes_FromStringAndSize(&data_ptr[i * length], length)\n *             Py_INCREF(item)\n *             PyTuple_SET_ITEM(items, i, item)             # <<<<<<<<<<<<<<\n *         return items\n * \n */\n    PyTuple_SET_ITEM(__pyx_v_items, __pyx_v_i, __pyx_v_item);\n  }\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":129\n *             Py_INCREF(item)\n *             PyTuple_SET_ITEM(items, i, item)\n *         return items             # <<<<<<<<<<<<<<\n * \n *     def write_items(self, items, buf):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":118\n *     null_value = b''\n * \n *     def read_items(self, Py_ssize_t n_items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t i\n *         cdef Py_ssize_t length = self.length\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteFixedString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_data);\n  __Pyx_XDECREF(__pyx_v_items);\n  __Pyx_XDECREF(__pyx_v_item);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 407,
        "code": "static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > maxbytes) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > maxbytes) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n\n  //printf(\"c%d\", ctbytes);\n  return ctbytes;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-29367"
    },
    {
        "index": 408,
        "code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!IsSupportedType(input->type)) {\n    TF_LITE_KERNEL_LOG(context, \"Input data type %s (%d) is not supported.\",\n                       TfLiteTypeGetName(input->type), input->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 409,
        "code": "void PaymentRequest::UpdateWith(mojom::PaymentDetailsPtr details) {\n   std::string error;\n   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {\n    LOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (details->shipping_address_errors &&\n       !PaymentsValidators::IsValidAddressErrorsFormat(\n           details->shipping_address_errors, &error)) {\n    DLOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (!details->total) {\n    LOG(ERROR) << \"Missing total\";\n     OnConnectionTerminated();\n     return;\n   }\n\n  spec_->UpdateWith(std::move(details));\n }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 410,
        "code": "MONGO_EXPORT void bson_destroy( bson *b ) {\n    if (b) {\n        bson_free( b->data );\n        b->err = 0;\n        b->data = 0;\n        b->cur = 0;\n        b->finished = 1;\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 411,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* seq_lengths = GetInput(context, node, kSeqLengthsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(seq_lengths), 1);\n\n  if (input->type != kTfLiteInt32 && input->type != kTfLiteFloat32 &&\n      input->type != kTfLiteUInt8 && input->type != kTfLiteInt16 &&\n      input->type != kTfLiteInt64) {\n    context->ReportError(context,\n                         \"Type '%s' is not supported by reverse_sequence.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n  if (seq_lengths->type != kTfLiteInt32 && seq_lengths->type != kTfLiteInt64) {\n    context->ReportError(\n        context, \"Seq_lengths type '%s' is not supported by reverse_sequence.\",\n        TfLiteTypeGetName(seq_lengths->type));\n    return kTfLiteError;\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input->dims);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 412,
        "code": "static int isLegalUTF8( const unsigned char *source, int length ) {\n    unsigned char a;\n    const unsigned char *srcptr = source + length;\n    switch ( length ) {\n    default:\n        return 0;\n        /* Everything else falls through when \"true\"... */\n    case 4:\n        if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;\n    case 3:\n        if ( ( a = ( *--srcptr ) ) < 0x80 || a > 0xBF ) return 0;\n    case 2:\n        if ( ( a = ( *--srcptr ) ) > 0xBF ) return 0;\n        switch ( *source ) {\n            /* no fall-through in this inner switch */\n        case 0xE0:\n            if ( a < 0xA0 ) return 0;\n            break;\n        case 0xF0:\n            if ( a < 0x90 ) return 0;\n            break;\n        case 0xF4:\n            if ( a > 0x8F ) return 0;\n            break;\n        default:\n            if ( a < 0x80 ) return 0;\n        }\n    case 1:\n        if ( *source >= 0x80 && *source < 0xC2 ) return 0;\n        if ( *source > 0xF4 ) return 0;\n    }\n    return 1;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 413,
        "code": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); /* \".$cmd\" + nul */\n    int res, success = 0;\n\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 414,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_CompressedBufferedWriter__set_state(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  char *__pyx_t_2;\n  Py_ssize_t __pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  PyObject *__pyx_t_9 = NULL;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_CompressedBufferedWriter__set_state\", 0);\n\n  /* \"(tree fragment)\":12\n *     return __pyx_result\n * cdef __pyx_unpickle_CompressedBufferedWriter__set_state(CompressedBufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.compressor = __pyx_state[2]; __pyx_result.position = __pyx_state[3]             # <<<<<<<<<<<<<<\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyObject_AsWritableString(__pyx_t_1); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __pyx_v___pyx_result->__pyx_base.buffer = __pyx_t_2;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_3 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.buffer_size = __pyx_t_3;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->compressor);\n  __Pyx_DECREF(__pyx_v___pyx_result->compressor);\n  __pyx_v___pyx_result->compressor = __pyx_t_1;\n  __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_3 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.position = __pyx_t_3;\n\n  /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_CompressedBufferedWriter__set_state(CompressedBufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.compressor = __pyx_state[2]; __pyx_result.position = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(1, 13, __pyx_L1_error)\n  }\n  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_5 = ((__pyx_t_3 > 4) != 0);\n  if (__pyx_t_5) {\n  } else {\n    __pyx_t_4 = __pyx_t_5;\n    goto __pyx_L4_bool_binop_done;\n  }\n  __pyx_t_5 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_6 = (__pyx_t_5 != 0);\n  __pyx_t_4 = __pyx_t_6;\n  __pyx_L4_bool_binop_done:;\n  if (__pyx_t_4) {\n\n    /* \"(tree fragment)\":14\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.compressor = __pyx_state[2]; __pyx_result.position = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])             # <<<<<<<<<<<<<<\n */\n    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_update); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_8);\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    if (unlikely(__pyx_v___pyx_state == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(1, 14, __pyx_L1_error)\n    }\n    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_9 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {\n      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);\n      if (likely(__pyx_t_9)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);\n        __Pyx_INCREF(__pyx_t_9);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_8, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_9, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_7);\n    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n    /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_CompressedBufferedWriter__set_state(CompressedBufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.compressor = __pyx_state[2]; __pyx_result.position = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  }\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_CompressedBufferedWriter__set_state(<CompressedBufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_CompressedBufferedWriter__set_state(CompressedBufferedWriter __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.compressor = __pyx_state[2]; __pyx_result.position = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_XDECREF(__pyx_t_9);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_CompressedBufferedWriter__set_state\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 415,
        "code": "  TfLiteRegistration CopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      // Set output size to input size\n      const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n      TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n      TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n      return context->ResizeTensor(context, tensor1, newSize);\n    };\n\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      CallReporting* call_reporting =\n          static_cast<CallReporting*>(node->builtin_data);\n      // Copy input data to output data.\n      const TfLiteTensor* a0 = GetInput(context, node, 0);\n      TfLiteTensor* a1 = GetOutput(context, node, 0);\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        a1->data.f[i] = a0->data.f[i];\n      }\n      call_reporting->Record();\n      return kTfLiteOk;\n    };\n    return reg;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 416,
        "code": "Jsi_RC jsi_evalcode_sub(jsi_Pstate *ps, Jsi_OpCodes *opcodes, \n     jsi_ScopeChain *scope, Jsi_Value *currentScope,\n     Jsi_Value *_this, Jsi_Value *vret)\n{\n    Jsi_Interp* interp = ps->interp;\n    jsi_OpCode *ip = &opcodes->codes[0];\n    Jsi_RC rc = JSI_OK;\n    int curLine = 0;\n    int context_id = ps->_context_id++, lop = -1;\n    jsi_OpCode *end = &opcodes->codes[opcodes->code_len];\n    jsi_TryList  *trylist = NULL;\n    bool strict = interp->strict;\n    const char *curFile = NULL;\n    \n    if (currentScope->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Eval: current scope is not a object\");\n        return JSI_ERROR;\n    }\n    if (interp->maxDepth>0 && interp->level > interp->maxDepth)\n        rc = Jsi_LogError(\"Exceeded call depth: %d\", interp->level);\n    \n    while(ip < end && rc == JSI_OK) {\n        int plop = ip->op;\n\n        if (ip->logflag) { // Mask out LogDebug, etc if not enabled.\n            interp->curIp = ip;\n            switch (ip->logflag) {\n                case jsi_Oplf_assert:\n                    if (!interp->asserts) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_assert && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_debug:\n                    if (!interp->logOpts.Debug && !(interp->framePtr->logflag &(1<<jsi_Oplf_debug))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_debug && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_test:\n                    if (!interp->logOpts.Test && !(interp->framePtr->logflag &(1<<jsi_Oplf_test))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_test && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_trace:\n                    if (!interp->logOpts.Trace && !(interp->framePtr->logflag &(1<<jsi_Oplf_trace))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_trace && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (interp->interrupted) {\n            if (!interp->framePtr->tryDepth) {\n                Jsi_LogError(\"program interrupted: function=%s\", interp->framePtr->funcName);\n                interp->interrupted = 0;\n            } else {\n                interp->interrupted++;\n            }\n            rc = JSI_ERROR;\n            break;\n        }\n        if (interp->exited) {\n            rc = JSI_ERROR;\n            break;\n        }\n        interp->opCnt++;\n        if (interp->maxOpCnt && interp->opCnt > interp->maxOpCnt) {\n            puts(\"EXEC CAP EXCEED\");\n            interp->maxOpCnt += 1000;\n            rc = Jsi_LogError(\"Exceeded execution cap: %d\", interp->opCnt);\n            interp->exited = 1;\n            interp->exitCode = 99;\n            break;\n        }\n        if (interp->traceOp) {\n            jsiDumpInstr(interp, ps, _this, trylist, ip, opcodes);\n        }\n        if (interp->parent && interp->busyCallback && (interp->opCnt%(interp->busyInterval<=0?100000:interp->busyInterval))==0) {\n            // Handle parent interp events.\n            if (jsi_FuncIsNoop(interp, interp->busyCallback))\n                Jsi_EventProcess(interp->parent, -1);\n            else {\n                Jsi_DString nStr;\n                Jsi_DSInit(&nStr);\n                Jsi_DSPrintf(&nStr, \"[\\\"#Interp_%d\\\", %d]\", interp->objId, interp->opCnt);//TODO: use actual time interval rather than opCnt.\n                if (Jsi_FunctionInvokeJSON(interp->parent, interp->busyCallback, Jsi_DSValue(&nStr), NULL) != JSI_OK)\n                    rc = JSI_ERROR;\n                Jsi_DSFree(&nStr);\n            }\n        }\n        ip->hit=1;\n#ifndef USE_STATIC_STACK\n        if ((interp->maxStack-interp->framePtr->Sp)<STACK_MIN_PAD)\n            jsiSetupStack(interp);\n#endif\n        jsiPush(interp,0);\n        interp->curIp = ip;\n        // Carry forward line/file info from previous OPs.\n        if (!ip->Line)\n            ip->Line = curLine;\n        else\n            curLine = ip->Line;\n        if (!ip->fname)\n            ip->fname = curFile;\n        else\n            curFile = ip->fname;\n        if (interp->debugOpts.hook) {\n            interp->framePtr->fileName = curFile;\n            interp->framePtr->line = curLine;\n            if ((rc = (*interp->debugOpts.hook)(interp, curFile, curLine, interp->framePtr->level, interp->curFunction, jsi_opcode_string(ip->op), ip, NULL)) != JSI_OK)\n                break;\n        }\n\n        switch(ip->op) {\n            case OP_NOP:\n            case OP_LASTOP:\n                break;\n            case OP_PUSHUND:\n                Jsi_ValueMakeUndef(interp, &_jsi_STACKIDX(interp->framePtr->Sp));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHNULL:\n                Jsi_ValueMakeNull(interp, &_jsi_STACKIDX(interp->framePtr->Sp));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHBOO:\n                Jsi_ValueMakeBool(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (uintptr_t)ip->data);\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHNUM:\n                Jsi_ValueMakeNumber(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (*((Jsi_Number *)ip->data)));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHSTR: {\n                Jsi_Value **v = &_jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_ValueMakeStringKey(interp, v, (char*)ip->data);\n                interp->lastPushStr = Jsi_ValueString(interp, *v, NULL);\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHVSTR: {\n                Jsi_String *s = (Jsi_String *)ip->data;\n                Jsi_Value **v = &_jsi_STACKIDX(interp->framePtr->Sp);\n                if (s->flags&1)\n                    jsi_ValueMakeBlobDup(interp,v, (uchar*)s->str, s->len);\n                else {\n                    Jsi_ValueMakeStringKey(interp, v, s->str);\n                    interp->lastPushStr = s->str;\n                }\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHVAR: {\n                rc = jsi_PushVar(ps, ip, scope, currentScope, context_id);      \n                break;\n            }\n            case OP_PUSHFUN: {\n                jsi_PushFunc(ps, ip, scope, currentScope);\n                break;\n            }\n            case OP_NEWFCALL:\n                if (interp->maxUserObjs && interp->userObjCnt > interp->maxUserObjs) {\n                    rc = Jsi_LogError(\"Max 'new' count exceeded\");\n                    break;\n                }\n            case OP_FCALL: {\n                /* TODO: need reliable way to capture func string name to handle unknown functions.*/\n                int discard = ((ip+1)<end && ip[1].op == OP_POP);\n                switch (jsiEvalFunction(ps, ip, discard)) {        /* throw an execption */\n                    case JSI_OK: break;\n                    case JSI_BREAK:\n                        if (interp->framePtr->tryDepth<=0)\n                            interp->isHelp = 1;\n                        JSI_DO_THROW(\"help\");\n                        break;\n                    default:  \n                        JSI_DO_THROW(\"fcall\");\n                }\n                strict = interp->strict;\n                /* TODO: new Function return a function without scopechain, add here */\n                break;\n            }\n            case OP_SUBSCRIPT: {\n                rc = jsi_evalSubscript(interp, _jsi_TOQ, _jsi_TOP, ip, end, currentScope);\n                break;\n            }\n            case OP_ASSIGN: {\n                Jsi_Value *sval = _jsi_TOP, *dval = _jsi_TOQ;\n                bool globThis = (sval->vt == JSI_VT_OBJECT && sval->d.obj == interp->csc->d.obj);\n                if ((uintptr_t)ip->data == 1) {\n                    jsiVarDeref(interp,1);\n                    rc = jsi_ValueAssign(interp, dval, sval, lop);                    \n                    if (strict && sval->vt == JSI_VT_UNDEF)\n                        rc = jsi_ValueAssignCheck(interp, sval, lop);\n                    jsiPop(interp,1);\n                } else {\n                    jsiVarDeref(interp, 3);\n                    Jsi_Value *v3 = _jsi_STACKIDX(interp->framePtr->Sp-3);\n                    if (v3->vt == JSI_VT_OBJECT) {\n                        if (strict && sval->vt == JSI_VT_UNDEF)\n                            rc = jsi_ValueAssignCheck(interp, sval, lop);\n                        jsi_ValueObjKeyAssign(interp, v3, dval, sval, 0);\n                        jsi_ValueDebugLabel(sval, \"assign\", NULL);\n                    } else if (strict)\n                        rc = Jsi_LogError(\"assign to a non-exist object\");\n                    jsiClearStack(interp,3);\n                    Jsi_ValueCopy(interp,v3, sval);\n                    dval = v3;\n                    jsiPop(interp, 2);\n                }\n                if (interp->framePtr->level<=1 && globThis && rc == JSI_OK && dval && dval->vt == JSI_VT_VARIABLE) {\n                    dval = dval->d.lval;\n                    //printf(\"GLOBAL THIS: %p\\n\", dval);\n                    Jsi_HashSet(interp->genValueTbl, dval, dval);\n                }\n                break;\n            }\n            case OP_PUSHREG: {\n                Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n                obj->d.robj = (Jsi_Regex *)ip->data;\n                Jsi_ValueMakeObject(interp, &_jsi_STACKIDX(interp->framePtr->Sp), obj);\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHARG:\n                //Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), currentScope);\n                \n                if (!interp->framePtr->arguments) {\n                    interp->framePtr->arguments = Jsi_ValueNewObj(interp,\n                        Jsi_ObjNewArray(interp, currentScope->d.obj->arr, currentScope->d.obj->arrCnt, 0));\n                    Jsi_IncrRefCount(interp, interp->framePtr->arguments);\n                    if (interp->hasCallee) {\n                        Jsi_Value *callee = Jsi_ValueObjLookup(interp, currentScope, \"\\1callee\\1\", 0);\n                        if (callee)\n                            Jsi_ValueInsert(interp, interp->framePtr->arguments, \"\\1callee\\1\", callee, JSI_OM_DONTENUM);\n                    }\n                    // interp->framePtr->arguments->d.obj->__proto__ = interp->Object_prototype; // ecma\n                }\n                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), interp->framePtr->arguments);\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHTHS: { //TODO: Value copy can cause memory leak!\n                Jsi_Value *tval = _jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_ValueCopy(interp, tval, _this);\n                /*if (interp->csc == _this)\n                    Jsi_ValueDup2(interp, &tval, _this);\n                else\n                    Jsi_ValueCopy(interp, tval, _this);*/\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHTOP:\n                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), _jsi_TOP);\n                jsiPush(interp,1);\n                break;\n            case OP_UNREF:\n                jsiVarDeref(interp,1);\n                break;\n            case OP_PUSHTOP2: {\n                Jsi_Value *vp1 = _jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_Value *vp2 = _jsi_STACKIDX(interp->framePtr->Sp+1);\n                if (!vp1 || !vp2)\n                    rc = Jsi_LogError(\"Invalid lookup/push\");\n                else {\n                    Jsi_ValueCopy(interp, vp1, _jsi_TOQ);\n                    Jsi_ValueCopy(interp, vp2, _jsi_TOP);\n                    jsiPush(interp, 2);\n                }\n                break;\n            }\n            case OP_CHTHIS: {\n                if (ip->data) {\n                    int t = interp->framePtr->Sp - 2;\n                    Assert(t>=0);\n                    Jsi_Value *v = _jsi_THISIDX(t);\n                    jsiClearThis(interp, t);\n                    Jsi_ValueCopy(interp, v, _jsi_TOQ);\n                    if (v->vt == JSI_VT_VARIABLE) {\n                        Jsi_ValueCopy(interp, v, v->d.lval);\n                    }\n                    Jsi_ValueToObject(interp, v);\n                }\n                break;\n            }\n            case OP_LOCAL: {\n                Jsi_Value key = VALINIT, *kPtr = &key; // Note we use a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, (char*)ip->data);\n                jsi_ValueObjKeyAssign(interp, currentScope, kPtr, NULL, JSI_OM_DONTENUM);\n                context_id = ps->_context_id++;\n                break;\n            }\n            case OP_POP: {\n                Jsi_Value *tval = _jsi_TOP;\n                if ((interp->evalFlags&JSI_EVAL_RETURN) && (ip+1) >= end && \n                (Jsi_ValueIsObjType(interp, tval, JSI_OT_ITER)==0 &&\n                Jsi_ValueIsObjType(interp, tval, JSI_OT_FUNCTION)==0)) {\n                    /* Interactive and last instruction is a pop: save result. */\n                    Jsi_ValueMove(interp, vret, tval); /*TODO***: correct ***/\n                    tval->vt = JSI_VT_UNDEF;\n                }\n                jsiPop(interp, (uintptr_t)ip->data);\n                break;\n            }\n            case OP_NEG:\n                jsiVarDeref(interp,1);\n                Jsi_ValueToNumber(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                _jsi_TOP->d.num = -(_jsi_TOP->d.num);\n                break;\n            case OP_POS:\n                jsiVarDeref(interp,1);\n                Jsi_ValueToNumber(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                break;\n            case OP_NOT: {\n                int val = 0;\n                jsiVarDeref(interp,1);\n                \n                val = Jsi_ValueIsTrue(interp, _jsi_TOP);\n                \n                jsiClearStack(interp,1);\n                Jsi_ValueMakeBool(interp, &_jsi_TOP, !val);\n                break;\n            }\n            case OP_BNOT: {\n                jsiVarDeref(interp,1);\n                jsi_ValueToOInt32(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                _jsi_TOP->d.num = (Jsi_Number)(~((int)_jsi_TOP->d.num));\n                break;\n            }\n            case OP_ADD: {\n                jsiVarDeref(interp,2);\n                Jsi_Value *v, *v1 = _jsi_TOP, *v2 = _jsi_TOQ;\n                int l1, l2;\n                if (strict)\n                    if (Jsi_ValueIsUndef(interp, v1) || Jsi_ValueIsUndef(interp, v2)) {\n                        rc = Jsi_LogError(\"operand value to + is undefined\");\n                        break;\n                    }\n                char *s1 = Jsi_ValueString(interp, v1, &l1);\n                char *s2 = Jsi_ValueString(interp, v2, &l2);\n                if (s1 || s2) {\n                    char *str;\n                    if (!(s1 && s2)) {\n                        v = (s1 ? v2 : v1);\n                        jsi_ValueToPrimitive(interp, &v);\n                        Jsi_ValueToString(interp, v, NULL);\n                        str = Jsi_ValueString(interp, v, (s1?&l2:&l1));\n                        if (s1) s2 = str; else s1 = str;\n                    }\n                    Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);\n                    Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);\n                    str = (char*)Jsi_Malloc(l1+l2+1);\n                    memcpy(str, s2, l2);\n                    memcpy(str+l2, s1, l1);\n                    str[l1+l2] = 0;\n                    jsiClearStack(interp,2);\n                    Jsi_ValueMakeBlob(interp, &v2, (uchar*)str, l1+l2);\n                } else {\n                    Jsi_ValueToNumber(interp, v1);\n                    Jsi_ValueToNumber(interp, v2);\n                    rc = _jsi_StrictChk2(v1, v2);\n                    Jsi_Number n = v1->d.num + v2->d.num;\n                    jsiClearStack(interp,2);\n                    Jsi_ValueMakeNumber(interp, &v2, n);\n                }\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_IN: {\n                Jsi_Value *v, *vl;\n                const char *cp = NULL;\n                Jsi_Number nval;\n                jsiVarDeref(interp,2);\n                vl = _jsi_TOQ;\n                v = _jsi_TOP;\n                if (Jsi_ValueIsString(interp,vl))\n                    cp = Jsi_ValueGetStringLen(interp, vl, NULL);\n                else if (Jsi_ValueIsNumber(interp,vl))\n                    Jsi_ValueGetNumber(interp, vl, &nval);\n                else {\n                    if (strict)\n                        Jsi_LogWarn(\"expected string or number before IN\");\n                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);\n                    jsiPop(interp,1);\n                    break;\n                }\n                \n                if (v->vt == JSI_VT_VARIABLE) {\n                    v = v->d.lval;\n                    SIGASSERT(v, VALUE);\n                }\n                if (v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_OBJECT) {\n                    if (strict)\n                        Jsi_LogWarn(\"expected object after IN\");\n                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);\n                    jsiPop(interp,1);\n                    break;\n                }\n                int bval = 0;\n                char nbuf[100];\n                Jsi_Value *vv;\n                Jsi_Obj *obj = v->d.obj;\n                if (!cp) {\n                    snprintf(nbuf, sizeof(nbuf), \"%d\", (int)nval);\n                    cp = nbuf;\n                }\n                if (obj->arr) {\n                    vv = jsi_ObjArrayLookup(interp, obj, (char*)cp);\n                } else {\n                    vv = Jsi_TreeObjGetValue(obj, (char*)cp, 1);\n                }\n                bval = (vv != 0);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, bval);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_SUB: \n                common_math_opr(-); break;\n            case OP_MUL:\n                common_math_opr(*); break;\n            case OP_DIV:\n                common_math_opr(/); break;\n            case OP_MOD: {\n                jsiVarDeref(interp,2);\n                if (!Jsi_ValueIsType(interp,_jsi_TOP, JSI_VT_NUMBER))\n                    Jsi_ValueToNumber(interp, _jsi_TOP);\n                if (!Jsi_ValueIsType(interp,_jsi_TOQ, JSI_VT_NUMBER))\n                    Jsi_ValueToNumber(interp, _jsi_TOQ);\n                rc = _jsi_StrictChk2(_jsi_TOP,_jsi_TOQ);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.num = fmod(_jsi_TOQ->d.num, _jsi_TOP->d.num);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_LESS:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,2,1);\n                jsiPop(interp,1);\n                break;\n            case OP_GREATER:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,1,2);\n                jsiPop(interp,1);\n                break;\n            case OP_LESSEQU:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,1,2);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.val = !_jsi_TOQ->d.val;\n                jsiPop(interp,1);\n                break;\n            case OP_GREATEREQU:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,2,1);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.val = !_jsi_TOQ->d.val;\n                jsiPop(interp,1);\n                break;\n            case OP_EQUAL:\n            case OP_NOTEQUAL: {\n                jsiVarDeref(interp,2);\n                int r = Jsi_ValueCmp(interp, _jsi_TOP, _jsi_TOQ, 0);\n                r = (ip->op == OP_EQUAL ? !r : r);\n                jsiClearStack(interp,2);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_STRICTEQU:\n            case OP_STRICTNEQ: {\n                int r = 0;\n                jsiVarDeref(interp,2);\n                rc = _jsi_StrictUChk3(_jsi_TOQ, _jsi_TOP);\n                r = !Jsi_ValueIsEqual(interp, _jsi_TOP, _jsi_TOQ);\n                r = (ip->op == OP_STRICTEQU ? !r : r);\n                jsiClearStack(interp,2);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_BAND: \n                common_bitwise_opr(&); break;\n            case OP_BOR:\n                common_bitwise_opr(|); break;\n            case OP_BXOR:\n                common_bitwise_opr(^); break;\n            case OP_SHF: {\n                jsiVarDeref(interp,2);\n                jsi_ValueToOInt32(interp, _jsi_TOQ);\n                jsi_ValueToOInt32(interp, _jsi_TOP);\n                int t1 = (int)_jsi_TOQ->d.num;\n                int t2 = ((unsigned int)_jsi_TOP->d.num) & 0x1f;\n                if (ip->data) {                 /* shift right */\n                    if ((uintptr_t)ip->data == 2) {   /* unsigned shift */\n                        unsigned int t3 = (unsigned int)t1;\n                        t3 >>= t2;\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t3);\n                    } else {\n                        t1 >>= t2;\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);\n                    }\n                } else {\n                    t1 <<= t2;\n                    Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);\n                }\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_KEY: {\n                jsiVarDeref(interp,1);\n                if (ip->isof && !Jsi_ValueIsArray(interp, _jsi_TOP)) {\n                    rc = Jsi_LogError(\"operand not an array\");\n                    break;\n                }\n                if (_jsi_TOP->vt != JSI_VT_UNDEF && _jsi_TOP->vt != JSI_VT_NULL)\n                    Jsi_ValueToObject(interp, _jsi_TOP);\n                Jsi_Value *spret = Jsi_ValueNew1(interp);\n                jsi_ValueObjGetKeys(interp, _jsi_TOP, spret, ip->isof);\n                Jsi_ValueReplace(interp, _jsi_STACK+interp->framePtr->Sp, spret);  \n                Jsi_DecrRefCount(interp, spret);  \n                jsiPush(interp,1);\n                break;\n            }\n            case OP_NEXT: {\n                Jsi_Value *toq = _jsi_TOQ, *top = _jsi_TOP;\n                if (toq->vt != JSI_VT_OBJECT || toq->d.obj->ot != JSI_OT_ITER) Jsi_LogBug(\"next: toq not a iter\\n\");\n                if (top->vt != JSI_VT_VARIABLE) {\n                    rc = Jsi_LogError (\"invalid for/in left hand-side\");\n                    break;\n                }\n                if (strict && top->f.bits.local==0) {\n                    const char *varname = \"\";\n                    Jsi_Value *v = top->d.lval;\n                    if (v->f.bits.lookupfailed)\n                        varname = v->d.lookupFail;\n\n                    rc = Jsi_LogError(\"function created global: \\\"%s\\\"\", varname);\n                    break;\n                }\n                \n                Jsi_IterObj *io = toq->d.obj->d.iobj;\n                if (io->iterCmd) {\n                    io->iterCmd(io, top, _jsi_STACKIDX(interp->framePtr->Sp-3), io->iter++);\n                } else {\n                    while (io->iter < io->count) {\n                        if (!io->isArrayList) {\n                            if (Jsi_ValueKeyPresent(interp, _jsi_STACKIDX(interp->framePtr->Sp-3), io->keys[io->iter],1)) \n                                break;\n                        } else {\n                            while (io->cur < io->obj->arrCnt) {\n                                if (io->obj->arr[io->cur]) break;\n                                io->cur++;\n                            }\n                            if (io->cur >= io->obj->arrCnt) {\n                                /* TODO: Is this really a bug??? */\n                                /* Jsi_LogBug(\"NOT FOUND LIST ARRAY\");*/\n                                io->iter = io->count;\n                                break;\n                            } else if (io->obj->arr[io->cur]) {\n                                io->cur++;\n                                break;\n                            }\n                        }\n                        io->iter++;\n                    }\n                    if (io->iter >= io->count) {\n                        jsiClearStack(interp,1);\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 0);\n                    } else {\n                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;\n                        SIGASSERT(v, VALUE);\n                        Jsi_ValueReset(interp, vPtr);\n                        if (io->isArrayList) {\n                            if (!io->isof)\n                                Jsi_ValueMakeNumber(interp, &v, io->cur-1);\n                            else if (!io->obj->arr[io->cur-1])\n                                Jsi_ValueMakeNull(interp, &v);\n                            else\n                                Jsi_ValueCopy(interp, v, io->obj->arr[io->cur-1]);\n                        } else\n                            Jsi_ValueMakeStringKey(interp, &v, io->keys[io->iter]);\n                        io->iter++;\n                        \n                        jsiClearStack(interp,1);\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 1);\n                    }\n                    break;\n                }\n            }\n            case OP_INC:\n            case OP_DEC: {\n                int inc = ip->op == OP_INC ? 1 : -1;\n                \n                if (_jsi_TOP->vt != JSI_VT_VARIABLE) {\n                    rc = Jsi_LogError(\"operand not left value\");\n                    break;\n                }\n                Jsi_Value *v = _jsi_TOP->d.lval;\n                SIGASSERT(v, VALUE);\n                Jsi_ValueToNumber(interp, v);\n                rc = _jsi_StrictChk(v);\n                v->d.num += inc;\n                    \n                jsiVarDeref(interp,1);\n                if (ip->data) {\n                    _jsi_TOP->d.num -= inc;\n                }\n                break;\n            }\n            case OP_TYPEOF: {\n                const char *typ;\n                Jsi_Value *v = _jsi_TOP;\n                if (v->vt == JSI_VT_VARIABLE) {\n                    v = v->d.lval;\n                    SIGASSERT(v, VALUE);\n                }\n                typ = Jsi_ValueTypeStr(interp, v);\n                jsiVarDeref(interp,1);\n                Jsi_ValueMakeStringKey(interp, &_jsi_TOP, (char*)typ);\n                break;\n            }\n            case OP_INSTANCEOF: {\n\n                jsiVarDeref(interp,2);\n                int bval = Jsi_ValueInstanceOf(interp, _jsi_TOQ, _jsi_TOP);\n                jsiPop(interp,1);\n                Jsi_ValueMakeBool(interp, &_jsi_TOP, bval);\n                break;\n            }\n            case OP_JTRUE:\n            case OP_JFALSE: \n            case OP_JTRUE_NP:\n            case OP_JFALSE_NP: {\n                jsiVarDeref(interp,1);\n                int off = (uintptr_t)ip->data - 1; \n                int r = Jsi_ValueIsTrue(interp, _jsi_TOP);\n                \n                if (ip->op == OP_JTRUE || ip->op == OP_JFALSE) jsiPop(interp,1);\n                ip += ((ip->op == OP_JTRUE || ip->op == OP_JTRUE_NP) ^ r) ? 0 : off;\n                break;\n            }\n            case OP_JMPPOP: \n                jsiPop(interp, ((jsi_JmpPopInfo *)ip->data)->topop);\n            case OP_JMP: {\n                int off = (ip->op == OP_JMP ? (uintptr_t)ip->data - 1\n                            : (uintptr_t)((jsi_JmpPopInfo *)ip->data)->off - 1);\n\n                while (1) {\n                    if (trylist == NULL) break;\n                    jsi_OpCode *tojmp = ip + off;\n\n                    /* jmp out of a try block, should execute the finally block */\n                    /* while jmp out a 'with' block, restore the scope */\n\n                    if (trylist->type == jsi_TL_TRY) { \n                        if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) break;\n                        \n                        if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {\n                            trylist->d.td.last_op = jsi_LOP_JMP;\n                            trylist->d.td.ld.tojmp = tojmp;\n                            \n                            ip = trylist->d.td.fstart - 1;\n                            off = 0;\n                            break;\n                        } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {\n                            pop_try(trylist);\n                        } else Jsi_LogBug(\"jmp within a try, but not in its scope?\");\n                    } else {\n                        /* with block */\n                        \n                        if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) break;\n                        \n                        JSI_RESTORE_SCOPE();\n                        pop_try(trylist);\n                    }\n                }\n                \n                ip += off;\n                break;\n            }\n            case OP_EVAL: {\n                int stackargc = (uintptr_t)ip->data;\n                jsiVarDeref(interp, stackargc);\n\n                int r = 0;\n                Jsi_Value *spPtr = Jsi_ValueNew1(interp);\n                if (stackargc > 0) {\n                    if (_jsi_STACKIDX(interp->framePtr->Sp - stackargc)->vt == JSI_VT_UNDEF) {\n                        Jsi_LogError(\"undefined value to eval()\");\n                        goto undef_eval;\n                    }\n                    int plen;\n                    char *pro = Jsi_ValueString(interp, _jsi_STACKIDX(interp->framePtr->Sp - stackargc), &plen);\n                    if (pro) {\n                        pro = Jsi_StrdupLen(pro, plen);\n                        r = jsiEvalOp(interp, ps, pro, scope, currentScope, _this, &spPtr);\n                        Jsi_Free(pro);\n                    } else {\n                        Jsi_ValueCopy(interp, spPtr, _jsi_STACKIDX(interp->framePtr->Sp - stackargc));\n                    }\n                }\nundef_eval:\n                jsiPop(interp, stackargc);\n                Jsi_ValueCopy(interp, _jsi_STACK[interp->framePtr->Sp], spPtr); /*TODO: is this correct?*/\n                Jsi_DecrRefCount(interp, spPtr);\n                jsiPush(interp,1);\n\n                if (r) {\n                    JSI_DO_THROW(\"eval\");\n                }\n                break;\n            }\n            case OP_RET: {\n                if (interp->framePtr->Sp>=1 && ip->data) {\n                    jsiVarDeref(interp,1);\n                    Jsi_ValueMove(interp, vret, _jsi_TOP);\n                }\n                jsiPop(interp, (uintptr_t)ip->data);\n                interp->didReturn = 1;\n                if (trylist) {\n                    while (trylist) {\n                        if (trylist->type == jsi_TL_TRY && trylist->inCatch)\n                            JSI_RESTORE_SCOPE();\n                        pop_try(trylist);\n                    }\n                    goto done;\n                }\n                ip = end;\n                break;\n            }\n            case OP_DELETE: {\n                int count = (uintptr_t)ip->data;\n                if (count == 1) { // Non-standard.\n                    if (_jsi_TOP->vt != JSI_VT_VARIABLE)\n                        rc = Jsi_LogError(\"delete a right value\");\n                    else {\n                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;\n                        SIGASSERT(v, VALUE);\n                        if (v->f.bits.dontdel) {\n                            if (strict) rc = Jsi_LogWarn(\"delete not allowed\");\n                        } else if (v != currentScope) {\n                            Jsi_ValueReset(interp,vPtr);     /* not allow to delete arguments */\n                        }\n                        else if (strict)\n                            Jsi_LogWarn(\"Delete arguments\");\n                    }\n                    jsiPop(interp,1);\n                } else if (count == 2) {\n                    jsiVarDeref(interp,2);\n                    assert(interp->framePtr->Sp>=2);\n                    if (strict) {\n                        if (_jsi_TOQ->vt != JSI_VT_OBJECT) Jsi_LogWarn(\"delete non-object key, ignore\");\n                        if (_jsi_TOQ->d.obj == currentScope->d.obj) Jsi_LogWarn(\"Delete arguments\");\n                    }\n                    jsi_ValueObjDelete(interp, _jsi_TOQ, _jsi_TOP, 0);\n                    \n                    jsiPop(interp,2);\n                } else Jsi_LogBug(\"delete\");\n                break;\n            }\n            case OP_OBJECT: {\n                int itemcount = (uintptr_t)ip->data;\n                Assert(itemcount>=0);\n                jsiVarDeref(interp, itemcount * 2);\n                Jsi_Obj *obj = Jsi_ObjNewObj(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount*2), itemcount*2);\n                jsiPop(interp, itemcount * 2 - 1);       /* one left */\n                jsiClearStack(interp,1);\n                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);\n                break;\n            }\n            case OP_ARRAY: {\n                int itemcount = (uintptr_t)ip->data;\n                Assert(itemcount>=0);\n                jsiVarDeref(interp, itemcount);\n                Jsi_Obj *obj = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount), itemcount, 1);\n                jsiPop(interp, itemcount - 1);\n                jsiClearStack(interp,1);\n                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);\n                break;\n            }\n            case OP_STRY: {\n                jsi_TryInfo *ti = (jsi_TryInfo *)ip->data;\n                jsi_TryList *n = jsi_trylist_new(jsi_TL_TRY, scope, currentScope);\n                \n                n->d.td.tstart = ip;                            /* make every thing pointed to right pos */\n                n->d.td.tend = n->d.td.tstart + ti->trylen;\n                n->d.td.cstart = n->d.td.tend + 1;\n                n->d.td.cend = n->d.td.tend + ti->catchlen;\n                n->d.td.fstart = n->d.td.cend + 1;\n                n->d.td.fend = n->d.td.cend + ti->finallen;\n                n->d.td.tsp = interp->framePtr->Sp;\n                n->inCatch=0;\n                n->inFinal=0;\n\n                jsi_push_try(interp, &trylist, n);\n                break;\n            }\n            case OP_ETRY: {             /* means nothing happen go to final */\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected ETRY opcode??\");\n\n                ip = trylist->d.td.fstart - 1;\n                break;\n            }\n            case OP_SCATCH: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY) \n                    Jsi_LogBug(\"Unexpected SCATCH opcode??\");\n\n                if (!ip->data) {\n                    JSI_DO_THROW(\"catch\");\n                } else {\n                    trylist->inCatch=1;\n                    /* new scope and make var */\n                    scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n                    currentScope = jsi_ObjValueNew(interp);\n                    interp->framePtr->ingsc = scope;  //TODO: changing frame\n                    interp->framePtr->incsc = currentScope;\n                    Jsi_IncrRefCount(interp, currentScope);\n                    Jsi_Value *excpt = Jsi_ValueNew1(interp);\n                    if (ps->last_exception && ps->last_exception->vt != JSI_VT_UNDEF) {\n                        //TODO: fix test262 crash in freeValueTbl@jsiInterp.c:565 for last_exception which is\n                        // freed in jsi_PstateFree@jsiPstate.c:251. Is this code the problem?\n                        Jsi_Value *ple = ps->last_exception;\n                        Jsi_ValueCopy(interp, excpt, ple);\n                        Jsi_ValueReset(interp, &ps->last_exception);\n                    } else if (interp->errMsgBuf[0]) {\n                        Jsi_ValueMakeStringDup(interp, &excpt, interp->errMsgBuf);\n                        interp->errMsgBuf[0] = 0;\n                    }\n                    Jsi_ValueInsert(interp, currentScope, (char*)ip->data, excpt, JSI_OM_DONTENUM);\n                    Jsi_DecrRefCount(interp, excpt);\n                    context_id = ps->_context_id++;\n                }\n                break;\n            }\n            case OP_ECATCH: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected ECATCH opcode??\");\n\n                trylist->inCatch=0;\n                ip = trylist->d.td.fstart - 1;\n                break;\n            }\n            case OP_SFINAL: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected SFINAL opcode??\");\n\n                /* restore scatch scope chain */\n                trylist->inFinal = 1;\n                JSI_RESTORE_SCOPE();\n                break;\n            }\n            case OP_EFINAL: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected EFINAL opcode??\");\n\n                trylist->inFinal = 0;\n                int last_op = trylist->d.td.last_op;\n                jsi_OpCode *tojmp = (last_op == jsi_LOP_JMP ? trylist->d.td.ld.tojmp : 0);\n                \n                pop_try(trylist);\n\n                if (last_op == jsi_LOP_THROW) {\n                    JSI_DO_THROW(\"finally\");\n                } else if (last_op == jsi_LOP_JMP) {\n                    while (1) {\n                        if (trylist == NULL) {\n                            ip = tojmp;\n                            break;\n                        }\n                        /* same as jmp opcode, see above */\n                        if (trylist->type == jsi_TL_TRY) {\n                            if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) {\n                                ip = tojmp;\n                                break;\n                            }\n                            \n                            if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {\n                                trylist->d.td.last_op = jsi_LOP_JMP;\n                                trylist->d.td.ld.tojmp = tojmp;\n                                \n                                ip = trylist->d.td.fstart - 1;\n                                break;\n                            } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {\n                                pop_try(trylist);\n                            } else Jsi_LogBug(\"jmp within a try, but not in its scope?\");\n                        } else {        /* 'with' block */\n                            if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) {\n                                ip = tojmp;\n                                break;\n                            }\n                            JSI_RESTORE_SCOPE();\n                            pop_try(trylist);\n                        }\n                    }\n                }\n                break;\n            }\n            case OP_THROW: {\n                jsiVarDeref(interp,1);\n                Jsi_ValueDup2(interp,&ps->last_exception, _jsi_TOP);\n                interp->didReturn = 1; /* TODO: could possibly hide _jsi_STACK problem */\n                JSI_DO_THROW(\"throw\");\n                break;\n            }\n            case OP_WITH: {\n                static int warnwith = 1;\n                if (strict && warnwith && interp->typeCheck.nowith) {\n                    warnwith = 0;\n                    rc = Jsi_LogError(\"use of with is illegal due to \\\"use nowith\\\"\");\n                    break;\n                }\n                jsiVarDeref(interp,1);\n                Jsi_ValueToObject(interp, _jsi_TOP);\n                \n                jsi_TryList *n = jsi_trylist_new(jsi_TL_WITH, scope, currentScope);\n                \n                n->d.wd.wstart = ip;\n                n->d.wd.wend = n->d.wd.wstart + (uintptr_t)ip->data;\n\n                jsi_push_try(interp, &trylist, n);\n                interp->framePtr->withDepth++;\n                \n                /* make expr to top of scope chain */\n                scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n                currentScope = Jsi_ValueNew1(interp);\n                interp->framePtr->ingsc = scope;\n                interp->framePtr->incsc = currentScope;\n                Jsi_ValueCopy(interp, currentScope, _jsi_TOP);\n                jsiPop(interp,1);\n                \n                context_id = ps->_context_id++;\n                break;\n            }\n            case OP_EWITH: {\n                if (trylist == NULL || trylist->type != jsi_TL_WITH)\n                    Jsi_LogBug(\"Unexpected EWITH opcode??\");\n\n                JSI_RESTORE_SCOPE();\n                \n                pop_try(trylist);\n                interp->framePtr->withDepth--;\n                break;\n            }\n            case OP_DEBUG: {\n                jsi_DebuggerStmt();\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_RESERVED: {\n                jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ip->data;\n                const char *cmd = ri->type == RES_CONTINUE ? \"continue\" : \"break\";\n                /* TODO: continue/break out of labeled scope: see tests/prob/break.jsi. */\n                if (ri->label) {\n                    Jsi_LogError(\"%s: label(%s) not found\", cmd, ri->label);\n                } else {\n                    Jsi_LogError(\"%s must be inside loop(or switch)\", cmd);\n                }\n                rc = JSI_ERROR;\n                break;\n            }\n#ifndef __cplusplus\n            default:\n                Jsi_LogBug(\"invalid op ceod: %d\", ip->op);\n#endif\n        }\n        lop = plop;\n        ip++;\n    }\ndone:\n    while (trylist) {\n        JSI_RESTORE_SCOPE();\n        pop_try(trylist);\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 418,
        "code": "get_function_line(\n\texarg_T\t\t*eap,\n\tchar_u\t\t**line_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (*eap->cmdlinep == *line_to_free)\n\t    *eap->cmdlinep = theline;\n\tvim_free(*line_to_free);\n\t*line_to_free = theline;\n    }\n\n    return theline;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 419,
        "code": "TfLiteStatus EvalHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n\n  // The resource id is generated based on the given table name.\n  const int resource_id = std::hash<std::string>{}(params->table_name);\n\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  auto* resource_handle_data =\n      GetTensorData<std::int32_t>(resource_handle_tensor);\n  resource_handle_data[0] = resource_id;\n\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  resource::CreateHashtableResourceIfNotAvailable(\n      &resources, resource_id, params->key_dtype, params->value_dtype);\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 420,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader_4__reduce_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *__pyx_v_self) {\n  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.current_buffer_size, self.position, self.read_block)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.current_buffer_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->__pyx_base.position); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_INCREF(__pyx_v_self->__pyx_base.buffer);\n  __Pyx_GIVEREF(__pyx_v_self->__pyx_base.buffer);\n  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self->__pyx_base.buffer);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);\n  __Pyx_INCREF(__pyx_v_self->read_block);\n  __Pyx_GIVEREF(__pyx_v_self->read_block);\n  PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_v_self->read_block);\n  __pyx_t_1 = 0;\n  __pyx_t_2 = 0;\n  __pyx_v_state = ((PyObject*)__pyx_t_3);\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":6\n *     cdef bint use_setstate\n *     state = (self.buffer, self.current_buffer_size, self.position, self.read_block)\n *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<\n *     if _dict is not None:\n *         state += (_dict,)\n */\n  __pyx_t_3 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_v__dict = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":7\n *     state = (self.buffer, self.current_buffer_size, self.position, self.read_block)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n  __pyx_t_4 = (__pyx_v__dict != Py_None);\n  __pyx_t_5 = (__pyx_t_4 != 0);\n  if (__pyx_t_5) {\n\n    /* \"(tree fragment)\":8\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *         state += (_dict,)             # <<<<<<<<<<<<<<\n *         use_setstate = True\n *     else:\n */\n    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(__pyx_v__dict);\n    __Pyx_GIVEREF(__pyx_v__dict);\n    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v__dict);\n    __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_2));\n    __pyx_t_2 = 0;\n\n    /* \"(tree fragment)\":9\n *     if _dict is not None:\n *         state += (_dict,)\n *         use_setstate = True             # <<<<<<<<<<<<<<\n *     else:\n *         use_setstate = self.buffer is not None or self.read_block is not None\n */\n    __pyx_v_use_setstate = 1;\n\n    /* \"(tree fragment)\":7\n *     state = (self.buffer, self.current_buffer_size, self.position, self.read_block)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n    goto __pyx_L3;\n  }\n\n  /* \"(tree fragment)\":11\n *         use_setstate = True\n *     else:\n *         use_setstate = self.buffer is not None or self.read_block is not None             # <<<<<<<<<<<<<<\n *     if use_setstate:\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, None), state\n */\n  /*else*/ {\n    __pyx_t_4 = (__pyx_v_self->__pyx_base.buffer != ((PyObject*)Py_None));\n    __pyx_t_6 = (__pyx_t_4 != 0);\n    if (!__pyx_t_6) {\n    } else {\n      __pyx_t_5 = __pyx_t_6;\n      goto __pyx_L4_bool_binop_done;\n    }\n    __pyx_t_6 = (__pyx_v_self->read_block != Py_None);\n    __pyx_t_4 = (__pyx_t_6 != 0);\n    __pyx_t_5 = __pyx_t_4;\n    __pyx_L4_bool_binop_done:;\n    __pyx_v_use_setstate = __pyx_t_5;\n  }\n  __pyx_L3:;\n\n  /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.buffer is not None or self.read_block is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, None), state\n *     else:\n */\n  __pyx_t_5 = (__pyx_v_use_setstate != 0);\n  if (__pyx_t_5) {\n\n    /* \"(tree fragment)\":13\n *         use_setstate = self.buffer is not None or self.read_block is not None\n *     if use_setstate:\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, None), state             # <<<<<<<<<<<<<<\n *     else:\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_CompressedBuffere); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_25411819);\n    __Pyx_GIVEREF(__pyx_int_25411819);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_25411819);\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    PyTuple_SET_ITEM(__pyx_t_3, 2, Py_None);\n    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_GIVEREF(__pyx_t_2);\n    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);\n    __pyx_t_2 = 0;\n    __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_1;\n    __pyx_t_1 = 0;\n    goto __pyx_L0;\n\n    /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.buffer is not None or self.read_block is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, None), state\n *     else:\n */\n  }\n\n  /* \"(tree fragment)\":15\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, None), state\n *     else:\n *         return __pyx_unpickle_CompressedBufferedReader, (type(self), 0x183c0eb, state)             # <<<<<<<<<<<<<<\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_CompressedBufferedReader__set_state(self, __pyx_state)\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_CompressedBuffere); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_25411819);\n    __Pyx_GIVEREF(__pyx_int_25411819);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_25411819);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_state);\n    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_1);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);\n    __pyx_t_1 = 0;\n    __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"(tree fragment)\":1\n * def __reduce_cython__(self):             # <<<<<<<<<<<<<<\n *     cdef tuple state\n *     cdef object _dict\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.CompressedBufferedReader.__reduce_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_state);\n  __Pyx_XDECREF(__pyx_v__dict);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 421,
        "code": "void HTMLFormElement::ScheduleFormSubmission(FormSubmission* submission) {\n  DCHECK(submission->Method() == FormSubmission::kPostMethod ||\n         submission->Method() == FormSubmission::kGetMethod);\n  DCHECK(submission->Data());\n  DCHECK(submission->Form());\n  if (submission->Action().IsEmpty())\n    return;\n  if (GetDocument().IsSandboxed(kSandboxForms)) {\n    GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n        kSecurityMessageSource, kErrorMessageLevel,\n        \"Blocked form submission to '\" + submission->Action().ElidedString() +\n            \"' because the form's frame is sandboxed and the 'allow-forms' \"\n            \"permission is not set.\"));\n    return;\n  }\n\n  if (!GetDocument().GetContentSecurityPolicy()->AllowFormAction(\n          submission->Action())) {\n    return;\n  }\n\n  if (submission->Action().ProtocolIsJavaScript()) {\n    GetDocument()\n        .GetFrame()\n        ->GetScriptController()\n        .ExecuteScriptIfJavaScriptURL(submission->Action(), this);\n    return;\n  }\n\n  Frame* target_frame = GetDocument().GetFrame()->FindFrameForNavigation(\n      submission->Target(), *GetDocument().GetFrame(),\n      submission->RequestURL());\n  if (!target_frame) {\n    target_frame = GetDocument().GetFrame();\n  } else {\n    submission->ClearTarget();\n  }\n  if (!target_frame->GetPage())\n    return;\n\n  UseCounter::Count(GetDocument(), WebFeature::kFormsSubmitted);\n  if (MixedContentChecker::IsMixedFormAction(GetDocument().GetFrame(),\n                                             submission->Action())) {\n    UseCounter::Count(GetDocument().GetFrame(),\n                      WebFeature::kMixedContentFormsSubmitted);\n  }\n\n  if (target_frame->IsLocalFrame()) {\n    ToLocalFrame(target_frame)\n        ->GetNavigationScheduler()\n        .ScheduleFormSubmission(&GetDocument(), submission);\n   } else {\n     FrameLoadRequest frame_load_request =\n         submission->CreateFrameLoadRequest(&GetDocument());\n     ToRemoteFrame(target_frame)->Navigate(frame_load_request);\n   }\n }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5790"
    },
    {
        "index": 422,
        "code": "static int __pyx_pw_17clickhouse_driver_14bufferedreader_20BufferedSocketReader_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_sock = 0;\n  PyObject *__pyx_v_bufsize = 0;\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sock,&__pyx_n_s_bufsize,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sock)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bufsize)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, 1); __PYX_ERR(0, 183, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 183, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_sock = values[0];\n    __pyx_v_bufsize = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 183, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedSocketReader.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_20BufferedSocketReader___init__(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *)__pyx_v_self), __pyx_v_sock, __pyx_v_bufsize);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 423,
        "code": "static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {\n    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;\n    const int is_unsigned = neg_one > const_zero;\n    if (is_unsigned) {\n        if (sizeof(long) < sizeof(long)) {\n            return PyInt_FromLong((long) value);\n        } else if (sizeof(long) <= sizeof(unsigned long)) {\n            return PyLong_FromUnsignedLong((unsigned long) value);\n#ifdef HAVE_LONG_LONG\n        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {\n            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);\n#endif\n        }\n    } else {\n        if (sizeof(long) <= sizeof(long)) {\n            return PyInt_FromLong((long) value);\n#ifdef HAVE_LONG_LONG\n        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {\n            return PyLong_FromLongLong((PY_LONG_LONG) value);\n#endif\n        }\n    }\n    {\n        int one = 1; int little = (int)*(unsigned char *)&one;\n        unsigned char *bytes = (unsigned char *)&value;\n        return _PyLong_FromByteArray(bytes, sizeof(long),\n                                     little, !is_unsigned);\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 424,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedreader_14BufferedReader_5read(PyObject *__pyx_v_self, PyObject *__pyx_arg_unread) {\n  Py_ssize_t __pyx_v_unread;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read (wrapper)\", 0);\n  assert(__pyx_arg_unread); {\n    __pyx_v_unread = __Pyx_PyIndex_AsSsize_t(__pyx_arg_unread); if (unlikely((__pyx_v_unread == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 25, __pyx_L3_error)\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_4read(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *)__pyx_v_self), ((Py_ssize_t)__pyx_v_unread));\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 425,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_4read(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, Py_ssize_t __pyx_v_unread) {\n  Py_ssize_t __pyx_v_next_position;\n  Py_ssize_t __pyx_v_t;\n  char *__pyx_v_buffer_ptr;\n  Py_ssize_t __pyx_v_read_bytes;\n  PyObject *__pyx_v_rv = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  Py_ssize_t __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  Py_ssize_t __pyx_t_6;\n  Py_ssize_t __pyx_t_7;\n  __Pyx_RefNannySetupContext(\"read\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":28\n *         # When the buffer is large enough bytes read are almost\n *         # always hit the buffer.\n *         cdef Py_ssize_t next_position = unread + self.position             # <<<<<<<<<<<<<<\n *         if next_position < self.current_buffer_size:\n *             t = self.position\n */\n  __pyx_v_next_position = (__pyx_v_unread + __pyx_v_self->position);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":29\n *         # always hit the buffer.\n *         cdef Py_ssize_t next_position = unread + self.position\n *         if next_position < self.current_buffer_size:             # <<<<<<<<<<<<<<\n *             t = self.position\n *             self.position = next_position\n */\n  __pyx_t_1 = ((__pyx_v_next_position < __pyx_v_self->current_buffer_size) != 0);\n  if (__pyx_t_1) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":30\n *         cdef Py_ssize_t next_position = unread + self.position\n *         if next_position < self.current_buffer_size:\n *             t = self.position             # <<<<<<<<<<<<<<\n *             self.position = next_position\n *             return bytes(self.buffer[t:self.position])\n */\n    __pyx_t_2 = __pyx_v_self->position;\n    __pyx_v_t = __pyx_t_2;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":31\n *         if next_position < self.current_buffer_size:\n *             t = self.position\n *             self.position = next_position             # <<<<<<<<<<<<<<\n *             return bytes(self.buffer[t:self.position])\n * \n */\n    __pyx_v_self->position = __pyx_v_next_position;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":32\n *             t = self.position\n *             self.position = next_position\n *             return bytes(self.buffer[t:self.position])             # <<<<<<<<<<<<<<\n * \n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)\n */\n    __Pyx_XDECREF(__pyx_r);\n    if (unlikely(__pyx_v_self->buffer == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(0, 32, __pyx_L1_error)\n    }\n    __pyx_t_3 = PySequence_GetSlice(__pyx_v_self->buffer, __pyx_v_t, __pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 32, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 32, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_4;\n    __pyx_t_4 = 0;\n    goto __pyx_L0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":29\n *         # always hit the buffer.\n *         cdef Py_ssize_t next_position = unread + self.position\n *         if next_position < self.current_buffer_size:             # <<<<<<<<<<<<<<\n *             t = self.position\n *             self.position = next_position\n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":34\n *             return bytes(self.buffer[t:self.position])\n * \n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t read_bytes\n *         rv = bytes()\n */\n  __pyx_t_4 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_4);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":36\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)\n *         cdef Py_ssize_t read_bytes\n *         rv = bytes()             # <<<<<<<<<<<<<<\n * \n *         while unread > 0:\n */\n  __pyx_t_4 = __Pyx_PyObject_CallNoArg(((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 36, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_v_rv = ((PyObject*)__pyx_t_4);\n  __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":38\n *         rv = bytes()\n * \n *         while unread > 0:             # <<<<<<<<<<<<<<\n *             if self.position == self.current_buffer_size:\n *                 self.read_into_buffer()\n */\n  while (1) {\n    __pyx_t_1 = ((__pyx_v_unread > 0) != 0);\n    if (!__pyx_t_1) break;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":39\n * \n *         while unread > 0:\n *             if self.position == self.current_buffer_size:             # <<<<<<<<<<<<<<\n *                 self.read_into_buffer()\n *                 buffer_ptr = PyByteArray_AsString(self.buffer)\n */\n    __pyx_t_1 = ((__pyx_v_self->position == __pyx_v_self->current_buffer_size) != 0);\n    if (__pyx_t_1) {\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":40\n *         while unread > 0:\n *             if self.position == self.current_buffer_size:\n *                 self.read_into_buffer()             # <<<<<<<<<<<<<<\n *                 buffer_ptr = PyByteArray_AsString(self.buffer)\n *                 self.position = 0\n */\n      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_read_into_buffer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 40, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_5 = NULL;\n      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);\n        if (likely(__pyx_t_5)) {\n          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n          __Pyx_INCREF(__pyx_t_5);\n          __Pyx_INCREF(function);\n          __Pyx_DECREF_SET(__pyx_t_3, function);\n        }\n      }\n      __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_4);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":41\n *             if self.position == self.current_buffer_size:\n *                 self.read_into_buffer()\n *                 buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *                 self.position = 0\n * \n */\n      __pyx_t_4 = __pyx_v_self->buffer;\n      __Pyx_INCREF(__pyx_t_4);\n      __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_4);\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":42\n *                 self.read_into_buffer()\n *                 buffer_ptr = PyByteArray_AsString(self.buffer)\n *                 self.position = 0             # <<<<<<<<<<<<<<\n * \n *             read_bytes = min(unread, self.current_buffer_size - self.position)\n */\n      __pyx_v_self->position = 0;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":39\n * \n *         while unread > 0:\n *             if self.position == self.current_buffer_size:             # <<<<<<<<<<<<<<\n *                 self.read_into_buffer()\n *                 buffer_ptr = PyByteArray_AsString(self.buffer)\n */\n    }\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":44\n *                 self.position = 0\n * \n *             read_bytes = min(unread, self.current_buffer_size - self.position)             # <<<<<<<<<<<<<<\n *             rv += PyBytes_FromStringAndSize(\n *                 &buffer_ptr[self.position], read_bytes\n */\n    __pyx_t_2 = (__pyx_v_self->current_buffer_size - __pyx_v_self->position);\n    __pyx_t_6 = __pyx_v_unread;\n    if (((__pyx_t_2 < __pyx_t_6) != 0)) {\n      __pyx_t_7 = __pyx_t_2;\n    } else {\n      __pyx_t_7 = __pyx_t_6;\n    }\n    __pyx_v_read_bytes = __pyx_t_7;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":45\n * \n *             read_bytes = min(unread, self.current_buffer_size - self.position)\n *             rv += PyBytes_FromStringAndSize(             # <<<<<<<<<<<<<<\n *                 &buffer_ptr[self.position], read_bytes\n *             )\n */\n    __pyx_t_4 = PyBytes_FromStringAndSize((&(__pyx_v_buffer_ptr[__pyx_v_self->position])), __pyx_v_read_bytes); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 45, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_rv, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 45, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    __Pyx_DECREF_SET(__pyx_v_rv, ((PyObject*)__pyx_t_3));\n    __pyx_t_3 = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":48\n *                 &buffer_ptr[self.position], read_bytes\n *             )\n *             self.position += read_bytes             # <<<<<<<<<<<<<<\n *             unread -= read_bytes\n * \n */\n    __pyx_v_self->position = (__pyx_v_self->position + __pyx_v_read_bytes);\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":49\n *             )\n *             self.position += read_bytes\n *             unread -= read_bytes             # <<<<<<<<<<<<<<\n * \n *         return rv\n */\n    __pyx_v_unread = (__pyx_v_unread - __pyx_v_read_bytes);\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":51\n *             unread -= read_bytes\n * \n *         return rv             # <<<<<<<<<<<<<<\n * \n *     def read_one(self):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_rv);\n  __pyx_r = __pyx_v_rv;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":25\n *         raise NotImplementedError\n * \n *     def read(self, Py_ssize_t unread):             # <<<<<<<<<<<<<<\n *         # When the buffer is large enough bytes read are almost\n *         # always hit the buffer.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_rv);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 426,
        "code": "static CYTHON_INLINE PyObject* __Pyx_decode_c_string(\n         const char* cstring, Py_ssize_t start, Py_ssize_t stop,\n         const char* encoding, const char* errors,\n         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {\n    Py_ssize_t length;\n    if (unlikely((start < 0) | (stop < 0))) {\n        size_t slen = strlen(cstring);\n        if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"c-string too long to convert to Python\");\n            return NULL;\n        }\n        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 427,
        "code": "TfLiteStatus EvalHybrid(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  const double scaling_factor = value->params.scale;\n\n  // col_size after we flatten tensor into 2D.\n  int col_size = 1;\n  for (int i = 1; i < NumDimensions(value); i++) {\n    col_size *= SizeOfDimension(value, i);\n  }\n\n  float* output_ptr = GetTensorData<float>(output);\n  const int8_t* value_ptr = GetTensorData<int8_t>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      // Dequantize embedding values.\n      // TODO(alanchiao): refactor scalar multiply into separate function\n      // for ease of adding a neon equivalent if ever necessary.\n      for (int j = 0; j < col_size; j++) {\n        output_ptr[j + i * col_size] =\n            value_ptr[j + idx * col_size] * scaling_factor;\n      }\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 428,
        "code": "static int parse_json(ogs_sbi_message_t *message,\n        char *content_type, char *json)\n{\n    int rv = OGS_OK;\n    cJSON *item = NULL;\n\n    ogs_assert(message);\n\n    if (!json)\n        return OGS_OK;\n\n    if (!content_type) {\n        ogs_error(\"No Content-type\");\n        return OGS_ERROR;\n    }\n\n    ogs_log_print(OGS_LOG_TRACE, \"%s\", json);\n    item = cJSON_Parse(json);\n    if (!item) {\n        ogs_error(\"JSON parse error\");\n        return OGS_ERROR;\n    }\n\n    if (content_type &&\n        !strncmp(content_type, OGS_SBI_CONTENT_PROBLEM_TYPE,\n            strlen(OGS_SBI_CONTENT_PROBLEM_TYPE))) {\n        message->ProblemDetails = OpenAPI_problem_details_parseFromJSON(item);\n    } else if (content_type &&\n                !strncmp(content_type, OGS_SBI_CONTENT_PATCH_TYPE,\n                    strlen(OGS_SBI_CONTENT_PATCH_TYPE))) {\n        if (item) {\n            OpenAPI_patch_item_t *patch_item = NULL;\n            cJSON *patchJSON = NULL;\n            message->PatchItemList = OpenAPI_list_create();\n            cJSON_ArrayForEach(patchJSON, item) {\n                if (!cJSON_IsObject(patchJSON)) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown JSON\");\n                    goto cleanup;\n                }\n\n                patch_item = OpenAPI_patch_item_parseFromJSON(patchJSON);\n                OpenAPI_list_add(message->PatchItemList, patch_item);\n            }\n        }\n    } else {\n        SWITCH(message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NNRF_NFM)\n\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NF_INSTANCES)\n                message->NFProfile =\n                    OpenAPI_nf_profile_parseFromJSON(item);\n                if (!message->NFProfile) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SUBSCRIPTIONS)\n                message->SubscriptionData =\n                    OpenAPI_subscription_data_parseFromJSON(item);\n                if (!message->SubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_NF_STATUS_NOTIFY)\n                message->NotificationData =\n                    OpenAPI_notification_data_parseFromJSON(item);\n                if (!message->NotificationData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NNRF_DISC)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NF_INSTANCES)\n                message->SearchResult =\n                    OpenAPI_search_result_parseFromJSON(item);\n                if (!message->SearchResult) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n                SWITCH(message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    if (message->res_status == 0) {\n                        message->AuthenticationInfo =\n                            OpenAPI_authentication_info_parseFromJSON(item);\n                        if (!message->AuthenticationInfo) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->UeAuthenticationCtx =\n                        OpenAPI_ue_authentication_ctx_parseFromJSON(item);\n                        if (!message->UeAuthenticationCtx) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    if (message->res_status == 0) {\n                        message->ConfirmationData =\n                            OpenAPI_confirmation_data_parseFromJSON(item);\n                        if (!message->ConfirmationData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->ConfirmationDataResponse =\n                            OpenAPI_confirmation_data_response_parseFromJSON(\n                                    item);\n                        if (!message->ConfirmationDataResponse) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown method [%s]\", message->h.method);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UEAU)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_SECURITY_INFORMATION)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_GENERATE_AUTH_DATA)\n                    if (message->res_status == 0) {\n                        message->AuthenticationInfoRequest =\n                        OpenAPI_authentication_info_request_parseFromJSON(\n                                item);\n                        if (!message->AuthenticationInfoRequest) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->AuthenticationInfoResult =\n                        OpenAPI_authentication_info_result_parseFromJSON(\n                                item);\n                        if (!message->AuthenticationInfoResult) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_AUTH_EVENTS)\n                message->AuthEvent = OpenAPI_auth_event_parseFromJSON(item);\n                if (!message->AuthEvent) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_AMF_3GPP_ACCESS)\n                    message->Amf3GppAccessRegistration =\n                        OpenAPI_amf3_gpp_access_registration_parseFromJSON(\n                                item);\n                    if (!message->Amf3GppAccessRegistration) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_SDM)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n                message->AccessAndMobilitySubscriptionData =\n                    OpenAPI_access_and_mobility_subscription_data_parseFromJSON(\n                            item);\n                if (!message->AccessAndMobilitySubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECT_DATA)\n                message->SmfSelectionSubscriptionData =\n                    OpenAPI_smf_selection_subscription_data_parseFromJSON(item);\n                if (!message->SmfSelectionSubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n                message->UeContextInSmfData =\n                    OpenAPI_ue_context_in_smf_data_parseFromJSON(item);\n                if (!message->UeContextInSmfData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n                message->SessionManagementSubscriptionData =\n                    OpenAPI_session_management_subscription_data_parseFromJSON(\n                            item);\n                if (!message->SessionManagementSubscriptionData) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDR_DR)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SUBSCRIPTION_DATA)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_DATA)\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_SUBSCRIPTION)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->AuthenticationSubscription =\n                                OpenAPI_authentication_subscription_parseFromJSON(item);\n                            if (!message->AuthenticationSubscription) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    CASE(OGS_SBI_RESOURCE_NAME_AUTHENTICATION_STATUS)\n                        message->AuthEvent =\n                            OpenAPI_auth_event_parseFromJSON(item);\n                        if (!message->AuthEvent) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                    break;\n\n                CASE(OGS_SBI_RESOURCE_NAME_CONTEXT_DATA)\n                    message->Amf3GppAccessRegistration =\n                        OpenAPI_amf3_gpp_access_registration_parseFromJSON(\n                                item);\n                    if (!message->Amf3GppAccessRegistration) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n\n                DEFAULT\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_PROVISIONED_DATA)\n                        SWITCH(message->h.resource.component[4])\n                        CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n                            message->AccessAndMobilitySubscriptionData =\n                                OpenAPI_access_and_mobility_subscription_data_parseFromJSON(item);\n                            if (!message->AccessAndMobilitySubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_SMF_SELECTION_SUBSCRIPTION_DATA)\n                            message->SmfSelectionSubscriptionData =\n                                OpenAPI_smf_selection_subscription_data_parseFromJSON(item);\n                            if (!message->SmfSelectionSubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXT_IN_SMF_DATA)\n                            message->UeContextInSmfData =\n                                OpenAPI_ue_context_in_smf_data_parseFromJSON(\n                                        item);\n                            if (!message->UeContextInSmfData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n                            message->SessionManagementSubscriptionData =\n                                OpenAPI_session_management_subscription_data_parseFromJSON(item);\n                            if (!message->SessionManagementSubscriptionData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"Unknown resource name [%s]\",\n                                    message->h.resource.component[4]);\n                        END\n                        break;\n\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                END\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_POLICY_DATA)\n                SWITCH(message->h.resource.component[1])\n                CASE(OGS_SBI_RESOURCE_NAME_UES)\n                    SWITCH(message->h.resource.component[3])\n                    CASE(OGS_SBI_RESOURCE_NAME_AM_DATA)\n\n                        message->AmPolicyData =\n                            OpenAPI_am_policy_data_parseFromJSON(item);\n                        if (!message->AmPolicyData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n\n                    CASE(OGS_SBI_RESOURCE_NAME_SM_DATA)\n\n                        message->SmPolicyData =\n                            OpenAPI_sm_policy_data_parseFromJSON(item);\n                        if (!message->SmPolicyData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                        break;\n\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[3]);\n                    END\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[1]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NSMF_PDUSESSION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_CONTEXTS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_MODIFY)\n                    if (message->res_status == 0) {\n                        message->SmContextUpdateData =\n                            OpenAPI_sm_context_update_data_parseFromJSON(item);\n                        if (!message->SmContextUpdateData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->SmContextUpdatedData =\n                            OpenAPI_sm_context_updated_data_parseFromJSON(item);\n                        if (!message->SmContextUpdatedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_BAD_REQUEST ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_FORBIDDEN ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_NOT_FOUND ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_SERVICE_UNAVAILABLE ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_GATEWAY_TIMEOUT) {\n                        message->SmContextUpdateError =\n                            OpenAPI_sm_context_update_error_parseFromJSON(item);\n                        if (!message->SmContextUpdateError) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                CASE(OGS_SBI_RESOURCE_NAME_RELEASE)\n                    if (message->res_status == 0) {\n                        message->SmContextReleaseData =\n                            OpenAPI_sm_context_release_data_parseFromJSON(item);\n                        if (!message->SmContextReleaseData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NO_CONTENT) {\n                    } else if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                        message->SmContextReleasedData =\n                            OpenAPI_sm_context_released_data_parseFromJSON(\n                                    item);\n                        if (!message->SmContextReleasedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n                DEFAULT\n                    if (message->res_status == 0) {\n                        message->SmContextCreateData =\n                            OpenAPI_sm_context_create_data_parseFromJSON(item);\n                        if (!message->SmContextCreateData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->SmContextCreatedData =\n                            OpenAPI_sm_context_created_data_parseFromJSON(item);\n                        if (!message->SmContextCreatedData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_BAD_REQUEST ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_FORBIDDEN ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_NOT_FOUND ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_SERVICE_UNAVAILABLE ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_GATEWAY_TIMEOUT) {\n                        message->SmContextCreateError =\n                            OpenAPI_sm_context_create_error_parseFromJSON(item);\n                        if (!message->SmContextCreateError) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_COMM)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_CONTEXTS)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES)\n                    if (message->res_status == 0) {\n                        message->N1N2MessageTransferReqData =\n                            OpenAPI_n1_n2_message_transfer_req_data_parseFromJSON(item);\n                        if (!message->N1N2MessageTransferReqData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                                OGS_SBI_HTTP_STATUS_OK ||\n                                message->res_status ==\n                                    OGS_SBI_HTTP_STATUS_ACCEPTED) {\n                        message->N1N2MessageTransferRspData =\n                            OpenAPI_n1_n2_message_transfer_rsp_data_parseFromJSON(item);\n                        if (!message->N1N2MessageTransferRspData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_AM_POLICY_CONTROL)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_POLICIES)\n                if (message->res_status == 0) {\n                    message->PolicyAssociationRequest =\n                        OpenAPI_policy_association_request_parseFromJSON(\n                                item);\n                    if (!message->PolicyAssociationRequest) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                } else if (message->res_status == OGS_SBI_HTTP_STATUS_CREATED) {\n                    message->PolicyAssociation =\n                        OpenAPI_policy_association_parseFromJSON(item);\n                    if (!message->PolicyAssociation) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_SMPOLICYCONTROL)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_POLICIES)\n                if (!message->h.resource.component[1]) {\n                    if (message->res_status == 0) {\n                        message->SmPolicyContextData =\n                            OpenAPI_sm_policy_context_data_parseFromJSON(item);\n                        if (!message->SmPolicyContextData) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    } else if (message->res_status ==\n                            OGS_SBI_HTTP_STATUS_CREATED) {\n                        message->SmPolicyDecision =\n                            OpenAPI_sm_policy_decision_parseFromJSON(item);\n                        if (!message->SmPolicyDecision) {\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        }\n                    }\n                } else {\n                    SWITCH(message->h.resource.component[2])\n                    CASE(OGS_SBI_RESOURCE_NAME_DELETE)\n                        if (message->res_status == 0) {\n                            message->SmPolicyDeleteData =\n                                OpenAPI_sm_policy_delete_data_parseFromJSON(\n                                        item);\n                            if (!message->SmPolicyDeleteData) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown resource name [%s]\",\n                                message->h.resource.component[2]);\n                    END\n                    break;\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NNSSF_NSSELECTION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_NETWORK_SLICE_INFORMATION)\n                if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                    message->AuthorizedNetworkSliceInfo =\n                        OpenAPI_authorized_network_slice_info_parseFromJSON(\n                                item);\n                    if (!message->AuthorizedNetworkSliceInfo) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NBSF_MANAGEMENT)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_PCF_BINDINGS)\n                if (message->h.resource.component[1]) {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_PATCH)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    CASE(OGS_SBI_HTTP_METHOD_DELETE)\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                    break;\n                } else {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_POST)\n                        if (message->res_status == 0 ||\n                            message->res_status ==\n                                OGS_SBI_HTTP_STATUS_CREATED) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n\n                    CASE(OGS_SBI_HTTP_METHOD_GET)\n                        if (message->res_status == OGS_SBI_HTTP_STATUS_OK) {\n                            message->PcfBinding =\n                                OpenAPI_pcf_binding_parseFromJSON(item);\n                            if (!message->PcfBinding) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                    break;\n                }\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NPCF_POLICYAUTHORIZATION)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_APP_SESSIONS)\n                if (message->h.resource.component[1]) {\n                    if (message->h.resource.component[2]) {\n                        SWITCH(message->h.resource.component[2])\n                        CASE(OGS_SBI_RESOURCE_NAME_DELETE)\n                            /* Nothing */\n                            break;\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        END\n                    } else {\n                        SWITCH(message->h.method)\n                        CASE(OGS_SBI_HTTP_METHOD_PATCH)\n                            message->AppSessionContextUpdateDataPatch =\n                                OpenAPI_app_session_context_update_data_patch_parseFromJSON(item);\n                            if (!message->AppSessionContextUpdateDataPatch) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                            break;\n                        DEFAULT\n                            rv = OGS_ERROR;\n                            ogs_error(\"JSON parse error\");\n                        END\n                    }\n                } else {\n                    SWITCH(message->h.method)\n                    CASE(OGS_SBI_HTTP_METHOD_POST)\n                        if (message->res_status == 0 ||\n                            message->res_status ==\n                                OGS_SBI_HTTP_STATUS_CREATED) {\n                            message->AppSessionContext =\n                                OpenAPI_app_session_context_parseFromJSON(item);\n                            if (!message->AppSessionContext) {\n                                rv = OGS_ERROR;\n                                ogs_error(\"JSON parse error\");\n                            }\n                        }\n                        break;\n                    DEFAULT\n                        rv = OGS_ERROR;\n                        ogs_error(\"Unknown method [%s]\", message->h.method);\n                    END\n                }\n                break;\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NAMF_CALLBACK)\n            SWITCH(message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_SM_CONTEXT_STATUS)\n                message->SmContextStatusNotification =\n                    OpenAPI_sm_context_status_notification_parseFromJSON(item);\n                if (!message->SmContextStatusNotification) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[1]);\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NSMF_CALLBACK)\n            SWITCH(message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_N1_N2_FAILURE_NOTIFY)\n                message->N1N2MsgTxfrFailureNotification =\n                    OpenAPI_n1_n2_msg_txfr_failure_notification_parseFromJSON(\n                            item);\n                if (!message->N1N2MsgTxfrFailureNotification) {\n                    rv = OGS_ERROR;\n                    ogs_error(\"JSON parse error\");\n                }\n                break;\n\n            CASE(OGS_SBI_RESOURCE_NAME_SM_POLICY_NOTIFY)\n                SWITCH(message->h.resource.component[2])\n                CASE(OGS_SBI_RESOURCE_NAME_UPDATE)\n                    message->SmPolicyNotification =\n                        OpenAPI_sm_policy_notification_parseFromJSON(item);\n                    if (!message->SmPolicyNotification) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n                CASE(OGS_SBI_RESOURCE_NAME_TERMINATE)\n                    message->TerminationNotification =\n                        OpenAPI_termination_notification_parseFromJSON(item);\n                    if (!message->TerminationNotification) {\n                        rv = OGS_ERROR;\n                        ogs_error(\"JSON parse error\");\n                    }\n                    break;\n\n                DEFAULT\n                    rv = OGS_ERROR;\n                    ogs_error(\"Unknown resource name [%s]\",\n                            message->h.resource.component[2]);\n                END\n                break;\n\n            DEFAULT\n                rv = OGS_ERROR;\n                ogs_error(\"Unknown resource name [%s]\",\n                        message->h.resource.component[0]);\n            END\n            break;\n\n        DEFAULT\n            rv = OGS_ERROR;\n            ogs_error(\"Not implemented API name [%s]\",\n                    message->h.service.name);\n        END\n    }\n\ncleanup:\n\n    cJSON_Delete(item);\n    return rv;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-44108"
    },
    {
        "index": 429,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_10__reduce_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.current_buffer_size, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->current_buffer_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_INCREF(__pyx_v_self->buffer);\n  __Pyx_GIVEREF(__pyx_v_self->buffer);\n  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self->buffer);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);\n  __pyx_t_1 = 0;\n  __pyx_t_2 = 0;\n  __pyx_v_state = ((PyObject*)__pyx_t_3);\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":6\n *     cdef bint use_setstate\n *     state = (self.buffer, self.current_buffer_size, self.position)\n *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<\n *     if _dict is not None:\n *         state += (_dict,)\n */\n  __pyx_t_3 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_v__dict = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":7\n *     state = (self.buffer, self.current_buffer_size, self.position)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n  __pyx_t_4 = (__pyx_v__dict != Py_None);\n  __pyx_t_5 = (__pyx_t_4 != 0);\n  if (__pyx_t_5) {\n\n    /* \"(tree fragment)\":8\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *         state += (_dict,)             # <<<<<<<<<<<<<<\n *         use_setstate = True\n *     else:\n */\n    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(__pyx_v__dict);\n    __Pyx_GIVEREF(__pyx_v__dict);\n    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v__dict);\n    __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_2));\n    __pyx_t_2 = 0;\n\n    /* \"(tree fragment)\":9\n *     if _dict is not None:\n *         state += (_dict,)\n *         use_setstate = True             # <<<<<<<<<<<<<<\n *     else:\n *         use_setstate = self.buffer is not None\n */\n    __pyx_v_use_setstate = 1;\n\n    /* \"(tree fragment)\":7\n *     state = (self.buffer, self.current_buffer_size, self.position)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n    goto __pyx_L3;\n  }\n\n  /* \"(tree fragment)\":11\n *         use_setstate = True\n *     else:\n *         use_setstate = self.buffer is not None             # <<<<<<<<<<<<<<\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, None), state\n */\n  /*else*/ {\n    __pyx_t_5 = (__pyx_v_self->buffer != ((PyObject*)Py_None));\n    __pyx_v_use_setstate = __pyx_t_5;\n  }\n  __pyx_L3:;\n\n  /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.buffer is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, None), state\n *     else:\n */\n  __pyx_t_5 = (__pyx_v_use_setstate != 0);\n  if (__pyx_t_5) {\n\n    /* \"(tree fragment)\":13\n *         use_setstate = self.buffer is not None\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, None), state             # <<<<<<<<<<<<<<\n *     else:\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_BufferedReader); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_44607813);\n    __Pyx_GIVEREF(__pyx_int_44607813);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_44607813);\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    PyTuple_SET_ITEM(__pyx_t_3, 2, Py_None);\n    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_GIVEREF(__pyx_t_2);\n    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);\n    __pyx_t_2 = 0;\n    __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_1;\n    __pyx_t_1 = 0;\n    goto __pyx_L0;\n\n    /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = self.buffer is not None\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, None), state\n *     else:\n */\n  }\n\n  /* \"(tree fragment)\":15\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, None), state\n *     else:\n *         return __pyx_unpickle_BufferedReader, (type(self), 0x2a8a945, state)             # <<<<<<<<<<<<<<\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedReader__set_state(self, __pyx_state)\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pyx_unpickle_BufferedReader); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_44607813);\n    __Pyx_GIVEREF(__pyx_int_44607813);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_44607813);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_v_state);\n    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_1);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);\n    __pyx_t_1 = 0;\n    __pyx_t_3 = 0;\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"(tree fragment)\":1\n * def __reduce_cython__(self):             # <<<<<<<<<<<<<<\n *     cdef tuple state\n *     cdef object _dict\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.__reduce_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_state);\n  __Pyx_XDECREF(__pyx_v__dict);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 430,
        "code": "static CYTHON_INLINE unsigned char __Pyx_PyInt_As_unsigned_char(PyObject *x) {\n    const unsigned char neg_one = (unsigned char) ((unsigned char) 0 - (unsigned char) 1), const_zero = (unsigned char) 0;\n    const int is_unsigned = neg_one > const_zero;\n#if PY_MAJOR_VERSION < 3\n    if (likely(PyInt_Check(x))) {\n        if (sizeof(unsigned char) < sizeof(long)) {\n            __PYX_VERIFY_RETURN_INT(unsigned char, long, PyInt_AS_LONG(x))\n        } else {\n            long val = PyInt_AS_LONG(x);\n            if (is_unsigned && unlikely(val < 0)) {\n                goto raise_neg_overflow;\n            }\n            return (unsigned char) val;\n        }\n    } else\n#endif\n    if (likely(PyLong_Check(x))) {\n        if (is_unsigned) {\n#if CYTHON_USE_PYLONG_INTERNALS\n            const digit* digits = ((PyLongObject*)x)->ob_digit;\n            switch (Py_SIZE(x)) {\n                case  0: return (unsigned char) 0;\n                case  1: __PYX_VERIFY_RETURN_INT(unsigned char, digit, digits[0])\n                case 2:\n                    if (8 * sizeof(unsigned char) > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) >= 2 * PyLong_SHIFT) {\n                            return (unsigned char) (((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));\n                        }\n                    }\n                    break;\n                case 3:\n                    if (8 * sizeof(unsigned char) > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) >= 3 * PyLong_SHIFT) {\n                            return (unsigned char) (((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));\n                        }\n                    }\n                    break;\n                case 4:\n                    if (8 * sizeof(unsigned char) > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) >= 4 * PyLong_SHIFT) {\n                            return (unsigned char) (((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));\n                        }\n                    }\n                    break;\n            }\n#endif\n#if CYTHON_COMPILING_IN_CPYTHON\n            if (unlikely(Py_SIZE(x) < 0)) {\n                goto raise_neg_overflow;\n            }\n#else\n            {\n                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);\n                if (unlikely(result < 0))\n                    return (unsigned char) -1;\n                if (unlikely(result == 1))\n                    goto raise_neg_overflow;\n            }\n#endif\n            if (sizeof(unsigned char) <= sizeof(unsigned long)) {\n                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, unsigned long, PyLong_AsUnsignedLong(x))\n#ifdef HAVE_LONG_LONG\n            } else if (sizeof(unsigned char) <= sizeof(unsigned PY_LONG_LONG)) {\n                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))\n#endif\n            }\n        } else {\n#if CYTHON_USE_PYLONG_INTERNALS\n            const digit* digits = ((PyLongObject*)x)->ob_digit;\n            switch (Py_SIZE(x)) {\n                case  0: return (unsigned char) 0;\n                case -1: __PYX_VERIFY_RETURN_INT(unsigned char, sdigit, (sdigit) (-(sdigit)digits[0]))\n                case  1: __PYX_VERIFY_RETURN_INT(unsigned char,  digit, +digits[0])\n                case -2:\n                    if (8 * sizeof(unsigned char) - 1 > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT) {\n                            return (unsigned char) (((unsigned char)-1)*(((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));\n                        }\n                    }\n                    break;\n                case 2:\n                    if (8 * sizeof(unsigned char) > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT) {\n                            return (unsigned char) ((((((unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));\n                        }\n                    }\n                    break;\n                case -3:\n                    if (8 * sizeof(unsigned char) - 1 > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT) {\n                            return (unsigned char) (((unsigned char)-1)*(((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));\n                        }\n                    }\n                    break;\n                case 3:\n                    if (8 * sizeof(unsigned char) > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT) {\n                            return (unsigned char) ((((((((unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));\n                        }\n                    }\n                    break;\n                case -4:\n                    if (8 * sizeof(unsigned char) - 1 > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) - 1 > 4 * PyLong_SHIFT) {\n                            return (unsigned char) (((unsigned char)-1)*(((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));\n                        }\n                    }\n                    break;\n                case 4:\n                    if (8 * sizeof(unsigned char) > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(unsigned char, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(unsigned char) - 1 > 4 * PyLong_SHIFT) {\n                            return (unsigned char) ((((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0])));\n                        }\n                    }\n                    break;\n            }\n#endif\n            if (sizeof(unsigned char) <= sizeof(long)) {\n                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, long, PyLong_AsLong(x))\n#ifdef HAVE_LONG_LONG\n            } else if (sizeof(unsigned char) <= sizeof(PY_LONG_LONG)) {\n                __PYX_VERIFY_RETURN_INT_EXC(unsigned char, PY_LONG_LONG, PyLong_AsLongLong(x))\n#endif\n            }\n        }\n        {\n#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers\");\n#else\n            unsigned char val;\n            PyObject *v = __Pyx_PyNumber_IntOrLong(x);\n #if PY_MAJOR_VERSION < 3\n            if (likely(v) && !PyLong_Check(v)) {\n                PyObject *tmp = v;\n                v = PyNumber_Long(tmp);\n                Py_DECREF(tmp);\n            }\n #endif\n            if (likely(v)) {\n                int one = 1; int is_little = (int)*(unsigned char *)&one;\n                unsigned char *bytes = (unsigned char *)&val;\n                int ret = _PyLong_AsByteArray((PyLongObject *)v,\n                                              bytes, sizeof(val),\n                                              is_little, !is_unsigned);\n                Py_DECREF(v);\n                if (likely(!ret))\n                    return val;\n            }\n#endif\n            return (unsigned char) -1;\n        }\n    } else {\n        unsigned char val;\n        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);\n        if (!tmp) return (unsigned char) -1;\n        val = __Pyx_PyInt_As_unsigned_char(tmp);\n        Py_DECREF(tmp);\n        return val;\n    }\nraise_overflow:\n    PyErr_SetString(PyExc_OverflowError,\n        \"value too large to convert to unsigned char\");\n    return (unsigned char) -1;\nraise_neg_overflow:\n    PyErr_SetString(PyExc_OverflowError,\n        \"can't convert negative value to unsigned char\");\n    return (unsigned char) -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 431,
        "code": "sixel_allocator_realloc(\n    sixel_allocator_t   /* in */ *allocator,  /* allocator object */\n    void                /* in */ *p,          /* existing buffer to be re-allocated */\n    size_t              /* in */ n)           /* re-allocation size */\n{\n    /* precondition */\n    assert(allocator);\n    assert(allocator->fn_realloc);\n\n    return allocator->fn_realloc(p, n);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21049"
    },
    {
        "index": 432,
        "code": "MONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    int overhead =  16 + 4 + strlen( ns ) + 1;\n    int size = overhead;\n\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n\n    /* TODO: refactor so that we can send the insert message\n     * and the getlasterror messages together. */\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 433,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        regs[a] = mrb_hash_get(mrb, va, vb);\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      regs[a] = mrb_vm_const_get(mrb, syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      regs[a] = mrb_hash_get(mrb, kdict, k);\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1071"
    },
    {
        "index": 434,
        "code": "__Pyx_PyMODINIT_FUNC initbufferedwriter(void)\n#else\n__Pyx_PyMODINIT_FUNC PyInit_bufferedwriter(void) CYTHON_SMALL_CODE; /*proto*/\n__Pyx_PyMODINIT_FUNC PyInit_bufferedwriter(void)\n#if CYTHON_PEP489_MULTI_PHASE_INIT\n{\n  return PyModuleDef_Init(&__pyx_moduledef);\n}\nstatic CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {\n    #if PY_VERSION_HEX >= 0x030700A1\n    static PY_INT64_T main_interpreter_id = -1;\n    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);\n    if (main_interpreter_id == -1) {\n        main_interpreter_id = current_id;\n        return (unlikely(current_id == -1)) ? -1 : 0;\n    } else if (unlikely(main_interpreter_id != current_id))\n    #else\n    static PyInterpreterState *main_interpreter = NULL;\n    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;\n    if (!main_interpreter) {\n        main_interpreter = current_interpreter;\n    } else if (unlikely(main_interpreter != current_interpreter))\n    #endif\n    {\n        PyErr_SetString(\n            PyExc_ImportError,\n            \"Interpreter change detected - this module can only be loaded into one interpreter per process.\");\n        return -1;\n    }\n    return 0;\n}\nstatic CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {\n    PyObject *value = PyObject_GetAttrString(spec, from_name);\n    int result = 0;\n    if (likely(value)) {\n        if (allow_none || value != Py_None) {\n            result = PyDict_SetItemString(moddict, to_name, value);\n        }\n        Py_DECREF(value);\n    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {\n        PyErr_Clear();\n    } else {\n        result = -1;\n    }\n    return result;\n}\nstatic CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {\n    PyObject *module = NULL, *moddict, *modname;\n    if (__Pyx_check_single_interpreter())\n        return NULL;\n    if (__pyx_m)\n        return __Pyx_NewRef(__pyx_m);\n    modname = PyObject_GetAttrString(spec, \"name\");\n    if (unlikely(!modname)) goto bad;\n    module = PyModule_NewObject(modname);\n    Py_DECREF(modname);\n    if (unlikely(!module)) goto bad;\n    moddict = PyModule_GetDict(module);\n    if (unlikely(!moddict)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"loader\", \"__loader__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"origin\", \"__file__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"parent\", \"__package__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"submodule_search_locations\", \"__path__\", 0) < 0)) goto bad;\n    return module;\nbad:\n    Py_XDECREF(module);\n    return NULL;\n}\n\n\nstatic CYTHON_SMALL_CODE int __pyx_pymod_exec_bufferedwriter(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'bufferedwriter' has already been imported. Re-initialisation is not supported.\");\n    return -1;\n  }\n  #elif PY_MAJOR_VERSION >= 3\n  if (__pyx_m) return __Pyx_NewRef(__pyx_m);\n  #endif\n  #if CYTHON_REFNANNY\n__Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"refnanny\");\nif (!__Pyx_RefNanny) {\n  PyErr_Clear();\n  __Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"Cython.Runtime.refnanny\");\n  if (!__Pyx_RefNanny)\n      Py_FatalError(\"failed to import 'refnanny' module\");\n}\n#endif\n  __Pyx_RefNannySetupContext(\"__Pyx_PyMODINIT_FUNC PyInit_bufferedwriter(void)\", 0);\n  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pxy_PyFrame_Initialize_Offsets\n  __Pxy_PyFrame_Initialize_Offsets();\n  #endif\n  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_bytes = PyBytes_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_unicode = PyUnicode_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pyx_CyFunction_USED\n  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_FusedFunction_USED\n  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Coroutine_USED\n  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Generator_USED\n  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_AsyncGen_USED\n  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_StopAsyncIteration_USED\n  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  /*--- Library function declarations ---*/\n  /*--- Threads initialization code ---*/\n  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS\n  #ifdef WITH_THREAD /* Python build with threading support? */\n  PyEval_InitThreads();\n  #endif\n  #endif\n  /*--- Module creation code ---*/\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  __pyx_m = __pyx_pyinit_module;\n  Py_INCREF(__pyx_m);\n  #else\n  #if PY_MAJOR_VERSION < 3\n  __pyx_m = Py_InitModule4(\"bufferedwriter\", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);\n  #else\n  __pyx_m = PyModule_Create(&__pyx_moduledef);\n  #endif\n  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_d);\n  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_b);\n  __pyx_cython_runtime = PyImport_AddModule((char *) \"cython_runtime\"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_cython_runtime);\n  if (PyObject_SetAttrString(__pyx_m, \"__builtins__\", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);\n  /*--- Initialize various global constants etc. ---*/\n  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)\n  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  if (__pyx_module_is_main_clickhouse_driver__bufferedwriter) {\n    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  }\n  #if PY_MAJOR_VERSION >= 3\n  {\n    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)\n    if (!PyDict_GetItemString(modules, \"clickhouse_driver.bufferedwriter\")) {\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.bufferedwriter\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  /*--- Builtin init code ---*/\n  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;\n  /*--- Constants init code ---*/\n  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;\n  /*--- Global type/function init code ---*/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;\n  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  /*--- Execution code ---*/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":5\n * from libc.string cimport memcpy\n * \n * from .varint import write_varint             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_INCREF(__pyx_n_s_write_varint);\n  __Pyx_GIVEREF(__pyx_n_s_write_varint);\n  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_write_varint);\n  __pyx_t_2 = __Pyx_Import(__pyx_n_s_varint, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_write_varint); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_write_varint, __pyx_t_1) < 0) __PYX_ERR(0, 5, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedWriter(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_14bufferedwriter_1__pyx_unpickle_BufferedWriter, NULL, __pyx_n_s_clickhouse_driver_bufferedwriter); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_BufferedWriter, __pyx_t_2) < 0) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_BufferedWriter__set_state(<BufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedWriter__set_state(BufferedWriter __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n */\n  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_14bufferedwriter_3__pyx_unpickle_BufferedSocketWriter, NULL, __pyx_n_s_clickhouse_driver_bufferedwriter); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_BufferedSocketWri, __pyx_t_2) < 0) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_CompressedBufferedWriter(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_14bufferedwriter_5__pyx_unpickle_CompressedBufferedWriter, NULL, __pyx_n_s_clickhouse_driver_bufferedwriter); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_CompressedBuffere, __pyx_t_2) < 0) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":1\n * from cpython cimport PyMem_Malloc, PyMem_Free, PyBytes_AsString, \\             # <<<<<<<<<<<<<<\n *     PyBytes_Check, PyBytes_FromStringAndSize\n * from libc.string cimport memcpy\n */\n  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /*--- Wrapped vars code ---*/\n\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  if (__pyx_m) {\n    if (__pyx_d) {\n      __Pyx_AddTraceback(\"init clickhouse_driver.bufferedwriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n    }\n    Py_CLEAR(__pyx_m);\n  } else if (!PyErr_Occurred()) {\n    PyErr_SetString(PyExc_ImportError, \"init clickhouse_driver.bufferedwriter\");\n  }\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  return (__pyx_m != NULL) ? 0 : -1;\n  #elif PY_MAJOR_VERSION >= 3\n  return __pyx_m;\n  #else\n  return;\n  #endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 435,
        "code": "void AdminRequestHandler::teardownRequest(Transport* transport) noexcept {\n  SCOPE_EXIT {\n    auto const cmd = transport->getCommand();\n\n    if (strncmp(cmd.c_str(), \"dump-apc\", 8) == 0) {\n      hphp_context_exit();\n      hphp_session_exit();\n    } else {\n      hphp_memory_cleanup();\n    }\n  };\n  GetAccessLog().log(transport, nullptr);\n  WarnIfNotOK(transport);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 436,
        "code": "Function *ESTreeIRGen::genES5Function(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode,\n    bool isGeneratorInnerFunction) {\n  assert(functionNode && \"Function AST cannot be null\");\n\n  auto *body = ESTree::getBlockStatement(functionNode);\n  assert(body && \"body of ES5 function cannot be null\");\n\n  Function *newFunction = isGeneratorInnerFunction\n      ? Builder.createGeneratorInnerFunction(\n            originalName,\n            Function::DefinitionKind::ES5Function,\n            ESTree::isStrict(functionNode->strictness),\n            functionNode->getSourceRange(),\n            /* insertBefore */ nullptr)\n      : Builder.createFunction(\n            originalName,\n            Function::DefinitionKind::ES5Function,\n            ESTree::isStrict(functionNode->strictness),\n            functionNode->getSourceRange(),\n            /* isGlobal */ false,\n            /* insertBefore */ nullptr);\n\n  newFunction->setLazyClosureAlias(lazyClosureAlias);\n\n  if (auto *bodyBlock = llvh::dyn_cast<ESTree::BlockStatementNode>(body)) {\n    if (bodyBlock->isLazyFunctionBody) {\n      // Set the AST position and variable context so we can continue later.\n      newFunction->setLazyScope(saveCurrentScope());\n      auto &lazySource = newFunction->getLazySource();\n      lazySource.bufferId = bodyBlock->bufferId;\n      lazySource.nodeKind = getLazyFunctionKind(functionNode);\n      lazySource.functionRange = functionNode->getSourceRange();\n\n      // Set the function's .length.\n      newFunction->setExpectedParamCountIncludingThis(\n          countExpectedArgumentsIncludingThis(functionNode));\n      return newFunction;\n    }\n  }\n\n  FunctionContext newFunctionContext{\n      this, newFunction, functionNode->getSemInfo()};\n\n  if (isGeneratorInnerFunction) {\n    // StartGeneratorInst\n    // ResumeGeneratorInst\n    // at the beginning of the function, to allow for the first .next() call.\n    auto *initGenBB = Builder.createBasicBlock(newFunction);\n    Builder.setInsertionBlock(initGenBB);\n    Builder.createStartGeneratorInst();\n    auto *prologueBB = Builder.createBasicBlock(newFunction);\n    auto *prologueResumeIsReturn = Builder.createAllocStackInst(\n        genAnonymousLabelName(\"isReturn_prologue\"));\n    genResumeGenerator(nullptr, prologueResumeIsReturn, prologueBB);\n\n    if (hasSimpleParams(functionNode)) {\n      // If there are simple params, then we don't need an extra yield/resume.\n      // They can simply be initialized on the first call to `.next`.\n      Builder.setInsertionBlock(prologueBB);\n      emitFunctionPrologue(\n          functionNode,\n          prologueBB,\n          InitES5CaptureState::Yes,\n          DoEmitParameters::Yes);\n    } else {\n      // If there are non-simple params, then we must add a new yield/resume.\n      // The `.next()` call will occur once in the outer function, before\n      // the iterator is returned to the caller of the `function*`.\n      auto *entryPointBB = Builder.createBasicBlock(newFunction);\n      auto *entryPointResumeIsReturn =\n          Builder.createAllocStackInst(genAnonymousLabelName(\"isReturn_entry\"));\n\n      // Initialize parameters.\n      Builder.setInsertionBlock(prologueBB);\n      emitFunctionPrologue(\n          functionNode,\n          prologueBB,\n          InitES5CaptureState::Yes,\n          DoEmitParameters::Yes);\n      Builder.createSaveAndYieldInst(\n          Builder.getLiteralUndefined(), entryPointBB);\n\n      // Actual entry point of function from the caller's perspective.\n      Builder.setInsertionBlock(entryPointBB);\n      genResumeGenerator(\n          nullptr,\n          entryPointResumeIsReturn,\n          Builder.createBasicBlock(newFunction));\n    }\n  } else {\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(newFunction),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::Yes);\n  }\n\n  genStatement(body);\n  emitFunctionEpilogue(Builder.getLiteralUndefined());\n\n  return curFunction()->function;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 437,
        "code": "void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {\n  u_int32_t a;\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  if((packet->payload_packet_len < 3) || (packet->payload == NULL))\n    return;\n\n  if(packet->packet_lines_parsed_complete != 0)\n    return;\n\n  packet->packet_lines_parsed_complete = 1;\n  ndpi_reset_packet_line_info(packet);\n\n  packet->line[packet->parsed_lines].ptr = packet->payload;\n  packet->line[packet->parsed_lines].len = 0;\n\n  for (a = 0; (a < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {\n    if((a + 1) >= packet->payload_packet_len)\n      return; /* Return if only one byte remains (prevent invalid reads past end-of-buffer) */\n\n    if(get_u_int16_t(packet->payload, a) == ntohs(0x0d0a)) {\n      /* If end of line char sequence CR+NL \"\\r\\n\", process line */\n\n      if(((a + 3) <= packet->payload_packet_len)\n\t && (get_u_int16_t(packet->payload, a+2) == ntohs(0x0d0a))) {\n\t/* \\r\\n\\r\\n */\n\tint diff; /* No unsigned ! */\n\tu_int32_t a1 = a + 4;\n\n\tdiff = ndpi_min(packet->payload_packet_len-a1, sizeof(flow->initial_binary_bytes));\n\n\tif(diff > 0) {\n\t  memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);\n\t  flow->initial_binary_bytes_len = diff;\n\t}\n      }\n\n      packet->line[packet->parsed_lines].len =\n\t(u_int16_t)(((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));\n\n      /* First line of a HTTP response parsing. Expected a \"HTTP/1.? ???\" */\n      if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&\n\t strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&\n\t packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] > '0' && /* response code between 000 and 699 */\n\t packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {\n\tpacket->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];\n\tpacket->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");\n\tpacket->http_num_headers++;\n\n\t/* Set server HTTP response code */\n\tif(packet->payload_packet_len >= 12) {\n\t  char buf[4];\n\n\t  /* Set server HTTP response code */\n\t  strncpy(buf, (char *) &packet->payload[9], 3);\n\t  buf[3] = '\\0';\n\n\t  flow->http.response_status_code = atoi(buf);\n\t  /* https://en.wikipedia.org/wiki/List_of_HTTP_status_codes */\n\t  if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))\n\t    flow->http.response_status_code = 0; /* Out of range */\n\t}\n      }\n\n      /* \"Server:\" header line in HTTP response */\n      if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,\n\t\t     \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {\n\t// some stupid clients omit a space and place the servername directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {\n\t  packet->server_line.ptr =\n\t    &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];\n\t  packet->server_line.len =\n\t    packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);\n\t} else {\n\t  packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];\n\t  packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"Host:\" header line in HTTP request */\n      if(packet->line[packet->parsed_lines].len > 6 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {\n\t// some stupid clients omit a space and place the hostname directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[5] == ' ') {\n\t  packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];\n\t  packet->host_line.len = packet->line[packet->parsed_lines].len - 6;\n\t} else {\n\t  packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];\n\t  packet->host_line.len = packet->line[packet->parsed_lines].len - 5;\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"X-Forwarded-For:\" header line in HTTP request. Commonly used for HTTP proxies. */\n      if(packet->line[packet->parsed_lines].len > 17 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {\n\t// some stupid clients omit a space and place the hostname directly after the colon\n\tif(packet->line[packet->parsed_lines].ptr[16] == ' ') {\n\t  packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];\n\t  packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;\n\t} else {\n\t  packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\t  packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;\n\t}\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Type:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 14 &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {\n\tpacket->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];\n\tpacket->content_line.len = packet->line[packet->parsed_lines].len - 14;\n\n\twhile ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))\n\t  packet->content_line.len--, packet->content_line.ptr++;\n\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Type:\" header line in HTTP AGAIN. Probably a bogus response without space after \":\" */\n      if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {\n\tpacket->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];\n\tpacket->content_line.len = packet->line[packet->parsed_lines].len - 13;\n\tpacket->http_num_headers++;\n      }\n\n      if(packet->content_line.len > 0) {\n\t/* application/json; charset=utf-8 */\n\tchar separator[] = {';', '\\r', '\\0'};\n\tint i;\n\n\tfor (i = 0; separator[i] != '\\0'; i++) {\n\t  char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);\n\n\t  if(c != NULL)\n\t    packet->content_line.len = c - (char *) packet->content_line.ptr;\n\t}\n      }\n\n      /* \"Accept:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {\n\tpacket->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->accept_line.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"Referer:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 9 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {\n\tpacket->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];\n\tpacket->referer_line.len = packet->line[packet->parsed_lines].len - 9;\n\tpacket->http_num_headers++;\n      }\n      /* \"User-Agent:\" header line in HTTP request. */\n      if(packet->line[packet->parsed_lines].len > 12 &&\n\t (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {\n\tpacket->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];\n\tpacket->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Encoding:\" header line in HTTP response (and request?). */\n      if(packet->line[packet->parsed_lines].len > 18 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {\n\tpacket->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];\n\tpacket->http_encoding.len = packet->line[packet->parsed_lines].len - 18;\n\tpacket->http_num_headers++;\n      }\n      /* \"Transfer-Encoding:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 19 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {\n\tpacket->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];\n\tpacket->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Length:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 16 &&\n\t ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {\n\tpacket->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\tpacket->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;\n\tpacket->http_num_headers++;\n      }\n      /* \"Content-Disposition\"*/\n      if(packet->line[packet->parsed_lines].len > 21 &&\n\t ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {\n\tpacket->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];\n\tpacket->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;\n\tpacket->http_num_headers++;\n      }\n      /* \"Cookie:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {\n\tpacket->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->http_cookie.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"Origin:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 8 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {\n\tpacket->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];\n\tpacket->http_origin.len = packet->line[packet->parsed_lines].len - 8;\n\tpacket->http_num_headers++;\n      }\n      /* \"X-Session-Type:\" header line in HTTP. */\n      if(packet->line[packet->parsed_lines].len > 16 &&\n\t strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {\n\tpacket->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];\n\tpacket->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;\n\tpacket->http_num_headers++;\n      }\n      /* Identification and counting of other HTTP headers.\n       * We consider the most common headers, but there are many others,\n       * which can be seen at references below:\n       * - https://tools.ietf.org/html/rfc7230\n       * - https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\n       */\n      if((packet->line[packet->parsed_lines].len > 6 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 8 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||\n\t (packet->line[packet->parsed_lines].len > 9 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||\n\t (packet->line[packet->parsed_lines].len > 12 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 15 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 17 &&\n\t  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||\n\t   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||\n\t (packet->line[packet->parsed_lines].len > 27 &&\n\t  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,\n\t\t      \"Upgrade-Insecure-Requests: \", 27) == 0)) {\n\t/* Just count. In the future, if needed, this if can be splited to parse these headers */\n\tpacket->http_num_headers++;\n      }\n\n      if(packet->line[packet->parsed_lines].len == 0) {\n\tpacket->empty_line_position = a;\n\tpacket->empty_line_position_set = 1;\n      }\n\n      if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))\n\treturn;\n\n      packet->parsed_lines++;\n      packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];\n      packet->line[packet->parsed_lines].len = 0;\n\n      a++; /* next char in the payload */\n    }\n  }\n\n  if(packet->parsed_lines >= 1) {\n    packet->line[packet->parsed_lines].len =\n      (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -\n\t\t  ((unsigned long) packet->line[packet->parsed_lines].ptr));\n    packet->parsed_lines++;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15471"
    },
    {
        "index": 438,
        "code": "Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[200];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       \n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"call with undefined var %s%s '%s'%s\", p1, idxBuf, p2, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        return rc;\n    }\n    if (typ <= 0)\n        return JSI_OK;\n    //if (typ&JSI_TT_VOID)\n    //    return JSI_OK;\n    if (interp->typeCheck.all==0) {\n        if (func ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))\n            return JSI_OK;\n    }\n    if (index == 0 && func && func->type == FC_BUILDIN && \n        interp->typeCheck.all == 0) // Normally do not check return types for builtins.\n        return JSI_OK; \n    if ((typ&JSI_TT_ANY)) return JSI_OK;\n    if (index == 0 && arg->vt == JSI_VT_UNDEF) {\n        if (!(typ&JSI_TT_VOID)) \n            goto done;\n        return JSI_OK;\n    }\n    if (isdefault && index && typ&JSI_TT_VOID && arg->vt == JSI_VT_UNDEF)\n        return JSI_OK;\n    if (typ&JSI_TT_UNDEFINED && Jsi_ValueIsUndef(interp, arg)) return rc;\n    if (typ&JSI_TT_NUMBER && Jsi_ValueIsNumber(interp, arg)) return rc;\n    if (typ&JSI_TT_STRING && Jsi_ValueIsString(interp, arg)) return rc;\n    if (typ&JSI_TT_BOOLEAN && Jsi_ValueIsBoolean(interp, arg))  return rc;\n    if (typ&JSI_TT_ARRAY && Jsi_ValueIsArray(interp, arg))   return rc;\n    if (typ&JSI_TT_FUNCTION && Jsi_ValueIsFunction(interp, arg)) return rc;\n    if (typ&JSI_TT_REGEXP && Jsi_ValueIsObjType(interp, arg, JSI_OT_REGEXP)) return rc;\n    if (typ&JSI_TT_USEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_USEROBJ)) return rc;\n    if (typ&JSI_TT_ITEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_ITER)) return rc;\n    if (typ&JSI_TT_OBJECT && (\n        Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT) && Jsi_ValueIsArray(interp, arg)==0))\n        return rc;\n    if (typ&JSI_TT_NULL && Jsi_ValueIsNull(interp, arg)) return rc;\ndone:\n    {\n        Jsi_DString dStr = {};\n        const char *exp = jsi_typeName(interp, typ, &dStr);\n        const char *vtyp = jsi_ValueTypeName(interp, arg);\n        if (index>0)\n            snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        jsi_TypeMismatch(interp);\n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\",\n            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        Jsi_DSFree(&dStr);\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 439,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_6varint_3read_varint(PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_varint (wrapper)\", 0);\n  __pyx_r = __pyx_pf_17clickhouse_driver_6varint_2read_varint(__pyx_self, ((PyObject *)__pyx_v_f));\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 440,
        "code": "Variant HHVM_FUNCTION(fwrite,\n                      const Resource& handle,\n                      const String& data,\n                      int64_t length /* = 0 */) {\n  CHECK_HANDLE(handle, f);\n  int64_t ret = f->write(data, length);\n  if (ret < 0) {\n    raise_notice(\"fwrite(): send of %d bytes failed with errno=%d %s\",\n                 data.size(), errno, folly::errnoStr(errno).c_str());\n    ret = 0;\n  }\n  return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 441,
        "code": "static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)\n{\n    struct parser_buf pbuf = {\n        .f_indx = 0,\n        .tmp_indx = 0,\n        .f_read_size = 0\n    };\n\n    int write_count = 0;\n    int src_fd;\n    int p_state = P_STATE_CODE;\n\n    src_fd = open(src, O_RDONLY);\n    if (src_fd == -1) {\n        fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);\n        return -1;\n    }\n\n    while (p_buf_refill(&pbuf, src_fd) > 0) {\n\n        while (PBUF_F_REMD(pbuf)) {\n\n            switch (p_state) {\n            case P_STATE_COMMENT_C:\n\n                switch (PBUF_F_CHAR(pbuf)) {\n                case '*':\n                    p_buf_push_tmp_char(&pbuf, '*');\n                    continue;\n\n                case '/':\n                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {\n                        pbuf.tmp_indx--;\n                        p_state = P_STATE_CODE;\n                    }\n                    break;\n\n                default:\n                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))\n                        pbuf.tmp_indx--;\n                    break;\n                }\n\n                pbuf.f_indx++;\n\n            case P_STATE_CODE:\n            default:\n\n                /* TODO: add trigraph support */\n\n                switch (PBUF_F_CHAR(pbuf)) {\n                case ' ':\n                case '\\t':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                             PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))\n                        pbuf.f_indx++;\n                    else\n                        p_buf_push_tmp_char(&pbuf, ' ');\n\n                    continue;\n\n                case '\\r':\n                case '\\n':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                             PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {\n                        pbuf.f_indx++;\n                    } else if (pbuf.tmp_indx && \n                            (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {\n                        pbuf.tmp_indx--;\n                        pbuf.f_indx++;\n                    } else {\n                        p_buf_push_tmp_char(&pbuf, '\\n');\n                    }\n\n                    continue;\n\n                case '\\\\':\n                    p_buf_push_tmp_char(&pbuf, '\\\\');\n                    continue;\n\n                case '/':\n                    p_buf_push_tmp_char(&pbuf, '/');\n                    continue;\n\n                case '*':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {\n                        pbuf.tmp_indx--;\n                        pbuf.f_indx++;\n                        p_state = P_STATE_COMMENT_C;\n                        continue;\n                    }\n\n                default:\n                    break;\n                }\n\n                /* TODO: check return values */\n                p_buf_write_tmp(&pbuf, tmp_fd);\n                p_buf_write_f_char(&pbuf, tmp_fd);\n            }\n        }\n    }\n\n    p_buf_write_tmp(&pbuf, tmp_fd);\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21572"
    },
    {
        "index": 442,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader_2read_into_buffer(struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  Py_ssize_t __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_into_buffer\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":202\n * \n *     def read_into_buffer(self):\n *         self.buffer = bytearray(self.read_block())             # <<<<<<<<<<<<<<\n *         self.current_buffer_size = len(self.buffer)\n * \n */\n  __Pyx_INCREF(__pyx_v_self->read_block);\n  __pyx_t_2 = __pyx_v_self->read_block; __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyByteArray_Type)), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_GIVEREF(__pyx_t_2);\n  __Pyx_GOTREF(__pyx_v_self->__pyx_base.buffer);\n  __Pyx_DECREF(__pyx_v_self->__pyx_base.buffer);\n  __pyx_v_self->__pyx_base.buffer = ((PyObject*)__pyx_t_2);\n  __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":203\n *     def read_into_buffer(self):\n *         self.buffer = bytearray(self.read_block())\n *         self.current_buffer_size = len(self.buffer)             # <<<<<<<<<<<<<<\n * \n *         if self.current_buffer_size == 0:\n */\n  __pyx_t_2 = __pyx_v_self->__pyx_base.buffer;\n  __Pyx_INCREF(__pyx_t_2);\n  if (unlikely(__pyx_t_2 == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(0, 203, __pyx_L1_error)\n  }\n  __pyx_t_4 = PyByteArray_GET_SIZE(__pyx_t_2); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 203, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v_self->__pyx_base.current_buffer_size = __pyx_t_4;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":205\n *         self.current_buffer_size = len(self.buffer)\n * \n *         if self.current_buffer_size == 0:             # <<<<<<<<<<<<<<\n *             raise EOFError('Unexpected EOF while reading bytes')\n */\n  __pyx_t_5 = ((__pyx_v_self->__pyx_base.current_buffer_size == 0) != 0);\n  if (unlikely(__pyx_t_5)) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":206\n * \n *         if self.current_buffer_size == 0:\n *             raise EOFError('Unexpected EOF while reading bytes')             # <<<<<<<<<<<<<<\n */\n    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_EOFError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_Raise(__pyx_t_2, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __PYX_ERR(0, 206, __pyx_L1_error)\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":205\n *         self.current_buffer_size = len(self.buffer)\n * \n *         if self.current_buffer_size == 0:             # <<<<<<<<<<<<<<\n *             raise EOFError('Unexpected EOF while reading bytes')\n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":201\n *         super(CompressedBufferedReader, self).__init__(bufsize)\n * \n *     def read_into_buffer(self):             # <<<<<<<<<<<<<<\n *         self.buffer = bytearray(self.read_block())\n *         self.current_buffer_size = len(self.buffer)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.CompressedBufferedReader.read_into_buffer\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 443,
        "code": "lambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    char_u\t*line_to_free = NULL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_characters_str), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n    {\n\tif (cmdline != line_to_free)\n\t    vim_free(cmdline);\n\tgoto erret;\n    }\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t    if (cmdline == line_to_free)\n\t\tline_to_free = NULL;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    vim_free(line_to_free);\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 444,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* ids = GetInput(context, node, 0);\n  const TfLiteTensor* indices = GetInput(context, node, 1);\n  const TfLiteTensor* dense_shape = GetInput(context, node, 2);\n  const TfLiteTensor* weights = GetInput(context, node, 3);\n  const TfLiteTensor* value = GetInput(context, node, 4);\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  int k = 0;\n  int embedding_size = 1;\n  int lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const int dim = dense_shape->data.i32[i];\n    lookup_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const int dim = SizeOfDimension(value, i);\n    embedding_size *= dim;\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const int output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 445,
        "code": "std::unique_ptr<BytecodeModule> BytecodeModuleGenerator::generate() {\n  assert(\n      valid_ &&\n      \"BytecodeModuleGenerator::generate() cannot be called more than once\");\n  valid_ = false;\n\n  assert(\n      functionIDMap_.getElements().size() == functionGenerators_.size() &&\n      \"Missing functions.\");\n\n  auto kinds = stringTable_.getStringKinds();\n  auto hashes = stringTable_.getIdentifierHashes();\n\n  BytecodeOptions bytecodeOptions;\n  bytecodeOptions.staticBuiltins = options_.staticBuiltinsEnabled;\n  bytecodeOptions.cjsModulesStaticallyResolved = !cjsModulesStatic_.empty();\n  std::unique_ptr<BytecodeModule> BM{new BytecodeModule(\n      functionGenerators_.size(),\n      std::move(kinds),\n      std::move(hashes),\n      stringTable_.acquireStringTable(),\n      stringTable_.acquireStringStorage(),\n      regExpTable_.getEntryList(),\n      regExpTable_.getBytecodeBuffer(),\n      entryPointIndex_,\n      std::move(arrayBuffer_),\n      std::move(objKeyBuffer_),\n      std::move(objValBuffer_),\n      cjsModuleOffset_,\n      std::move(cjsModules_),\n      std::move(cjsModulesStatic_),\n      bytecodeOptions)};\n\n  DebugInfoGenerator debugInfoGen{std::move(filenameTable_)};\n\n  const uint32_t strippedFunctionNameId =\n      options_.stripFunctionNames ? getStringID(kStrippedFunctionName) : 0;\n  auto functions = functionIDMap_.getElements();\n  std::shared_ptr<Context> contextIfNeeded;\n  for (unsigned i = 0, e = functions.size(); i < e; ++i) {\n    auto *F = functions[i];\n    auto &BFG = *functionGenerators_[F];\n\n    uint32_t functionNameId = options_.stripFunctionNames\n        ? strippedFunctionNameId\n        : getStringID(functions[i]->getOriginalOrInferredName().str());\n\n    std::unique_ptr<BytecodeFunction> func = BFG.generateBytecodeFunction(\n        F->getDefinitionKind(),\n        F->getKind(),\n        F->isStrictMode(),\n        F->getExpectedParamCountIncludingThis(),\n        F->getFunctionScope()->getVariables().size(),\n        functionNameId);\n\n#ifndef HERMESVM_LEAN\n    if (F->getParent()\n            ->shareContext()\n            ->allowFunctionToStringWithRuntimeSource() ||\n        F->isLazy()) {\n      auto context = F->getParent()->shareContext();\n      assert(\n          (!contextIfNeeded || contextIfNeeded.get() == context.get()) &&\n          \"Different instances of Context seen\");\n      contextIfNeeded = context;\n      BM->setFunctionSourceRange(i, F->getSourceRange());\n    }\n#endif\n\n    if (F->isLazy()) {\n#ifdef HERMESVM_LEAN\n      llvm_unreachable(\"Lazy support compiled out\");\n#else\n      auto lazyData = llvh::make_unique<LazyCompilationData>();\n      lazyData->parentScope = F->getLazyScope();\n      lazyData->nodeKind = F->getLazySource().nodeKind;\n      lazyData->bufferId = F->getLazySource().bufferId;\n      lazyData->originalName = F->getOriginalOrInferredName();\n      lazyData->closureAlias = F->getLazyClosureAlias()\n          ? F->getLazyClosureAlias()->getName()\n          : Identifier();\n      lazyData->strictMode = F->isStrictMode();\n      func->setLazyCompilationData(std::move(lazyData));\n#endif\n    }\n\n    if (BFG.hasDebugInfo()) {\n      uint32_t sourceLocOffset = debugInfoGen.appendSourceLocations(\n          BFG.getSourceLocation(), i, BFG.getDebugLocations());\n      uint32_t lexicalDataOffset = debugInfoGen.appendLexicalData(\n          BFG.getLexicalParentID(), BFG.getDebugVariableNames());\n      func->setDebugOffsets({sourceLocOffset, lexicalDataOffset});\n    }\n    BM->setFunction(i, std::move(func));\n  }\n\n  BM->setContext(contextIfNeeded);\n\n  BM->setDebugInfo(debugInfoGen.serializeWithMove());\n  return BM;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 446,
        "code": "  explicit DataFormatVecPermuteOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    src_format_ = src_format;\n    dst_format_ = dst_format;\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26267"
    },
    {
        "index": 447,
        "code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteMulParams* params, OpData* data) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInput1Tensor);\n  const TfLiteTensor* input2 = GetInput(context, node, kInput2Tensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n\n    double real_multiplier = static_cast<double>(input1->params.scale) *\n                             static_cast<double>(input2->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n\n    data->input1_zero_point = input1->params.zero_point;\n    data->input2_zero_point = input2->params.zero_point;\n    data->output_zero_point = output->params.zero_point;\n  } else {\n    CalculateActivationRange(params->activation,\n                             &data->output_activation_min_f32,\n                             &data->output_activation_max_f32);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 448,
        "code": "compile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    char_u\t*line_to_free = NULL;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tvim_free(line_to_free);\n\t\tline_to_free = line;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon || !(*cmd == '\\''\n\t\t       || (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &line_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    vim_free(line_to_free);\n    free_imported(&cctx);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 449,
        "code": "Variant HHVM_FUNCTION(fwrite,\n                      const Resource& handle,\n                      const String& data,\n                      int64_t length /* = 0 */) {\n  CHECK_HANDLE(handle, f);\n  int64_t ret = f->write(data, length);\n  if (ret < 0) {\n    raise_notice(\"fwrite(): send of %d bytes failed with errno=%d %s\",\n                 data.size(), errno, folly::errnoStr(errno).c_str());\n    ret = 0;\n  }\n  return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 450,
        "code": "static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_InitCachedConstants\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":191\n * \n *         if self.current_buffer_size == 0:\n *             raise EOFError('Unexpected EOF while reading bytes')             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_Unexpected_EOF_while_reading_byt); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 191, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_tuple_);\n  __Pyx_GIVEREF(__pyx_tuple_);\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n  __pyx_tuple__2 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_tuple__2);\n  __Pyx_GIVEREF(__pyx_tuple__2);\n  __pyx_codeobj__3 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__2, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_BufferedReader, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__3)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __pyx_tuple__4 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_tuple__4);\n  __Pyx_GIVEREF(__pyx_tuple__4);\n  __pyx_codeobj__5 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__4, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_BufferedSocketRea, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__5)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __pyx_tuple__6 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_tuple__6);\n  __Pyx_GIVEREF(__pyx_tuple__6);\n  __pyx_codeobj__7 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__6, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_CompressedBuffere, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__7)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_RefNannyFinishContext();\n  return 0;\n  __pyx_L1_error:;\n  __Pyx_RefNannyFinishContext();\n  return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 451,
        "code": "TypedValue HHVM_FUNCTION(substr_compare,\n                         const String& main_str,\n                         const String& str,\n                         int offset,\n                         int length /* = INT_MAX */,\n                         bool case_insensitivity /* = false */) {\n  int s1_len = main_str.size();\n  int s2_len = str.size();\n\n  if (length <= 0) {\n    raise_warning(\"The length must be greater than zero\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (offset < 0) {\n    offset = s1_len + offset;\n    if (offset < 0) offset = 0;\n  }\n\n  if (offset >= s1_len) {\n    raise_warning(\"The start position cannot exceed initial string length\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  int cmp_len = s1_len - offset;\n  if (cmp_len < s2_len) cmp_len = s2_len;\n  if (cmp_len > length) cmp_len = length;\n\n  const char *s1 = main_str.data();\n  if (case_insensitivity) {\n    return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len));\n  }\n  return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 452,
        "code": "gif_process_raster(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g\n)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char lzw_cs;\n    signed int len, code;\n    unsigned int first;\n    signed int codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n    gif_lzw *p;\n\n    lzw_cs = gif_get8(s);\n    clear = 1 << lzw_cs;\n    first = 1;\n    codesize = lzw_cs + 1;\n    codemask = (1 << codesize) - 1;\n    bits = 0;\n    valid_bits = 0;\n    for (code = 0; code < clear; code++) {\n        g->codes[code].prefix = -1;\n        g->codes[code].first = (unsigned char) code;\n        g->codes[code].suffix = (unsigned char) code;\n    }\n\n    /* support no starting clear code */\n    avail = clear + 2;\n    oldcode = (-1);\n\n    len = 0;\n    for(;;) {\n        if (valid_bits < codesize) {\n            if (len == 0) {\n                len = gif_get8(s); /* start new block */\n                if (len == 0) {\n                    return SIXEL_OK;\n                }\n            }\n            --len;\n            bits |= (signed int) gif_get8(s) << valid_bits;\n            valid_bits += 8;\n        } else {\n            code = bits & codemask;\n            bits >>= codesize;\n            valid_bits -= codesize;\n            /* @OPTIMIZE: is there some way we can accelerate the non-clear path? */\n            if (code == clear) {  /* clear code */\n                codesize = lzw_cs + 1;\n                codemask = (1 << codesize) - 1;\n                avail = clear + 2;\n                oldcode = -1;\n                first = 0;\n            } else if (code == clear + 1) { /* end of stream code */\n                s->img_buffer += len;\n                while ((len = gif_get8(s)) > 0) {\n                    s->img_buffer += len;\n                }\n                return SIXEL_OK;\n            } else if (code <= avail) {\n                if (first) {\n                    sixel_helper_set_additional_message(\n                        \"corrupt GIF (reason: no clear code).\");\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n                if (oldcode >= 0) {\n                    if (avail < 4096) {\n                        p = &g->codes[avail++];\n                        p->prefix = (signed short) oldcode;\n                        p->first = g->codes[oldcode].first;\n                        p->suffix = (code == avail) ? p->first : g->codes[code].first;\n                    }\n                } else if (code == avail) {\n                    sixel_helper_set_additional_message(\n                        \"corrupt GIF (reason: illegal code in raster).\");\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n\n                gif_out_code(g, (unsigned short) code);\n\n                if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n                    codesize++;\n                    codemask = (1 << codesize) - 1;\n                }\n\n                oldcode = code;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: illegal code in raster).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21050"
    },
    {
        "index": 453,
        "code": "static Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, nsiz, i, fval, n = 0, maa = 0;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL;\n    Jsi_Func *fptr = NULL;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrCnt;\n    if (nsiz<=0) nsiz = 1;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        Jsi_LogError(\"index too large: %d\", nsiz);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[4];\n\n    fptr = func->d.obj->d.fobj->func;\n    maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < curlen; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if( JSI_OK!=rc ) {\n            goto bail;\n        }\n        if (fval) {\n            nobj->arr[n++] = obj->arr[i];\n            Jsi_IncrRefCount(interp, obj->arr[i]);\n        }\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_ObjSetLength(interp, nobj, n);\n    return JSI_OK;\n        \nbail:\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    if (nrPtr)\n        Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 454,
        "code": "TfLiteStatus PrepareMeanOrSum(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_OK(context, PrepareSimple(context, node));\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  // reduce_mean requires a buffer to store intermediate sum result.\n  OpContext op_context(context, node);\n  if (op_context.input->type == kTfLiteInt8 ||\n      op_context.input->type == kTfLiteUInt8 ||\n      op_context.input->type == kTfLiteInt16) {\n    const double real_multiplier =\n        static_cast<double>(op_context.input->params.scale) /\n        static_cast<double>(op_context.output->params.scale);\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &exponent);\n    data->shift = exponent;\n  }\n  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);\n  if (!IsConstantTensor(op_context.axis)) {\n    SetTensorToDynamic(temp_sum);\n    return kTfLiteOk;\n  }\n  temp_sum->allocation_type = kTfLiteArenaRw;\n  return ResizeTempSum(context, &op_context, temp_sum);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 455,
        "code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 456,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader__set_state(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  int __pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedReader__set_state\", 0);\n\n  /* \"(tree fragment)\":12\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]             # <<<<<<<<<<<<<<\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[3])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (!(likely(PyByteArray_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"bytearray\", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->buffer);\n  __Pyx_DECREF(__pyx_v___pyx_result->buffer);\n  __pyx_v___pyx_result->buffer = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->current_buffer_size = __pyx_t_2;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->position = __pyx_t_2;\n\n  /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[3])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(1, 13, __pyx_L1_error)\n  }\n  __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_4 = ((__pyx_t_2 > 3) != 0);\n  if (__pyx_t_4) {\n  } else {\n    __pyx_t_3 = __pyx_t_4;\n    goto __pyx_L4_bool_binop_done;\n  }\n  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_5 = (__pyx_t_4 != 0);\n  __pyx_t_3 = __pyx_t_5;\n  __pyx_L4_bool_binop_done:;\n  if (__pyx_t_3) {\n\n    /* \"(tree fragment)\":14\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[3])             # <<<<<<<<<<<<<<\n */\n    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    if (unlikely(__pyx_v___pyx_state == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(1, 14, __pyx_L1_error)\n    }\n    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_8 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {\n      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);\n      if (likely(__pyx_t_8)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);\n        __Pyx_INCREF(__pyx_t_8);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_7, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);\n    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n    /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[3])\n */\n  }\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedReader__set_state\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 457,
        "code": "_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            /* bad input, clear info */\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        /* bad size, clear it */\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-17498"
    },
    {
        "index": 458,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  // Check that the inputs and outputs have the right sizes and types.\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 2);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output_values->type);\n\n  const TfLiteTensor* top_k = GetInput(context, node, kInputTopK);\n  TF_LITE_ENSURE_TYPES_EQ(context, top_k->type, kTfLiteInt32);\n\n  // Set output dynamic if the input is not const.\n  if (IsConstantTensor(top_k)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n  } else {\n    TfLiteTensor* output_indexes = GetOutput(context, node, kOutputIndexes);\n    TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n    SetTensorToDynamic(output_indexes);\n    SetTensorToDynamic(output_values);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 459,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_11FixedString_5write_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_items = 0;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"write_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 1); __PYX_ERR(0, 83, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 2); __PYX_ERR(0, 83, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"write_items\") < 0)) __PYX_ERR(0, 83, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_items = values[1];\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 83, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString_4write_items(__pyx_self, __pyx_v_self, __pyx_v_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 460,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedreader_3__pyx_unpickle_BufferedSocketReader(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v___pyx_type = 0;\n  long __pyx_v___pyx_checksum;\n  PyObject *__pyx_v___pyx_state = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedSocketReader (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedSocketReader\", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedSocketReader\", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__pyx_unpickle_BufferedSocketReader\") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v___pyx_type = values[0];\n    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)\n    __pyx_v___pyx_state = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedSocketReader\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedSocketReader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedreader_2__pyx_unpickle_BufferedSocketReader(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 461,
        "code": "TfLiteStatus EvalMean(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  int num_axis = static_cast<int>(NumElements(op_context.axis));\n  TfLiteTensor* temp_index = GetTemporary(context, node, /*index=*/0);\n  TfLiteTensor* resolved_axis = GetTemporary(context, node, /*index=*/1);\n  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);\n  // Resize the output tensor if the output tensor is dynamic.\n  if (IsDynamicTensor(op_context.output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeTempAxis(context, &op_context, resolved_axis));\n    TF_LITE_ENSURE_OK(context, ResizeOutputTensor(context, &op_context));\n    TF_LITE_ENSURE_OK(context, ResizeTempSum(context, &op_context, temp_sum));\n  }\n\n  if (kernel_type == kGenericOptimized) {\n    // Use optimized ops if available.\n    switch (op_context.input->type) {\n      case kTfLiteInt8: {\n        tflite::MeanParams op_params;\n        op_params.axis_count = num_axis;\n        ResolveAxis(GetTensorData<int>(op_context.axis), num_axis, &op_params);\n        const TfLiteTensor* input = op_context.input;\n        if (op_context.params->keep_dims && NumDimensions(input) == 4 &&\n            op_params.axis_count == 2 &&\n            ((op_params.axis[0] == 1 && op_params.axis[1] == 2) ||\n             (op_params.axis[0] == 2 && op_params.axis[1] == 1))) {\n          optimized_integer_ops::Mean(\n              op_params, GetTensorShape(input), GetTensorData<int8_t>(input),\n              input->params.zero_point, input->params.scale,\n              GetTensorShape(op_context.output),\n              GetTensorData<int8_t>(op_context.output),\n              op_context.output->params.zero_point,\n              op_context.output->params.scale,\n              CpuBackendContext::GetFromContext(context));\n          return kTfLiteOk;\n        }\n      } break;\n      case kTfLiteUInt8: {\n        tflite::MeanParams op_params;\n        op_params.axis_count = num_axis;\n        ResolveAxis(GetTensorData<int>(op_context.axis), num_axis, &op_params);\n        const TfLiteTensor* input = op_context.input;\n        if (op_context.params->keep_dims && NumDimensions(input) == 4 &&\n            op_params.axis_count == 2 &&\n            ((op_params.axis[0] == 1 && op_params.axis[1] == 2) ||\n             (op_params.axis[0] == 2 && op_params.axis[1] == 1))) {\n          optimized_ops::Mean(op_params, GetTensorShape(input),\n                              GetTensorData<uint8_t>(input),\n                              input->params.zero_point, input->params.scale,\n                              GetTensorShape(op_context.output),\n                              GetTensorData<uint8_t>(op_context.output),\n                              op_context.output->params.zero_point,\n                              op_context.output->params.scale,\n                              CpuBackendContext::GetFromContext(context));\n          return kTfLiteOk;\n        }\n      } break;\n      default:\n        break;\n    }\n  }\n\n  // From here, it uses the reference implementations.\n  // TODO(b/139102329): Clean up the function signatures to merge the variations\n  // and handle the specialized cases in the combined reference implementations\n  // per each op.\n  switch (op_context.input->type) {\n    case kTfLiteFloat32: {\n      tflite::MeanParams op_params;\n      op_params.axis_count = num_axis;\n      ResolveAxis(GetTensorData<int>(op_context.axis), num_axis, &op_params);\n      const TfLiteTensor* input = op_context.input;\n      // TODO(b/139102329): Handle the below special case in the combined\n      // reference method.\n      // Defer to specialized implementation for 4D Mean across axes 1 & 2.\n      if (op_context.params->keep_dims && NumDimensions(input) == 4 &&\n          op_params.axis_count == 2 &&\n          ((op_params.axis[0] == 1 && op_params.axis[1] == 2) ||\n           (op_params.axis[0] == 2 && op_params.axis[1] == 1))) {\n        reference_ops::Mean(op_params, GetTensorShape(input),\n                            GetTensorData<float>(input),\n                            GetTensorShape(op_context.output),\n                            GetTensorData<float>(op_context.output));\n      } else {\n        TF_LITE_ENSURE(\n            context,\n            optimized_ops::MeanGeneral(\n                GetTensorData<float>(op_context.input),\n                op_context.input->dims->data, op_context.input->dims->size,\n                GetTensorData<float>(op_context.output),\n                op_context.output->dims->data, op_context.output->dims->size,\n                GetTensorData<int>(op_context.axis), num_axis,\n                op_context.params->keep_dims, GetTensorData<int>(temp_index),\n                GetTensorData<int>(resolved_axis),\n                GetTensorData<float>(temp_sum)));\n      }\n    } break;\n    case kTfLiteInt32:\n      TF_LITE_ENSURE(\n          context,\n          reference_ops::Mean(\n              GetTensorData<int>(op_context.input),\n              op_context.input->dims->data, op_context.input->dims->size,\n              GetTensorData<int>(op_context.output),\n              op_context.output->dims->data, op_context.output->dims->size,\n              GetTensorData<int>(op_context.axis), num_axis,\n              op_context.params->keep_dims, GetTensorData<int>(temp_index),\n              GetTensorData<int>(resolved_axis),\n              GetTensorData<int64_t>(temp_sum)));\n      break;\n    case kTfLiteInt64:\n      TF_LITE_ENSURE(\n          context,\n          reference_ops::Mean(\n              GetTensorData<int64_t>(op_context.input),\n              op_context.input->dims->data, op_context.input->dims->size,\n              GetTensorData<int64_t>(op_context.output),\n              op_context.output->dims->data, op_context.output->dims->size,\n              GetTensorData<int>(op_context.axis), num_axis,\n              op_context.params->keep_dims, GetTensorData<int>(temp_index),\n              GetTensorData<int>(resolved_axis),\n              GetTensorData<int64_t>(temp_sum)));\n      break;\n    case kTfLiteInt8: {\n      TF_LITE_ENSURE_OK(context, EvalMeanReferenceOps<int8_t>(\n                                     context, op_context, num_axis, data,\n                                     temp_index, resolved_axis, temp_sum));\n    } break;\n    case kTfLiteInt16: {\n      TF_LITE_ENSURE_OK(context, EvalMeanReferenceOps<int16_t>(\n                                     context, op_context, num_axis, data,\n                                     temp_index, resolved_axis, temp_sum));\n    } break;\n    case kTfLiteUInt8: {\n      TF_LITE_ENSURE_OK(context, EvalMeanReferenceOps<uint8_t>(\n                                     context, op_context, num_axis, data,\n                                     temp_index, resolved_axis, temp_sum));\n    } break;\n    default:\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 462,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, Py_ssize_t __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  Py_ssize_t __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  Py_ssize_t __pyx_v_right;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_bytes_read;\n  unsigned char __pyx_v_b;\n  char *__pyx_v_c_string;\n  Py_ssize_t __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  Py_ssize_t __pyx_t_6;\n  Py_ssize_t __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  Py_ssize_t __pyx_t_10;\n  Py_ssize_t __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef Py_ssize_t i\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":71\n *         cdef Py_ssize_t i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t right\n *         # String length vars\n */\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n */\n  __pyx_v_c_string = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n */\n  __pyx_v_c_string_size = 0x400;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n */\n  __pyx_v_c_encoding = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_encoding); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 81, __pyx_L1_error)\n  if (__pyx_t_2) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":82\n *         cdef char *c_encoding = NULL\n *         if encoding:\n *             encoding = encoding.encode('utf-8')             # <<<<<<<<<<<<<<\n *             c_encoding = encoding\n * \n */\n    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_encoding, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n      if (likely(__pyx_t_4)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_u_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n    __pyx_t_1 = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":83\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding             # <<<<<<<<<<<<<<\n * \n *         cdef object rv = object()\n */\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":85\n *             c_encoding = encoding\n * \n *         cdef object rv = object()             # <<<<<<<<<<<<<<\n *         # String for decode vars.\n *         if c_encoding:\n */\n  __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_builtin_object); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_rv = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":87\n *         cdef object rv = object()\n *         # String for decode vars.\n *         if c_encoding:             # <<<<<<<<<<<<<<\n *             c_string = <char *> PyMem_Realloc(NULL, c_string_size)\n * \n */\n  __pyx_t_2 = (__pyx_v_c_encoding != 0);\n  if (__pyx_t_2) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":88\n *         # String for decode vars.\n *         if c_encoding:\n *             c_string = <char *> PyMem_Realloc(NULL, c_string_size)             # <<<<<<<<<<<<<<\n * \n *         for i in range(n_items):\n */\n    __pyx_v_c_string = ((char *)PyMem_Realloc(NULL, __pyx_v_c_string_size));\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":87\n *         cdef object rv = object()\n *         # String for decode vars.\n *         if c_encoding:             # <<<<<<<<<<<<<<\n *             c_string = <char *> PyMem_Realloc(NULL, c_string_size)\n * \n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":90\n *             c_string = <char *> PyMem_Realloc(NULL, c_string_size)\n * \n *         for i in range(n_items):             # <<<<<<<<<<<<<<\n *             shift = size = 0\n * \n */\n  __pyx_t_6 = __pyx_v_n_items;\n  __pyx_t_7 = __pyx_t_6;\n  for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {\n    __pyx_v_i = __pyx_t_8;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":91\n * \n *         for i in range(n_items):\n *             shift = size = 0             # <<<<<<<<<<<<<<\n * \n *             # Read string size\n */\n    __pyx_v_shift = 0;\n    __pyx_v_size = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":94\n * \n *             # Read string size\n *             while True:             # <<<<<<<<<<<<<<\n *                 if self.position == self.current_buffer_size:\n *                     self.read_into_buffer()\n */\n    while (1) {\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":95\n *             # Read string size\n *             while True:\n *                 if self.position == self.current_buffer_size:             # <<<<<<<<<<<<<<\n *                     self.read_into_buffer()\n *                     # `read_into_buffer` can override buffer\n */\n      __pyx_t_2 = ((__pyx_v_self->position == __pyx_v_self->current_buffer_size) != 0);\n      if (__pyx_t_2) {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":96\n *             while True:\n *                 if self.position == self.current_buffer_size:\n *                     self.read_into_buffer()             # <<<<<<<<<<<<<<\n *                     # `read_into_buffer` can override buffer\n *                     buffer_ptr = PyByteArray_AsString(self.buffer)\n */\n        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_read_into_buffer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 96, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_3);\n        __pyx_t_4 = NULL;\n        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n          if (likely(__pyx_t_4)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n            __Pyx_INCREF(__pyx_t_4);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_3, function);\n          }\n        }\n        __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 96, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_1);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":98\n *                     self.read_into_buffer()\n *                     # `read_into_buffer` can override buffer\n *                     buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *                     self.position = 0\n * \n */\n        __pyx_t_1 = __pyx_v_self->buffer;\n        __Pyx_INCREF(__pyx_t_1);\n        __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":99\n *                     # `read_into_buffer` can override buffer\n *                     buffer_ptr = PyByteArray_AsString(self.buffer)\n *                     self.position = 0             # <<<<<<<<<<<<<<\n * \n *                 b = buffer_ptr[self.position]\n */\n        __pyx_v_self->position = 0;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":95\n *             # Read string size\n *             while True:\n *                 if self.position == self.current_buffer_size:             # <<<<<<<<<<<<<<\n *                     self.read_into_buffer()\n *                     # `read_into_buffer` can override buffer\n */\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":101\n *                     self.position = 0\n * \n *                 b = buffer_ptr[self.position]             # <<<<<<<<<<<<<<\n *                 self.position += 1\n * \n */\n      __pyx_v_b = (__pyx_v_buffer_ptr[__pyx_v_self->position]);\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":102\n * \n *                 b = buffer_ptr[self.position]\n *                 self.position += 1             # <<<<<<<<<<<<<<\n * \n *                 size |= (b & 0x7f) << shift\n */\n      __pyx_v_self->position = (__pyx_v_self->position + 1);\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":104\n *                 self.position += 1\n * \n *                 size |= (b & 0x7f) << shift             # <<<<<<<<<<<<<<\n *                 if b < 0x80:\n *                     break\n */\n      __pyx_v_size = (__pyx_v_size | ((__pyx_v_b & 0x7f) << __pyx_v_shift));\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":105\n * \n *                 size |= (b & 0x7f) << shift\n *                 if b < 0x80:             # <<<<<<<<<<<<<<\n *                     break\n * \n */\n      __pyx_t_2 = ((__pyx_v_b < 0x80) != 0);\n      if (__pyx_t_2) {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":106\n *                 size |= (b & 0x7f) << shift\n *                 if b < 0x80:\n *                     break             # <<<<<<<<<<<<<<\n * \n *                 shift += 7\n */\n        goto __pyx_L8_break;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":105\n * \n *                 size |= (b & 0x7f) << shift\n *                 if b < 0x80:             # <<<<<<<<<<<<<<\n *                     break\n * \n */\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":108\n *                     break\n * \n *                 shift += 7             # <<<<<<<<<<<<<<\n * \n *             right = self.position + size\n */\n      __pyx_v_shift = (__pyx_v_shift + 7);\n    }\n    __pyx_L8_break:;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":110\n *                 shift += 7\n * \n *             right = self.position + size             # <<<<<<<<<<<<<<\n * \n *             if c_encoding:\n */\n    __pyx_v_right = (__pyx_v_self->position + __pyx_v_size);\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":112\n *             right = self.position + size\n * \n *             if c_encoding:             # <<<<<<<<<<<<<<\n *                 if size + 1 > c_string_size:\n *                     c_string_size = size + 1\n */\n    __pyx_t_2 = (__pyx_v_c_encoding != 0);\n    if (__pyx_t_2) {\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":113\n * \n *             if c_encoding:\n *                 if size + 1 > c_string_size:             # <<<<<<<<<<<<<<\n *                     c_string_size = size + 1\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)\n */\n      __pyx_t_2 = (((__pyx_v_size + 1) > __pyx_v_c_string_size) != 0);\n      if (__pyx_t_2) {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":114\n *             if c_encoding:\n *                 if size + 1 > c_string_size:\n *                     c_string_size = size + 1             # <<<<<<<<<<<<<<\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)\n *                     if c_string is NULL:\n */\n        __pyx_v_c_string_size = (__pyx_v_size + 1);\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":115\n *                 if size + 1 > c_string_size:\n *                     c_string_size = size + 1\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)             # <<<<<<<<<<<<<<\n *                     if c_string is NULL:\n *                         raise MemoryError()\n */\n        __pyx_v_c_string = ((char *)PyMem_Realloc(__pyx_v_c_string, __pyx_v_c_string_size));\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":116\n *                     c_string_size = size + 1\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)\n *                     if c_string is NULL:             # <<<<<<<<<<<<<<\n *                         raise MemoryError()\n *                 c_string[size] = 0\n */\n        __pyx_t_2 = ((__pyx_v_c_string == NULL) != 0);\n        if (unlikely(__pyx_t_2)) {\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":117\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)\n *                     if c_string is NULL:\n *                         raise MemoryError()             # <<<<<<<<<<<<<<\n *                 c_string[size] = 0\n *                 bytes_read = 0\n */\n          PyErr_NoMemory(); __PYX_ERR(0, 117, __pyx_L1_error)\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":116\n *                     c_string_size = size + 1\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)\n *                     if c_string is NULL:             # <<<<<<<<<<<<<<\n *                         raise MemoryError()\n *                 c_string[size] = 0\n */\n        }\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":113\n * \n *             if c_encoding:\n *                 if size + 1 > c_string_size:             # <<<<<<<<<<<<<<\n *                     c_string_size = size + 1\n *                     c_string = <char *> PyMem_Realloc(c_string, c_string_size)\n */\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":118\n *                     if c_string is NULL:\n *                         raise MemoryError()\n *                 c_string[size] = 0             # <<<<<<<<<<<<<<\n *                 bytes_read = 0\n * \n */\n      (__pyx_v_c_string[__pyx_v_size]) = 0;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":119\n *                         raise MemoryError()\n *                 c_string[size] = 0\n *                 bytes_read = 0             # <<<<<<<<<<<<<<\n * \n *             # Decoding pure c strings in Cython is faster than in pure Python.\n */\n      __pyx_v_bytes_read = 0;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":112\n *             right = self.position + size\n * \n *             if c_encoding:             # <<<<<<<<<<<<<<\n *                 if size + 1 > c_string_size:\n *                     c_string_size = size + 1\n */\n    }\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":124\n *             # We need to copy it into buffer for adding null symbol at the end.\n *             # In ClickHouse block there is no null\n *             if right > self.current_buffer_size:             # <<<<<<<<<<<<<<\n *                 if c_encoding:\n *                     memcpy(&c_string[bytes_read], &buffer_ptr[self.position],\n */\n    __pyx_t_2 = ((__pyx_v_right > __pyx_v_self->current_buffer_size) != 0);\n    if (__pyx_t_2) {\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":125\n *             # In ClickHouse block there is no null\n *             if right > self.current_buffer_size:\n *                 if c_encoding:             # <<<<<<<<<<<<<<\n *                     memcpy(&c_string[bytes_read], &buffer_ptr[self.position],\n *                            self.current_buffer_size - self.position)\n */\n      __pyx_t_2 = (__pyx_v_c_encoding != 0);\n      if (__pyx_t_2) {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":126\n *             if right > self.current_buffer_size:\n *                 if c_encoding:\n *                     memcpy(&c_string[bytes_read], &buffer_ptr[self.position],             # <<<<<<<<<<<<<<\n *                            self.current_buffer_size - self.position)\n *                 else:\n */\n        (void)(memcpy((&(__pyx_v_c_string[__pyx_v_bytes_read])), (&(__pyx_v_buffer_ptr[__pyx_v_self->position])), (__pyx_v_self->current_buffer_size - __pyx_v_self->position)));\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":125\n *             # In ClickHouse block there is no null\n *             if right > self.current_buffer_size:\n *                 if c_encoding:             # <<<<<<<<<<<<<<\n *                     memcpy(&c_string[bytes_read], &buffer_ptr[self.position],\n *                            self.current_buffer_size - self.position)\n */\n        goto __pyx_L15;\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":129\n *                            self.current_buffer_size - self.position)\n *                 else:\n *                     rv = PyBytes_FromStringAndSize(             # <<<<<<<<<<<<<<\n *                         &buffer_ptr[self.position],\n *                         self.current_buffer_size - self.position\n */\n      /*else*/ {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":131\n *                     rv = PyBytes_FromStringAndSize(\n *                         &buffer_ptr[self.position],\n *                         self.current_buffer_size - self.position             # <<<<<<<<<<<<<<\n *                     )\n * \n */\n        __pyx_t_1 = PyBytes_FromStringAndSize((&(__pyx_v_buffer_ptr[__pyx_v_self->position])), (__pyx_v_self->current_buffer_size - __pyx_v_self->position)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_1);\n        __Pyx_DECREF_SET(__pyx_v_rv, __pyx_t_1);\n        __pyx_t_1 = 0;\n      }\n      __pyx_L15:;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":134\n *                     )\n * \n *                 bytes_read = self.current_buffer_size - self.position             # <<<<<<<<<<<<<<\n *                 # Read the rest of the string.\n *                 while bytes_read != size:\n */\n      __pyx_v_bytes_read = (__pyx_v_self->current_buffer_size - __pyx_v_self->position);\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":136\n *                 bytes_read = self.current_buffer_size - self.position\n *                 # Read the rest of the string.\n *                 while bytes_read != size:             # <<<<<<<<<<<<<<\n *                     self.position = size - bytes_read\n * \n */\n      while (1) {\n        __pyx_t_2 = ((__pyx_v_bytes_read != __pyx_v_size) != 0);\n        if (!__pyx_t_2) break;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":137\n *                 # Read the rest of the string.\n *                 while bytes_read != size:\n *                     self.position = size - bytes_read             # <<<<<<<<<<<<<<\n * \n *                     self.read_into_buffer()\n */\n        __pyx_v_self->position = (__pyx_v_size - __pyx_v_bytes_read);\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":139\n *                     self.position = size - bytes_read\n * \n *                     self.read_into_buffer()             # <<<<<<<<<<<<<<\n *                     # `read_into_buffer` can override buffer\n *                     buffer_ptr = PyByteArray_AsString(self.buffer)\n */\n        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_read_into_buffer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_3);\n        __pyx_t_4 = NULL;\n        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n          if (likely(__pyx_t_4)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n            __Pyx_INCREF(__pyx_t_4);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_3, function);\n          }\n        }\n        __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_1);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":141\n *                     self.read_into_buffer()\n *                     # `read_into_buffer` can override buffer\n *                     buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *                     # There can be not enough data in buffer.\n *                     self.position = min(\n */\n        __pyx_t_1 = __pyx_v_self->buffer;\n        __Pyx_INCREF(__pyx_t_1);\n        __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":144\n *                     # There can be not enough data in buffer.\n *                     self.position = min(\n *                         self.position, self.current_buffer_size             # <<<<<<<<<<<<<<\n *                     )\n *                     if c_encoding:\n */\n        __pyx_t_9 = __pyx_v_self->current_buffer_size;\n        __pyx_t_10 = __pyx_v_self->position;\n        if (((__pyx_t_9 < __pyx_t_10) != 0)) {\n          __pyx_t_11 = __pyx_t_9;\n        } else {\n          __pyx_t_11 = __pyx_t_10;\n        }\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":143\n *                     buffer_ptr = PyByteArray_AsString(self.buffer)\n *                     # There can be not enough data in buffer.\n *                     self.position = min(             # <<<<<<<<<<<<<<\n *                         self.position, self.current_buffer_size\n *                     )\n */\n        __pyx_v_self->position = __pyx_t_11;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":146\n *                         self.position, self.current_buffer_size\n *                     )\n *                     if c_encoding:             # <<<<<<<<<<<<<<\n *                         memcpy(\n *                             &c_string[bytes_read], buffer_ptr, self.position\n */\n        __pyx_t_2 = (__pyx_v_c_encoding != 0);\n        if (__pyx_t_2) {\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":147\n *                     )\n *                     if c_encoding:\n *                         memcpy(             # <<<<<<<<<<<<<<\n *                             &c_string[bytes_read], buffer_ptr, self.position\n *                         )\n */\n          (void)(memcpy((&(__pyx_v_c_string[__pyx_v_bytes_read])), __pyx_v_buffer_ptr, __pyx_v_self->position));\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":146\n *                         self.position, self.current_buffer_size\n *                     )\n *                     if c_encoding:             # <<<<<<<<<<<<<<\n *                         memcpy(\n *                             &c_string[bytes_read], buffer_ptr, self.position\n */\n          goto __pyx_L18;\n        }\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":151\n *                         )\n *                     else:\n *                         rv += PyBytes_FromStringAndSize(             # <<<<<<<<<<<<<<\n *                             buffer_ptr, self.position\n *                         )\n */\n        /*else*/ {\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":152\n *                     else:\n *                         rv += PyBytes_FromStringAndSize(\n *                             buffer_ptr, self.position             # <<<<<<<<<<<<<<\n *                         )\n *                     bytes_read += self.position\n */\n          __pyx_t_1 = PyBytes_FromStringAndSize(__pyx_v_buffer_ptr, __pyx_v_self->position); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 151, __pyx_L1_error)\n          __Pyx_GOTREF(__pyx_t_1);\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":151\n *                         )\n *                     else:\n *                         rv += PyBytes_FromStringAndSize(             # <<<<<<<<<<<<<<\n *                             buffer_ptr, self.position\n *                         )\n */\n          __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_rv, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 151, __pyx_L1_error)\n          __Pyx_GOTREF(__pyx_t_3);\n          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n          __Pyx_DECREF_SET(__pyx_v_rv, __pyx_t_3);\n          __pyx_t_3 = 0;\n        }\n        __pyx_L18:;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":154\n *                             buffer_ptr, self.position\n *                         )\n *                     bytes_read += self.position             # <<<<<<<<<<<<<<\n * \n *             else:\n */\n        __pyx_v_bytes_read = (__pyx_v_bytes_read + __pyx_v_self->position);\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":124\n *             # We need to copy it into buffer for adding null symbol at the end.\n *             # In ClickHouse block there is no null\n *             if right > self.current_buffer_size:             # <<<<<<<<<<<<<<\n *                 if c_encoding:\n *                     memcpy(&c_string[bytes_read], &buffer_ptr[self.position],\n */\n      goto __pyx_L14;\n    }\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":157\n * \n *             else:\n *                 if c_encoding:             # <<<<<<<<<<<<<<\n *                     memcpy(c_string, &buffer_ptr[self.position], size)\n *                 else:\n */\n    /*else*/ {\n      __pyx_t_2 = (__pyx_v_c_encoding != 0);\n      if (__pyx_t_2) {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":158\n *             else:\n *                 if c_encoding:\n *                     memcpy(c_string, &buffer_ptr[self.position], size)             # <<<<<<<<<<<<<<\n *                 else:\n *                     rv = PyBytes_FromStringAndSize(\n */\n        (void)(memcpy(__pyx_v_c_string, (&(__pyx_v_buffer_ptr[__pyx_v_self->position])), __pyx_v_size));\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":157\n * \n *             else:\n *                 if c_encoding:             # <<<<<<<<<<<<<<\n *                     memcpy(c_string, &buffer_ptr[self.position], size)\n *                 else:\n */\n        goto __pyx_L19;\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":160\n *                     memcpy(c_string, &buffer_ptr[self.position], size)\n *                 else:\n *                     rv = PyBytes_FromStringAndSize(             # <<<<<<<<<<<<<<\n *                         &buffer_ptr[self.position], size\n *                     )\n */\n      /*else*/ {\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":161\n *                 else:\n *                     rv = PyBytes_FromStringAndSize(\n *                         &buffer_ptr[self.position], size             # <<<<<<<<<<<<<<\n *                     )\n *                 self.position = right\n */\n        __pyx_t_3 = PyBytes_FromStringAndSize((&(__pyx_v_buffer_ptr[__pyx_v_self->position])), __pyx_v_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_3);\n        __Pyx_DECREF_SET(__pyx_v_rv, __pyx_t_3);\n        __pyx_t_3 = 0;\n      }\n      __pyx_L19:;\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":163\n *                         &buffer_ptr[self.position], size\n *                     )\n *                 self.position = right             # <<<<<<<<<<<<<<\n * \n *             if c_encoding:\n */\n      __pyx_v_self->position = __pyx_v_right;\n    }\n    __pyx_L14:;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":165\n *                 self.position = right\n * \n *             if c_encoding:             # <<<<<<<<<<<<<<\n *                 try:\n *                     rv = c_string[:size].decode(c_encoding)\n */\n    __pyx_t_2 = (__pyx_v_c_encoding != 0);\n    if (__pyx_t_2) {\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":166\n * \n *             if c_encoding:\n *                 try:             # <<<<<<<<<<<<<<\n *                     rv = c_string[:size].decode(c_encoding)\n *                 except UnicodeDecodeError:\n */\n      {\n        __Pyx_PyThreadState_declare\n        __Pyx_PyThreadState_assign\n        __Pyx_ExceptionSave(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14);\n        __Pyx_XGOTREF(__pyx_t_12);\n        __Pyx_XGOTREF(__pyx_t_13);\n        __Pyx_XGOTREF(__pyx_t_14);\n        /*try:*/ {\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":167\n *             if c_encoding:\n *                 try:\n *                     rv = c_string[:size].decode(c_encoding)             # <<<<<<<<<<<<<<\n *                 except UnicodeDecodeError:\n *                     rv = PyBytes_FromStringAndSize(c_string, size)\n */\n          __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_c_string, 0, __pyx_v_size, __pyx_v_c_encoding, NULL, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 167, __pyx_L21_error)\n          __Pyx_GOTREF(__pyx_t_3);\n          __Pyx_DECREF_SET(__pyx_v_rv, __pyx_t_3);\n          __pyx_t_3 = 0;\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":166\n * \n *             if c_encoding:\n *                 try:             # <<<<<<<<<<<<<<\n *                     rv = c_string[:size].decode(c_encoding)\n *                 except UnicodeDecodeError:\n */\n        }\n        __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;\n        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;\n        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;\n        goto __pyx_L28_try_end;\n        __pyx_L21_error:;\n        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":168\n *                 try:\n *                     rv = c_string[:size].decode(c_encoding)\n *                 except UnicodeDecodeError:             # <<<<<<<<<<<<<<\n *                     rv = PyBytes_FromStringAndSize(c_string, size)\n * \n */\n        __pyx_t_15 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_UnicodeDecodeError);\n        if (__pyx_t_15) {\n          __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read_strings\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n          if (__Pyx_GetException(&__pyx_t_3, &__pyx_t_1, &__pyx_t_4) < 0) __PYX_ERR(0, 168, __pyx_L23_except_error)\n          __Pyx_GOTREF(__pyx_t_3);\n          __Pyx_GOTREF(__pyx_t_1);\n          __Pyx_GOTREF(__pyx_t_4);\n\n          /* \"clickhouse_driver/bufferedreader.pyx\":169\n *                     rv = c_string[:size].decode(c_encoding)\n *                 except UnicodeDecodeError:\n *                     rv = PyBytes_FromStringAndSize(c_string, size)             # <<<<<<<<<<<<<<\n * \n *             Py_INCREF(rv)\n */\n          __pyx_t_16 = PyBytes_FromStringAndSize(__pyx_v_c_string, __pyx_v_size); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 169, __pyx_L23_except_error)\n          __Pyx_GOTREF(__pyx_t_16);\n          __Pyx_DECREF_SET(__pyx_v_rv, __pyx_t_16);\n          __pyx_t_16 = 0;\n          __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n          goto __pyx_L22_exception_handled;\n        }\n        goto __pyx_L23_except_error;\n        __pyx_L23_except_error:;\n\n        /* \"clickhouse_driver/bufferedreader.pyx\":166\n * \n *             if c_encoding:\n *                 try:             # <<<<<<<<<<<<<<\n *                     rv = c_string[:size].decode(c_encoding)\n *                 except UnicodeDecodeError:\n */\n        __Pyx_XGIVEREF(__pyx_t_12);\n        __Pyx_XGIVEREF(__pyx_t_13);\n        __Pyx_XGIVEREF(__pyx_t_14);\n        __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_13, __pyx_t_14);\n        goto __pyx_L1_error;\n        __pyx_L22_exception_handled:;\n        __Pyx_XGIVEREF(__pyx_t_12);\n        __Pyx_XGIVEREF(__pyx_t_13);\n        __Pyx_XGIVEREF(__pyx_t_14);\n        __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_13, __pyx_t_14);\n        __pyx_L28_try_end:;\n      }\n\n      /* \"clickhouse_driver/bufferedreader.pyx\":165\n *                 self.position = right\n * \n *             if c_encoding:             # <<<<<<<<<<<<<<\n *                 try:\n *                     rv = c_string[:size].decode(c_encoding)\n */\n    }\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":171\n *                     rv = PyBytes_FromStringAndSize(c_string, size)\n * \n *             Py_INCREF(rv)             # <<<<<<<<<<<<<<\n *             PyTuple_SET_ITEM(items, i, rv)\n * \n */\n    Py_INCREF(__pyx_v_rv);\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":172\n * \n *             Py_INCREF(rv)\n *             PyTuple_SET_ITEM(items, i, rv)             # <<<<<<<<<<<<<<\n * \n *         if c_string:\n */\n    PyTuple_SET_ITEM(__pyx_v_items, __pyx_v_i, __pyx_v_rv);\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":174\n *             PyTuple_SET_ITEM(items, i, rv)\n * \n *         if c_string:             # <<<<<<<<<<<<<<\n *             PyMem_Free(c_string)\n * \n */\n  __pyx_t_2 = (__pyx_v_c_string != 0);\n  if (__pyx_t_2) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":175\n * \n *         if c_string:\n *             PyMem_Free(c_string)             # <<<<<<<<<<<<<<\n * \n *         return items\n */\n    PyMem_Free(__pyx_v_c_string);\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":174\n *             PyTuple_SET_ITEM(items, i, rv)\n * \n *         if c_string:             # <<<<<<<<<<<<<<\n *             PyMem_Free(c_string)\n * \n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":177\n *             PyMem_Free(c_string)\n * \n *         return items             # <<<<<<<<<<<<<<\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, Py_ssize_t n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_16);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read_strings\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_items);\n  __Pyx_XDECREF(__pyx_v_rv);\n  __Pyx_XDECREF(__pyx_v_encoding);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 463,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // TODO(ahentz): Our current implementations rely on the input being 4D,\n  // and the size being 1D tensor with exactly 2 elements.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, size->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, size->dims->data[0], 2);\n\n  output->type = input->type;\n\n  if (!IsConstantTensor(size)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n  return ResizeOutputTensor(context, input, size, output);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 464,
        "code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n\n  // Build the outer function which creates the generator.\n  // Does not have an associated source range.\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n      /* insertBefore */ nullptr);\n\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n\n    // Create a generator function, which will store the arguments.\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n\n    if (!hasSimpleParams(functionNode)) {\n      // If there are non-simple params, step the inner function once to\n      // initialize them.\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n\n    emitFunctionEpilogue(gen);\n  }\n\n  return outerFn;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 465,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSkipGramParams*>(node->builtin_data);\n\n  // Split sentence to words.\n  std::vector<StringRef> words;\n  tflite::StringRef strref = tflite::GetString(GetInput(context, node, 0), 0);\n  int prev_idx = 0;\n  for (int i = 1; i < strref.len; i++) {\n    if (isspace(*(strref.str + i))) {\n      if (i > prev_idx && !isspace(*(strref.str + prev_idx))) {\n        words.push_back({strref.str + prev_idx, i - prev_idx});\n      }\n      prev_idx = i + 1;\n    }\n  }\n  if (strref.len > prev_idx) {\n    words.push_back({strref.str + prev_idx, strref.len - prev_idx});\n  }\n\n  // Generate n-grams recursively.\n  tflite::DynamicBuffer buf;\n  if (words.size() < params->ngram_size) {\n    buf.WriteToTensorAsVector(GetOutput(context, node, 0));\n    return kTfLiteOk;\n  }\n\n  // Stack stores the index of word used to generate ngram.\n  // The size of stack is the size of ngram.\n  std::vector<int> stack(params->ngram_size, 0);\n  // Stack index that indicates which depth the recursion is operating at.\n  int stack_idx = 1;\n  int num_words = words.size();\n\n  while (stack_idx >= 0) {\n    if (ShouldStepInRecursion(params, stack, stack_idx, num_words)) {\n      // When current depth can fill with a new word\n      // and the new word is within the max range to skip,\n      // fill this word to stack, recurse into next depth.\n      stack[stack_idx]++;\n      stack_idx++;\n      if (stack_idx < params->ngram_size) {\n        stack[stack_idx] = stack[stack_idx - 1];\n      }\n    } else {\n      if (ShouldIncludeCurrentNgram(params, stack_idx)) {\n        // Add n-gram to tensor buffer when the stack has filled with enough\n        // words to generate the ngram.\n        std::vector<StringRef> gram(stack_idx);\n        for (int i = 0; i < stack_idx; i++) {\n          gram[i] = words[stack[i]];\n        }\n        buf.AddJoinedString(gram, ' ');\n      }\n      // When current depth cannot fill with a valid new word,\n      // and not in last depth to generate ngram,\n      // step back to previous depth to iterate to next possible word.\n      stack_idx--;\n    }\n  }\n\n  buf.WriteToTensorAsVector(GetOutput(context, node, 0));\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 466,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input1->type) {\n    case kTfLiteInt32: {\n      return EvalImpl<int32_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteInt64: {\n      return EvalImpl<int64_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteFloat32: {\n      return EvalImpl<float>(context, data->requires_broadcast, input1, input2,\n                             output);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by floor_mod.\",\n                           TfLiteTypeGetName(input1->type));\n      return kTfLiteError;\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 467,
        "code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  return len;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0481"
    },
    {
        "index": 468,
        "code": "get_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    // End of the line, get the next one.\n\t    char_u *theline = get_function_line(eap, line_to_free, 0,\n\t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\n\t    if (theline == NULL)\n\t\tbreak;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invalid_argument_str), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(e_non_default_argument_follows_default_argument));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 469,
        "code": "static int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs;\n\tint insn_cnt = env->prog->len, i;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tenv->prev_linfo = NULL;\n\n\tstate = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->curframe = 0;\n\tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n\tif (!state->frame[0]) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\tenv->cur_state = state;\n\tinit_func_state(env, state->frame[0],\n\t\t\tBPF_MAIN_FUNC /* callsite */,\n\t\t\t0 /* frameno */,\n\t\t\t0 /* subprogno, zero == main subprog */);\n\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (env->insn_idx >= insn_cnt) {\n\t\t\tverbose(env, \"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tenv->insn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[env->insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(env,\n\t\t\t\t\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, env->insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (env->log.level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(env, \"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EAGAIN;\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\tif (env->log.level > 1 || (env->log.level && do_print_state)) {\n\t\t\tif (env->log.level > 1)\n\t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n\t\t\telse\n\t\t\t\tverbose(env, \"\\nfrom %d to %d:\",\n\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n\t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (env->log.level) {\n\t\t\tconst struct bpf_insn_cbs cbs = {\n\t\t\t\t.cb_print\t= verbose,\n\t\t\t\t.private_data\t= env,\n\t\t\t};\n\n\t\t\tverbose_linfo(env, env->insn_idx, \"; \");\n\t\t\tverbose(env, \"%d: \", env->insn_idx);\n\t\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t\t}\n\n\t\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\t\terr = bpf_prog_offload_verify_insn(env, env->insn_idx,\n\t\t\t\t\t\t\t   env->prev_insn_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tregs = cur_regs(env);\n\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->src_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_READ, insn->dst_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_src_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, env->insn_idx, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, insn->src_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(env, \"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (is_ctx_reg(env, insn->dst_reg)) {\n\t\t\t\tverbose(env, \"BPF_ST stores into R%d %s is not allowed\\n\",\n\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\treg_type_str[reg_state(env, insn->dst_reg)->type]);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, -1, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    (insn->src_reg != BPF_REG_0 &&\n\t\t\t\t     insn->src_reg != BPF_PSEUDO_CALL) ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\t\terr = check_func_call(env, insn, &env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\terr = check_helper_call(env, insn->imm, env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tenv->insn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (state->curframe) {\n\t\t\t\t\t/* exit from nested function */\n\t\t\t\t\tenv->prev_insn_idx = env->insn_idx;\n\t\t\t\t\terr = prepare_func_exit(env, &env->insn_idx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = check_reference_leak(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(env, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(env, \"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\n\t\t\t\terr = check_return_code(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\nprocess_bpf_exit:\n\t\t\t\terr = pop_stack(env, &env->prev_insn_idx,\n\t\t\t\t\t\t&env->insn_idx);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\t\t\t} else {\n\t\t\t\tverbose(env, \"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(env, \"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tenv->insn_idx++;\n\t}\n\n\tverbose(env, \"processed %d insns (limit %d), stack depth \",\n\t\tinsn_processed, BPF_COMPLEXITY_LIMIT_INSNS);\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tu32 depth = env->subprog_info[i].stack_depth;\n\n\t\tverbose(env, \"%d\", depth);\n\t\tif (i + 1 < env->subprog_cnt)\n\t\t\tverbose(env, \"+\");\n\t}\n\tverbose(env, \"\\n\");\n\tenv->prog->aux->stack_depth = env->subprog_info[0].stack_depth;\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 470,
        "code": "bool MemFile::seek(int64_t offset, int whence /* = SEEK_SET */) {\n  assertx(m_len != -1);\n  if (whence == SEEK_CUR) {\n    if (offset > 0 && offset < bufferedLen()) {\n      setReadPosition(getReadPosition() + offset);\n      setPosition(getPosition() + offset);\n      return true;\n    }\n    offset += getPosition();\n    whence = SEEK_SET;\n  }\n\n  // invalidate the current buffer\n  setWritePosition(0);\n  setReadPosition(0);\n  if (whence == SEEK_SET) {\n    m_cursor = offset;\n  } else {\n    assertx(whence == SEEK_END);\n    m_cursor = m_len + offset;\n  }\n  setPosition(m_cursor);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 471,
        "code": "static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count;\n\tu32 crc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\tgf_list_add(list, sl);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-40563"
    },
    {
        "index": 472,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_3write_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_items = 0;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"write_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 1); __PYX_ERR(0, 131, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, 2); __PYX_ERR(0, 131, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"write_items\") < 0)) __PYX_ERR(0, 131, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_items = values[1];\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"write_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 131, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteFixedString.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_2write_items(__pyx_self, __pyx_v_self, __pyx_v_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 473,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_v___pyx_PickleError = 0;\n  PyObject *__pyx_v___pyx_result = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedReader\", 0);\n\n  /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x2a8a945:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)\n */\n  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x2a8a945) != 0);\n  if (__pyx_t_1) {\n\n    /* \"(tree fragment)\":5\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x2a8a945:\n *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedReader.__new__(__pyx_type)\n */\n    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_n_s_PickleError);\n    __Pyx_GIVEREF(__pyx_n_s_PickleError);\n    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);\n    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_t_2);\n    __pyx_v___pyx_PickleError = __pyx_t_2;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":6\n *     if __pyx_checksum != 0x2a8a945:\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)             # <<<<<<<<<<<<<<\n *     __pyx_result = BufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:\n */\n    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x2a, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_INCREF(__pyx_v___pyx_PickleError);\n    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_5)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_5);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);\n    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_Raise(__pyx_t_3, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __PYX_ERR(1, 6, __pyx_L1_error)\n\n    /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x2a8a945:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)\n */\n  }\n\n  /* \"(tree fragment)\":7\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedReader.__new__(__pyx_type)             # <<<<<<<<<<<<<<\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedReader), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v___pyx_result = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);\n  __pyx_t_6 = (__pyx_t_1 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":9\n *     __pyx_result = BufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):\n */\n    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)\n    __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x2a8a945 = (buffer, current_buffer_size, position))\" % __pyx_checksum)\n *     __pyx_result = BufferedReader.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  }\n\n  /* \"(tree fragment)\":10\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result             # <<<<<<<<<<<<<<\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v___pyx_result);\n  __pyx_r = __pyx_v___pyx_result;\n  goto __pyx_L0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedReader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v___pyx_PickleError);\n  __Pyx_XDECREF(__pyx_v___pyx_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 474,
        "code": "static int __Pyx_modinit_function_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_import_code\", 0);\n  /*--- Function import code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 475,
        "code": "void Free(TfLiteContext* context, void* buffer) {}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 476,
        "code": "static Jsi_RC StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    /* Now handles perl regex flag extensions.*/\n    const char *source_str;\n    int source_len, bLen;\n    const char *replace_str = NULL;\n    int replace_len;\n    int regexec_flags = 0;\n    Jsi_Value *seq, *strVal;\n    Jsi_DString dStr = {};\n    regex_t *regex;\n    Jsi_Regex *re;\n    const char *p;\n    int maxArgs = 1;\n\n    int offset = 0, n, j, isglob = 0, num_matches = 0;\n    /* Is a generic  String.replace if _this->d.obj is a function */\n    ChkString(_this, funcPtr, source_str, &source_len, &bLen);\n    source_len = bLen;\n    if (!skip)\n        strVal = _this;\n    else\n        strVal = Jsi_ValueArrayIndex(interp, args, 0);\n    seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, 1+skip);\n    if (!Jsi_ValueIsFunction(interp, repVal))\n        replace_str = Jsi_ValueToString(interp, repVal, &replace_len);\n    else\n        maxArgs = repVal->d.obj->d.fobj->func->argnames->argCnt;\n    Jsi_DSInit(&dStr);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        const char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        if (!(ce = Jsi_Strstr(source_str, cp)))\n            Jsi_ValueMakeStringDup(interp, ret, source_str);\n        else {\n            int slen;\n            slen = (ce-source_str);\n            if (slen)\n                Jsi_DSAppendLen(&dStr, source_str, slen);\n            if (replace_str)\n                Jsi_DSAppendLen(&dStr, replace_str, replace_len);\n            else {\n                Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, source_str);\n                Jsi_IncrRefCount(interp, inStr);\n                Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n                Jsi_DecrRefCount(interp, inStr);\n            }\n            Jsi_DSAppend(&dStr, ce+Jsi_Strlen(cp), NULL);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNull(interp, ret);\n        return JSI_OK;\n    }\n\n    re = seq->d.obj->d.robj;\n    regex = &re->reg;\n    isglob = (re->eflags & JSI_REG_GLOB);\n    \n    regmatch_t pmatch[MAX_SUBREGEX] = {};\n    /* If an offset has been specified, adjust for that now.\n     * If it points past the end of the string, point to the terminating null\n     */\n    int eoffset=0;\n    if (offset) {\n        if (offset < 0) {\n            offset += source_len + 1;\n        }\n        if (offset > source_len) {\n            offset = source_len;\n        }\n        else if (offset < 0) {\n            offset = 0;\n        }\n    }\n\n    Jsi_DSAppendLen(&dStr, source_str, offset);\n    n = source_len - offset;\n    p = source_str + offset;\n    Jsi_RC rc = JSI_OK;\n    do {\n        if (num_matches > 10000000) {\n            Jsi_LogBug(\"regexp infinite loop\");\n            rc = JSI_ERROR;\n            break;\n        }\n        int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags);\n\n        if (match >= REG_BADPAT) {\n            char buf[100];\n\n            regerror(match, regex, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            Jsi_DSFree(&dStr);\n            return JSI_ERROR;\n        }\n        if (match == REG_NOMATCH) {\n            break;\n        }\n        num_matches++;\n        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);\n\n        if (replace_str &&  !Jsi_Strchr(replace_str, '$'))\n            Jsi_DSAppend(&dStr, replace_str, NULL);\n        else if (replace_str) {\n            for (j = 0; j < replace_len; j++) {\n                int idx;\n                int c = replace_str[j];\n     \n                if (c == '$' && j < replace_len) {\n                    c = replace_str[++j];\n                    if ((c >= '0') && (c <= '9')) {\n                        idx = c - '0';\n                    } else if (c == '&') {\n                        idx = 0;\n                    } else if (c == '$') {\n                        Jsi_DSAppendLen(&dStr, replace_str + j, 1);\n                        continue;\n                    }\n                    else if (c == '\\'') {\n                        Jsi_DSAppendLen(&dStr, p + pmatch[0].rm_eo, pmatch[0].rm_eo-Jsi_Strlen(p));\n                        continue;\n                    }\n                    else if (c == '`') {\n                        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);\n                        continue;\n                    }\n                    else {\n                        Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2);\n                        continue;\n                    }\n                } else {\n                     Jsi_DSAppendLen(&dStr, replace_str + j, 1);\n                     continue;\n                }\n                if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) {\n                    Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so,\n                        pmatch[idx].rm_eo - pmatch[idx].rm_so);\n                }\n            }\n    \n        } else {\n            Jsi_DString sStr;\n            Jsi_DSInit(&sStr); \n            if (pmatch[0].rm_so <= 0 && pmatch[0].rm_eo <= 0)\n                break;\n            int olen = -1;\n            char *ostr = jsi_SubstrDup(p, -1, pmatch[0].rm_so, pmatch[0].rm_eo - pmatch[0].rm_so, &olen);\n            Jsi_Value *inStr = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n            Jsi_DSFree(&sStr);\n            Jsi_IncrRefCount(interp, inStr);\n            if (maxArgs==1) {\n                Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n            } else {\n                Jsi_Value *vpargs, *items[MAX_SUBREGEX] = {}, *ret;\n                int i;\n                items[0] = inStr;\n                for (i=1; i<=(int)re->reg.re_nsub && i<(MAX_SUBREGEX-3); i++) {\n                    if (pmatch[i].rm_so<0)\n                        items[i] = interp->NullValue;\n                    else {\n                        ostr = jsi_SubstrDup(p, -1, pmatch[i].rm_so, pmatch[i].rm_eo - pmatch[i].rm_so, &olen);\n                        items[i] = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n                    }\n                }\n                items[i++] = Jsi_ValueMakeNumber(interp, NULL, eoffset+pmatch[0].rm_so);\n                items[i++] = strVal;\n                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n                Jsi_IncrRefCount(interp, vpargs);\n                ret = Jsi_ValueNew1(interp);\n                rc = Jsi_FunctionInvoke(interp, repVal, vpargs, &ret, NULL);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                Jsi_DecrRefCount(interp, vpargs);\n                if (rc == JSI_OK)\n                    Jsi_DSAppend(&dStr, Jsi_ValueToString(interp, ret, NULL), NULL);\n                Jsi_DecrRefCount(interp, ret);\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n            }\n            Jsi_DecrRefCount(interp, inStr);\n        }\n        eoffset += pmatch[0].rm_eo;\n        p += pmatch[0].rm_eo;\n        n -= pmatch[0].rm_eo;\n        /* If -all is not specified, or there is no source left, we are done */\n        if (!isglob || n == 0 || pmatch[0].rm_eo == 0) {\n            break;\n        }\n        /* An anchored pattern without -line must be done */\n        if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') {\n            break;\n        }\n        \n        /* If the pattern is empty, need to step forwards */\n        if (re->pattern[0] == '\\0' && n) {\n            /* Need to copy the char we are moving over */\n            Jsi_DSAppendLen(&dStr, p, 1);\n            p++;\n            n--;\n        }\n\n        regexec_flags |= REG_NOTBOL;\n    } while (n);\n\n    /*\n     * Copy the portion of the string after the last match to the\n     * result variable.\n     */\n    Jsi_DSAppend(&dStr, p, NULL);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return rc;\n\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 477,
        "code": "static int __pyx_pw_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_sock = 0;\n  PyObject *__pyx_v_bufsize = 0;\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sock,&__pyx_n_s_bufsize,0};\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sock)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bufsize)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, 1); __PYX_ERR(0, 66, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 66, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_sock = values[0];\n    __pyx_v_bufsize = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 66, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedSocketWriter.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter___init__(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *)__pyx_v_self), __pyx_v_sock, __pyx_v_bufsize);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 478,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    double real_multiplier =\n        input1->params.scale * input2->params.scale / output->params.scale;\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 479,
        "code": "TfLiteStatus ResizeOutput(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteIntArray* output_shape = GetOutputShape(context, node);\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)>\n      scoped_output_shape(output_shape, TfLiteIntArrayFree);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Tensorflow's Reshape allows one of the shape components to have the\n  // special -1 value, meaning it will be calculated automatically based on the\n  // input. Here we calculate what that dimension should be so that the number\n  // of output elements in the same as the number of input elements.\n  int num_input_elements = NumElements(input);\n\n  int num_output_elements = 1;\n  int stretch_dim = -1;\n  for (int i = 0; i < output_shape->size; ++i) {\n    int value = output_shape->data[i];\n    if (value == -1) {\n      TF_LITE_ENSURE_EQ(context, stretch_dim, -1);\n      stretch_dim = i;\n    } else {\n      num_output_elements *= value;\n    }\n  }\n  if (stretch_dim != -1) {\n    output_shape->data[stretch_dim] = num_input_elements / num_output_elements;\n    num_output_elements *= output_shape->data[stretch_dim];\n  }\n\n  TF_LITE_ENSURE_EQ(context, num_input_elements, num_output_elements);\n  return context->ResizeTensor(context, output, scoped_output_shape.release());\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 480,
        "code": "   std::string MakeMediaAccessRequest(int index) {\n     const int render_process_id = 1;\n     const int render_frame_id = 1;\n     const int page_request_id = 1;\n     const url::Origin security_origin;\n     MediaStreamManager::MediaAccessRequestCallback callback =\n         base::BindOnce(&MediaStreamManagerTest::ResponseCallback,\n                        base::Unretained(this), index);\n     StreamControls controls(true, true);\n     return media_stream_manager_->MakeMediaAccessRequest(\n        render_process_id, render_frame_id, page_request_id, controls,\n        security_origin, std::move(callback));\n   }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 481,
        "code": "void luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n tailcall:\n  trap = L->hookmask;\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (trap) {\n    if (cl->p->is_vararg)\n      trap = 0;  /* hooks will start after VARARGPREP instruction */\n    else if (pc == cl->p->code)  /* first instruction (not resuming)? */\n      luaD_hookcall(L, ci);\n    ci->u.l.trap = 1;  /* there may be other hooks */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    StkId ra;  /* instruction's A register */\n    vmfetch();\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        Protect(luaF_close(L, ra, LUA_OK));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        ProtectNT(luaD_call(L, ra, nresults));\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int nparams1 = GETARG_C(i);\n        /* delat is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* some calls here can raise errors */\n        if (TESTARG_k(i)) {\n          /* close upvalues from current call; the compiler ensures\n             that there are no to-be-closed variables here, so this\n             call cannot change the stack */\n          luaF_close(L, base, NOCLOSINGMETH);\n          lua_assert(base == ci->func + 1);\n        }\n        while (!ttisfunction(s2v(ra))) {  /* not a function? */\n          luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */\n          b++;  /* there is now one extra argument */\n          checkstackp(L, 1, ra);\n        }\n        if (!ttisLclosure(s2v(ra))) {  /* C function? */\n          luaD_call(L, ra, LUA_MULTRET);  /* call it */\n          updatetrap(ci);\n          updatestack(ci);  /* stack may have been relocated */\n          ci->func -= delta;\n          luaD_poscall(L, ci, cast_int(L->top - ra));\n          return;\n        }\n        ci->func -= delta;\n        luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */\n        goto tailcall;\n      }\n      vmcase(OP_RETURN) {\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, LUA_OK);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        return;\n      }\n      vmcase(OP_RETURN0) {\n        if (L->hookmask) {\n          L->top = ra;\n          halfProtectNT(luaD_poscall(L, ci, 0));  /* no hurry... */\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          while (nres-- > 0)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        return;\n      }\n      vmcase(OP_RETURN1) {\n        if (L->hookmask) {\n          L->top = ra + 1;\n          halfProtectNT(luaD_poscall(L, ci, 1));  /* no hurry... */\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            while (--nres > 0)  /* complete missing results */\n              setnilvalue(s2v(L->top++));\n          }\n        }\n        return;\n      }\n      vmcase(OP_FORLOOP) {\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall:\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }\n      vmcase(OP_TFORLOOP) {\n        l_tforloop:\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETLIST) {\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p);\n        updatetrap(ci);\n        if (trap) {\n          luaD_hookcall(L, ci);\n          L->oldpc = pc + 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 482,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1106"
    },
    {
        "index": 483,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_2read_into_buffer(CYTHON_UNUSED struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_into_buffer\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":23\n * \n *     def read_into_buffer(self):\n *         raise NotImplementedError             # <<<<<<<<<<<<<<\n * \n *     def read(self, Py_ssize_t unread):\n */\n  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);\n  __PYX_ERR(0, 23, __pyx_L1_error)\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":22\n *         super(BufferedReader, self).__init__()\n * \n *     def read_into_buffer(self):             # <<<<<<<<<<<<<<\n *         raise NotImplementedError\n * \n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read_into_buffer\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 484,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const auto* params =\n      reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* positions = GetInput(context, node, kInputPositions);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (positions->type) {\n    case kTfLiteInt64:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(\n          context, \"Positions of type '%s' are not supported by gather.\",\n          TfLiteTypeGetName(positions->type));\n      return kTfLiteError;\n  }\n\n  // Assign to output the input type.\n  output->type = input->type;\n\n  // Check conditions for different types.\n  switch (input->type) {\n    case kTfLiteFloat32:\n    case kTfLiteUInt8:\n    case kTfLiteInt8:\n    case kTfLiteInt16:\n    case kTfLiteInt64:\n    case kTfLiteInt32:\n    case kTfLiteBool:\n      break;\n    case kTfLiteString: {\n      // Only 1D input is supported.\n      TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n    } break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by gather.\",\n                           TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n\n  int axis = params->axis;\n  if (axis < 0) {\n    axis += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, 0 <= axis && axis < NumDimensions(input));\n\n  const int num_dimensions =\n      NumDimensions(input) + NumDimensions(positions) - 1;\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(num_dimensions);\n  int output_index = 0;\n  for (int i = 0; i < axis; ++i) {\n    output_shape->data[output_index++] = input->dims->data[i];\n  }\n  for (int i = 0; i < positions->dims->size; ++i) {\n    output_shape->data[output_index++] = positions->dims->data[i];\n  }\n  for (int i = axis + 1; i < input->dims->size; ++i) {\n    output_shape->data[output_index++] = input->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 485,
        "code": "MONGO_EXPORT void bson_free( void *ptr ) {\n    bson_free_func( ptr );\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 486,
        "code": "PackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t) {\n            return &((unsigned char const *)file_image)[(size_t)t];\n        }\n        break;\n    }\n    return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-20805"
    },
    {
        "index": 487,
        "code": "static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {\n    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;\n    const int is_unsigned = neg_one > const_zero;\n    if (is_unsigned) {\n        if (sizeof(long) < sizeof(long)) {\n            return PyInt_FromLong((long) value);\n        } else if (sizeof(long) <= sizeof(unsigned long)) {\n            return PyLong_FromUnsignedLong((unsigned long) value);\n#ifdef HAVE_LONG_LONG\n        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {\n            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);\n#endif\n        }\n    } else {\n        if (sizeof(long) <= sizeof(long)) {\n            return PyInt_FromLong((long) value);\n#ifdef HAVE_LONG_LONG\n        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {\n            return PyLong_FromLongLong((PY_LONG_LONG) value);\n#endif\n        }\n    }\n    {\n        int one = 1; int little = (int)*(unsigned char *)&one;\n        unsigned char *bytes = (unsigned char *)&value;\n        return _PyLong_FromByteArray(bytes, sizeof(long),\n                                     little, !is_unsigned);\n    }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 488,
        "code": "TfLiteStatus PrepareHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           value_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               value_tensor->type == kTfLiteInt64));\n  // TODO(b/144731295): Tensorflow lookup ops support 1-D vector in storing\n  // values.\n  TF_LITE_ENSURE(context, HaveSameShapes(key_tensor, value_tensor));\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 489,
        "code": "bool MemFile::seek(int64_t offset, int whence /* = SEEK_SET */) {\n  assertx(m_len != -1);\n  if (whence == SEEK_CUR) {\n    if (offset > 0 && offset < bufferedLen()) {\n      setReadPosition(getReadPosition() + offset);\n      setPosition(getPosition() + offset);\n      return true;\n    }\n    offset += getPosition();\n    whence = SEEK_SET;\n  }\n\n  // invalidate the current buffer\n  setWritePosition(0);\n  setReadPosition(0);\n  if (whence == SEEK_SET) {\n    m_cursor = offset;\n  } else {\n    assertx(whence == SEEK_END);\n    m_cursor = m_len + offset;\n  }\n  setPosition(m_cursor);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 490,
        "code": "input_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tn++;\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-27347"
    },
    {
        "index": 491,
        "code": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26572"
    },
    {
        "index": 492,
        "code": "do_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1796"
    },
    {
        "index": 493,
        "code": "Status UncompressElement(const CompressedElement& compressed,\n                         std::vector<Tensor>* out) {\n  int num_components = compressed.component_metadata_size();\n  out->clear();\n  out->reserve(num_components);\n\n  // Step 1: Prepare the memory that we will uncompress into.\n  std::vector<struct iovec> iov(num_components);\n  // We use tstring for access to resize_uninitialized.\n  std::vector<tstring> tensor_proto_strs;\n  // num_components is a conservative estimate. It is important to reserve\n  // vector space so that the vector doesn't resize itself, which could\n  // invalidate pointers to its strings' data.\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      // Allocate an empty Tensor. We will fill it out later after\n      // uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }\n    total_size += iov[i].iov_len;\n  }\n\n  // Step 2: Uncompress into the iovec.\n  const std::string& compressed_data = compressed.data();\n  size_t uncompressed_size;\n  if (!port::Snappy_GetUncompressedLength(\n          compressed_data.data(), compressed_data.size(), &uncompressed_size)) {\n    return errors::Internal(\n        \"Could not get snappy uncompressed length. Compressed data size: \",\n        compressed_data.size());\n  }\n  if (uncompressed_size != static_cast<size_t>(total_size)) {\n    return errors::Internal(\n        \"Uncompressed size mismatch. Snappy expects \", uncompressed_size,\n        \" whereas the tensor metadata suggests \", total_size);\n  }\n  if (!port::Snappy_UncompressToIOVec(compressed_data.data(),\n                                      compressed_data.size(), iov.data(),\n                                      num_components)) {\n    return errors::Internal(\"Failed to perform snappy decompression.\");\n  }\n\n  // Step 3: Deserialize tensor proto strings to tensors.\n  int tensor_proto_strs_index = 0;\n  for (int i = 0; i < num_components; ++i) {\n    if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) {\n      continue;\n    }\n    TensorProto tp;\n    if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) {\n      return errors::Internal(\"Could not parse TensorProto\");\n    }\n    if (!out->at(i).FromProto(tp)) {\n      return errors::Internal(\"Could not parse Tensor\");\n    }\n  }\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37637"
    },
    {
        "index": 494,
        "code": "MONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n\n    start = b->data + b->stack[ --b->stackPos ];\n    i = b->cur - start;\n    bson_little_endian32( start, &i );\n\n    return BSON_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 495,
        "code": "Variant HHVM_FUNCTION(fwrite,\n                      const Resource& handle,\n                      const String& data,\n                      int64_t length /* = 0 */) {\n  CHECK_HANDLE(handle, f);\n  int64_t ret = f->write(data, length);\n  if (ret < 0) {\n    raise_notice(\"fwrite(): send of %d bytes failed with errno=%d %s\",\n                 data.size(), errno, folly::errnoStr(errno).c_str());\n    ret = 0;\n  }\n  return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 496,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_11FixedString___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_length, PyObject *__pyx_v_kwargs) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":48\n * \n *     def __init__(self, length, **kwargs):\n *         self.length = length             # <<<<<<<<<<<<<<\n *         super(FixedString, self).__init__(**kwargs)\n * \n */\n  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_length, __pyx_v_length) < 0) __PYX_ERR(0, 48, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":49\n *     def __init__(self, length, **kwargs):\n *         self.length = length\n *         super(FixedString, self).__init__(**kwargs)             # <<<<<<<<<<<<<<\n * \n *     def read_items(self, Py_ssize_t n_items, buf):\n */\n  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_FixedString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n  __Pyx_INCREF(__pyx_v_self);\n  __Pyx_GIVEREF(__pyx_v_self);\n  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);\n  __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_v_kwargs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":47\n *     ch_type = 'FixedString'\n * \n *     def __init__(self, length, **kwargs):             # <<<<<<<<<<<<<<\n *         self.length = length\n *         super(FixedString, self).__init__(**kwargs)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.FixedString.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 497,
        "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 498,
        "code": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                /* packet_data_pptr would overflow! */\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    /* Option number 15 reserved for payload marker. This is handled as a error! */\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n\n    *dst = option_number;\n    return 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12887"
    },
    {
        "index": 499,
        "code": "__Pyx_PyMODINIT_FUNC initbufferedreader(void)\n#else\n__Pyx_PyMODINIT_FUNC PyInit_bufferedreader(void) CYTHON_SMALL_CODE; /*proto*/\n__Pyx_PyMODINIT_FUNC PyInit_bufferedreader(void)\n#if CYTHON_PEP489_MULTI_PHASE_INIT\n{\n  return PyModuleDef_Init(&__pyx_moduledef);\n}\nstatic CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {\n    #if PY_VERSION_HEX >= 0x030700A1\n    static PY_INT64_T main_interpreter_id = -1;\n    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);\n    if (main_interpreter_id == -1) {\n        main_interpreter_id = current_id;\n        return (unlikely(current_id == -1)) ? -1 : 0;\n    } else if (unlikely(main_interpreter_id != current_id))\n    #else\n    static PyInterpreterState *main_interpreter = NULL;\n    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;\n    if (!main_interpreter) {\n        main_interpreter = current_interpreter;\n    } else if (unlikely(main_interpreter != current_interpreter))\n    #endif\n    {\n        PyErr_SetString(\n            PyExc_ImportError,\n            \"Interpreter change detected - this module can only be loaded into one interpreter per process.\");\n        return -1;\n    }\n    return 0;\n}\nstatic CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {\n    PyObject *value = PyObject_GetAttrString(spec, from_name);\n    int result = 0;\n    if (likely(value)) {\n        if (allow_none || value != Py_None) {\n            result = PyDict_SetItemString(moddict, to_name, value);\n        }\n        Py_DECREF(value);\n    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {\n        PyErr_Clear();\n    } else {\n        result = -1;\n    }\n    return result;\n}\nstatic CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {\n    PyObject *module = NULL, *moddict, *modname;\n    if (__Pyx_check_single_interpreter())\n        return NULL;\n    if (__pyx_m)\n        return __Pyx_NewRef(__pyx_m);\n    modname = PyObject_GetAttrString(spec, \"name\");\n    if (unlikely(!modname)) goto bad;\n    module = PyModule_NewObject(modname);\n    Py_DECREF(modname);\n    if (unlikely(!module)) goto bad;\n    moddict = PyModule_GetDict(module);\n    if (unlikely(!moddict)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"loader\", \"__loader__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"origin\", \"__file__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"parent\", \"__package__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"submodule_search_locations\", \"__path__\", 0) < 0)) goto bad;\n    return module;\nbad:\n    Py_XDECREF(module);\n    return NULL;\n}\n\n\nstatic CYTHON_SMALL_CODE int __pyx_pymod_exec_bufferedreader(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'bufferedreader' has already been imported. Re-initialisation is not supported.\");\n    return -1;\n  }\n  #elif PY_MAJOR_VERSION >= 3\n  if (__pyx_m) return __Pyx_NewRef(__pyx_m);\n  #endif\n  #if CYTHON_REFNANNY\n__Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"refnanny\");\nif (!__Pyx_RefNanny) {\n  PyErr_Clear();\n  __Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"Cython.Runtime.refnanny\");\n  if (!__Pyx_RefNanny)\n      Py_FatalError(\"failed to import 'refnanny' module\");\n}\n#endif\n  __Pyx_RefNannySetupContext(\"__Pyx_PyMODINIT_FUNC PyInit_bufferedreader(void)\", 0);\n  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pxy_PyFrame_Initialize_Offsets\n  __Pxy_PyFrame_Initialize_Offsets();\n  #endif\n  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_bytes = PyBytes_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_unicode = PyUnicode_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pyx_CyFunction_USED\n  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_FusedFunction_USED\n  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Coroutine_USED\n  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Generator_USED\n  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_AsyncGen_USED\n  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_StopAsyncIteration_USED\n  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  /*--- Library function declarations ---*/\n  /*--- Threads initialization code ---*/\n  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS\n  #ifdef WITH_THREAD /* Python build with threading support? */\n  PyEval_InitThreads();\n  #endif\n  #endif\n  /*--- Module creation code ---*/\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  __pyx_m = __pyx_pyinit_module;\n  Py_INCREF(__pyx_m);\n  #else\n  #if PY_MAJOR_VERSION < 3\n  __pyx_m = Py_InitModule4(\"bufferedreader\", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);\n  #else\n  __pyx_m = PyModule_Create(&__pyx_moduledef);\n  #endif\n  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_d);\n  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_b);\n  __pyx_cython_runtime = PyImport_AddModule((char *) \"cython_runtime\"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_cython_runtime);\n  if (PyObject_SetAttrString(__pyx_m, \"__builtins__\", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);\n  /*--- Initialize various global constants etc. ---*/\n  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)\n  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  if (__pyx_module_is_main_clickhouse_driver__bufferedreader) {\n    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  }\n  #if PY_MAJOR_VERSION >= 3\n  {\n    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)\n    if (!PyDict_GetItemString(modules, \"clickhouse_driver.bufferedreader\")) {\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.bufferedreader\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  /*--- Builtin init code ---*/\n  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;\n  /*--- Constants init code ---*/\n  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;\n  /*--- Global type/function init code ---*/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;\n  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  /*--- Execution code ---*/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_14bufferedreader_1__pyx_unpickle_BufferedReader, NULL, __pyx_n_s_clickhouse_driver_bufferedreader); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_BufferedReader, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_BufferedReader__set_state(<BufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedReader__set_state(BufferedReader __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]\n *     if len(__pyx_state) > 3 and hasattr(__pyx_result, '__dict__'):\n */\n  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_14bufferedreader_3__pyx_unpickle_BufferedSocketReader, NULL, __pyx_n_s_clickhouse_driver_bufferedreader); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_BufferedSocketRea, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_CompressedBufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_14bufferedreader_5__pyx_unpickle_CompressedBufferedReader, NULL, __pyx_n_s_clickhouse_driver_bufferedreader); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_CompressedBuffere, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":1\n * from cpython cimport Py_INCREF, PyBytes_FromStringAndSize             # <<<<<<<<<<<<<<\n * from cpython.bytearray cimport PyByteArray_AsString\n * # Using python's versions of pure c memory management functions for\n */\n  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /*--- Wrapped vars code ---*/\n\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  if (__pyx_m) {\n    if (__pyx_d) {\n      __Pyx_AddTraceback(\"init clickhouse_driver.bufferedreader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n    }\n    Py_CLEAR(__pyx_m);\n  } else if (!PyErr_Occurred()) {\n    PyErr_SetString(PyExc_ImportError, \"init clickhouse_driver.bufferedreader\");\n  }\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  return (__pyx_m != NULL) ? 0 : -1;\n  #elif PY_MAJOR_VERSION >= 3\n  return __pyx_m;\n  #else\n  return;\n  #endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 500,
        "code": "void PCRECache::insert(\n  Accessor& accessor,\n  const StringData* regex,\n  TempKeyCache& keyCache,\n  const pcre_cache_entry* ent\n) {\n  switch (m_kind) {\n    case CacheKind::Static:\n      {\n        assertx(m_staticCache.load());\n        // Clear the cache if we haven't refreshed it in a while\n        if (time(nullptr) > m_expire) {\n          clearStatic();\n        }\n        auto const cache = m_staticCache.load(std::memory_order_acquire);\n        auto const key =\n          regex->isStatic() ||\n          (regex->isUncounted() && regex->uncountedIncRef()) ?\n          regex : StringData::MakeUncounted(regex->slice());\n        auto pair = cache->insert(StaticCachePair(key, ent));\n        if (pair.second) {\n          // Inserted, container owns the pointer\n          accessor = ent;\n        } else {\n          // Not inserted, caller needs to own the pointer\n          if (regex->isUncounted()) StringData::ReleaseUncounted(key);\n          accessor = EntryPtr(ent);\n        }\n      }\n      break;\n    case CacheKind::Lru:\n    case CacheKind::Scalable:\n      {\n        if (!keyCache) {\n          keyCache.reset(new LRUCacheKey(regex->data(), regex->size()));\n        }\n        // Pointer ownership is shared between container and caller\n        accessor = EntryPtr(ent);\n        if (m_kind == CacheKind::Lru) {\n          m_lruCache->insert(*keyCache, accessor.entryPtr());\n        } else {\n          m_scalableCache->insert(*keyCache, accessor.entryPtr());\n        }\n      }\n      break;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 501,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSequenceRNNParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* input_weights = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* recurrent_weights =\n      GetInput(context, node, kRecurrentWeightsTensor);\n  const TfLiteTensor* bias = GetInput(context, node, kBiasTensor);\n  // The hidden_state is a variable input tensor that can be modified.\n  TfLiteTensor* hidden_state =\n      const_cast<TfLiteTensor*>(GetInput(context, node, kHiddenStateTensor));\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input_weights->type) {\n    case kTfLiteFloat32:\n      return EvalFloat(input, input_weights, recurrent_weights, bias, params,\n                       hidden_state, output);\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      // TODO(mirkov): implement eval with quantized inputs as well.\n      auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n      TfLiteTensor* input_quantized = GetTemporary(context, node, 0);\n      TfLiteTensor* hidden_state_quantized = GetTemporary(context, node, 1);\n      TfLiteTensor* scaling_factors = GetTemporary(context, node, 2);\n      TfLiteTensor* accum_scratch = GetTemporary(context, node, 3);\n      TfLiteTensor* zero_points = GetTemporary(context, node, 4);\n      TfLiteTensor* row_sums = GetTemporary(context, node, 5);\n      return EvalHybrid(input, input_weights, recurrent_weights, bias, params,\n                        input_quantized, hidden_state_quantized,\n                        scaling_factors, hidden_state, output, zero_points,\n                        accum_scratch, row_sums, &op_data->compute_row_sums);\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %d not currently supported.\",\n                         TfLiteTypeGetName(input_weights->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 502,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8position___get__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__get__\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.position.__get__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 503,
        "code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0419"
    },
    {
        "index": 504,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n\n  // TODO(b/128934713): Add support for fixed-point per-channel quantization.\n  // Currently this only support affine per-layer quantization.\n  TF_LITE_ENSURE_EQ(context, output->quantization.type,\n                    kTfLiteAffineQuantization);\n  const auto* affine_quantization =\n      static_cast<TfLiteAffineQuantization*>(output->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  TF_LITE_ENSURE(context, affine_quantization->scale->size == 1);\n\n  if (input->type == kTfLiteFloat32) {\n    // Quantize use case.\n    TF_LITE_ENSURE(context, output->type == kTfLiteUInt8 ||\n                                output->type == kTfLiteInt8 ||\n                                output->type == kTfLiteInt16);\n  } else {\n    // Requantize use case.\n    if (input->type == kTfLiteInt16) {\n      TF_LITE_ENSURE(\n          context, output->type == kTfLiteInt8 || output->type == kTfLiteInt16);\n    } else {\n      TF_LITE_ENSURE(context,\n                     input->type == kTfLiteInt8 || input->type == kTfLiteUInt8);\n      TF_LITE_ENSURE(\n          context, output->type == kTfLiteUInt8 || output->type == kTfLiteInt8);\n    }\n    const double effective_output_scale =\n        static_cast<double>(input->params.scale) /\n        static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_output_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 505,
        "code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-9278"
    },
    {
        "index": 506,
        "code": "static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,\n        word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,\n        int saltLen, int bits, void* heap)\n{\n    int   ret = 0;\n    int   hLen, i, o, maskLen, hiBits;\n    byte* m;\n    byte* s;\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n        byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n    #else\n        byte* salt = NULL;\n    #endif\n#else\n    byte salt[WC_MAX_DIGEST_SIZE];\n#endif\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    if (pkcsBlockLen > RSA_MAX_SIZE/8) {\n        return MEMORY_E;\n    }\n#endif\n\n    hLen = wc_HashGetDigestSize(hType);\n    if (hLen < 0)\n        return hLen;\n    if ((int)inputLen != hLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    hiBits = (bits - 1) & 0x7;\n    if (hiBits == 0) {\n        /* Per RFC8017, set the leftmost 8emLen - emBits bits of the\n           leftmost octet in DB to zero.\n        */\n        *(pkcsBlock++) = 0;\n        pkcsBlockLen--;\n    }\n\n    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {\n        saltLen = hLen;\n        #ifdef WOLFSSL_SHA512\n            /* See FIPS 186-4 section 5.5 item (e). */\n            if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {\n                saltLen = RSA_PSS_SALT_MAX_SZ;\n            }\n        #endif\n    }\n#ifndef WOLFSSL_PSS_LONG_SALT\n    else if (saltLen > hLen) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER\n    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {\n        return PSS_SALTLEN_E;\n    }\n#else\n    else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {\n        saltLen = (int)pkcsBlockLen - hLen - 2;\n        if (saltLen < 0) {\n            return PSS_SALTLEN_E;\n        }\n    }\n    else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n    if ((int)pkcsBlockLen - hLen < saltLen + 2) {\n        return PSS_SALTLEN_E;\n    }\n    maskLen = pkcsBlockLen - 1 - hLen;\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (salt == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n    s = m = salt;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = (int)(m - s);\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, m, saltLen);\n        if (ret == 0) {\n            m += saltLen;\n        }\n    }\n#else\n    s = m = pkcsBlock;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = 0;\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, salt, saltLen);\n        if (ret == 0) {\n            XMEMCPY(m, salt, saltLen);\n            m += saltLen;\n        }\n    }\n#endif\n    if (ret == 0) {\n        /* Put Hash at end of pkcsBlock - 1 */\n        ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);\n    }\n    if (ret == 0) {\n       /* Set the last eight bits or trailer field to the octet 0xbc */\n        pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;\n\n        ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);\n    }\n    if (ret == 0) {\n        /* Clear the first high bit when \"8emLen - emBits\" is non-zero.\n           where emBits = n modBits - 1 */\n        if (hiBits)\n            pkcsBlock[0] &= (1 << hiBits) - 1;\n\n        m = pkcsBlock + maskLen - saltLen - 1;\n        *(m++) ^= 0x01;\n        for (i = 0; i < saltLen; i++) {\n            m[i] ^= salt[o + i];\n        }\n    }\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        if (salt != NULL) {\n            XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);\n        }\n    #endif\n#endif\n    return ret;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-36177"
    },
    {
        "index": 507,
        "code": "static int __Pyx_modinit_function_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_import_code\", 0);\n  /*--- Function import code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 508,
        "code": "static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {\n            case Token_CloseBrace:\n                bson_append_finish_object( b );\n                DOC_POP_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = s;\n                state = State_DocSpecValue;\n                break;\n            }\n            break;\n        case State_DocSpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_DocValue;\n                break;\n            case Token_OpenBrace:\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_Element);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_Element);\n                state = State_ArraySpecValue;\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                state = State_Element;\n                break;\n            }\n            break;\n        case State_DocValue:\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_Element;\n            typespec = 0;\n            break;\n        case State_ArraySpecValue:\n            switch (bcon_token(s)) {\n            case Token_Typespec:\n                typespec = s;\n                state = State_ArrayValue;\n                break;\n            case Token_OpenBrace:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_object( b, key );\n                DOC_PUSH_STATE(State_ArraySpecValue);\n                state = State_Element;\n                break;\n            case Token_OpenBracket:\n                key = ARRAY_KEY_STRING(array_index++);\n                bson_append_start_array( b, key );\n                ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue);\n                /* state = State_ArraySpecValue; */\n                break;\n            case Token_CloseBracket:\n                bson_append_finish_array( b );\n                ARRAY_POP_INDEX_STATE; /* state = ...; */\n                break;\n            case Token_End:\n                end_of_data = 1;\n                break;\n            default:\n                key = ARRAY_KEY_STRING(array_index++);\n                ret = bson_bcon_key_value(b, key, typespec, bci);\n                /* state = State_ArraySpecValue; */\n                break;\n            }\n            break;\n        case State_ArrayValue:\n            key = ARRAY_KEY_STRING(array_index++);\n            ret = bson_bcon_key_value(b, key, typespec, bci);\n            state = State_ArraySpecValue;\n            typespec = 0;\n            break;\n        default: assert(NOT_REACHED); break;\n        }\n    }\n    return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 509,
        "code": "static bool php_openssl_validate_iv(\n    String piv,\n    int iv_required_len,\n    String& out,\n    EVP_CIPHER_CTX* cipher_ctx,\n    const php_openssl_cipher_mode* mode) {\n  if (cipher_ctx == nullptr || mode == nullptr) {\n    return false;\n  }\n\n  /* Best case scenario, user behaved */\n  if (piv.size() == iv_required_len) {\n    out = std::move(piv);\n    return true;\n  }\n\n  if (mode->is_aead) {\n    if (EVP_CIPHER_CTX_ctrl(\n            cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) {\n      raise_warning(\n          \"Setting of IV length for AEAD mode failed, the expected length is \"\n          \"%d bytes\",\n          iv_required_len);\n      return false;\n    }\n    out = std::move(piv);\n    return true;\n  }\n\n  String s = String(iv_required_len, ReserveString);\n  char* iv_new = s.mutableData();\n  memset(iv_new, 0, iv_required_len);\n\n  if (piv.size() <= 0) {\n    /* BC behavior */\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  if (piv.size() < iv_required_len) {\n    raise_warning(\"IV passed is only %d bytes long, cipher \"\n                  \"expects an IV of precisely %d bytes, padding with \\\\0\",\n                  piv.size(), iv_required_len);\n    memcpy(iv_new, piv.data(), piv.size());\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  raise_warning(\"IV passed is %d bytes long which is longer than the %d \"\n                \"expected by selected cipher, truncating\", piv.size(),\n                iv_required_len);\n  memcpy(iv_new, piv.data(), iv_required_len);\n  s.setSize(iv_required_len);\n  out = std::move(s);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 510,
        "code": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  // A simple op which outputs a tensor with values of 7.\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {\n      .data_ = nullptr,\n      .Prepare = [](TfLiteContext* context,\n                    TfLiteDelegate* delegate) -> TfLiteStatus {\n        TfLiteIntArray* execution_plan;\n        TF_LITE_ENSURE_STATUS(\n            context->GetExecutionPlan(context, &execution_plan));\n        context->ReplaceNodeSubsetsWithDelegateKernels(\n            context, registration, execution_plan, delegate);\n        // Now bind delegate buffer handles for all tensors.\n        for (size_t i = 0; i < context->tensors_size; ++i) {\n          context->tensors[i].delegate = delegate;\n          context->tensors[i].buffer_handle = static_cast<int>(i);\n        }\n        return kTfLiteOk;\n      },\n      .CopyFromBufferHandle = nullptr,\n      .CopyToBufferHandle = nullptr,\n      .FreeBufferHandle = nullptr,\n      .flags = kTfLiteDelegateFlagsAllowDynamicTensors,\n  };\n  return reinterpret_cast<jlong>(&delegate);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 511,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n\n  OpContext op_context(context, node);\n\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), op_context.params->num_splits);\n\n  auto input_type = op_context.input->type;\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||\n                     input_type == kTfLiteInt32);\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    GetOutput(context, node, i)->type = input_type;\n  }\n\n  // If we know the contents of the 'axis' tensor, resize all outputs.\n  // Otherwise, wait until Eval().\n  if (IsConstantTensor(op_context.axis)) {\n    return ResizeOutputTensors(context, node, op_context.axis, op_context.input,\n                               op_context.params->num_splits);\n  } else {\n    return UseDynamicOutputTensors(context, node);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 512,
        "code": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  /* get all extra arguments available */\n    checkstackp(L, nextra, where);  /* ensure stack space */\n    L->top = where + nextra;  /* next instruction will need top */\n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   /* complete required results with nil */\n    setnilvalue(s2v(where + i));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 513,
        "code": "TEST_P(ProtocolIntegrationTest, FragmentStrippedFromPathWithOverride) {\n  config_helper_.addRuntimeOverride(\"envoy.reloadable_features.http_reject_path_with_fragment\",\n                                    \"false\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort(\"http\"))));\n  Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                                 {\":path\", \"/some/path?p1=v1#fragment\"},\n                                                 {\":scheme\", \"http\"},\n                                                 {\":authority\", \"foo.com\"}};\n  Http::TestRequestHeaderMapImpl expected_request_headers{request_headers};\n  expected_request_headers.setPath(\"/some/path?p1=v1\");\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  auto response = sendRequestAndWaitForResponse(expected_request_headers, 0, response_headers, 0, 0,\n                                                TestUtility::DefaultTimeout);\n  EXPECT_TRUE(upstream_request_->complete());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43825"
    },
    {
        "index": 514,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_6String_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_encoding = 0;\n  PyObject *__pyx_v_kwargs = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__init__ (wrapper)\", 0);\n  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;\n  __Pyx_GOTREF(__pyx_v_kwargs);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_encoding,0};\n    PyObject* values[2] = {0,0};\n    __pyx_defaults *__pyx_dynamic_args = __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self);\n    values[1] = __pyx_dynamic_args->__pyx_arg_encoding;\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (kw_args > 0) {\n          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_encoding);\n          if (value) { values[1] = value; kw_args--; }\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, \"__init__\") < 0)) __PYX_ERR(0, 22, __pyx_L3_error)\n      }\n    } else {\n      switch (PyTuple_GET_SIZE(__pyx_args)) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_encoding = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 22, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.String.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_6String___init__(__pyx_self, __pyx_v_self, __pyx_v_encoding, __pyx_v_kwargs);\n\n  /* function exit code */\n  __Pyx_XDECREF(__pyx_v_kwargs);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 515,
        "code": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 516,
        "code": "TEST_P(TcpTunnelingIntegrationTest, ResetStreamTest) {\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    return;\n  }\n  enableHalfClose(false);\n  initialize();\n\n  setUpConnection(fake_upstream_connection_);\n\n  // Reset the stream.\n  upstream_request_->encodeResetStream();\n  tcp_client_->waitForDisconnect();\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2021-43826"
    },
    {
        "index": 517,
        "code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37647"
    },
    {
        "index": 518,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input1->type) {\n    case kTfLiteInt32: {\n      return EvalImpl<int32_t>(context, data->requires_broadcast, input1,\n                               input2, output);\n    }\n    case kTfLiteFloat32: {\n      return EvalImpl<float>(context, data->requires_broadcast, input1, input2,\n                             output);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",\n                           TfLiteTypeGetName(input1->type));\n      return kTfLiteError;\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 519,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_7columns_12stringcolumn_6String_5read_items(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v_self = 0;\n  PyObject *__pyx_v_n_items = 0;\n  PyObject *__pyx_v_buf = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_items (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_n_items,&__pyx_n_s_buf,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_items)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 1); __PYX_ERR(0, 29, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, 2); __PYX_ERR(0, 29, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"read_items\") < 0)) __PYX_ERR(0, 29, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v_self = values[0];\n    __pyx_v_n_items = values[1];\n    __pyx_v_buf = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"read_items\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 29, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.String.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_6String_4read_items(__pyx_self, __pyx_v_self, __pyx_v_n_items, __pyx_v_buf);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 520,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_CompressedBufferedReader__set_state(struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  Py_ssize_t __pyx_t_2;\n  int __pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_CompressedBufferedReader__set_state\", 0);\n\n  /* \"(tree fragment)\":12\n *     return __pyx_result\n * cdef __pyx_unpickle_CompressedBufferedReader__set_state(CompressedBufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.read_block = __pyx_state[3]             # <<<<<<<<<<<<<<\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (!(likely(PyByteArray_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"bytearray\", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->__pyx_base.buffer);\n  __Pyx_DECREF(__pyx_v___pyx_result->__pyx_base.buffer);\n  __pyx_v___pyx_result->__pyx_base.buffer = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.current_buffer_size = __pyx_t_2;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_2 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.position = __pyx_t_2;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->read_block);\n  __Pyx_DECREF(__pyx_v___pyx_result->read_block);\n  __pyx_v___pyx_result->read_block = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_CompressedBufferedReader__set_state(CompressedBufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.read_block = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(1, 13, __pyx_L1_error)\n  }\n  __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_4 = ((__pyx_t_2 > 4) != 0);\n  if (__pyx_t_4) {\n  } else {\n    __pyx_t_3 = __pyx_t_4;\n    goto __pyx_L4_bool_binop_done;\n  }\n  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_5 = (__pyx_t_4 != 0);\n  __pyx_t_3 = __pyx_t_5;\n  __pyx_L4_bool_binop_done:;\n  if (__pyx_t_3) {\n\n    /* \"(tree fragment)\":14\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.read_block = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])             # <<<<<<<<<<<<<<\n */\n    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    if (unlikely(__pyx_v___pyx_state == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(1, 14, __pyx_L1_error)\n    }\n    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_8 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {\n      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);\n      if (likely(__pyx_t_8)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);\n        __Pyx_INCREF(__pyx_t_8);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_7, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);\n    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n    /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_CompressedBufferedReader__set_state(CompressedBufferedReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.read_block = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  }\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_CompressedBufferedReader__set_state(<CompressedBufferedReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_CompressedBufferedReader__set_state(CompressedBufferedReader __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.read_block = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_CompressedBufferedReader__set_state\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 521,
        "code": "set_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t\t && ((State & INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    if ((buf_valid(buf) && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\tenter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0443"
    },
    {
        "index": 522,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  output->type = input->type;\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 523,
        "code": "ReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\"Couldn't allocate memory for %s->data\", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 )\n                            len = len+(8-(len % 8));\n                        cells[i]->name = (char*)malloc(len+1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read,name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        name_len = name_len+(8-(name_len % 8));\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-19497"
    },
    {
        "index": 524,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_6String_2write_items(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_items, PyObject *__pyx_v_buf) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  __Pyx_RefNannySetupContext(\"write_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":27\n * \n *     def write_items(self, items, buf):\n *         buf.write_strings(items, encoding=self.encoding)             # <<<<<<<<<<<<<<\n * \n *     def read_items(self, n_items, buf):\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_write_strings); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 27, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(__pyx_v_items);\n  __Pyx_GIVEREF(__pyx_v_items);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_items);\n  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 27, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_encoding); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 27, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_encoding, __pyx_t_4) < 0) __PYX_ERR(0, 27, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 27, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":26\n *         super(String, self).__init__(**kwargs)\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         buf.write_strings(items, encoding=self.encoding)\n * \n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.String.write_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 525,
        "code": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t/* Redrawing not needed */\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-28097"
    },
    {
        "index": 526,
        "code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t// no valid instruction pointer\n\telse\n\t\treturn regs->nip;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-38200"
    },
    {
        "index": 528,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n\n  int32_t* out_buf = GetOutput(context, node, 0)->data.i32;\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  const TfLiteTensor* weight =\n      NumInputs(node) == 2 ? nullptr : GetInput(context, node, 2);\n\n  switch (params->type) {\n    case kTfLiteLshProjectionDense:\n      DenseLshProjection(hash, input, weight, out_buf);\n      break;\n    case kTfLiteLshProjectionSparse:\n      SparseLshProjection(hash, input, weight, out_buf);\n      break;\n    default:\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 529,
        "code": "TfLiteStatus SelectPrepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input_condition =\n      GetInput(context, node, kInputTensorCondition);\n  const TfLiteTensor* input_x = GetInput(context, node, kInputTensorX);\n  const TfLiteTensor* input_y = GetInput(context, node, kInputTensorY);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Input must be bool.\n  TF_LITE_ENSURE_TYPES_EQ(context, input_condition->type, kTfLiteBool);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_x->type, input_y->type);\n  output->type = input_x->type;\n\n  bool same_shape = HaveSameShapes(input_condition, input_x) &&\n                    HaveSameShapes(input_x, input_y);\n  TfLiteIntArray* output_size;\n  if (!same_shape) {\n    switch (kernel_type) {\n      case kVersionOne: {\n        bool is_input_condition_scalar = NumDimensions(input_condition) == 0;\n        bool has_rank_one_input_condition =\n            NumDimensions(input_condition) == 1 &&\n            SizeOfDimension(input_condition, 0) == SizeOfDimension(input_x, 0);\n        data->has_low_rank_input_condition =\n            is_input_condition_scalar || has_rank_one_input_condition;\n        TF_LITE_ENSURE(context, data->has_low_rank_input_condition);\n\n        output_size = TfLiteIntArrayCopy(input_x->dims);\n\n        // Input tensors must have the same type and size\n        TF_LITE_ENSURE(context, HaveSameShapes(input_x, input_y));\n        break;\n      }\n      case kVersionTwo: {\n        TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                       context, input_condition, input_x,\n                                       input_y, &output_size));\n        data->requires_broadcast = true;\n        break;\n      }\n      default:\n        return kTfLiteError;\n    }\n  } else {\n    output_size = TfLiteIntArrayCopy(input_x->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 530,
        "code": "void ForEach(int first, int last, const std::function<void(int)>& f) {\n#if TARGET_OS_IPHONE\n  for (int i = first; i < last; i++) {\n    f(i);\n  }\n#else\n  int num_threads = std::min(kNumThreads, last - first);\n  thread::ThreadPool threads(Env::Default(), \"ForEach\", num_threads);\n  for (int i = first; i < last; i++) {\n    threads.Schedule([f, i] { f(i); });\n  }\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26269"
    },
    {
        "index": 531,
        "code": "proc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-4110"
    },
    {
        "index": 532,
        "code": "bool IsFullyConnectedOpSupported(const TfLiteRegistration* registration,\n                                 const TfLiteNode* node,\n                                 TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  const auto* fc_params =\n      reinterpret_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const int kInput = 0;\n  const int kWeights = 1;\n  const int kBias = 2;\n\n  if (fc_params->weights_format != kTfLiteFullyConnectedWeightsFormatDefault) {\n    return false;\n  }\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* weights = GetInput(context, node, kWeights);\n\n  if (!IsFloatType(input->type)) {\n    return false;\n  }\n  if (!IsFloatType(weights->type) || !IsConstantTensor(weights)) {\n    return false;\n  }\n  // Core ML 2 only supports single-batch fully connected layer, thus dimensions\n  // except the last one should be 1.\n  if (input->dims->data[input->dims->size - 1] != NumElements(input)) {\n    return false;\n  }\n\n  if (node->inputs->size > 2) {\n    const TfLiteTensor* bias = GetInput(context, node, kBias);\n    if (!IsFloatType(bias->type) || !IsConstantTensor(bias)) {\n      return false;\n    }\n  }\n\n  TfLiteFusedActivation activation = fc_params->activation;\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 533,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  const int block_size = params->block_size;\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 534,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_write_into_stream(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *__pyx_v_self, int __pyx_skip_dispatch) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  __Pyx_RefNannySetupContext(\"write_into_stream\", 0);\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overridden in Python */\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {\n      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      #endif\n      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_write_into_stream); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_1);\n      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_17clickhouse_driver_14bufferedwriter_20BufferedSocketWriter_3write_into_stream)) {\n        __Pyx_XDECREF(__pyx_r);\n        __Pyx_INCREF(__pyx_t_1);\n        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;\n        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {\n          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n          if (likely(__pyx_t_4)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n            __Pyx_INCREF(__pyx_t_4);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_3, function);\n          }\n        }\n        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);\n        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 70, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_2);\n        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n        __pyx_r = __pyx_t_2;\n        __pyx_t_2 = 0;\n        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n        goto __pyx_L0;\n      }\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));\n      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {\n        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n      }\n      #endif\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    }\n    #endif\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":71\n * \n *     cpdef write_into_stream(self):\n *         self.sock.sendall(             # <<<<<<<<<<<<<<\n *             PyBytes_FromStringAndSize(self.buffer, self.position)\n *         )\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->sock, __pyx_n_s_sendall); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 71, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":72\n *     cpdef write_into_stream(self):\n *         self.sock.sendall(\n *             PyBytes_FromStringAndSize(self.buffer, self.position)             # <<<<<<<<<<<<<<\n *         )\n *         self.position = 0\n */\n  __pyx_t_3 = PyBytes_FromStringAndSize(__pyx_v_self->__pyx_base.buffer, __pyx_v_self->__pyx_base.position); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 72, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":74\n *             PyBytes_FromStringAndSize(self.buffer, self.position)\n *         )\n *         self.position = 0             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_v_self->__pyx_base.position = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":70\n *         super(BufferedSocketWriter, self).__init__(bufsize)\n * \n *     cpdef write_into_stream(self):             # <<<<<<<<<<<<<<\n *         self.sock.sendall(\n *             PyBytes_FromStringAndSize(self.buffer, self.position)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedSocketWriter.write_into_stream\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 535,
        "code": "static Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }\n\n    int i, j, m;\n    for (i = 0; i<curlen; i++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[i] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);\n    }\n    m = i;\n    for (i = 0; i < argc; i++) {\n         va = Jsi_ValueArrayIndex(interp, args, i);\n         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {\n            int margc = Jsi_ValueGetLength(interp, va);\n            Jsi_Obj *mobj = va->d.obj;\n            Jsi_ObjListifyArray(interp, mobj);\n            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            for (j = 0; j<margc; j++, m++)\n            {\n                if (!mobj->arr[j]) continue;\n                nobj->arr[m] = NULL;\n                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);\n            }\n        } else {\n            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            nobj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, nobj->arr+m++, va);\n       }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 536,
        "code": "static bool php_openssl_validate_iv(\n    String piv,\n    int iv_required_len,\n    String& out,\n    EVP_CIPHER_CTX* cipher_ctx,\n    const php_openssl_cipher_mode* mode) {\n  if (cipher_ctx == nullptr || mode == nullptr) {\n    return false;\n  }\n\n  /* Best case scenario, user behaved */\n  if (piv.size() == iv_required_len) {\n    out = std::move(piv);\n    return true;\n  }\n\n  if (mode->is_aead) {\n    if (EVP_CIPHER_CTX_ctrl(\n            cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) {\n      raise_warning(\n          \"Setting of IV length for AEAD mode failed, the expected length is \"\n          \"%d bytes\",\n          iv_required_len);\n      return false;\n    }\n    out = std::move(piv);\n    return true;\n  }\n\n  String s = String(iv_required_len, ReserveString);\n  char* iv_new = s.mutableData();\n  memset(iv_new, 0, iv_required_len);\n\n  if (piv.size() <= 0) {\n    /* BC behavior */\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  if (piv.size() < iv_required_len) {\n    raise_warning(\"IV passed is only %d bytes long, cipher \"\n                  \"expects an IV of precisely %d bytes, padding with \\\\0\",\n                  piv.size(), iv_required_len);\n    memcpy(iv_new, piv.data(), piv.size());\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  raise_warning(\"IV passed is %d bytes long which is longer than the %d \"\n                \"expected by selected cipher, truncating\", piv.size(),\n                iv_required_len);\n  memcpy(iv_new, piv.data(), iv_required_len);\n  s.setSize(iv_required_len);\n  out = std::move(s);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 537,
        "code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22874"
    },
    {
        "index": 538,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_12__reduce_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self) {\n  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);\n  __pyx_t_1 = 0;\n  __pyx_t_2 = 0;\n  __pyx_t_3 = 0;\n  __pyx_v_state = ((PyObject*)__pyx_t_4);\n  __pyx_t_4 = 0;\n\n  /* \"(tree fragment)\":6\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position)\n *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<\n *     if _dict is not None:\n *         state += (_dict,)\n */\n  __pyx_t_4 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_v__dict = __pyx_t_4;\n  __pyx_t_4 = 0;\n\n  /* \"(tree fragment)\":7\n *     state = (self.buffer, self.buffer_size, self.position)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n  __pyx_t_5 = (__pyx_v__dict != Py_None);\n  __pyx_t_6 = (__pyx_t_5 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":8\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *         state += (_dict,)             # <<<<<<<<<<<<<<\n *         use_setstate = True\n *     else:\n */\n    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(__pyx_v__dict);\n    __Pyx_GIVEREF(__pyx_v__dict);\n    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v__dict);\n    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 8, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_3));\n    __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":9\n *     if _dict is not None:\n *         state += (_dict,)\n *         use_setstate = True             # <<<<<<<<<<<<<<\n *     else:\n *         use_setstate = False\n */\n    __pyx_v_use_setstate = 1;\n\n    /* \"(tree fragment)\":7\n *     state = (self.buffer, self.buffer_size, self.position)\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:             # <<<<<<<<<<<<<<\n *         state += (_dict,)\n *         use_setstate = True\n */\n    goto __pyx_L3;\n  }\n\n  /* \"(tree fragment)\":11\n *         use_setstate = True\n *     else:\n *         use_setstate = False             # <<<<<<<<<<<<<<\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, None), state\n */\n  /*else*/ {\n    __pyx_v_use_setstate = 0;\n  }\n  __pyx_L3:;\n\n  /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = False\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, None), state\n *     else:\n */\n  __pyx_t_6 = (__pyx_v_use_setstate != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":13\n *         use_setstate = False\n *     if use_setstate:\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, None), state             # <<<<<<<<<<<<<<\n *     else:\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pyx_unpickle_BufferedWriter); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_39656716);\n    __Pyx_GIVEREF(__pyx_int_39656716);\n    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_int_39656716);\n    __Pyx_INCREF(Py_None);\n    __Pyx_GIVEREF(Py_None);\n    PyTuple_SET_ITEM(__pyx_t_4, 2, Py_None);\n    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 13, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_3);\n    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_state);\n    __pyx_t_3 = 0;\n    __pyx_t_4 = 0;\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n\n    /* \"(tree fragment)\":12\n *     else:\n *         use_setstate = False\n *     if use_setstate:             # <<<<<<<<<<<<<<\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, None), state\n *     else:\n */\n  }\n\n  /* \"(tree fragment)\":15\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, None), state\n *     else:\n *         return __pyx_unpickle_BufferedWriter, (type(self), 0x25d1d0c, state)             # <<<<<<<<<<<<<<\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_BufferedWriter__set_state(self, __pyx_state)\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pyx_unpickle_BufferedWriter); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));\n    __Pyx_INCREF(__pyx_int_39656716);\n    __Pyx_GIVEREF(__pyx_int_39656716);\n    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_int_39656716);\n    __Pyx_INCREF(__pyx_v_state);\n    __Pyx_GIVEREF(__pyx_v_state);\n    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_state);\n    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 15, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_GIVEREF(__pyx_t_2);\n    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);\n    __Pyx_GIVEREF(__pyx_t_4);\n    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_4);\n    __pyx_t_2 = 0;\n    __pyx_t_4 = 0;\n    __pyx_r = __pyx_t_3;\n    __pyx_t_3 = 0;\n    goto __pyx_L0;\n  }\n\n  /* \"(tree fragment)\":1\n * def __reduce_cython__(self):             # <<<<<<<<<<<<<<\n *     cdef tuple state\n *     cdef object _dict\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.__reduce_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_state);\n  __Pyx_XDECREF(__pyx_v__dict);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 539,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_24CompressedBufferedWriter_8__setstate_cython__(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *__pyx_v_self, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__setstate_cython__\", 0);\n\n  /* \"(tree fragment)\":17\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, state)\n * def __setstate_cython__(self, __pyx_state):\n *     __pyx_unpickle_CompressedBufferedWriter__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<\n */\n  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)\n  __pyx_t_1 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_CompressedBufferedWriter__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":16\n *     else:\n *         return __pyx_unpickle_CompressedBufferedWriter, (type(self), 0x108d208, state)\n * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_unpickle_CompressedBufferedWriter__set_state(self, __pyx_state)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.CompressedBufferedWriter.__setstate_cython__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 540,
        "code": "TfLiteStatus PopulateQuantizedLstmParams8x8_8(\n    TfLiteContext* context, TfLiteNode* node,\n    lstm_eval::IntegerLstmParameter* integer_lstm_param) {\n  // Get all tensors.\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kInputLayerNormCoefficientsTensor);\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kForgetLayerNormCoefficientsTensor);\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kCellLayerNormCoefficientsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, kForgetGateBiasTensor);\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, kCellGateBiasTensor);\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, kOutputGateBiasTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(context, node, kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  // Since we have already checked that weights are all there or none, we can\n  // check the existence of only one to get the condition.\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  const bool use_peephole = (cell_to_output_weights != nullptr);\n  const bool is_layer_norm_lstm = (forget_layer_norm_coefficients != nullptr);\n  const bool use_projection = (projection_weights != nullptr);\n\n  // Weights and states.\n  int8_t* input_to_input_weight_ptr = nullptr;\n  int8_t* recurrent_to_input_weight_ptr = nullptr;\n  int8_t* cell_to_input_weight_ptr = nullptr;\n  int8_t* input_to_forget_weight_ptr = nullptr;\n  int8_t* recurrent_to_forget_weight_ptr = nullptr;\n  int8_t* cell_to_forget_weight_ptr = nullptr;\n  int8_t* input_to_cell_weight_ptr = nullptr;\n  int8_t* recurrent_to_cell_weight_ptr = nullptr;\n  int8_t* input_to_output_weight_ptr = nullptr;\n  int8_t* recurrent_to_output_weight_ptr = nullptr;\n  int8_t* cell_to_output_weight_ptr = nullptr;\n  int8_t* projection_weight_ptr = nullptr;\n  int16_t* layer_norm_input_weight_ptr = nullptr;\n  int16_t* layer_norm_forget_weight_ptr = nullptr;\n  int16_t* layer_norm_cell_weight_ptr = nullptr;\n  int16_t* layer_norm_output_weight_ptr = nullptr;\n  int32_t* input_gate_bias_ptr = nullptr;\n  int32_t* forget_gate_bias_ptr = nullptr;\n  int32_t* cell_gate_bias_ptr = nullptr;\n  int32_t* output_gate_bias_ptr = nullptr;\n  int32_t* projection_bias_ptr = nullptr;\n  int16_t* cell_ptr = nullptr;\n  int8_t* output_state_ptr = nullptr;\n\n  // Scales.\n  const float default_scale = 1.0;\n  float input_scale = default_scale;\n  float input_to_input_weight_scale = default_scale;\n  float recurrent_to_input_weight_scale = default_scale;\n  float cell_to_input_weight_scale = default_scale;\n  float input_to_forget_weight_scale = default_scale;\n  float recurrent_to_forget_weight_scale = default_scale;\n  float cell_to_forget_weight_scale = default_scale;\n  float input_to_cell_weight_scale = default_scale;\n  float recurrent_to_cell_weight_scale = default_scale;\n  float input_to_output_weight_scale = default_scale;\n  float recurrent_to_output_weight_scale = default_scale;\n  float cell_to_output_weight_scale = default_scale;\n  float projection_weight_scale = default_scale;\n  float layer_norm_input_scale = default_scale;\n  float layer_norm_forget_scale = default_scale;\n  float layer_norm_cell_scale = default_scale;\n  float layer_norm_output_scale = default_scale;\n  float output_state_scale = default_scale;\n\n  // Effective scales.\n  float effective_input_to_input_scale = default_scale;\n  float effective_recurrent_to_input_scale = default_scale;\n  float effective_cell_to_input_scale = default_scale;\n  float effective_input_to_forget_scale = default_scale;\n  float effective_recurrent_to_forget_scale = default_scale;\n  float effective_cell_to_forget_scale = default_scale;\n  float effective_input_to_cell_scale = default_scale;\n  float effective_recurrent_to_cell_scale = default_scale;\n  float effective_input_to_output_scale = default_scale;\n  float effective_recurrent_to_output_scale = default_scale;\n  float effective_cell_to_output_scale = default_scale;\n  float effective_proj_scale = default_scale;\n\n  // Zero points\n  int input_zp = 0;\n  int output_state_zp = 0;\n\n  // Populate all the values.\n  if (!use_cifg) {\n    input_to_input_weight_ptr = input_to_input_weights->data.int8;\n    recurrent_to_input_weight_ptr = recurrent_to_input_weights->data.int8;\n    input_gate_bias_ptr = input_gate_bias->data.i32;\n    input_to_input_weight_scale = input_to_input_weights->params.scale;\n    recurrent_to_input_weight_scale = recurrent_to_input_weights->params.scale;\n  }\n\n  if (use_peephole) {\n    if (!use_cifg) {\n      cell_to_input_weight_ptr = cell_to_input_weights->data.int8;\n      cell_to_input_weight_scale = cell_to_input_weights->params.scale;\n    }\n    cell_to_forget_weight_ptr = cell_to_forget_weights->data.int8;\n    cell_to_output_weight_ptr = cell_to_output_weights->data.int8;\n    cell_to_forget_weight_scale = cell_to_forget_weights->params.scale;\n    cell_to_output_weight_scale = cell_to_output_weights->params.scale;\n  }\n\n  if (is_layer_norm_lstm) {\n    if (!use_cifg) {\n      layer_norm_input_weight_ptr = input_layer_norm_coefficients->data.i16;\n      layer_norm_input_scale = input_layer_norm_coefficients->params.scale;\n    }\n    layer_norm_forget_weight_ptr = forget_layer_norm_coefficients->data.i16;\n    layer_norm_forget_scale = forget_layer_norm_coefficients->params.scale;\n    layer_norm_cell_weight_ptr = cell_layer_norm_coefficients->data.i16;\n    layer_norm_cell_scale = cell_layer_norm_coefficients->params.scale;\n    layer_norm_output_weight_ptr = output_layer_norm_coefficients->data.i16;\n    layer_norm_output_scale = output_layer_norm_coefficients->params.scale;\n  }\n\n  if (use_projection) {\n    projection_weight_ptr = projection_weights->data.int8;\n    projection_weight_scale = projection_weights->params.scale;\n    if (projection_bias) {\n      projection_bias_ptr = projection_bias->data.i32;\n    }\n  }\n  output_state_scale = output_state->params.scale;\n\n  input_to_forget_weight_ptr = input_to_forget_weights->data.int8;\n  input_to_forget_weight_scale = input_to_forget_weights->params.scale;\n  input_to_cell_weight_ptr = input_to_cell_weights->data.int8;\n  input_to_cell_weight_scale = input_to_cell_weights->params.scale;\n  input_to_output_weight_ptr = input_to_output_weights->data.int8;\n  input_to_output_weight_scale = input_to_output_weights->params.scale;\n  recurrent_to_forget_weight_ptr = recurrent_to_forget_weights->data.int8;\n  recurrent_to_forget_weight_scale = recurrent_to_forget_weights->params.scale;\n  recurrent_to_cell_weight_ptr = recurrent_to_cell_weights->data.int8;\n  recurrent_to_cell_weight_scale = recurrent_to_cell_weights->params.scale;\n  recurrent_to_output_weight_ptr = recurrent_to_output_weights->data.int8;\n  recurrent_to_output_weight_scale = recurrent_to_output_weights->params.scale;\n  forget_gate_bias_ptr = forget_gate_bias->data.i32;\n  cell_gate_bias_ptr = cell_gate_bias->data.i32;\n  output_gate_bias_ptr = output_gate_bias->data.i32;\n  output_state_ptr = output_state->data.int8;\n  cell_ptr = cell_state->data.i16;\n  input_scale = input->params.scale;\n  input_zp = input->params.zero_point;\n  output_state_zp = output_state->params.zero_point;\n\n  std::vector<float> intermediate_scale;\n  for (int i = 0; i < 12; ++i) {\n    TfLiteTensor* intermediate =\n        &context->tensors[node->intermediates->data[i]];\n    auto* params = reinterpret_cast<TfLiteAffineQuantization*>(\n        intermediate->quantization.params);\n    intermediate_scale.push_back(params->scale->data[0]);\n    integer_lstm_param->intermediate_zp[i] = params->zero_point->data[0];\n  }\n\n  // Calculate effective scales.\n  if (!use_cifg) {\n    effective_input_to_input_scale =\n        input_to_input_weight_scale * input_scale / intermediate_scale[1];\n    effective_recurrent_to_input_scale = recurrent_to_input_weight_scale *\n                                         output_state_scale /\n                                         intermediate_scale[2];\n  }\n  effective_input_to_forget_scale =\n      input_to_forget_weight_scale * input_scale / intermediate_scale[4];\n  effective_recurrent_to_forget_scale = recurrent_to_forget_weight_scale *\n                                        output_state_scale /\n                                        intermediate_scale[5];\n\n  effective_input_to_cell_scale =\n      input_to_cell_weight_scale * input_scale / intermediate_scale[7];\n  effective_recurrent_to_cell_scale = recurrent_to_cell_weight_scale *\n                                      output_state_scale /\n                                      intermediate_scale[8];\n\n  effective_input_to_output_scale =\n      input_to_output_weight_scale * input_scale / intermediate_scale[10];\n  effective_recurrent_to_output_scale = recurrent_to_output_weight_scale *\n                                        output_state_scale /\n                                        intermediate_scale[11];\n  effective_proj_scale =\n      projection_weight_scale * std::pow(2, -15) / output_state_scale;\n\n  if (use_peephole) {\n    if (!use_cifg) {\n      effective_cell_to_input_scale =\n          std::pow(2, -15) * cell_to_input_weight_scale / intermediate_scale[0];\n    }\n    effective_cell_to_forget_scale =\n        std::pow(2, -15) * cell_to_forget_weight_scale / intermediate_scale[3];\n    effective_cell_to_output_scale =\n        std::pow(2, -15) * cell_to_output_weight_scale / intermediate_scale[9];\n  }\n\n  // Calculate effecgive scales.\n  QuantizeMultiplier(effective_input_to_input_scale,\n                     &integer_lstm_param->effective_input_to_input_scale_a,\n                     &integer_lstm_param->effective_input_to_input_scale_b);\n  QuantizeMultiplier(effective_recurrent_to_input_scale,\n                     &integer_lstm_param->effective_recurrent_to_input_scale_a,\n                     &integer_lstm_param->effective_recurrent_to_input_scale_b);\n  QuantizeMultiplier(effective_cell_to_input_scale,\n                     &integer_lstm_param->effective_cell_to_input_scale_a,\n                     &integer_lstm_param->effective_cell_to_input_scale_b);\n  QuantizeMultiplier(effective_input_to_forget_scale,\n                     &integer_lstm_param->effective_input_to_forget_scale_a,\n                     &integer_lstm_param->effective_input_to_forget_scale_b);\n  QuantizeMultiplier(\n      effective_recurrent_to_forget_scale,\n      &integer_lstm_param->effective_recurrent_to_forget_scale_a,\n      &integer_lstm_param->effective_recurrent_to_forget_scale_b);\n  QuantizeMultiplier(effective_cell_to_forget_scale,\n                     &integer_lstm_param->effective_cell_to_forget_scale_a,\n                     &integer_lstm_param->effective_cell_to_forget_scale_b);\n  QuantizeMultiplier(effective_input_to_cell_scale,\n                     &integer_lstm_param->effective_input_to_cell_scale_a,\n                     &integer_lstm_param->effective_input_to_cell_scale_b);\n  QuantizeMultiplier(effective_recurrent_to_cell_scale,\n                     &integer_lstm_param->effective_recurrent_to_cell_scale_a,\n                     &integer_lstm_param->effective_recurrent_to_cell_scale_b);\n  QuantizeMultiplier(effective_input_to_output_scale,\n                     &integer_lstm_param->effective_input_to_output_scale_a,\n                     &integer_lstm_param->effective_input_to_output_scale_b);\n  QuantizeMultiplier(\n      effective_recurrent_to_output_scale,\n      &integer_lstm_param->effective_recurrent_to_output_scale_a,\n      &integer_lstm_param->effective_recurrent_to_output_scale_b);\n  QuantizeMultiplier(effective_cell_to_output_scale,\n                     &integer_lstm_param->effective_cell_to_output_scale_a,\n                     &integer_lstm_param->effective_cell_to_output_scale_b);\n  QuantizeMultiplier(effective_proj_scale,\n                     &integer_lstm_param->effective_proj_scale_a,\n                     &integer_lstm_param->effective_proj_scale_b);\n  QuantizeMultiplier(layer_norm_input_scale,\n                     &integer_lstm_param->layer_norm_input_scale_a,\n                     &integer_lstm_param->layer_norm_input_scale_b);\n  QuantizeMultiplier(layer_norm_forget_scale,\n                     &integer_lstm_param->layer_norm_forget_scale_a,\n                     &integer_lstm_param->layer_norm_forget_scale_b);\n  QuantizeMultiplier(layer_norm_cell_scale,\n                     &integer_lstm_param->layer_norm_cell_scale_a,\n                     &integer_lstm_param->layer_norm_cell_scale_b);\n  QuantizeMultiplier(layer_norm_output_scale,\n                     &integer_lstm_param->layer_norm_output_scale_a,\n                     &integer_lstm_param->layer_norm_output_scale_b);\n\n  {\n    // Intermdiates in flatbuffer holds Wx, Wh and Wx+Wh.\n    // effective Wx, Wh is in effective_input/recurrent_to_<...>_scale\n    // So use intermediate_scale to hold scale from Wx and Wh to Wx+Wh\n    // 0: [1] -> [0]\n    // 1: [2] -> [0]\n    // and use intermdiate_zp as is.\n    const float s_1_0 = intermediate_scale[1] / intermediate_scale[0];\n    const float s_2_0 = intermediate_scale[2] / intermediate_scale[0];\n    const float s_4_3 = intermediate_scale[4] / intermediate_scale[3];\n    const float s_5_3 = intermediate_scale[5] / intermediate_scale[3];\n    const float s_7_6 = intermediate_scale[7] / intermediate_scale[6];\n    const float s_8_6 = intermediate_scale[8] / intermediate_scale[6];\n    const float s_10_9 = intermediate_scale[10] / intermediate_scale[9];\n    const float s_11_9 = intermediate_scale[11] / intermediate_scale[9];\n    QuantizeMultiplier(s_1_0, &integer_lstm_param->intermediate_scale_a[0],\n                       &integer_lstm_param->intermediate_scale_b[0]);\n    QuantizeMultiplier(s_2_0, &integer_lstm_param->intermediate_scale_a[1],\n                       &integer_lstm_param->intermediate_scale_b[1]);\n    QuantizeMultiplier(s_4_3, &integer_lstm_param->intermediate_scale_a[2],\n                       &integer_lstm_param->intermediate_scale_b[2]);\n    QuantizeMultiplier(s_5_3, &integer_lstm_param->intermediate_scale_a[3],\n                       &integer_lstm_param->intermediate_scale_b[3]);\n    QuantizeMultiplier(s_7_6, &integer_lstm_param->intermediate_scale_a[4],\n                       &integer_lstm_param->intermediate_scale_b[4]);\n    QuantizeMultiplier(s_8_6, &integer_lstm_param->intermediate_scale_a[5],\n                       &integer_lstm_param->intermediate_scale_b[5]);\n    QuantizeMultiplier(s_10_9, &integer_lstm_param->intermediate_scale_a[6],\n                       &integer_lstm_param->intermediate_scale_b[6]);\n    QuantizeMultiplier(s_11_9, &integer_lstm_param->intermediate_scale_a[7],\n                       &integer_lstm_param->intermediate_scale_b[7]);\n  }\n\n  // Calculate quantized clip for projection and cell.\n  const auto* params = reinterpret_cast<TfLiteLSTMParams*>(node->builtin_data);\n  const float cell_clip = params->cell_clip;\n  const float proj_clip = params->proj_clip;\n\n  const TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n\n  auto* cell_state_params = reinterpret_cast<TfLiteAffineQuantization*>(\n      cell_state->quantization.params);\n  auto* proj_params = reinterpret_cast<TfLiteAffineQuantization*>(\n      output_tensor->quantization.params);\n  TF_LITE_ENSURE_EQ(context, cell_state_params->scale->data[0], 1.0 / 32768);\n  if (cell_clip > 0.0 && cell_clip < 1.0) {\n    integer_lstm_param->quantized_cell_clip = static_cast<int16_t>(std::min(\n        std::max(cell_clip / cell_state_params->scale->data[0], -32768.0f),\n        32767.0f));\n  } else {\n    integer_lstm_param->quantized_cell_clip = 0;\n  }\n  if (proj_clip > 0.0) {\n    integer_lstm_param->quantized_proj_clip = static_cast<int8_t>(std::min(\n        std::max(proj_clip / proj_params->scale->data[0], -128.0f), 127.0f));\n  } else {\n    integer_lstm_param->quantized_proj_clip = 0;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 541,
        "code": "__Pyx_PyMODINIT_FUNC initstringcolumn(void)\n#else\n__Pyx_PyMODINIT_FUNC PyInit_stringcolumn(void) CYTHON_SMALL_CODE; /*proto*/\n__Pyx_PyMODINIT_FUNC PyInit_stringcolumn(void)\n#if CYTHON_PEP489_MULTI_PHASE_INIT\n{\n  return PyModuleDef_Init(&__pyx_moduledef);\n}\nstatic CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {\n    #if PY_VERSION_HEX >= 0x030700A1\n    static PY_INT64_T main_interpreter_id = -1;\n    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);\n    if (main_interpreter_id == -1) {\n        main_interpreter_id = current_id;\n        return (unlikely(current_id == -1)) ? -1 : 0;\n    } else if (unlikely(main_interpreter_id != current_id))\n    #else\n    static PyInterpreterState *main_interpreter = NULL;\n    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;\n    if (!main_interpreter) {\n        main_interpreter = current_interpreter;\n    } else if (unlikely(main_interpreter != current_interpreter))\n    #endif\n    {\n        PyErr_SetString(\n            PyExc_ImportError,\n            \"Interpreter change detected - this module can only be loaded into one interpreter per process.\");\n        return -1;\n    }\n    return 0;\n}\nstatic CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {\n    PyObject *value = PyObject_GetAttrString(spec, from_name);\n    int result = 0;\n    if (likely(value)) {\n        if (allow_none || value != Py_None) {\n            result = PyDict_SetItemString(moddict, to_name, value);\n        }\n        Py_DECREF(value);\n    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {\n        PyErr_Clear();\n    } else {\n        result = -1;\n    }\n    return result;\n}\nstatic CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {\n    PyObject *module = NULL, *moddict, *modname;\n    if (__Pyx_check_single_interpreter())\n        return NULL;\n    if (__pyx_m)\n        return __Pyx_NewRef(__pyx_m);\n    modname = PyObject_GetAttrString(spec, \"name\");\n    if (unlikely(!modname)) goto bad;\n    module = PyModule_NewObject(modname);\n    Py_DECREF(modname);\n    if (unlikely(!module)) goto bad;\n    moddict = PyModule_GetDict(module);\n    if (unlikely(!moddict)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"loader\", \"__loader__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"origin\", \"__file__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"parent\", \"__package__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"submodule_search_locations\", \"__path__\", 0) < 0)) goto bad;\n    return module;\nbad:\n    Py_XDECREF(module);\n    return NULL;\n}\n\n\nstatic CYTHON_SMALL_CODE int __pyx_pymod_exec_stringcolumn(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'stringcolumn' has already been imported. Re-initialisation is not supported.\");\n    return -1;\n  }\n  #elif PY_MAJOR_VERSION >= 3\n  if (__pyx_m) return __Pyx_NewRef(__pyx_m);\n  #endif\n  #if CYTHON_REFNANNY\n__Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"refnanny\");\nif (!__Pyx_RefNanny) {\n  PyErr_Clear();\n  __Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"Cython.Runtime.refnanny\");\n  if (!__Pyx_RefNanny)\n      Py_FatalError(\"failed to import 'refnanny' module\");\n}\n#endif\n  __Pyx_RefNannySetupContext(\"__Pyx_PyMODINIT_FUNC PyInit_stringcolumn(void)\", 0);\n  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pxy_PyFrame_Initialize_Offsets\n  __Pxy_PyFrame_Initialize_Offsets();\n  #endif\n  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_bytes = PyBytes_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_unicode = PyUnicode_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pyx_CyFunction_USED\n  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_FusedFunction_USED\n  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Coroutine_USED\n  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Generator_USED\n  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_AsyncGen_USED\n  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_StopAsyncIteration_USED\n  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  /*--- Library function declarations ---*/\n  /*--- Threads initialization code ---*/\n  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS\n  #ifdef WITH_THREAD /* Python build with threading support? */\n  PyEval_InitThreads();\n  #endif\n  #endif\n  /*--- Module creation code ---*/\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  __pyx_m = __pyx_pyinit_module;\n  Py_INCREF(__pyx_m);\n  #else\n  #if PY_MAJOR_VERSION < 3\n  __pyx_m = Py_InitModule4(\"stringcolumn\", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);\n  #else\n  __pyx_m = PyModule_Create(&__pyx_moduledef);\n  #endif\n  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_d);\n  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_b);\n  __pyx_cython_runtime = PyImport_AddModule((char *) \"cython_runtime\"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_cython_runtime);\n  if (PyObject_SetAttrString(__pyx_m, \"__builtins__\", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);\n  /*--- Initialize various global constants etc. ---*/\n  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)\n  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  if (__pyx_module_is_main_clickhouse_driver__columns__stringcolumn) {\n    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  }\n  #if PY_MAJOR_VERSION >= 3\n  {\n    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)\n    if (!PyDict_GetItemString(modules, \"clickhouse_driver.columns.stringcolumn\")) {\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.columns.stringcolumn\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  /*--- Builtin init code ---*/\n  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;\n  /*--- Constants init code ---*/\n  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;\n  /*--- Global type/function init code ---*/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  (void)__Pyx_modinit_type_init_code();\n  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  /*--- Execution code ---*/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":9\n * from libc.string cimport memcpy, memset\n * \n * from .. import defines             # <<<<<<<<<<<<<<\n * from .. import errors\n * from ..util import compat\n */\n  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_INCREF(__pyx_n_s_defines);\n  __Pyx_GIVEREF(__pyx_n_s_defines);\n  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_defines);\n  __pyx_t_2 = __Pyx_Import(__pyx_n_s__2, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_defines); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_defines, __pyx_t_1) < 0) __PYX_ERR(0, 9, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":10\n * \n * from .. import defines\n * from .. import errors             # <<<<<<<<<<<<<<\n * from ..util import compat\n * from .base import Column\n */\n  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 10, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(__pyx_n_s_errors);\n  __Pyx_GIVEREF(__pyx_n_s_errors);\n  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_errors);\n  __pyx_t_1 = __Pyx_Import(__pyx_n_s__2, __pyx_t_2, 2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_errors); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 10, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_errors, __pyx_t_2) < 0) __PYX_ERR(0, 10, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":11\n * from .. import defines\n * from .. import errors\n * from ..util import compat             # <<<<<<<<<<<<<<\n * from .base import Column\n * \n */\n  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_INCREF(__pyx_n_s_compat);\n  __Pyx_GIVEREF(__pyx_n_s_compat);\n  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_compat);\n  __pyx_t_2 = __Pyx_Import(__pyx_n_s_util, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_compat); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_compat, __pyx_t_1) < 0) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":12\n * from .. import errors\n * from ..util import compat\n * from .base import Column             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(__pyx_n_s_Column);\n  __Pyx_GIVEREF(__pyx_n_s_Column);\n  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Column);\n  __pyx_t_1 = __Pyx_Import(__pyx_n_s_base, __pyx_t_2, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Column); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Column, __pyx_t_2) < 0) __PYX_ERR(0, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":15\n * \n * \n * class String(Column):             # <<<<<<<<<<<<<<\n *     ch_type = 'String'\n *     py_types = compat.string_types\n */\n  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_Column); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n  __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_String, __pyx_n_s_String, (PyObject *) NULL, __pyx_n_s_clickhouse_driver_columns_string, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":16\n * \n * class String(Column):\n *     ch_type = 'String'             # <<<<<<<<<<<<<<\n *     py_types = compat.string_types\n *     null_value = ''\n */\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_ch_type, __pyx_n_u_String) < 0) __PYX_ERR(0, 16, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":17\n * class String(Column):\n *     ch_type = 'String'\n *     py_types = compat.string_types             # <<<<<<<<<<<<<<\n *     null_value = ''\n * \n */\n  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_compat); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_string_types); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 17, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_5);\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_py_types, __pyx_t_5) < 0) __PYX_ERR(0, 17, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":18\n *     ch_type = 'String'\n *     py_types = compat.string_types\n *     null_value = ''             # <<<<<<<<<<<<<<\n * \n *     default_encoding = defines.STRINGS_ENCODING\n */\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_null_value, __pyx_kp_u__2) < 0) __PYX_ERR(0, 18, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":20\n *     null_value = ''\n * \n *     default_encoding = defines.STRINGS_ENCODING             # <<<<<<<<<<<<<<\n * \n *     def __init__(self, encoding=default_encoding, **kwargs):\n */\n  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_defines); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_5);\n  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_STRINGS_ENCODING); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_default_encoding, __pyx_t_4) < 0) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":22\n *     default_encoding = defines.STRINGS_ENCODING\n * \n *     def __init__(self, encoding=default_encoding, **kwargs):             # <<<<<<<<<<<<<<\n *         self.encoding = encoding\n *         super(String, self).__init__(**kwargs)\n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_6String_1__init__, 0, __pyx_n_s_String___init, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__4)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 22, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (!__Pyx_CyFunction_InitDefaults(__pyx_t_4, sizeof(__pyx_defaults), 1)) __PYX_ERR(0, 22, __pyx_L1_error)\n  __pyx_t_5 = PyObject_GetItem(__pyx_t_3, __pyx_n_s_default_encoding);\n  if (unlikely(!__pyx_t_5)) {\n    PyErr_Clear();\n    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_default_encoding);\n  }\n  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 22, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_5);\n  __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_t_4)->__pyx_arg_encoding = __pyx_t_5;\n  __Pyx_GIVEREF(__pyx_t_5);\n  __pyx_t_5 = 0;\n  __Pyx_CyFunction_SetDefaultsGetter(__pyx_t_4, __pyx_pf_17clickhouse_driver_7columns_12stringcolumn_2__defaults__);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 22, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":26\n *         super(String, self).__init__(**kwargs)\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         buf.write_strings(items, encoding=self.encoding)\n * \n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_6String_3write_items, 0, __pyx_n_s_String_write_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__6)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 26, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_write_items, __pyx_t_4) < 0) __PYX_ERR(0, 26, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":29\n *         buf.write_strings(items, encoding=self.encoding)\n * \n *     def read_items(self, n_items, buf):             # <<<<<<<<<<<<<<\n *         return buf.read_strings(n_items, encoding=self.encoding)\n * \n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_6String_5read_items, 0, __pyx_n_s_String_read_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__8)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 29, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_read_items, __pyx_t_4) < 0) __PYX_ERR(0, 29, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":15\n * \n * \n * class String(Column):             # <<<<<<<<<<<<<<\n *     ch_type = 'String'\n *     py_types = compat.string_types\n */\n  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_String, __pyx_t_2, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_String, __pyx_t_4) < 0) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":33\n * \n * \n * class ByteString(String):             # <<<<<<<<<<<<<<\n *     py_types = (bytes, )\n *     null_value = b''\n */\n  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_String); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 33, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 33, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);\n  __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 33, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_ByteString, __pyx_n_s_ByteString, (PyObject *) NULL, __pyx_n_s_clickhouse_driver_columns_string, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 33, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":34\n * \n * class ByteString(String):\n *     py_types = (bytes, )             # <<<<<<<<<<<<<<\n *     null_value = b''\n * \n */\n  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 34, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_INCREF(((PyObject *)(&PyBytes_Type)));\n  __Pyx_GIVEREF(((PyObject *)(&PyBytes_Type)));\n  PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)(&PyBytes_Type)));\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_py_types, __pyx_t_4) < 0) __PYX_ERR(0, 34, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":35\n * class ByteString(String):\n *     py_types = (bytes, )\n *     null_value = b''             # <<<<<<<<<<<<<<\n * \n *     def write_items(self, items, buf):\n */\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_null_value, __pyx_kp_b__2) < 0) __PYX_ERR(0, 35, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":37\n *     null_value = b''\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         buf.write_strings(items)\n * \n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_10ByteString_1write_items, 0, __pyx_n_s_ByteString_write_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__10)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 37, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_write_items, __pyx_t_4) < 0) __PYX_ERR(0, 37, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":40\n *         buf.write_strings(items)\n * \n *     def read_items(self, n_items, buf):             # <<<<<<<<<<<<<<\n *         return buf.read_strings(n_items)\n * \n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_10ByteString_3read_items, 0, __pyx_n_s_ByteString_read_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__12)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 40, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_read_items, __pyx_t_4) < 0) __PYX_ERR(0, 40, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":33\n * \n * \n * class ByteString(String):             # <<<<<<<<<<<<<<\n *     py_types = (bytes, )\n *     null_value = b''\n */\n  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_ByteString, __pyx_t_1, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 33, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ByteString, __pyx_t_4) < 0) __PYX_ERR(0, 33, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":44\n * \n * \n * class FixedString(String):             # <<<<<<<<<<<<<<\n *     ch_type = 'FixedString'\n * \n */\n  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_String); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n  __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_FixedString, __pyx_n_s_FixedString, (PyObject *) NULL, __pyx_n_s_clickhouse_driver_columns_string, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":45\n * \n * class FixedString(String):\n *     ch_type = 'FixedString'             # <<<<<<<<<<<<<<\n * \n *     def __init__(self, length, **kwargs):\n */\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_ch_type, __pyx_n_u_FixedString) < 0) __PYX_ERR(0, 45, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":47\n *     ch_type = 'FixedString'\n * \n *     def __init__(self, length, **kwargs):             # <<<<<<<<<<<<<<\n *         self.length = length\n *         super(FixedString, self).__init__(**kwargs)\n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_11FixedString_1__init__, 0, __pyx_n_s_FixedString___init, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__14)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 47, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":51\n *         super(FixedString, self).__init__(**kwargs)\n * \n *     def read_items(self, Py_ssize_t n_items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t i, j, length = self.length\n *         encoding = self.encoding.encode('utf-8')\n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_11FixedString_3read_items, 0, __pyx_n_s_FixedString_read_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__16)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 51, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_read_items, __pyx_t_4) < 0) __PYX_ERR(0, 51, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":83\n *         return items\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length\n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_11FixedString_5write_items, 0, __pyx_n_s_FixedString_write_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__18)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 83, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_write_items, __pyx_t_4) < 0) __PYX_ERR(0, 83, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":44\n * \n * \n * class FixedString(String):             # <<<<<<<<<<<<<<\n *     ch_type = 'FixedString'\n * \n */\n  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_FixedString, __pyx_t_2, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FixedString, __pyx_t_4) < 0) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":114\n * \n * \n * class ByteFixedString(FixedString):             # <<<<<<<<<<<<<<\n *     py_types = (bytearray, bytes)\n *     null_value = b''\n */\n  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_FixedString); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 114, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);\n  __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 114, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_ByteFixedString, __pyx_n_s_ByteFixedString, (PyObject *) NULL, __pyx_n_s_clickhouse_driver_columns_string, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":115\n * \n * class ByteFixedString(FixedString):\n *     py_types = (bytearray, bytes)             # <<<<<<<<<<<<<<\n *     null_value = b''\n * \n */\n  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 115, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_INCREF(((PyObject *)(&PyByteArray_Type)));\n  __Pyx_GIVEREF(((PyObject *)(&PyByteArray_Type)));\n  PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)(&PyByteArray_Type)));\n  __Pyx_INCREF(((PyObject *)(&PyBytes_Type)));\n  __Pyx_GIVEREF(((PyObject *)(&PyBytes_Type)));\n  PyTuple_SET_ITEM(__pyx_t_4, 1, ((PyObject *)(&PyBytes_Type)));\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_py_types, __pyx_t_4) < 0) __PYX_ERR(0, 115, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":116\n * class ByteFixedString(FixedString):\n *     py_types = (bytearray, bytes)\n *     null_value = b''             # <<<<<<<<<<<<<<\n * \n *     def read_items(self, Py_ssize_t n_items, buf):\n */\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_null_value, __pyx_kp_b__2) < 0) __PYX_ERR(0, 116, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":118\n *     null_value = b''\n * \n *     def read_items(self, Py_ssize_t n_items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t i\n *         cdef Py_ssize_t length = self.length\n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_1read_items, 0, __pyx_n_s_ByteFixedString_read_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__20)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 118, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_read_items, __pyx_t_4) < 0) __PYX_ERR(0, 118, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":131\n *         return items\n * \n *     def write_items(self, items, buf):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t buf_pos = 0\n *         cdef Py_ssize_t length = self.length\n */\n  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_15ByteFixedString_3write_items, 0, __pyx_n_s_ByteFixedString_write_items, NULL, __pyx_n_s_clickhouse_driver_columns_string, __pyx_d, ((PyObject *)__pyx_codeobj__22)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 131, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_write_items, __pyx_t_4) < 0) __PYX_ERR(0, 131, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":114\n * \n * \n * class ByteFixedString(FixedString):             # <<<<<<<<<<<<<<\n *     py_types = (bytearray, bytes)\n *     null_value = b''\n */\n  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_ByteFixedString, __pyx_t_1, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 114, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ByteFixedString, __pyx_t_4) < 0) __PYX_ERR(0, 114, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":158\n * \n * \n * def create_string_column(spec, column_options):             # <<<<<<<<<<<<<<\n *     client_settings = column_options['context'].client_settings\n *     strings_as_bytes = client_settings['strings_as_bytes']\n */\n  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_7columns_12stringcolumn_1create_string_column, NULL, __pyx_n_s_clickhouse_driver_columns_string); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 158, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_create_string_column, __pyx_t_1) < 0) __PYX_ERR(0, 158, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":1\n * from cpython cimport Py_INCREF, PyBytes_AsString, PyBytes_FromStringAndSize, \\             # <<<<<<<<<<<<<<\n *     PyBytes_Check\n * # Using python's versions of pure c memory management functions for\n */\n  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /*--- Wrapped vars code ---*/\n\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  if (__pyx_m) {\n    if (__pyx_d) {\n      __Pyx_AddTraceback(\"init clickhouse_driver.columns.stringcolumn\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n    }\n    Py_CLEAR(__pyx_m);\n  } else if (!PyErr_Occurred()) {\n    PyErr_SetString(PyExc_ImportError, \"init clickhouse_driver.columns.stringcolumn\");\n  }\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  return (__pyx_m != NULL) ? 0 : -1;\n  #elif PY_MAJOR_VERSION >= 3\n  return __pyx_m;\n  #else\n  return;\n  #endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 542,
        "code": "static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(env, \"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 543,
        "code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output = GetOutput(context, node, i);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 544,
        "code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = mrb_vm_ci_target_class(ci);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {\n        goto super_typeerror;\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n#if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n#endif\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#ifdef MRB_USE_BIGINT\n#define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n#else\n#define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n#endif\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1934"
    },
    {
        "index": 545,
        "code": "void luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n tailcall:\n  trap = L->hookmask;\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (trap) {\n    if (cl->p->is_vararg)\n      trap = 0;  /* hooks will start after VARARGPREP instruction */\n    else if (pc == cl->p->code)  /* first instruction (not resuming)? */\n      luaD_hookcall(L, ci);\n    ci->u.l.trap = 1;  /* there may be other hooks */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    StkId ra;  /* instruction's A register */\n    vmfetch();\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        Protect(luaF_close(L, ra, LUA_OK));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        ProtectNT(luaD_call(L, ra, nresults));\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int nparams1 = GETARG_C(i);\n        /* delat is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* some calls here can raise errors */\n        if (TESTARG_k(i)) {\n          /* close upvalues from current call; the compiler ensures\n             that there are no to-be-closed variables here, so this\n             call cannot change the stack */\n          luaF_close(L, base, NOCLOSINGMETH);\n          lua_assert(base == ci->func + 1);\n        }\n        while (!ttisfunction(s2v(ra))) {  /* not a function? */\n          luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */\n          b++;  /* there is now one extra argument */\n          checkstackp(L, 1, ra);\n        }\n        if (!ttisLclosure(s2v(ra))) {  /* C function? */\n          luaD_call(L, ra, LUA_MULTRET);  /* call it */\n          updatetrap(ci);\n          updatestack(ci);  /* stack may have been relocated */\n          ci->func -= delta;\n          luaD_poscall(L, ci, cast_int(L->top - ra));\n          return;\n        }\n        ci->func -= delta;\n        luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */\n        goto tailcall;\n      }\n      vmcase(OP_RETURN) {\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, LUA_OK);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        return;\n      }\n      vmcase(OP_RETURN0) {\n        if (L->hookmask) {\n          L->top = ra;\n          halfProtectNT(luaD_poscall(L, ci, 0));  /* no hurry... */\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          while (nres-- > 0)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        return;\n      }\n      vmcase(OP_RETURN1) {\n        if (L->hookmask) {\n          L->top = ra + 1;\n          halfProtectNT(luaD_poscall(L, ci, 1));  /* no hurry... */\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            while (--nres > 0)  /* complete missing results */\n              setnilvalue(s2v(L->top++));\n          }\n        }\n        return;\n      }\n      vmcase(OP_FORLOOP) {\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall:\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }\n      vmcase(OP_TFORLOOP) {\n        l_tforloop:\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETLIST) {\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p);\n        updatetrap(ci);\n        if (trap) {\n          luaD_hookcall(L, ci);\n          L->oldpc = pc + 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 546,
        "code": "static int jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)\n{\n    int k, cnt, erc = -1;\n    Jsi_CDataDb statbinds[] = {{}, {}};\n    if (!dbopts) dbopts = statbinds;\n    OptionBind ob = {.binds = dbopts};\n    Jsi_StructSpec *specPtr, *specs;\n    Jsi_Interp *interp = jdb->interp;\n    if (!query) query=\"\";\n    if (query[0]==';') {\n        if (!dbExecCmd(jdb, query+1, &erc)) {\n            Jsi_LogError(\"EXEC ERROR=\\\"%s\\\", SQL=\\\"%s\\\"\", sqlite3_errmsg(jdb->db), query);\n            return erc;\n        }\n        return 0;\n    }\n    const char *cPtr = Jsi_Strstr(query, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(query, \"\\t%s\");\n    if (!dbopts) {\n        Jsi_LogError(\"dbopts may not be null\");\n        return -1;\n    }\n    if (!dbopts[0].data) {\n        Jsi_LogError(\"data may not be null\");\n        return -1;\n    }\n    if (!dbopts[0].sf) {\n        Jsi_LogError(\"specs may not be null\");\n        return -1;\n    }\n    for (k=0; dbopts[k].sf; k++) {\n        if (dbopts[k].arrSize>1 || k==0) {\n            int scnt = 0;\n            for (specPtr = dbopts[k].sf, scnt=0; specPtr->id>=JSI_OPTION_BOOL\n                && specPtr->id < JSI_OPTION_END; specPtr++, scnt++) {\n                if (specPtr->flags&JSI_OPT_DB_IGNORE)\n                    continue;\n                if (k==0) {\n                    if (specPtr->flags&JSI_OPT_DB_ROWID) {\n                        if (specPtr->id != JSI_OPTION_INT64) {\n                            Jsi_LogError(\"rowid flag must be a wide field: %s\", specPtr->name);\n                            return -1;\n                        }\n                        ob.rowidPtr = specPtr;\n                    }\n                    if (specPtr->flags&JSI_OPT_DB_DIRTY) {\n                        if (specPtr->id == JSI_OPTION_BOOL || specPtr->id == JSI_OPTION_INT) {\n                            ob.dirtyPtr = specPtr;\n                        } else {\n                            Jsi_LogError(\"dirty flag must be a int/bool field: %s\", specPtr->name);\n                            return -1;\n                        }\n                    }\n                            \n                }\n            }\n            if (k==0)\n                ob.optLen = scnt;\n            assert(specPtr->id == JSI_OPTION_END);\n        }\n        if (!dbopts[k].prefix) break;\n    }\n    specs = dbopts[0].sf;\n    int structSize = specs[ob.optLen].size;\n    if (dbopts->memClear || dbopts->memFree) {\n        cnt = dbopts[0].arrSize;\n        void *rec = dbopts[0].data, *prec = rec;\n        void **recPtrPtr = NULL;\n        if (dbopts->isPtr2) {\n            recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */\n            rec = *recPtrPtr;\n        }\n        if (cnt<=0 && rec && dbopts->isPtr2) {\n            for (cnt=0; ((void**)rec)[cnt]!=NULL; cnt++);\n        }\n        for (k=0; k<cnt; k++) {\n            if (dbopts->isPtr2 || dbopts->isPtrs)\n                prec = ((void**)rec)[k];\n            else\n                prec = (char*)rec + (k * structSize);\n            if (!prec)\n                continue;\n            Jsi_OptionsFree(interp, (Jsi_OptionSpec*)specs, prec, 0);\n            if (dbopts->isPtr2 || dbopts->isPtrs) {\n                Jsi_Free(prec);\n            }\n        }\n        if (recPtrPtr) {\n            Jsi_Free(*recPtrPtr);\n            *recPtrPtr = NULL;\n        }\n        if (query == NULL || query[0] == 0)\n            return 0;\n    }\n    \n    if (!Jsi_Strncasecmp(query, \"SELECT\", 6))\n        return dbOptSelect(jdb, query, &ob, dbopts);\n        \n    DbEvalContext sEval = {};\n    int insert = 0, replace = 0, update = 0;\n    char nbuf[100], *bPtr;\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString sStr, *dStr = &sStr;\n    Jsi_DSInit(dStr);\n#endif\n    if (dbopts->noCache)\n        sEval.nocache = 1;\n    if (dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0) != JSI_OK)\n        return -1;\n    int dataMax = dbopts[0].arrSize;\n    cnt = 0;\n    if (dataMax==0)\n        dataMax = 1;\n    char ch[2];\n\n    ch[0] = dbopts[0].prefix;\n    ch[1] = 0;\n    if (!ch[0])\n        ch[0] = ':';\n    if ((update=(Jsi_Strncasecmp(query, \"UPDATE\", 6)==0))) {\n        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);\n        if (cPtr) {\n            Jsi_DSAppend(dStr, \" \", NULL);\n            int cidx = 0;\n            int killf = (JSI_OPT_DB_IGNORE|JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || (specPtr->flags&killf))\n                    continue;\n                const char *fname = specPtr->name;\n                if (ch[0] == '?')\n                    snprintf(bPtr=nbuf, sizeof(nbuf), \"%d\", cidx+1);\n                else\n                    bPtr = (char*)specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), \"[\", fname, \"]=\",\n                    ch, bPtr, NULL);\n                cnt++;\n            }\n            Jsi_DSAppend(dStr, cPtr+3, NULL);\n        }\n    } else if ((insert=(Jsi_Strncasecmp(query, \"INSERT\", 6)==0))\n        || (replace=(Jsi_Strncasecmp(query, \"REPLACE\", 7)==0))) {\n        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);\n        if (cPtr) {\n            Jsi_DSAppend(dStr, \" (\", NULL);\n            int killf = JSI_OPT_DB_IGNORE;\n            if (replace)\n                killf |= (JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || specPtr->flags&killf)\n                    continue;\n                const char *fname = specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), \"[\", fname, \"]\", NULL);\n                cnt++;\n            }\n            Jsi_DSAppendLen(dStr,\") VALUES(\", -1);\n            cnt = 0;\n            int cidx = 0;\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr\n                    || specPtr->flags&killf)\n                    continue;\n                if (ch[0] == '?')\n                    snprintf(bPtr=nbuf, sizeof(nbuf), \"%d\", cidx+1);\n                else\n                    bPtr = (char*)specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), ch, bPtr, NULL);\n                cnt++;\n            }\n            Jsi_DSAppend(dStr,\")\", cPtr+3, NULL);\n        }\n    } else if (!Jsi_Strncasecmp(query, \"DELETE\", 6)) {\n        Jsi_DSAppend(dStr, query, NULL);\n    } else {\n        Jsi_LogError(\"unrecognized query \\\"%s\\\": expected one of: SELECT, UPDATE, INSERT, REPLACE or DELETE\", query);\n        return -1;\n    }\n    sEval.zSql = Jsi_DSValue(dStr);\n    if (jdb->echo && sEval.zSql)\n        Jsi_LogInfo(\"SQL-ECHO: %s\\n\", sEval.zSql); \n\n    int rc, bindMax = -1, dataIdx = 0;\n    cnt = 0;\n    int ismodify = (replace||insert||update);\n    int isnew = (replace||insert);\n    int didBegin = 0;\n    DbEvalContext *p = &sEval;\n    rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n    if( rc!=JSI_OK ) return -1;\n    if (dataMax>1 && !dbopts->noBegin) {\n        didBegin = 1;\n        if (!dbExecCmd(jdb, JSI_DBQUERY_BEGIN_STR, &erc))\n            goto bail;\n    }\n    while (dataIdx<dataMax) {\n        if (ismodify && ob.dirtyPtr && (dbopts->dirtyOnly)) { /* Check to limit updates to dirty values only. */\n            void *rec = dbopts[0].data;\n            if (dbopts->isPtrs || dbopts->isPtr2)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = (char*)rec + (dataIdx * structSize);\n            char *ptr = (char*)rec + ob.dirtyPtr->offset;\n            int isDirty = *(int*)ptr;\n            int bit = 0;\n            if (ob.dirtyPtr->id == JSI_OPTION_BOOL)\n                bit = (uintptr_t)ob.dirtyPtr->data;\n            if (!(isDirty&(1<<(bit)))) {\n                dataIdx++;\n                continue;\n            }\n            isDirty &= ~(1<<(bit));\n            *(int*)ptr = isDirty; /* Note that the dirty bit is cleared, even upon error.*/\n        }\n        rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, &ob, dataIdx, bindMax, dbopts);\n        if( rc!=JSI_OK )\n            goto bail;\n        bindMax = 1;\n        rc = dbEvalStepSub(p, (dataIdx>=dataMax), &erc);\n        if (rc == JSI_ERROR)\n            goto bail;\n        cnt += sqlite3_changes(jdb->db);\n        if (rc != JSI_OK && rc != JSI_BREAK)\n            break;\n        if (ob.rowidPtr && isnew) {\n            void *rec = dbopts[0].data;\n            if (dbopts->isPtrs || dbopts->isPtr2)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = (char*)rec + (dataIdx * structSize);\n            char *ptr = (char*)rec + ob.rowidPtr->offset;\n            *(Jsi_Wide*)ptr = sqlite3_last_insert_rowid(jdb->db);\n        }\n        dataIdx++;\n    }\n    if (didBegin && !dbExecCmd(jdb, JSI_DBQUERY_COMMIT_STR, &erc))\n        rc = JSI_ERROR;\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    return (rc==JSI_OK?cnt:erc);\n\nbail:\n    dbEvalFinalize(&sEval);\n    if (didBegin)\n        dbExecCmd(jdb, JSI_DBQUERY_ROLLBACK_STR, NULL);\n    return erc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 547,
        "code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1795"
    },
    {
        "index": 548,
        "code": "TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteFullyConnectedParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE(context, node->inputs->size == 2 || node->inputs->size == 3);\n  // Shuffled formats need a workspace to store the shuffled input activations.\n  const int expected_outputs_count =\n      params->weights_format == kTfLiteFullyConnectedWeightsFormatDefault ? 1\n                                                                          : 2;\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, expected_outputs_count);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* bias =\n      (node->inputs->size == 3)\n          ? GetOptionalInputTensor(context, node, kBiasTensor)\n          : nullptr;\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Check proper datatype match among all Input Tensors\n  TF_LITE_ENSURE_STATUS(\n      CheckTypes(context, input, filter, bias, output, params));\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  int input_size = 1;\n  for (int i = 0; i < input->dims->size; i++) {\n    input_size *= input->dims->data[i];\n  }\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2);\n  const int batch_size = input_size / filter->dims->data[1];\n  const int num_units = filter->dims->data[0];\n\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0));\n  }\n\n  // Note that quantized inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training.\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8 ||\n      input->type == kTfLiteInt16) {\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, input, filter, bias, output, &real_multiplier));\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier, &exponent);\n    data->output_shift = exponent;\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n  }\n\n  if (input->type == kTfLiteInt16 && output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n  }\n\n  // If we have to perform on-the-fly quantization (with quantized weights and\n  // float inputs) first we need to quantize the inputs. Allocate a temporary\n  // buffer to store the intermediate quantized values.\n  // Additionally, we allocate a temporary buffer to store the accumulated\n  // quantized values prior to multiplication by the scaling factor.\n  if (input->type == kTfLiteFloat32 &&\n      (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8)) {\n    TfLiteIntArrayFree(node->temporaries);\n    data->compute_row_sums = true;\n    node->temporaries = TfLiteIntArrayCreate(5);\n    node->temporaries->data[0] = data->scratch_tensor_index;\n\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    input_quantized->type = filter->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n\n    TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                     input_quantized_size));\n\n    node->temporaries->data[1] = data->scratch_tensor_index + 1;\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/1);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    node->temporaries->data[2] = data->scratch_tensor_index + 2;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/2);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {num_units, batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);\n      accum_size->data[0] = num_units;\n      accum_size->data[1] = batch_size;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, accum_scratch, accum_size));\n    }\n\n    node->temporaries->data[3] = data->scratch_tensor_index + 3;\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/3);\n    input_offsets->type = kTfLiteInt32;\n    input_offsets->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);\n      input_offsets_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,\n                                                       input_offsets_size));\n    }\n    node->temporaries->data[4] = data->scratch_tensor_index + 4;\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/4);\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_units};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = nullptr;\n  if (params->keep_num_dims) {\n    // When number of dimensions are kept the filter operates along the last\n    // dimensions. In other words, for an input tensor with shape\n    // [batch_size, ..., n_inputs] and a filter of shape [n_inputs, n_units]\n    // this Op produces an output of shape [batch_size, ..., n_units].\n    TF_LITE_ENSURE_EQ(context, input->dims->data[input->dims->size - 1],\n                      SizeOfDimension(filter, 1));\n    output_size_array = TfLiteIntArrayCopy(input->dims);\n    output_size_array->data[output_size_array->size - 1] = num_units;\n  } else {\n    // Otherwise, the output is (potentially flattened to) a 2-D matrix.\n    output_size_array = TfLiteIntArrayCreate(2);\n    output_size_array->data[0] = batch_size;\n    output_size_array->data[1] = num_units;\n  }\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 549,
        "code": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-44108"
    },
    {
        "index": 550,
        "code": "const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[200];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:\n            ntxt = \"null\";\n            break;\n        case JSI_VT_NUMBER: {\n            d = v->d.num;\nfmtnum:\n            if (Jsi_NumberIsInteger(d)) {\n                Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNormal(d)) {\n                Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNaN(v->d.num)) {\n                ntxt = \"NaN\";\n            } else {\n                int s = Jsi_NumberIsInfinity(d);\n                if (s > 0) ntxt = \"Infinity\";\n                else if (s < 0) ntxt = \"-Infinity\";\n                else Jsi_LogBug(\"Ieee function got problem\");\n            }\n            break;\n        }\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_STRING:\n                    ntxt = obj->d.s.str;\n                    goto done;\n                case JSI_OT_BOOL:\n                    ntxt = obj->d.val ? \"true\":\"false\";\n                    break;\n                case JSI_OT_NUMBER:\n                    d = obj->d.num;\n                    goto fmtnum;\n                    break;\n                default:\n                    ntxt = \"[object Object]\";\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to string\", v->vt);\n            break;\n    }\n    Jsi_ValueReset(interp, &v);\n    if (!kflag) {\n        Jsi_ValueMakeStringDup(interp, &v, ntxt);\n        return Jsi_ValueString(interp, v, lenPtr);\n    }\n    \n    key = jsi_KeyFind(interp, ntxt, 0, &isKey);\n    if (key)\n        Jsi_ValueMakeStringKey(interp, &v, key);\n    else\n        Jsi_ValueMakeString(interp, &v, ntxt);\n    ntxt = v->d.s.str;\n    \ndone:\n    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);\n    return ntxt;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 551,
        "code": "u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n  /* ip address must be X.X.X.X with each X between 0 and 255 */\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  val = val + c;\n\n  *bytes_read = *bytes_read + read;\n\n  return(htonl(val));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15471"
    },
    {
        "index": 552,
        "code": "MONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n\n    mongo_pass_digest( user, pass, hex_digest );\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n\n    bson_destroy( &from_db );\n\n    result = mongo_run_command( conn, db, &cmd, NULL );\n\n    bson_destroy( &cmd );\n\n    return result;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 553,
        "code": "void luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 554,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_8flush(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"flush\", 0);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":47\n * \n *     def flush(self):\n *         self.write_into_stream()             # <<<<<<<<<<<<<<\n * \n *     def write_strings(self, items, encoding=None):\n */\n  __pyx_t_1 = ((struct __pyx_vtabstruct_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v_self->__pyx_vtab)->write_into_stream(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":46\n *             written += size\n * \n *     def flush(self):             # <<<<<<<<<<<<<<\n *         self.write_into_stream()\n * \n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.flush\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 555,
        "code": "TfLiteStatus EvalSum(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n  ruy::profiler::ScopeLabel label(\"Sum\");\n  const auto& input = op_context.input;\n  const auto& output = op_context.output;\n  const bool same_scale =\n      (input->params.scale == output->params.scale &&\n       input->params.zero_point == output->params.zero_point);\n  const bool eight_bit_quantized =\n      input->type == kTfLiteUInt8 || input->type == kTfLiteInt8;\n  const bool need_rescale = (eight_bit_quantized && !same_scale);\n  if (need_rescale) {\n    // Rescaling 8bit reduce sum.\n    int num_axis = static_cast<int>(NumElements(op_context.axis));\n    TfLiteTensor* temp_index = GetTemporary(context, node, /*index=*/0);\n    TfLiteTensor* resolved_axis = GetTemporary(context, node, /*index=*/1);\n    TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);\n    // Resize the output tensor if the output tensor is dynamic.\n    if (IsDynamicTensor(op_context.output)) {\n      TF_LITE_ENSURE_OK(context,\n                        ResizeTempAxis(context, &op_context, resolved_axis));\n      TF_LITE_ENSURE_OK(context, ResizeOutputTensor(context, &op_context));\n      TF_LITE_ENSURE_OK(context, ResizeTempSum(context, &op_context, temp_sum));\n    }\n    if (input->type == kTfLiteUInt8) {\n      TF_LITE_ENSURE(\n          context,\n          reference_ops::QuantizedMeanOrSum<>(\n              GetTensorData<uint8_t>(op_context.input),\n              op_context.input->params.zero_point,\n              op_context.input->params.scale, op_context.input->dims->data,\n              op_context.input->dims->size,\n              GetTensorData<uint8_t>(op_context.output),\n              op_context.output->params.zero_point,\n              op_context.output->params.scale, op_context.output->dims->data,\n              op_context.output->dims->size,\n              GetTensorData<int>(op_context.axis), num_axis,\n              op_context.params->keep_dims, GetTensorData<int>(temp_index),\n              GetTensorData<int>(resolved_axis), GetTensorData<int32>(temp_sum),\n              /*compute_sum=*/true));\n    }\n    if (input->type == kTfLiteInt8) {\n      TF_LITE_ENSURE(\n          context,\n          reference_ops::QuantizedMeanOrSum<>(\n              GetTensorData<int8_t>(op_context.input),\n              op_context.input->params.zero_point,\n              op_context.input->params.scale, op_context.input->dims->data,\n              op_context.input->dims->size,\n              GetTensorData<int8_t>(op_context.output),\n              op_context.output->params.zero_point,\n              op_context.output->params.scale, op_context.output->dims->data,\n              op_context.output->dims->size,\n              GetTensorData<int>(op_context.axis), num_axis,\n              op_context.params->keep_dims, GetTensorData<int>(temp_index),\n              GetTensorData<int>(resolved_axis), GetTensorData<int32>(temp_sum),\n              /*compute_sum=*/true));\n    }\n  } else {\n    return EvalGeneric<kReference, kSum>(context, node);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 556,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  ruy::profiler::ScopeLabel label(\"SquaredDifference\");\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32) {\n    EvalSquaredDifference<float>(context, node, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    EvalSquaredDifference<int32_t>(context, node, data, input1, input2, output);\n  } else {\n    context->ReportError(\n        context,\n        \"SquaredDifference only supports FLOAT32 and INT32 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 557,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 5);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* ids = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(ids), 1);\n  TF_LITE_ENSURE_EQ(context, ids->type, kTfLiteInt32);\n\n  const TfLiteTensor* indices = GetInput(context, node, 1);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(indices), 2);\n  TF_LITE_ENSURE_EQ(context, indices->type, kTfLiteInt32);\n\n  const TfLiteTensor* shape = GetInput(context, node, 2);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(shape), 1);\n  TF_LITE_ENSURE_EQ(context, shape->type, kTfLiteInt32);\n\n  const TfLiteTensor* weights = GetInput(context, node, 3);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(weights), 1);\n  TF_LITE_ENSURE_EQ(context, weights->type, kTfLiteFloat32);\n\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(ids, 0));\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(weights, 0));\n\n  const TfLiteTensor* value = GetInput(context, node, 4);\n  TF_LITE_ENSURE(context, NumDimensions(value) >= 2);\n\n  // Mark the output as a dynamic tensor.\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  output->allocation_type = kTfLiteDynamic;\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 558,
        "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 559,
        "code": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n\n    // TODO: check whether this really can be recursive (e.g. overlay of grid images)\n\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-19499"
    },
    {
        "index": 560,
        "code": "Jsi_RC jsi_StaticArgTypeCheck(Jsi_Interp *interp, int atyp, const char *p1, const char *p2, int index, Jsi_Func *func, jsi_Pline *line) {\n    Assert(index>0);\n    Jsi_RC rc;\n    if (interp->typeCheck.parse==0 && interp->typeCheck.all==0)\n        return JSI_OK;\n    int ai = index-1+func->callflags.bits.addargs;\n    if (func->argnames == NULL || ai>=func->argnames->count || ai<0)\n        return JSI_OK;\n    int typ = func->argnames->args[ai].type;\n    if (typ <= 0)\n        return JSI_OK;\n    if (index == 0 && func && func->type == FC_BUILDIN && \n        interp->typeCheck.all==0) // Normally do not check return types for builtins.\n        return JSI_OK; \n    if ((typ&JSI_TT_ANY)) return JSI_OK;\n    if (index == 0 && atyp == JSI_VT_UNDEF) {\n        if (!(typ&JSI_TT_VOID)) \n            goto done;\n        return JSI_OK;\n    }\n/*    if (index == 0 && (typ&JSI_TT_VOID)) {\n        if (atyp != JSI_VT_UNDEF && !(typ&JSI_TT_UNDEFINED))\n            goto done;\n        return JSI_OK;\n    }*/\n    if (atyp == JSI_VT_UNDEF)\n        return JSI_OK;\n    rc = JSI_OK;\n    if (typ&JSI_TT_UNDEFINED && atyp == JSI_TT_UNDEFINED) return rc;\n    if (typ&JSI_TT_NUMBER && atyp==JSI_TT_NUMBER) return rc;\n    if (typ&JSI_TT_STRING && atyp==JSI_TT_STRING) return rc;\n    if (typ&JSI_TT_BOOLEAN && atyp==JSI_TT_BOOLEAN)  return rc;\n    if (typ&JSI_TT_ARRAY && atyp==JSI_TT_ARRAY)   return rc;\n    if (typ&JSI_TT_FUNCTION && atyp==JSI_TT_FUNCTION) return rc;\n    if (typ&JSI_TT_REGEXP && atyp==JSI_TT_REGEXP) return rc;\n    if (typ&JSI_TT_USEROBJ && atyp==JSI_TT_USEROBJ) return rc;\n    if (typ&JSI_TT_ITEROBJ && atyp==JSI_TT_ITEROBJ) return rc;\n    if (typ&JSI_TT_OBJECT && atyp==JSI_TT_OBJECT) return rc;\n    if (typ&JSI_TT_NULL && atyp==JSI_TT_NULL) return rc;\ndone:\n    {\n        Jsi_DString dStr = {};\n        const char *exp = jsi_typeName(interp, typ, &dStr);\n        const char *vtyp = jsi_TypeName(interp, (Jsi_ttype)atyp);\n        char idxBuf[200];\n        idxBuf[0] = 0;\n        if (index>0)\n            snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        if (line)\n            interp->parseLine = line;\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        jsi_TypeMismatch(interp);\n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\",\n            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, NULL));\n        Jsi_DSFree(&fStr);\n        Jsi_DSFree(&dStr);\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 561,
        "code": "gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n  int i;\n  gdImagePtr im;\n\n  if (overflow2(sx, sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(unsigned char *), sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(int) + sizeof(unsigned char), sx * sy)) {\n    return NULL;\n  }\n\n  // Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + sy * (sizeof(int *) + sizeof(unsigned char *))\n    + sx * sy * (sizeof(int) + sizeof(unsigned char));\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    // Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n\n  im = (gdImage *) gdMalloc(sizeof(gdImage));\n  memset(im, 0, sizeof(gdImage));\n  im->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n  im->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n  im->polyInts = 0;\n  im->polyAllocated = 0;\n  im->brush = 0;\n  im->tile = 0;\n  im->style = 0;\n  for (i = 0; i < sy; i++) {\n    im->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n    im->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n  }\n  im->sx = sx;\n  im->sy = sy;\n  im->transparent = (-1);\n  im->interlace = 0;\n  im->trueColor = 1;\n  /* 2.0.2: alpha blending is now on by default, and saving of alpha is\n   * off by default. This allows font antialiasing to work as expected\n   * on the first try in JPEGs -- quite important -- and also allows\n   * for smaller PNGs when saving of alpha channel is not really\n   * desired, which it usually isn't!\n   */\n  im->saveAlphaFlag = 0;\n  im->alphaBlendingFlag = 1;\n  im->thick = 1;\n  im->AA = 0;\n  im->AA_polygon = 0;\n  im->cx1 = 0;\n  im->cy1 = 0;\n  im->cx2 = im->sx - 1;\n  im->cy2 = im->sy - 1;\n  im->interpolation = NULL;\n  im->interpolation_id = GD_BILINEAR_FIXED;\n  return im;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1916"
    },
    {
        "index": 562,
        "code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                      std::numeric_limits<int8_t>::min());\n\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n\n    data->input_zero_point = input->params.zero_point;\n\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 563,
        "code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 564,
        "code": "  void writeStats(Array& /*ret*/) override {\n    fprintf(stderr, \"writeStats start\\n\");\n    // RetSame: the return value is the same instance every time\n    // HasThis: call has a this argument\n    // AllSame: all returns were the same data even though args are different\n    // MemberCount: number of different arg sets (including this)\n    fprintf(stderr, \"Count Function MinSerLen MaxSerLen RetSame HasThis \"\n            \"AllSame MemberCount\\n\");\n    for (auto& me : m_memos) {\n      if (me.second.m_ignore) continue;\n      if (me.second.m_count == 1) continue;\n      int min_ser_len = 999999999;\n      int max_ser_len = 0;\n      int count = 0;\n      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),\n              min_ser_len, max_ser_len,\n              me.second.m_ret_tv_same ? \" true\" : \"false\",\n              me.second.m_has_this ? \" true\" : \"false\",\n              all_same ? \" true\" : \"false\",\n              member_count\n             );\n    }\n    fprintf(stderr, \"writeStats end\\n\");\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 565,
        "code": "TfLiteStatus MaxEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      MaxEvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n      MaxEvalQuantizedUInt8<kernel_type>(context, node, params, data, input,\n                                         output);\n      break;\n    case kTfLiteInt8:\n      MaxEvalQuantizedInt8<kernel_type>(context, node, params, data, input,\n                                        output);\n      break;\n    case kTfLiteInt16:\n      MaxEvalQuantizedInt16<kernel_type>(context, node, params, data, input,\n                                         output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 566,
        "code": "static bool php_openssl_validate_iv(\n    String piv,\n    int iv_required_len,\n    String& out,\n    EVP_CIPHER_CTX* cipher_ctx,\n    const php_openssl_cipher_mode* mode) {\n  if (cipher_ctx == nullptr || mode == nullptr) {\n    return false;\n  }\n\n  /* Best case scenario, user behaved */\n  if (piv.size() == iv_required_len) {\n    out = std::move(piv);\n    return true;\n  }\n\n  if (mode->is_aead) {\n    if (EVP_CIPHER_CTX_ctrl(\n            cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) {\n      raise_warning(\n          \"Setting of IV length for AEAD mode failed, the expected length is \"\n          \"%d bytes\",\n          iv_required_len);\n      return false;\n    }\n    out = std::move(piv);\n    return true;\n  }\n\n  String s = String(iv_required_len, ReserveString);\n  char* iv_new = s.mutableData();\n  memset(iv_new, 0, iv_required_len);\n\n  if (piv.size() <= 0) {\n    /* BC behavior */\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  if (piv.size() < iv_required_len) {\n    raise_warning(\"IV passed is only %d bytes long, cipher \"\n                  \"expects an IV of precisely %d bytes, padding with \\\\0\",\n                  piv.size(), iv_required_len);\n    memcpy(iv_new, piv.data(), piv.size());\n    s.setSize(iv_required_len);\n    out = std::move(s);\n    return true;\n  }\n\n  raise_warning(\"IV passed is %d bytes long which is longer than the %d \"\n                \"expected by selected cipher, truncating\", piv.size(),\n                iv_required_len);\n  memcpy(iv_new, piv.data(), iv_required_len);\n  s.setSize(iv_required_len);\n  out = std::move(s);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 567,
        "code": "\n\n\n            case M_DQT:\n\n                // Use for jpeg quality guessing\n\n                process_DQT(Data, itemlen);\n\n                break;\n\n\n\n            case M_DHT:   \n\n                // Use for jpeg quality guessing\n\n                process_DHT(Data, itemlen);\n\n                break;\n\n\n\n\n\n            case M_EOI:   // in case it's a tables-only JPEG stream\n\n                fprintf(stderr,\"No image in jpeg!\\n\");\n\n                return FALSE;\n\n\n\n            case M_COM: // Comment section\n\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\n\n                    // Discard this section.\n\n                    free(Sections[--SectionsRead].Data);\n\n                }else{\n\n                    process_COM(Data, itemlen);\n\n                    HaveCom = TRUE;\n\n                }\n\n                break;\n\n\n\n            case M_JFIF:\n\n                // Regular jpegs always have this tag, exif images have the exif\n\n                // marker instead, althogh ACDsee will write images with both markers.\n\n                // this program will re-create this marker on absence of exif marker.\n\n                // hence no need to keep the copy from the file.\n\n                if (itemlen < 16){\n\n                    fprintf(stderr,\"Jfif header too short\\n\");\n\n                    goto ignore;\n\n                }\n\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26208"
    },
    {
        "index": 568,
        "code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  /* number of arguments */\n  int nextra = actual - nfixparams;  /* number of extra arguments */\n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  /* copy function to the top of the stack */\n  setobjs2s(L, L->top++, ci->func);\n  /* move fixed parameters to the top of the stack */\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  /* erase original parameter (for GC) */\n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 569,
        "code": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    case kTfLiteInt8:\n      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,\n                                            output);\n      break;\n    case kTfLiteInt16:\n      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 570,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_24CompressedBufferedReader___init__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_CompressedBufferedReader *__pyx_v_self, PyObject *__pyx_v_read_block, PyObject *__pyx_v_bufsize) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":198\n * \n *     def __init__(self, read_block, bufsize):\n *         self.read_block = read_block             # <<<<<<<<<<<<<<\n *         super(CompressedBufferedReader, self).__init__(bufsize)\n * \n */\n  __Pyx_INCREF(__pyx_v_read_block);\n  __Pyx_GIVEREF(__pyx_v_read_block);\n  __Pyx_GOTREF(__pyx_v_self->read_block);\n  __Pyx_DECREF(__pyx_v_self->read_block);\n  __pyx_v_self->read_block = __pyx_v_read_block;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":199\n *     def __init__(self, read_block, bufsize):\n *         self.read_block = read_block\n *         super(CompressedBufferedReader, self).__init__(bufsize)             # <<<<<<<<<<<<<<\n * \n *     def read_into_buffer(self):\n */\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 199, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader));\n  __Pyx_GIVEREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_CompressedBufferedReader));\n  __Pyx_INCREF(((PyObject *)__pyx_v_self));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_self));\n  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 199, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_bufsize) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_bufsize);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":197\n *     cdef object read_block\n * \n *     def __init__(self, read_block, bufsize):             # <<<<<<<<<<<<<<\n *         self.read_block = read_block\n *         super(CompressedBufferedReader, self).__init__(bufsize)\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.CompressedBufferedReader.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 571,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const auto params =\n      static_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_MSG(context, input->type == filter->type,\n                     \"Hybrid models are not supported on TFLite Micro.\");\n\n  return CalculateOpData(context, params->activation, input->type, input,\n                         filter, bias, output, data);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 572,
        "code": "  void writeStats(Array& /*ret*/) override {\n    fprintf(stderr, \"writeStats start\\n\");\n    // RetSame: the return value is the same instance every time\n    // HasThis: call has a this argument\n    // AllSame: all returns were the same data even though args are different\n    // MemberCount: number of different arg sets (including this)\n    fprintf(stderr, \"Count Function MinSerLen MaxSerLen RetSame HasThis \"\n            \"AllSame MemberCount\\n\");\n    for (auto& me : m_memos) {\n      if (me.second.m_ignore) continue;\n      if (me.second.m_count == 1) continue;\n      int min_ser_len = 999999999;\n      int max_ser_len = 0;\n      int count = 0;\n      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),\n              min_ser_len, max_ser_len,\n              me.second.m_ret_tv_same ? \" true\" : \"false\",\n              me.second.m_has_this ? \" true\" : \"false\",\n              all_same ? \" true\" : \"false\",\n              member_count\n             );\n    }\n    fprintf(stderr, \"writeStats end\\n\");\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 573,
        "code": "static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\"Invalid HTTP content [%d]\", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content-type[%s]\", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-44108"
    },
    {
        "index": 574,
        "code": "static int __Pyx_modinit_function_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_function_import_code\", 0);\n  /*--- Function import code ---*/\n  __Pyx_RefNannyFinishContext();\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 575,
        "code": "bool MemFile::seek(int64_t offset, int whence /* = SEEK_SET */) {\n  assertx(m_len != -1);\n  if (whence == SEEK_CUR) {\n    if (offset > 0 && offset < bufferedLen()) {\n      setReadPosition(getReadPosition() + offset);\n      setPosition(getPosition() + offset);\n      return true;\n    }\n    offset += getPosition();\n    whence = SEEK_SET;\n  }\n\n  // invalidate the current buffer\n  setWritePosition(0);\n  setReadPosition(0);\n  if (whence == SEEK_SET) {\n    m_cursor = offset;\n  } else {\n    assertx(whence == SEEK_END);\n    m_cursor = m_len + offset;\n  }\n  setPosition(m_cursor);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 576,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_4__pyx_unpickle_CompressedBufferedWriter(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_v___pyx_PickleError = 0;\n  PyObject *__pyx_v___pyx_result = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_CompressedBufferedWriter\", 0);\n\n  /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x108d208:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)\n */\n  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x108d208) != 0);\n  if (__pyx_t_1) {\n\n    /* \"(tree fragment)\":5\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x108d208:\n *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedWriter.__new__(__pyx_type)\n */\n    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_n_s_PickleError);\n    __Pyx_GIVEREF(__pyx_n_s_PickleError);\n    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);\n    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_t_2);\n    __pyx_v___pyx_PickleError = __pyx_t_2;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":6\n *     if __pyx_checksum != 0x108d208:\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)             # <<<<<<<<<<<<<<\n *     __pyx_result = CompressedBufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:\n */\n    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x10, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_INCREF(__pyx_v___pyx_PickleError);\n    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_5)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_5);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);\n    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_Raise(__pyx_t_3, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __PYX_ERR(1, 6, __pyx_L1_error)\n\n    /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0x108d208:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)\n */\n  }\n\n  /* \"(tree fragment)\":7\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedWriter.__new__(__pyx_type)             # <<<<<<<<<<<<<<\n *     if __pyx_state is not None:\n *         __pyx_unpickle_CompressedBufferedWriter__set_state(<CompressedBufferedWriter> __pyx_result, __pyx_state)\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v___pyx_result = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_CompressedBufferedWriter__set_state(<CompressedBufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);\n  __pyx_t_6 = (__pyx_t_1 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":9\n *     __pyx_result = CompressedBufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:\n *         __pyx_unpickle_CompressedBufferedWriter__set_state(<CompressedBufferedWriter> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<\n *     return __pyx_result\n * cdef __pyx_unpickle_CompressedBufferedWriter__set_state(CompressedBufferedWriter __pyx_result, tuple __pyx_state):\n */\n    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)\n    __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_CompressedBufferedWriter__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedwriter_CompressedBufferedWriter *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0x108d208 = (buffer, buffer_size, compressor, position))\" % __pyx_checksum)\n *     __pyx_result = CompressedBufferedWriter.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_CompressedBufferedWriter__set_state(<CompressedBufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  }\n\n  /* \"(tree fragment)\":10\n *     if __pyx_state is not None:\n *         __pyx_unpickle_CompressedBufferedWriter__set_state(<CompressedBufferedWriter> __pyx_result, __pyx_state)\n *     return __pyx_result             # <<<<<<<<<<<<<<\n * cdef __pyx_unpickle_CompressedBufferedWriter__set_state(CompressedBufferedWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.compressor = __pyx_state[2]; __pyx_result.position = __pyx_state[3]\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v___pyx_result);\n  __pyx_r = __pyx_v___pyx_result;\n  goto __pyx_L0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_CompressedBufferedWriter(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_CompressedBufferedWriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v___pyx_PickleError);\n  __Pyx_XDECREF(__pyx_v___pyx_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 577,
        "code": "CallResult<bool> JSObject::putComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() &&\n      \"mustExist flag cannot be used with computed properties\");\n\n  // Try the fast-path first: has \"index-like\" properties, the \"name\"\n  // already is a valid integer index, selfHandle and receiver are the\n  // same, and it is present in storage.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {\n        if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n          auto result =\n              setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);\n          if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_LIKELY(*result))\n            return true;\n          if (opFlags.getThrowOnError()) {\n            // TODO: better message.\n            return runtime->raiseTypeError(\n                \"Cannot assign to read-only property\");\n          }\n          return false;\n        }\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      if (LLVM_UNLIKELY(\n              setComputedSlotValue(selfHandle, runtime, desc, valueHandle) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    // Is it an accessor?\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor = vmcast<PropertyAccessor>(\n          getComputedSlotValue(propObj.get(), runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeErrorForValue(\n              \"Cannot assign to property \",\n              nameValPrimitiveHandle,\n              \" which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              valueHandle.get()) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n      if (key == ExecutionStatus::EXCEPTION)\n        return ExecutionStatus::EXCEPTION;\n      CallResult<bool> setRes =\n          JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy trap returned false for property\"));\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        SymbolID id{};\n        LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(id));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeErrorForValue(\n            \"Cannot assign to read-only property \", nameValPrimitiveHandle, \"\");\n      }\n      return false;\n    }\n\n    if (selfHandle == propObj && desc.flags.internalSetter) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      return internalSetter(\n          selfHandle,\n          runtime,\n          id,\n          desc.castToNamedPropertyDescriptorRef(),\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n    CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n        receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);\n    if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    DefinePropertyFlags dpf;\n    if (*descDefinedRes) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      if (LLVM_LIKELY(\n              !desc.flags.internalSetter && !receiverHandle->isHostObject() &&\n              !receiverHandle->isProxyObject())) {\n        if (LLVM_UNLIKELY(\n                setComputedSlotValue(\n                    receiverHandle, runtime, desc, valueHandle) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        return true;\n      }\n    }\n\n    if (LLVM_UNLIKELY(\n            desc.flags.internalSetter || receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      if (desc.flags.internalSetter) {\n        return internalSetter(\n            receiverHandle,\n            runtime,\n            id,\n            desc.castToNamedPropertyDescriptorRef(),\n            valueHandle,\n            opFlags);\n      } else if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n      }\n      assert(\n          receiverHandle->isProxyObject() && \"descriptor flags are impossible\");\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle,\n          runtime,\n          nameValPrimitiveHandle,\n          dpf,\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  /// Can we add more properties?\n  if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // If we have indexed storage we must check whether the property is an index,\n  // and if it is, store it in indexed storage.\n  if (receiverHandle->flags_.indexedStorage) {\n    OptValue<uint32_t> arrayIndex;\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n    if (arrayIndex) {\n      // Check whether we need to update array's \".length\" property.\n      if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {\n        if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {\n          auto cr = putNamed_RJS(\n              receiverHandle,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime->makeHandle(\n                  HermesValue::encodeNumberValue(*arrayIndex + 1)),\n              opFlags);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_UNLIKELY(!*cr))\n            return false;\n        }\n      }\n\n      auto result =\n          setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (LLVM_LIKELY(*result))\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\"Cannot assign to read-only property\");\n      }\n      return false;\n    }\n  }\n\n  SymbolID id{};\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Add a new named property.\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      id,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1915"
    },
    {
        "index": 578,
        "code": "inline TfLiteStatus EvalImpl(TfLiteContext* context, TfLiteNode* node,\n                             std::function<T(T)> func,\n                             TfLiteType expected_type) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, expected_type);\n  const int64_t num_elements = NumElements(input);\n  const T* in_data = GetTensorData<T>(input);\n  T* out_data = GetTensorData<T>(output);\n  for (int64_t i = 0; i < num_elements; ++i) {\n    out_data[i] = func(in_data[i]);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 579,
        "code": "Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 580,
        "code": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 581,
        "code": "ga_init(garray_T *gap)\n{\n    gap->ga_data = NULL;\n    gap->ga_maxlen = 0;\n    gap->ga_len = 0;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 582,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedwriter_3__pyx_unpickle_BufferedSocketWriter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v___pyx_type = 0;\n  long __pyx_v___pyx_checksum;\n  PyObject *__pyx_v___pyx_state = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedSocketWriter (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedSocketWriter\", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedSocketWriter\", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__pyx_unpickle_BufferedSocketWriter\") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v___pyx_type = values[0];\n    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)\n    __pyx_v___pyx_state = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedSocketWriter\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedSocketWriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter_2__pyx_unpickle_BufferedSocketWriter(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 583,
        "code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37649"
    },
    {
        "index": 584,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMfccParams*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input_wav = GetInput(context, node, kInputTensorWav);\n  const TfLiteTensor* input_rate = GetInput(context, node, kInputTensorRate);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_wav), 3);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_rate), 1);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_wav->type, output->type);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_rate->type, kTfLiteInt32);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(3);\n  output_size->data[0] = input_wav->dims->data[0];\n  output_size->data[1] = input_wav->dims->data[1];\n  output_size->data[2] = params->dct_coefficient_count;\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 585,
        "code": "__Pyx_PyMODINIT_FUNC initvarint(void)\n#else\n__Pyx_PyMODINIT_FUNC PyInit_varint(void) CYTHON_SMALL_CODE; /*proto*/\n__Pyx_PyMODINIT_FUNC PyInit_varint(void)\n#if CYTHON_PEP489_MULTI_PHASE_INIT\n{\n  return PyModuleDef_Init(&__pyx_moduledef);\n}\nstatic CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {\n    #if PY_VERSION_HEX >= 0x030700A1\n    static PY_INT64_T main_interpreter_id = -1;\n    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);\n    if (main_interpreter_id == -1) {\n        main_interpreter_id = current_id;\n        return (unlikely(current_id == -1)) ? -1 : 0;\n    } else if (unlikely(main_interpreter_id != current_id))\n    #else\n    static PyInterpreterState *main_interpreter = NULL;\n    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;\n    if (!main_interpreter) {\n        main_interpreter = current_interpreter;\n    } else if (unlikely(main_interpreter != current_interpreter))\n    #endif\n    {\n        PyErr_SetString(\n            PyExc_ImportError,\n            \"Interpreter change detected - this module can only be loaded into one interpreter per process.\");\n        return -1;\n    }\n    return 0;\n}\nstatic CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {\n    PyObject *value = PyObject_GetAttrString(spec, from_name);\n    int result = 0;\n    if (likely(value)) {\n        if (allow_none || value != Py_None) {\n            result = PyDict_SetItemString(moddict, to_name, value);\n        }\n        Py_DECREF(value);\n    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {\n        PyErr_Clear();\n    } else {\n        result = -1;\n    }\n    return result;\n}\nstatic CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {\n    PyObject *module = NULL, *moddict, *modname;\n    if (__Pyx_check_single_interpreter())\n        return NULL;\n    if (__pyx_m)\n        return __Pyx_NewRef(__pyx_m);\n    modname = PyObject_GetAttrString(spec, \"name\");\n    if (unlikely(!modname)) goto bad;\n    module = PyModule_NewObject(modname);\n    Py_DECREF(modname);\n    if (unlikely(!module)) goto bad;\n    moddict = PyModule_GetDict(module);\n    if (unlikely(!moddict)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"loader\", \"__loader__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"origin\", \"__file__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"parent\", \"__package__\", 1) < 0)) goto bad;\n    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, \"submodule_search_locations\", \"__path__\", 0) < 0)) goto bad;\n    return module;\nbad:\n    Py_XDECREF(module);\n    return NULL;\n}\n\n\nstatic CYTHON_SMALL_CODE int __pyx_pymod_exec_varint(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'varint' has already been imported. Re-initialisation is not supported.\");\n    return -1;\n  }\n  #elif PY_MAJOR_VERSION >= 3\n  if (__pyx_m) return __Pyx_NewRef(__pyx_m);\n  #endif\n  #if CYTHON_REFNANNY\n__Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"refnanny\");\nif (!__Pyx_RefNanny) {\n  PyErr_Clear();\n  __Pyx_RefNanny = __Pyx_RefNannyImportAPI(\"Cython.Runtime.refnanny\");\n  if (!__Pyx_RefNanny)\n      Py_FatalError(\"failed to import 'refnanny' module\");\n}\n#endif\n  __Pyx_RefNannySetupContext(\"__Pyx_PyMODINIT_FUNC PyInit_varint(void)\", 0);\n  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pxy_PyFrame_Initialize_Offsets\n  __Pxy_PyFrame_Initialize_Offsets();\n  #endif\n  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_bytes = PyBytes_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __pyx_empty_unicode = PyUnicode_FromStringAndSize(\"\", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #ifdef __Pyx_CyFunction_USED\n  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_FusedFunction_USED\n  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Coroutine_USED\n  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_Generator_USED\n  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_AsyncGen_USED\n  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  #ifdef __Pyx_StopAsyncIteration_USED\n  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  /*--- Library function declarations ---*/\n  /*--- Threads initialization code ---*/\n  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS\n  #ifdef WITH_THREAD /* Python build with threading support? */\n  PyEval_InitThreads();\n  #endif\n  #endif\n  /*--- Module creation code ---*/\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  __pyx_m = __pyx_pyinit_module;\n  Py_INCREF(__pyx_m);\n  #else\n  #if PY_MAJOR_VERSION < 3\n  __pyx_m = Py_InitModule4(\"varint\", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);\n  #else\n  __pyx_m = PyModule_Create(&__pyx_moduledef);\n  #endif\n  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_d);\n  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_b);\n  __pyx_cython_runtime = PyImport_AddModule((char *) \"cython_runtime\"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)\n  Py_INCREF(__pyx_cython_runtime);\n  if (PyObject_SetAttrString(__pyx_m, \"__builtins__\", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);\n  /*--- Initialize various global constants etc. ---*/\n  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)\n  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n  if (__pyx_module_is_main_clickhouse_driver__varint) {\n    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  }\n  #if PY_MAJOR_VERSION >= 3\n  {\n    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)\n    if (!PyDict_GetItemString(modules, \"clickhouse_driver.varint\")) {\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.varint\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  /*--- Builtin init code ---*/\n  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;\n  /*--- Constants init code ---*/\n  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;\n  /*--- Global type/function init code ---*/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  (void)__Pyx_modinit_type_init_code();\n  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  /*--- Execution code ---*/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n\n  /* \"clickhouse_driver/varint.pyx\":4\n * \n * \n * def write_varint(Py_ssize_t number, buf):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Writes integer of variable length using LEB128.\n */\n  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_6varint_1write_varint, NULL, __pyx_n_s_clickhouse_driver_varint); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_write_varint, __pyx_t_1) < 0) __PYX_ERR(0, 4, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":29\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.\n */\n  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_6varint_3read_varint, NULL, __pyx_n_s_clickhouse_driver_varint); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_read_varint, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":1\n * from cpython cimport Py_INCREF, PyBytes_FromStringAndSize             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /*--- Wrapped vars code ---*/\n\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  if (__pyx_m) {\n    if (__pyx_d) {\n      __Pyx_AddTraceback(\"init clickhouse_driver.varint\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n    }\n    Py_CLEAR(__pyx_m);\n  } else if (!PyErr_Occurred()) {\n    PyErr_SetString(PyExc_ImportError, \"init clickhouse_driver.varint\");\n  }\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  return (__pyx_m != NULL) ? 0 : -1;\n  #elif PY_MAJOR_VERSION >= 3\n  return __pyx_m;\n  #else\n  return;\n  #endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 586,
        "code": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (!env->allow_ptr_leaks && !known && (smin_val < 0) != (smax_val < 0)) {\n\t\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\\n\",\n\t\t\t\toff_reg == dst_reg ? dst : src);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* fall-through */\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tdst_reg->raw = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tdst_reg->raw = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\t/* For unprivileged we require that resulting offset must be in bounds\n\t * in order to be able to sanitize access later on.\n\t */\n\tif (!env->allow_ptr_leaks) {\n\t\tif (dst_reg->type == PTR_TO_MAP_VALUE &&\n\t\t    check_map_access(env, dst, dst_reg->off, 1, false)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic of map value goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t} else if (dst_reg->type == PTR_TO_STACK &&\n\t\t\t   check_stack_access(env, dst_reg, dst_reg->off +\n\t\t\t\t\t      dst_reg->var_off.value, 1)) {\n\t\t\tverbose(env, \"R%d stack pointer arithmetic goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 587,
        "code": "prepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0240"
    },
    {
        "index": 589,
        "code": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 590,
        "code": "  void writeStats(Array& /*ret*/) override {\n    fprintf(stderr, \"writeStats start\\n\");\n    // RetSame: the return value is the same instance every time\n    // HasThis: call has a this argument\n    // AllSame: all returns were the same data even though args are different\n    // MemberCount: number of different arg sets (including this)\n    fprintf(stderr, \"Count Function MinSerLen MaxSerLen RetSame HasThis \"\n            \"AllSame MemberCount\\n\");\n    for (auto& me : m_memos) {\n      if (me.second.m_ignore) continue;\n      if (me.second.m_count == 1) continue;\n      int min_ser_len = 999999999;\n      int max_ser_len = 0;\n      int count = 0;\n      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),\n              min_ser_len, max_ser_len,\n              me.second.m_ret_tv_same ? \" true\" : \"false\",\n              me.second.m_has_this ? \" true\" : \"false\",\n              all_same ? \" true\" : \"false\",\n              member_count\n             );\n    }\n    fprintf(stderr, \"writeStats end\\n\");\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 591,
        "code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  // Create a top level function that will never be executed, because:\n  // 1. IRGen assumes the first function always has global scope\n  // 2. It serves as the root for dummy functions for lexical data\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n\n  // Save the top-level context, but ensure it doesn't outlive what it is\n  // pointing to.\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n\n  // We restore scoping information in two separate ways:\n  // 1. By adding them to ExternalScopes for resolution here\n  // 2. By adding dummy functions for lexical scoping debug info later\n  //\n  // Instruction selection determines the delta between the ExternalScope\n  // and the dummy function chain, so we add the ExternalScopes with\n  // positive depth.\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n\n  // If lazyData->closureAlias is specified, we must create an alias binding\n  // between originalName (which must be valid) and the variable identified by\n  // closureAlias.\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n\n    // NOTE: the closureAlias target must exist and must be a Variable.\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n\n    // Re-create the alias.\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1912"
    },
    {
        "index": 592,
        "code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n\n  uint32_t len = JSArray::getLength(*argArray);\n\n  bool isConstructor = args.getArgCount() == 2;\n\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1896"
    },
    {
        "index": 593,
        "code": "MONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n\n    return cursor;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 595,
        "code": "static Jsi_Interp* jsi_InterpNew(Jsi_Interp *parent, Jsi_Value *opts, Jsi_InterpOpts *iopts)\n{\n    Jsi_Interp* interp;\n    if (parent && parent->noSubInterps) {\n        interp = parent;\n        Jsi_LogError(\"subinterps disallowed\");\n        return NULL;\n    }\n    if (opts && parent && (Jsi_ValueIsObjType(parent, opts, JSI_OT_OBJECT)==0 ||\n        Jsi_TreeSize(opts->d.obj->tree)<=0))\n        opts = NULL;\n    interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp) + sizeof(jsi_Frame));\n    interp->framePtr = (jsi_Frame*)(((uchar*)interp)+sizeof(*interp));\n    if (!parent)\n        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;\n    else {\n        interp->maxInterpDepth = parent->maxInterpDepth;\n        interp->interpDepth = parent->interpDepth+1;\n        if (interp->interpDepth > interp->maxInterpDepth) {\n            Jsi_Free(interp);\n            interp = parent;\n            Jsi_LogError(\"exceeded max subinterp depth\");\n            return NULL;\n        }\n    }\n    interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;\n    interp->typeWarnMax = 50;\n    interp->subOpts.dblPrec = __DBL_DECIMAL_DIG__-1;\n    interp->subOpts.prompt = \"$ \";\n    interp->subOpts.prompt2 = \"> \";\n\n    int iocnt;\n    if (iopts) {\n        iopts->interp = interp;\n        interp->opts = *iopts;\n    }\n    interp->logOpts.file = 1;\n    interp->logOpts.func = 1;\n    interp->logOpts.Info = 1;\n    interp->logOpts.Warn = 1;\n    interp->logOpts.Error = 1;\n    int argc = interp->opts.argc;\n    char **argv = interp->opts.argv;\n    char *argv0 = (argv?argv[0]:NULL);\n    interp->parent = parent;\n    interp->topInterp = (parent == NULL ? interp: parent->topInterp);\n    if (jsiIntData.mainInterp == NULL)\n        jsiIntData.mainInterp = interp->topInterp;\n    interp->mainInterp = jsiIntData.mainInterp; // The first interps handles exit.\n    interp->memDebug = interp->opts.mem_debug;\n    if (parent) {\n        interp->dbPtr = parent->dbPtr;\n    } else {\n        interp->dbPtr = &interp->dbStatic;\n    }\n#ifdef JSI_MEM_DEBUG\n    if (!interp->dbPtr->valueDebugTbl) {\n        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    }\n#endif\n    if (parent) {\n        if (parent->pkgDirs)\n            interp->pkgDirs = Jsi_ValueDupJSON(interp, parent->pkgDirs);\n    } else {\n#ifdef JSI_PKG_DIRS\n        interp->pkgDirs = Jsi_StringSplit(interp, JSI_PKG_DIRS, \",\");\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n#endif\n    }\n#ifdef JSI_USE_COMPAT\n    interp->compat = JSI_USE_COMPAT;\n#endif\n#ifndef JSI_CONF_ARGS\n#define JSI_CONF_ARGS \"\"\n#endif\n    interp->confArgs = JSI_CONF_ARGS;\n    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--T\") == 0 || Jsi_Strcmp(aio, \"--C\") == 0 || Jsi_Strcmp(aio, \"--L\") == 0) {\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--F\") == 0 || Jsi_Strcmp(aio, \"--U\") == 0 || Jsi_Strcmp(aio, \"--V\") == 0) {\n            iocnt--;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\")) {\n            const char *aio2 = argv[iocnt+1];\n            if (!Jsi_Strncmp(\"memDebug:\", aio2, sizeof(\"memDebug\")))\n                interp->memDebug=strtol(aio2+sizeof(\"memDebug\"), NULL, 0);\n            else if (!Jsi_Strncmp(\"compat\", aio2, sizeof(\"compat\")))\n                interp->subOpts.compat=strtol(aio2+sizeof(\"compat\"), NULL, 0);\n            continue;\n        }\n        break;\n    }\n    SIGINIT(interp,INTERP);\n    interp->NullValue = Jsi_ValueNewNull(interp);\n    Jsi_IncrRefCount(interp, interp->NullValue);\n#ifdef __WIN32\n    Jsi_DString cwdStr;\n    Jsi_DSInit(&cwdStr);\n    interp->curDir = Jsi_Strdup(Jsi_GetCwd(interp, &cwdStr));\n    Jsi_DSFree(&cwdStr);\n#else\n    char buf[JSI_BUFSIZ];\n    interp->curDir = getcwd(buf, sizeof(buf));\n    interp->curDir = Jsi_Strdup(interp->curDir?interp->curDir:\".\");\n#endif\n    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);\n    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);\n    interp->cmdSpecTbl = Jsi_MapNew(interp, JSI_MAP_TREE, JSI_KEYS_STRING, freeCmdSpecTbl);\n    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);\n    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);\n    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);\n    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);\n    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);\n    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);\n    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_HashFree);\n    interp->loadTbl = (parent?parent->loadTbl:Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle));\n    interp->packageHash = Jsi_HashNew(interp, JSI_KEYS_STRING, packageHashFree);\n    interp->aliasHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_AliasFree);\n\n    interp->lockTimeout = -1;\n#ifdef JSI_LOCK_TIMEOUT\n    interp->lockTimeout JSI_LOCK_TIMEOUT;\n#endif\n#ifndef JSI_DO_UNLOCK\n#define JSI_DO_UNLOCK 1\n#endif\n    interp->subOpts.mutexUnlock = JSI_DO_UNLOCK;\n    Jsi_Map_Type mapType = JSI_MAP_HASH;\n#ifdef JSI_USE_MANY_STRKEY\n    mapType = JSI_MAP_TREE;\n#endif\n\n    if (interp == jsiIntData.mainInterp || interp->threadId != jsiIntData.mainInterp->threadId) {\n        interp->strKeyTbl = Jsi_MapNew(interp,  mapType, JSI_KEYS_STRING, NULL);\n        interp->subOpts.privKeys = 1;\n    }\n    // Handle interp options: -T value and -Ixxx value\n    for (iocnt = 1; (iocnt+1)<argc && !interp->parent; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--F\") == 0) {\n            interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--U\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--V\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 5;\n            interp->tracePuts = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--C\") == 0) {\n            if (interp->confFile)\n               Jsi_LogWarn(\"overriding confFile: %s\", interp->confFile);\n            interp->confFile = argv[iocnt+1];\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--L\") == 0) {\n            struct stat sb;\n            const char* path = argv[iocnt+1]; //TODO: convert to Jsi_Value first?\n            if (!path || stat(path, &sb)\n                || !((S_ISREG(sb.st_mode) && !access(path, W_OK)) || (S_ISDIR(sb.st_mode) && !access(path, X_OK)))) {\n                Jsi_LogError(\"Lockdown path must exist and be a writable file or executable dir: %s\", path);\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->isSafe = true;\n            interp->safeMode = jsi_safe_Lockdown;\n            if (interp->safeWriteDirs) {\n                Jsi_LogWarn(\"Overriding safeWriteDirs\");\n                Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            }\n            const char *vda[2] = {};\n            char npath[PATH_MAX];\n            vda[0] = Jsi_FileRealpathStr(interp, path, npath);\n            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda, 1);\n            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n            if (!interp->safeReadDirs) {\n                interp->safeReadDirs = interp->safeWriteDirs;\n                Jsi_IncrRefCount(interp, interp->safeReadDirs);\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--T\") == 0) {\n            if (jsi_ParseTypeCheckStr(interp, argv[iocnt+1]) != JSI_OK) {\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\"))  {\n            bool bv = 1;\n            char *aio2 = argv[iocnt+1], *aioc = Jsi_Strchr(aio2, ':'),\n                argNamS[50], *argNam = aio2;\n            const char *argVal;\n            if (!Jsi_Strcmp(\"traceCall\", aio2))\n                interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            else {\n                if (aioc) {\n                    argNam = argNamS;\n                    argVal = aioc+1;\n                    snprintf(argNamS, sizeof(argNamS), \"%.*s\", (int)(aioc-aio2), aio2);\n                }\n                \n                DECL_VALINIT(argV);\n                Jsi_Value *argValue = &argV;\n                Jsi_Number dv;\n                if (!aioc || Jsi_GetBool(interp, argVal, &bv) == JSI_OK) {\n                    Jsi_ValueMakeBool(interp, &argValue, bv);\n                } else if (!Jsi_Strcmp(\"null\", argVal)) {\n                    Jsi_ValueMakeNull(interp, &argValue);\n                } else if (Jsi_GetDouble(interp, argVal, &dv) == JSI_OK) {\n                    Jsi_ValueMakeNumber(interp, &argValue, dv);\n                } else {\n                    Jsi_ValueMakeStringKey(interp, &argValue, argVal);\n                }\n                if (JSI_OK != Jsi_OptionsSet(interp, InterpOptions, interp, argNam, argValue, 0)) {\n                    Jsi_InterpDelete(interp);\n                    return NULL;\n                }\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        break;\n    }\n    if (!interp->strKeyTbl)\n        interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n    if (opts) {\n        interp->inopts = opts = Jsi_ValueDupJSON(interp, opts);\n        if (Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0) {\n            Jsi_DecrRefCount(interp, opts);\n            interp->inopts = NULL;\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n    }\n    if (interp == jsiIntData.mainInterp) {\n        interp->subthread = 0;\n    } else {\n        if (opts) {\n            if (interp->subOpts.privKeys && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl) {\n                //Jsi_HashDelete(interp->strKeyTbl);\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                interp->strKeyTbl = Jsi_MapNew(interp, mapType, JSI_KEYS_STRING, NULL);\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            } else if (interp->subOpts.privKeys == 0 && interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl) {\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                Jsi_MapDelete(interp->strKeyTbl);\n                interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            }\n        }\n        if (parent && parent->isSafe) {\n            interp->isSafe = 1;\n            interp->safeMode = parent->safeMode;\n        }\n        if (interp->subthread && interp->isSafe) {\n            interp->subthread = 0;\n            Jsi_LogError(\"threading disallowed in safe mode\");\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n        if (interp->subthread)\n            jsiIntData.mainInterp->threadCnt++;\n        if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n            jsiIntData.mainInterp->threadShrCnt++;\n        if (jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n            jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = KeyLockerTree;\n#else\n            jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = KeyLocker;\n#endif\n    }\n    if (parent && parent->isSafe) {\n        interp->isSafe = 1;\n        interp->safeMode = parent->safeMode;\n        interp->maxOpCnt = parent->maxOpCnt;\n        if (interp->safeWriteDirs || interp->safeReadDirs || interp->safeExecPattern) {\n            Jsi_LogWarn(\"ignoring safe* options in safe sub-sub-interp\");\n            if (interp->safeWriteDirs) Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            if (interp->safeReadDirs) Jsi_DecrRefCount(interp, interp->safeReadDirs);\n            interp->safeWriteDirs = interp->safeReadDirs = NULL;\n            interp->safeExecPattern = NULL;\n        }\n    }\n\n    jsi_InterpConfFiles(interp);\n    if (!interp->udata) {\n        interp->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, interp->udata);\n    }\n    if (interp->subthread && !interp->scriptStr && !interp->scriptFile) {\n        Jsi_LogError(\"subthread interp must be specify either scriptFile or scriptStr\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n#ifndef JSI_MEM_DEBUG\n    static int warnNoDebug = 0;\n    if (interp->memDebug && warnNoDebug == 0) {\n        Jsi_LogWarn(\"ignoring memDebug as jsi was compiled without memory debugging\");\n        warnNoDebug = 1;\n    }\n#endif\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->parent && interp->subthread==0 && interp->threadId != interp->parent->threadId) {\n        interp->threadId = interp->parent->threadId;\n#ifndef JSI_MEM_DEBUG\n        Jsi_LogWarn(\"non-threaded sub-interp created by different thread than parent\");\n#endif\n    }\n    if (interp->safeMode != jsi_safe_None)\n        interp->isSafe = interp->startSafe = 1;\n    if (!interp->parent) {\n        if (interp->isSafe)\n            interp->startSafe = 1;\n        if (interp->debugOpts.msgCallback)\n            Jsi_LogWarn(\"ignoring msgCallback\");\n        if (interp->debugOpts.putsCallback)\n            Jsi_LogWarn(\"ignoring putsCallback\");\n        if (interp->busyCallback)\n            Jsi_LogWarn(\"ignoring busyCallback\");\n        if (interp->debugOpts.traceCallback)\n            Jsi_LogWarn(\"ignoring traceCallback\");\n    } else if (interp->busyCallback && interp->threadId != interp->parent->threadId) {\n        Jsi_LogWarn(\"disabling busyCallback due to threads\");\n        interp->busyCallback = NULL;\n    }\n    if (interp == jsiIntData.mainInterp)\n        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    else\n        interp->lexkeyTbl = jsiIntData.mainInterp->lexkeyTbl;\n    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);\n    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);\n    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);\n    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);\n    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);\n#ifdef JSI_MEM_DEBUG\n    interp->codesTbl = (interp == jsiIntData.mainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiIntData.mainInterp->codesTbl);\n#endif\n    if (interp->typeCheck.all|interp->typeCheck.parse|interp->typeCheck.funcsig)\n        interp->staticFuncsTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->maxArrayList = MAX_ARRAY_LIST;\n    if (!jsiIntData.isInit) {\n        jsiIntData.isInit = 1;\n        jsi_InitValue(interp, 0);\n        jsiIntData.interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n    }\n\n    /* current scope, also global */\n    interp->csc = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));\n    interp->framePtr->incsc = interp->csc;\n\n#define JSIDOINIT(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n#define JSIDOINIT2(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (Jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n\n    JSIDOINIT(Proto);\n\n    if (interp->pkgDirs) // Fix-up because above, array was not yet initialized.\n        interp->pkgDirs->d.obj->__proto__ = interp->Array_prototype;\n\n    Jsi_Value *modObj = Jsi_ValueNewObj(interp, Jsi_ObjNewType(interp, JSI_OT_OBJECT));\n    Jsi_ValueInsert(interp, interp->csc, \"Jsi_Auto\", modObj, JSI_OM_DONTDEL);\n\n    /* initial scope chain, nothing */\n    interp->framePtr->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);\n\n    interp->ps = jsi_PstateNew(interp); /* Default parser. */\n    if (interp->unitTest&2) {\n        interp->logOpts.before = 1;\n        interp->logOpts.full = 1;\n        interp->tracePuts = 1;\n        interp->noStderr = 1;\n    }\n    if (interp->args && argc) {\n        Jsi_LogBug(\"args may not be specified both as options and parameter\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)\n        interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n\n    // Create the args array.\n    if (argc >= 0 && !interp->args) {\n        Jsi_Value *iargs = Jsi_ValueNew1(interp);\n        iargs->f.bits.dontdel = 1;\n        iargs->f.bits.readonly = 1;\n        Jsi_Obj *iobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);\n        int i = 1, ii = (iocnt>1 ? iocnt : 1);\n        int msiz = (argc?argc-iocnt:0);\n        Jsi_ObjArraySizer(interp, iobj, msiz);\n        iobj->arrMaxSize = msiz;\n        iocnt--;\n        iobj->arrCnt = argc-iocnt;\n        for (i = 1; ii < argc; ++ii, i++) {\n            iobj->arr[i-1] = Jsi_ValueNewStringKey(interp, argv[ii]);\n            Jsi_IncrRefCount(interp, iobj->arr[i-1]);\n            jsi_ValueDebugLabel(iobj->arr[i-1], \"InterpCreate\", \"args\");\n        }\n        Jsi_ObjSetLength(interp, iobj, msiz);\n        interp->args = iargs;\n    } else if (interp->parent && interp->args) {\n        // Avoid strings from sneeking in with options from parent...\n        Jsi_Value *nar = Jsi_ValueDupJSON(interp, interp->args);\n        Jsi_DecrRefCount(interp, interp->args);\n        interp->args = nar;\n    }\n    JSIDOINIT(Options);\n    JSIDOINIT(Cmds);\n    JSIDOINIT(Interp);\n    JSIDOINIT(JSON);\n\n    interp->retValue = Jsi_ValueNew1(interp);\n    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n    if (1 || interp->subthread) {\n        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_DSInit(&interp->interpEvalQ);\n    }\n    JSIDOINIT(Lexer);\n    if (interp != jsiIntData.mainInterp && !parent)\n        Jsi_HashSet(jsiIntData.interpsTbl, interp, NULL);\n\n    if (!interp->isSafe) {\n        JSIDOINIT(Load);\n#if JSI__SIGNAL==1\n        JSIDOINIT(Signal);\n#endif\n    }\n    if (interp->isSafe == 0 || interp->startSafe || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {\n#if JSI__FILESYS==1\n        JSIDOINIT(FileCmds);\n        JSIDOINIT(Filesys);\n#endif\n    }\n#if JSI__SQLITE==1\n    JSIDOINIT2(Sqlite);\n#else\n    Jsi_initSqlite(interp, 0);\n#endif\n#if JSI__MYSQL==1\n    if (!interp->noNetwork) {\n        JSIDOINIT2(MySql);\n    }\n#endif\n#if JSI__SOCKET==1\n    JSIDOINIT2(Socket);\n#endif\n#if JSI__WEBSOCKET==1\n    JSIDOINIT2(WebSocket);\n#endif\n\n#if JSI__CDATA==1\n    JSIDOINIT(CData);\n#endif\n\n#ifdef JSI_USER_EXTENSION\n    extern int JSI_USER_EXTENSION(Jsi_Interp *interp, int release);\n    if (JSI_USER_EXTENSION (interp, 0) != JSI_OK) {\n        fprintf(stderr, \"extension load failed\");\n        return jsi_DoExit(interp, 1);\n    }\n#endif\n    Jsi_PkgProvide(interp, \"Jsi\", JSI_VERSION, NULL);\n    if (argc > 0) {\n        char *ss = argv0;\n        char epath[PATH_MAX] = \"\"; // Path of executable\n#ifdef __WIN32\n\n        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)\n            ss = epath;\n#else\n#ifndef PROC_SELF_DIR\n#define PROC_SELF_DIR \"/proc/self/exe\"\n#endif\n        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath)) && epath[0])\n            ss = epath;\n#endif\n        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);\n        Jsi_IncrRefCount(interp, src);\n        jsiIntData.execName = Jsi_Realpath(interp, src, NULL);\n        Jsi_DecrRefCount(interp, src);\n        if (!jsiIntData.execName) jsiIntData.execName = Jsi_Strdup(\"\");\n        jsiIntData.execValue = Jsi_ValueNewString(interp, jsiIntData.execName, -1);\n        Jsi_IncrRefCount(interp, jsiIntData.execValue);\n        Jsi_HashSet(interp->genValueTbl, jsiIntData.execValue, jsiIntData.execValue);\n    }\n\n    //interp->nocacheOpCodes = 1;\n    if (interp->debugOpts.debugCallback && !interp->debugOpts.hook) {\n        interp->debugOpts.hook = jsi_InterpDebugHook;\n    }\n    interp->startTime = jsi_GetTimestamp();\n#ifdef JSI_INTERP_EXTENSION_CODE // For extending interp from jsi.c\n    JSI_INTERP_EXTENSION_CODE\n#endif\n    if (interp->opts.initProc && (*interp->opts.initProc)(interp, 0) != JSI_OK)\n        Jsi_LogBug(\"Init failure in initProc\");\n\n    return interp;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22874"
    },
    {
        "index": 596,
        "code": "void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    \n    int len = Jsi_ObjGetLength(interp, v->d.obj);\n    if (len <= 0) return;\n    \n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    \n    Jsi_ValueReset(interp, &v0);\n    \n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 597,
        "code": "static int exif_scan_thumbnail(image_info_type *ImageInfo) {\n  unsigned char c, *data = (unsigned char*)ImageInfo->Thumbnail.data;\n  int n, marker;\n  size_t length=2, pos=0;\n  jpeg_sof_info sof_info;\n\n  if (!data || ImageInfo->Thumbnail.size < 4) {\n    return 0; /* nothing to do here */\n  }\n  if (memcmp(data, \"\\xFF\\xD8\\xFF\", 3)) {\n    if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {\n      raise_warning(\"Thumbnail is not a JPEG image\");\n    }\n    return 0;\n  }\n  for (;;) {\n    pos += length;\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    c = data[pos++];\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    if (c != 0xFF) {\n      return 0;\n    }\n    n = 8;\n    while ((c = data[pos++]) == 0xFF && n--) {\n      if (pos+3>=ImageInfo->Thumbnail.size)\n        return 0;\n      /* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n    }\n    if (c == 0xFF)\n      return 0;\n    marker = c;\n    length = php_jpg_get16(data+pos);\n    if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {\n      return 0;\n    }\n    switch (marker) {\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        /* handle SOFn block */\n        if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {\n          /* exif_process_SOFn needs 8 bytes */\n          return 0;\n        }\n        exif_process_SOFn(data+pos, marker, &sof_info);\n        ImageInfo->Thumbnail.height   = sof_info.height;\n        ImageInfo->Thumbnail.width    = sof_info.width;\n        return 1;\n\n      case M_SOS:\n      case M_EOI:\n        raise_warning(\"Could not compute size of thumbnail\");\n        return 0;\n        break;\n\n      default:\n        /* just skip */\n        break;\n    }\n  }\n\n  raise_warning(\"Could not compute size of thumbnail\");\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 598,
        "code": "static int exif_scan_thumbnail(image_info_type *ImageInfo) {\n  unsigned char c, *data = (unsigned char*)ImageInfo->Thumbnail.data;\n  int n, marker;\n  size_t length=2, pos=0;\n  jpeg_sof_info sof_info;\n\n  if (!data || ImageInfo->Thumbnail.size < 4) {\n    return 0; /* nothing to do here */\n  }\n  if (memcmp(data, \"\\xFF\\xD8\\xFF\", 3)) {\n    if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {\n      raise_warning(\"Thumbnail is not a JPEG image\");\n    }\n    return 0;\n  }\n  for (;;) {\n    pos += length;\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    c = data[pos++];\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    if (c != 0xFF) {\n      return 0;\n    }\n    n = 8;\n    while ((c = data[pos++]) == 0xFF && n--) {\n      if (pos+3>=ImageInfo->Thumbnail.size)\n        return 0;\n      /* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n    }\n    if (c == 0xFF)\n      return 0;\n    marker = c;\n    length = php_jpg_get16(data+pos);\n    if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {\n      return 0;\n    }\n    switch (marker) {\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        /* handle SOFn block */\n        if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {\n          /* exif_process_SOFn needs 8 bytes */\n          return 0;\n        }\n        exif_process_SOFn(data+pos, marker, &sof_info);\n        ImageInfo->Thumbnail.height   = sof_info.height;\n        ImageInfo->Thumbnail.width    = sof_info.width;\n        return 1;\n\n      case M_SOS:\n      case M_EOI:\n        raise_warning(\"Could not compute size of thumbnail\");\n        return 0;\n        break;\n\n      default:\n        /* just skip */\n        break;\n    }\n  }\n\n  raise_warning(\"Could not compute size of thumbnail\");\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 599,
        "code": "static PyObject *__pyx_pw_17clickhouse_driver_14bufferedwriter_1__pyx_unpickle_BufferedWriter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_v___pyx_type = 0;\n  long __pyx_v___pyx_checksum;\n  PyObject *__pyx_v___pyx_state = 0;\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedWriter (wrapper)\", 0);\n  {\n    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};\n    PyObject* values[3] = {0,0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n        CYTHON_FALLTHROUGH;\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        CYTHON_FALLTHROUGH;\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        CYTHON_FALLTHROUGH;\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        CYTHON_FALLTHROUGH;\n        case  1:\n        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedWriter\", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n        CYTHON_FALLTHROUGH;\n        case  2:\n        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedWriter\", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"__pyx_unpickle_BufferedWriter\") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);\n    }\n    __pyx_v___pyx_type = values[0];\n    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)\n    __pyx_v___pyx_state = values[2];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__pyx_unpickle_BufferedWriter\", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedWriter\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __pyx_r = __pyx_pf_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedWriter(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 600,
        "code": "static PyObject* patch(PyObject* self, PyObject* args)\n{\n    char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n    Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n    PyObject *controlTuples, *tuple, *results;\n    off_t oldpos, newpos, x, y, z;\n    int i, j, numTuples;\n\n    if (!PyArg_ParseTuple(args, \"s#nO!s#s#\",\n                          &origData, &origDataLength, &newDataLength,\n                          &PyList_Type, &controlTuples,\n                          &diffBlock, &diffBlockLength,\n                          &extraBlock, &extraBlockLength))\n        return NULL;\n\n    /* allocate the memory for the new data */\n    newData = PyMem_Malloc(newDataLength + 1);\n    if (!newData)\n        return PyErr_NoMemory();\n\n    oldpos = 0;\n    newpos = 0;\n    diffPtr = diffBlock;\n    extraPtr = extraBlock;\n    numTuples = PyList_GET_SIZE(controlTuples);\n    for (i = 0; i < numTuples; i++) {\n        tuple = PyList_GET_ITEM(controlTuples, i);\n        if (!PyTuple_Check(tuple)) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple\");\n            return NULL;\n        }\n        if (PyTuple_GET_SIZE(tuple) != 3) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple of size 3\");\n            return NULL;\n        }\n        x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n        y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n        z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n        if (newpos + x > newDataLength ||\n                diffPtr + x > diffBlock + diffBlockLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, diffPtr, x);\n        diffPtr += x;\n        for (j = 0; j < x; j++)\n            if ((oldpos + j >= 0) && (oldpos + j < origDataLength))\n                newData[newpos + j] += origData[oldpos + j];\n        newpos += x;\n        oldpos += x;\n        memcpy(newData + newpos, extraPtr, y);\n        extraPtr += y;\n        newpos += y;\n        oldpos += z;\n    }\n\n    /* confirm that a valid patch was applied */\n    if (newpos != newDataLength ||\n            diffPtr != diffBlock + diffBlockLength ||\n            extraPtr != extraBlock + extraBlockLength) {\n        PyMem_Free(newData);\n        PyErr_SetString(PyExc_ValueError, \"corrupt patch (underflow)\");\n        return NULL;\n    }\n\n    results = PyBytes_FromStringAndSize(newData, newDataLength);\n    PyMem_Free(newData);\n    return results;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15904"
    },
    {
        "index": 601,
        "code": "TfLiteStatus EvalLogic(TfLiteContext* context, TfLiteNode* node,\n                       OpContext* op_context, T init_value,\n                       T reducer(const T current, const T in)) {\n  int64_t num_axis = NumElements(op_context->axis);\n  TfLiteTensor* temp_index = GetTemporary(context, node, /*index=*/0);\n  TfLiteTensor* resolved_axis = GetTemporary(context, node, /*index=*/1);\n  // Resize the output tensor if the output tensor is dynamic.\n  if (IsDynamicTensor(op_context->output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeTempAxis(context, op_context, resolved_axis));\n    TF_LITE_ENSURE_OK(context, ResizeOutputTensor(context, op_context));\n  }\n  if (op_context->input->type == kTfLiteUInt8 ||\n      op_context->input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, op_context->input->params.scale,\n                      op_context->output->params.scale);\n    TF_LITE_ENSURE_EQ(context, op_context->input->params.zero_point,\n                      op_context->output->params.zero_point);\n  }\n  TF_LITE_ENSURE(\n      context,\n      reference_ops::ReduceGeneric<T>(\n          GetTensorData<T>(op_context->input), op_context->input->dims->data,\n          op_context->input->dims->size, GetTensorData<T>(op_context->output),\n          op_context->output->dims->data, op_context->output->dims->size,\n          GetTensorData<int>(op_context->axis), num_axis,\n          op_context->params->keep_dims, GetTensorData<int>(temp_index),\n          GetTensorData<int>(resolved_axis), init_value, reducer));\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 602,
        "code": "void RenderFrameHostImpl::RegisterMojoInterfaces() {\n#if !defined(OS_ANDROID)\n  registry_->AddInterface(base::Bind(&InstalledAppProviderImplDefault::Create));\n#endif  // !defined(OS_ANDROID)\n\n  PermissionControllerImpl* permission_controller =\n      PermissionControllerImpl::FromBrowserContext(\n          GetProcess()->GetBrowserContext());\n  if (delegate_) {\n    auto* geolocation_context = delegate_->GetGeolocationContext();\n    if (geolocation_context) {\n      geolocation_service_.reset(new GeolocationServiceImpl(\n          geolocation_context, permission_controller, this));\n      registry_->AddInterface(\n          base::Bind(&GeolocationServiceImpl::Bind,\n                     base::Unretained(geolocation_service_.get())));\n    }\n  }\n\n  registry_->AddInterface<device::mojom::WakeLock>(base::Bind(\n      &RenderFrameHostImpl::BindWakeLockRequest, base::Unretained(this)));\n\n#if defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebNfc)) {\n    registry_->AddInterface<device::mojom::NFC>(base::Bind(\n        &RenderFrameHostImpl::BindNFCRequest, base::Unretained(this)));\n  }\n#endif\n\n  if (!permission_service_context_)\n    permission_service_context_.reset(new PermissionServiceContext(this));\n\n  registry_->AddInterface(\n      base::Bind(&PermissionServiceContext::CreateService,\n                 base::Unretained(permission_service_context_.get())));\n\n  registry_->AddInterface(\n      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::Bind(&MediaSessionServiceImpl::Create, base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(\n      base::IgnoreResult(&RenderFrameHostImpl::CreateWebBluetoothService),\n      base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateWebUsbService, base::Unretained(this)));\n\n  registry_->AddInterface<media::mojom::InterfaceFactory>(\n      base::Bind(&RenderFrameHostImpl::BindMediaInterfaceFactoryRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateWebSocket, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateDedicatedWorkerHostFactory,\n      base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&SharedWorkerConnectorImpl::Create,\n                                     process_->GetID(), routing_id_));\n\n  registry_->AddInterface(base::BindRepeating(&device::GamepadMonitor::Create));\n\n  registry_->AddInterface<device::mojom::VRService>(base::Bind(\n      &WebvrServiceProvider::BindWebvrService, base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::BindRepeating(&RenderFrameHostImpl::CreateAudioInputStreamFactory,\n                          base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::BindRepeating(&RenderFrameHostImpl::CreateAudioOutputStreamFactory,\n                          base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::Bind(&CreateFrameResourceCoordinator, base::Unretained(this)));\n\n  if (BrowserMainLoop::GetInstance()) {\n    MediaStreamManager* media_stream_manager =\n        BrowserMainLoop::GetInstance()->media_stream_manager();\n    registry_->AddInterface(\n        base::Bind(&MediaDevicesDispatcherHost::Create, GetProcess()->GetID(),\n                   GetRoutingID(), base::Unretained(media_stream_manager)),\n         base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n \n     registry_->AddInterface(\n        base::BindRepeating(\n            &RenderFrameHostImpl::CreateMediaStreamDispatcherHost,\n            base::Unretained(this), base::Unretained(media_stream_manager)),\n         base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n   }\n \n#if BUILDFLAG(ENABLE_MEDIA_REMOTING)\n  registry_->AddInterface(base::Bind(&RemoterFactoryImpl::Bind,\n                                     GetProcess()->GetID(), GetRoutingID()));\n#endif  // BUILDFLAG(ENABLE_MEDIA_REMOTING)\n\n  registry_->AddInterface(base::BindRepeating(\n      &KeyboardLockServiceImpl::CreateMojoService, base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&ImageCaptureImpl::Create));\n\n#if !defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebAuth)) {\n    registry_->AddInterface(\n        base::Bind(&RenderFrameHostImpl::BindAuthenticatorRequest,\n                   base::Unretained(this)));\n    if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n            switches::kEnableWebAuthTestingAPI)) {\n      auto* environment_singleton =\n          ScopedVirtualAuthenticatorEnvironment::GetInstance();\n      registry_->AddInterface(base::BindRepeating(\n          &ScopedVirtualAuthenticatorEnvironment::AddBinding,\n          base::Unretained(environment_singleton)));\n    }\n  }\n#endif  // !defined(OS_ANDROID)\n\n  sensor_provider_proxy_.reset(\n      new SensorProviderProxyImpl(permission_controller, this));\n  registry_->AddInterface(\n      base::Bind(&SensorProviderProxyImpl::Bind,\n                 base::Unretained(sensor_provider_proxy_.get())));\n\n  media::VideoDecodePerfHistory::SaveCallback save_stats_cb;\n  if (GetSiteInstance()->GetBrowserContext()->GetVideoDecodePerfHistory()) {\n    save_stats_cb = GetSiteInstance()\n                        ->GetBrowserContext()\n                        ->GetVideoDecodePerfHistory()\n                        ->GetSaveCallback();\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &media::MediaMetricsProvider::Create, frame_tree_node_->IsMainFrame(),\n      base::BindRepeating(\n          &RenderFrameHostDelegate::GetUkmSourceIdForLastCommittedSource,\n          base::Unretained(delegate_)),\n      std::move(save_stats_cb)));\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          cc::switches::kEnableGpuBenchmarking)) {\n    registry_->AddInterface(\n        base::Bind(&InputInjectorImpl::Create, weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &QuotaDispatcherHost::CreateForFrame, GetProcess(), routing_id_));\n\n  registry_->AddInterface(\n      base::BindRepeating(SpeechRecognitionDispatcherHost::Create,\n                          GetProcess()->GetID(), routing_id_),\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n\n  file_system_manager_.reset(new FileSystemManagerImpl(\n      GetProcess()->GetID(), routing_id_,\n      GetProcess()->GetStoragePartition()->GetFileSystemContext(),\n      ChromeBlobStorageContext::GetFor(GetProcess()->GetBrowserContext())));\n  registry_->AddInterface(\n      base::BindRepeating(&FileSystemManagerImpl::BindRequest,\n                          base::Unretained(file_system_manager_.get())),\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));\n\n  if (Portal::IsEnabled()) {\n    registry_->AddInterface(base::BindRepeating(IgnoreResult(&Portal::Create),\n                                                base::Unretained(this)));\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &BackgroundFetchServiceImpl::CreateForFrame, GetProcess(), routing_id_));\n\n  registry_->AddInterface(base::BindRepeating(&ContactsManagerImpl::Create));\n\n  registry_->AddInterface(\n      base::BindRepeating(&FileChooserImpl::Create, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(&AudioContextManagerImpl::Create,\n                                              base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(&WakeLockServiceImpl::Create,\n                                              base::Unretained(this)));\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 603,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* axis_tensor = GetInput(context, node, kAxisTensor);\n  int axis = GetTensorData<int32_t>(axis_tensor)[0];\n  const int rank = NumDimensions(input);\n  if (axis < 0) {\n    axis += rank;\n  }\n\n  TF_LITE_ENSURE(context, axis >= 0 && axis < rank);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      reference_ops::Reverse<float>(\n          axis, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(output), GetTensorData<float>(output));\n      break;\n    }\n    case kTfLiteUInt8: {\n      reference_ops::Reverse<uint8_t>(\n          axis, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(output), GetTensorData<uint8_t>(output));\n      break;\n    }\n    case kTfLiteInt16: {\n      reference_ops::Reverse<int16_t>(\n          axis, GetTensorShape(input), GetTensorData<int16_t>(input),\n          GetTensorShape(output), GetTensorData<int16_t>(output));\n      break;\n    }\n    case kTfLiteInt32: {\n      reference_ops::Reverse<int32_t>(\n          axis, GetTensorShape(input), GetTensorData<int32_t>(input),\n          GetTensorShape(output), GetTensorData<int32_t>(output));\n      break;\n    }\n    case kTfLiteInt64: {\n      reference_ops::Reverse<int64_t>(\n          axis, GetTensorShape(input), GetTensorData<int64_t>(input),\n          GetTensorShape(output), GetTensorData<int64_t>(output));\n      break;\n    }\n    case kTfLiteBool: {\n      reference_ops::Reverse<bool>(\n          axis, GetTensorShape(input), GetTensorData<bool>(input),\n          GetTensorShape(output), GetTensorData<bool>(output));\n      break;\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by reverse.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 604,
        "code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\n\tif (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\n\t/* If we arrived here from different branches with different\n\t * limits to sanitize, then this won't work.\n\t */\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\n\t/* Corresponding fixup done in fixup_bpf_calls(). */\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\ndo_sim:\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 605,
        "code": "void RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \"elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-37639"
    },
    {
        "index": 606,
        "code": "Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 607,
        "code": "MONGO_EXPORT int bson_append_new_oid( bson *b, const char *name ) {\n    bson_oid_t oid;\n    bson_oid_gen( &oid );\n    return bson_append_oid( b, name, &oid );\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-12135"
    },
    {
        "index": 609,
        "code": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-1031"
    },
    {
        "index": 610,
        "code": "GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)\n{\n\tGF_Err e;\n\tu32 i, descIndex, duration;\n\tu64 ts;\n\tu8 PadBits;\n\tGF_Fraction ft;\n\tGF_ISOSample *samp;\n\n\ttkHint->HintSample = tkHint->RTPTime = 0;\n\n\ttkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);\n\tft.num = tkHint->rtp_p->sl_config.timestampResolution;\n\tft.den = tkHint->OrigTimeScale;\n\n\te = GF_OK;\n\tfor (i=0; i<tkHint->TotalSample; i++) {\n\t\tsamp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);\n\t\tif (!samp) return gf_isom_last_error(tkHint->file);\n\n\t\t//setup SL\n\t\ttkHint->CurrentSample = i + 1;\n\n\t\t/*keep same AU indicator if sync shadow - TODO FIXME: this assumes shadows are placed interleaved with\n\t\tthe track content which is the case for GPAC scene carousel generation, but may not always be true*/\n\t\tif (samp->IsRAP==RAP_REDUNDANT) {\n\t\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;\n\t\t\tsamp->IsRAP = RAP;\n\t\t}\n\n\t\tts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;\n\t\ttkHint->rtp_p->sl_header.compositionTimeStamp = ts;\n\n\t\tts = ft.num * samp->DTS / ft.den;\n\t\ttkHint->rtp_p->sl_header.decodingTimeStamp = ts;\n\t\ttkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;\n\n\t\ttkHint->base_offset_in_sample = 0;\n\t\t/*crypted*/\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tGF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);\n\t\t\t/*one byte take for selective_enc flag*/\n\t\t\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;\n\t\t\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;\n\t\t\tgf_free(samp->data);\n\t\t\tsamp->data = s->data;\n\t\t\tsamp->dataLength = s->dataLength;\n\t\t\tgf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);\n\t\t\ts->data = NULL;\n\t\t\ts->dataLength = 0;\n\t\t\tgf_isom_ismacryp_delete_sample(s);\n\t\t}\n\n\t\tif (tkHint->rtp_p->sl_config.usePaddingFlag) {\n\t\t\tgf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = PadBits;\n\t\t} else {\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = 0;\n\t\t}\n\n\t\tduration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);\n//\t\tts = (u32) (ft * (s64) (duration));\n\n\t\t/*unpack nal units*/\n\t\tif (tkHint->avc_nalu_size) {\n\t\t\tu32 v, size;\n\t\t\tu32 remain = samp->dataLength;\n\t\t\tchar *ptr = samp->data;\n\n\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 1;\n\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = 0;\n\t\t\twhile (remain) {\n\t\t\t\tsize = 0;\n\t\t\t\tv = tkHint->avc_nalu_size;\n\t\t\t\tif (v>remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (v) {\n\t\t\t\t\tsize |= (u8) *ptr;\n\t\t\t\t\tptr++;\n\t\t\t\t\tremain--;\n\t\t\t\t\tv-=1;\n\t\t\t\t\tif (v) size<<=8;\n\t\t\t\t}\n\t\t\t\ttkHint->base_offset_in_sample = samp->dataLength-remain;\n\t\t\t\tif (remain < size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tremain -= size;\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;\n\t\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t\t\tptr += size;\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 0;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t}\n\t\ttkHint->rtp_p->sl_header.packetSequenceNumber += 1;\n\n\t\t//signal some progress\n\t\tgf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);\n\n\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber += 1;\n\t\tgf_isom_sample_del(&samp);\n\n\t\tif (e) return e;\n\t}\n\n\t//flush\n\tgf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);\n\n\tgf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);\n\treturn GF_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-35979"
    },
    {
        "index": 611,
        "code": "static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,\n\t\t\t      u32 *ptr_limit, u8 opcode, bool off_is_neg)\n{\n\tbool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||\n\t\t\t    (opcode == BPF_SUB && !off_is_neg);\n\tu32 off;\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_STACK:\n\t\toff = ptr_reg->off + ptr_reg->var_off.value;\n\t\tif (mask_to_left)\n\t\t\t*ptr_limit = MAX_BPF_STACK + off;\n\t\telse\n\t\t\t*ptr_limit = -off;\n\t\treturn 0;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (mask_to_left) {\n\t\t\t*ptr_limit = ptr_reg->umax_value + ptr_reg->off;\n\t\t} else {\n\t\t\toff = ptr_reg->smin_value + ptr_reg->off;\n\t\t\t*ptr_limit = ptr_reg->map_ptr->value_size - off;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 612,
        "code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[100];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 613,
        "code": "static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n{\n  register char *s = nullptr;\n  char *q;\n  int s_len;\n\n  register int min_width = 0;\n  int precision = 0;\n  enum {\n    LEFT, RIGHT\n  } adjust;\n  char pad_char;\n  char prefix_char;\n\n  double fp_num;\n  wide_int i_num = (wide_int) 0;\n  u_wide_int ui_num;\n\n  char num_buf[NUM_BUF_SIZE];\n  char char_buf[2];      /* for printing %% and %<unknown> */\n\n#ifdef HAVE_LOCALE_H\n  struct lconv *lconv = nullptr;\n#endif\n\n  /*\n   * Flag variables\n   */\n  length_modifier_e modifier;\n  boolean_e alternate_form;\n  boolean_e print_sign;\n  boolean_e print_blank;\n  boolean_e adjust_precision;\n  boolean_e adjust_width;\n  int is_negative;\n\n  int size = 240;\n  char *result = (char *)malloc(size);\n  int outpos = 0;\n\n  while (*fmt) {\n    if (*fmt != '%') {\n      appendchar(&result, &outpos, &size, *fmt);\n    } else {\n      /*\n       * Default variable settings\n       */\n      adjust = RIGHT;\n      alternate_form = print_sign = print_blank = NO;\n      pad_char = ' ';\n      prefix_char = NUL;\n\n      fmt++;\n\n      /*\n       * Try to avoid checking for flags, width or precision\n       */\n      if (isascii((int)*fmt) && !islower((int)*fmt)) {\n        /*\n         * Recognize flags: -, #, BLANK, +\n         */\n        for (;; fmt++) {\n          if (*fmt == '-')\n            adjust = LEFT;\n          else if (*fmt == '+')\n            print_sign = YES;\n          else if (*fmt == '#')\n            alternate_form = YES;\n          else if (*fmt == ' ')\n            print_blank = YES;\n          else if (*fmt == '0')\n            pad_char = '0';\n          else\n            break;\n        }\n\n        /*\n         * Check if a width was specified\n         */\n        if (isdigit((int)*fmt)) {\n          STR_TO_DEC(fmt, min_width);\n          adjust_width = YES;\n        } else if (*fmt == '*') {\n          min_width = va_arg(ap, int);\n          fmt++;\n          adjust_width = YES;\n          if (min_width < 0) {\n            adjust = LEFT;\n            min_width = -min_width;\n          }\n        } else\n          adjust_width = NO;\n\n        /*\n         * Check if a precision was specified\n         *\n         * XXX: an unreasonable amount of precision may be specified\n         * resulting in overflow of num_buf. Currently we\n         * ignore this possibility.\n         */\n        if (*fmt == '.') {\n          adjust_precision = YES;\n          fmt++;\n          if (isdigit((int)*fmt)) {\n            STR_TO_DEC(fmt, precision);\n          } else if (*fmt == '*') {\n            precision = va_arg(ap, int);\n            fmt++;\n            if (precision < 0)\n              precision = 0;\n          } else\n            precision = 0;\n        } else\n          adjust_precision = NO;\n      } else\n        adjust_precision = adjust_width = NO;\n\n      /*\n       * Modifier check\n       */\n      switch (*fmt) {\n        case 'L':\n          fmt++;\n          modifier = LM_LONG_DOUBLE;\n          break;\n        case 'I':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == '6' && *(fmt+1) == '4') {\n            fmt += 2;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            if (*fmt == '3' && *(fmt+1) == '2') {\n              fmt += 2;\n              modifier = LM_LONG;\n            } else {\n#ifdef _WIN64\n              modifier = LM_LONG_LONG;\n#else\n              modifier = LM_LONG;\n#endif\n            }\n          break;\n        case 'l':\n          fmt++;\n#if SIZEOF_LONG_LONG\n          if (*fmt == 'l') {\n            fmt++;\n            modifier = LM_LONG_LONG;\n          } else\n#endif\n            modifier = LM_LONG;\n          break;\n        case 'z':\n          fmt++;\n          modifier = LM_SIZE_T;\n          break;\n        case 'j':\n          fmt++;\n#if SIZEOF_INTMAX_T\n          modifier = LM_INTMAX_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 't':\n          fmt++;\n#if SIZEOF_PTRDIFF_T\n          modifier = LM_PTRDIFF_T;\n#else\n          modifier = LM_SIZE_T;\n#endif\n          break;\n        case 'h':\n          fmt++;\n          if (*fmt == 'h') {\n            fmt++;\n          }\n          /* these are promoted to int, so no break */\n        default:\n          modifier = LM_STD;\n          break;\n      }\n\n      /*\n       * Argument extraction and printing.\n       * First we determine the argument type.\n       * Then, we convert the argument to a string.\n       * On exit from the switch, s points to the string that\n       * must be printed, s_len has the length of the string\n       * The precision requirements, if any, are reflected in s_len.\n       *\n       * NOTE: pad_char may be set to '0' because of the 0 flag.\n       *   It is reset to ' ' by non-numeric formats\n       */\n      switch (*fmt) {\n        case 'u':\n          switch(modifier) {\n            default:\n              i_num = (wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              i_num = (wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              i_num = (wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              i_num = (wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              i_num = (wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              i_num = (wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          /*\n           * The rest also applies to other integer formats, so fall\n           * into that case.\n           */\n        case 'd':\n        case 'i':\n          /*\n           * Get the arg if we haven't already.\n           */\n          if ((*fmt) != 'u') {\n            switch(modifier) {\n              default:\n                i_num = (wide_int) va_arg(ap, int);\n                break;\n              case LM_LONG_DOUBLE:\n                goto fmt_error;\n              case LM_LONG:\n                i_num = (wide_int) va_arg(ap, long int);\n                break;\n              case LM_SIZE_T:\n#if SIZEOF_SSIZE_T\n                i_num = (wide_int) va_arg(ap, ssize_t);\n#else\n                i_num = (wide_int) va_arg(ap, size_t);\n#endif\n                break;\n#if SIZEOF_LONG_LONG\n              case LM_LONG_LONG:\n                i_num = (wide_int) va_arg(ap, wide_int);\n                break;\n#endif\n#if SIZEOF_INTMAX_T\n              case LM_INTMAX_T:\n                i_num = (wide_int) va_arg(ap, intmax_t);\n                break;\n#endif\n#if SIZEOF_PTRDIFF_T\n              case LM_PTRDIFF_T:\n                i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                break;\n#endif\n            }\n          }\n          s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n\n          if (*fmt != 'u') {\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'o':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 3, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && *s != '0') {\n            *--s = '0';\n            s_len++;\n          }\n          break;\n\n\n        case 'x':\n        case 'X':\n          switch(modifier) {\n            default:\n              ui_num = (u_wide_int) va_arg(ap, unsigned int);\n              break;\n            case LM_LONG_DOUBLE:\n              goto fmt_error;\n            case LM_LONG:\n              ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n              break;\n            case LM_SIZE_T:\n              ui_num = (u_wide_int) va_arg(ap, size_t);\n              break;\n#if SIZEOF_LONG_LONG\n            case LM_LONG_LONG:\n              ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n              break;\n#endif\n#if SIZEOF_INTMAX_T\n            case LM_INTMAX_T:\n              ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n              break;\n#endif\n#if SIZEOF_PTRDIFF_T\n            case LM_PTRDIFF_T:\n              ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n              break;\n#endif\n          }\n          s = ap_php_conv_p2(ui_num, 4, *fmt,\n                &num_buf[NUM_BUF_SIZE], &s_len);\n          FIX_PRECISION(adjust_precision, precision, s, s_len);\n          if (alternate_form && i_num != 0) {\n            *--s = *fmt;  /* 'x' or 'X' */\n            *--s = '0';\n            s_len += 2;\n          }\n          break;\n\n\n        case 's':\n        case 'v':\n          s = va_arg(ap, char *);\n          if (s != nullptr) {\n            s_len = strlen(s);\n            if (adjust_precision && precision < s_len)\n              s_len = precision;\n          } else {\n            s = const_cast<char*>(s_null);\n            s_len = S_NULL_LEN;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case 'f':\n        case 'F':\n        case 'e':\n        case 'E':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n            s = const_cast<char*>(\"nan\");\n            s_len = 3;\n          } else if (std::isinf(fp_num)) {\n            s = const_cast<char*>(\"inf\");\n            s_len = 3;\n          } else {\n#ifdef HAVE_LOCALE_H\n            if (!lconv) {\n              lconv = localeconv();\n            }\n#endif\n            s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n             (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n             (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                  &is_negative, &num_buf[1], &s_len);\n            if (is_negative)\n              prefix_char = '-';\n            else if (print_sign)\n              prefix_char = '+';\n            else if (print_blank)\n              prefix_char = ' ';\n          }\n          break;\n\n\n        case 'g':\n        case 'k':\n        case 'G':\n        case 'H':\n          switch(modifier) {\n            case LM_LONG_DOUBLE:\n              fp_num = (double) va_arg(ap, long double);\n              break;\n            case LM_STD:\n              fp_num = va_arg(ap, double);\n              break;\n            default:\n              goto fmt_error;\n          }\n\n          if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"NAN\");\n             s_len = 3;\n             break;\n           } else if (std::isinf(fp_num)) {\n             if (fp_num > 0) {\n               s = const_cast<char*>(\"INF\");\n               s_len = 3;\n             } else {\n               s = const_cast<char*>(\"-INF\");\n               s_len = 4;\n             }\n             break;\n           }\n\n          if (adjust_precision == NO)\n            precision = FLOAT_DIGITS;\n          else if (precision == 0)\n            precision = 1;\n          /*\n           * * We use &num_buf[ 1 ], so that we have room for the sign\n           */\n#ifdef HAVE_LOCALE_H\n          if (!lconv) {\n            lconv = localeconv();\n          }\n#endif\n          s = php_gcvt(fp_num, precision,\n                       (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                       (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n          if (*s == '-')\n            prefix_char = *s++;\n          else if (print_sign)\n            prefix_char = '+';\n          else if (print_blank)\n            prefix_char = ' ';\n\n          s_len = strlen(s);\n\n          if (alternate_form && (q = strchr(s, '.')) == nullptr)\n            s[s_len++] = '.';\n          break;\n\n\n        case 'c':\n          char_buf[0] = (char) (va_arg(ap, int));\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case '%':\n          char_buf[0] = '%';\n          s = &char_buf[0];\n          s_len = 1;\n          pad_char = ' ';\n          break;\n\n\n        case 'n':\n          *(va_arg(ap, int *)) = outpos;\n          goto skip_output;\n\n          /*\n           * Always extract the argument as a \"char *\" pointer. We\n           * should be using \"void *\" but there are still machines\n           * that don't understand it.\n           * If the pointer size is equal to the size of an unsigned\n           * integer we convert the pointer to a hex number, otherwise\n           * we print \"%p\" to indicate that we don't handle \"%p\".\n           */\n        case 'p':\n          if (sizeof(char *) <= sizeof(u_wide_int)) {\n            ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n            s = ap_php_conv_p2(ui_num, 4, 'x',\n                &num_buf[NUM_BUF_SIZE], &s_len);\n            if (ui_num != 0) {\n              *--s = 'x';\n              *--s = '0';\n              s_len += 2;\n            }\n          } else {\n            s = const_cast<char*>(\"%p\");\n            s_len = 2;\n          }\n          pad_char = ' ';\n          break;\n\n\n        case NUL:\n          /*\n           * The last character of the format string was %.\n           * We ignore it.\n           */\n          continue;\n\n\nfmt_error:\n        throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n\n          /*\n           * The default case is for unrecognized %'s.\n           * We print %<char> to help the user identify what\n           * option is not understood.\n           * This is also useful in case the user wants to pass\n           * the output of format_converter to another function\n           * that understands some other %<char> (like syslog).\n           * Note that we can't point s inside fmt because the\n           * unknown <char> could be preceded by width etc.\n           */\n        default:\n          char_buf[0] = '%';\n          char_buf[1] = *fmt;\n          s = char_buf;\n          s_len = 2;\n          pad_char = ' ';\n          break;\n      }\n\n      if (prefix_char != NUL) {\n        *--s = prefix_char;\n        s_len++;\n      }\n      if (adjust_width && adjust == RIGHT && min_width > s_len) {\n        if (pad_char == '0' && prefix_char != NUL) {\n          appendchar(&result, &outpos, &size, *s);\n          s++;\n          s_len--;\n          min_width--;\n        }\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n      /*\n       * Print the (for now) non-null terminated string s.\n       */\n      appendsimplestring(&result, &outpos, &size, s, s_len);\n\n      if (adjust_width && adjust == LEFT && min_width > s_len) {\n        for (int i = 0; i < min_width - s_len; i++) {\n          appendchar(&result, &outpos, &size, pad_char);\n        }\n      }\n    }\nskip_output:\n    fmt++;\n  }\n  /*\n   * Add the terminating null here since it wasn't added incrementally above\n   * once the whole string has been composed.\n   */\n  result[outpos] = NUL;\n  *outbuf = result;\n  return outpos;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 614,
        "code": "Jsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    int len;\n    Jsi_ValueReset(interp, ret);\n    Jsi_Value *v = jsi_ValueLookupBase(interp, target, key, ret);\n    if (v)\n        return v;\n    const char *keyStr = Jsi_ValueString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    // Special cases such as \"length\", \"constructor\", etc...\n    if (Jsi_Strcmp(keyStr,\"length\")==0) {\n        if (Jsi_ValueIsString(interp, target)) {\n            len = Jsi_ValueStrlen(target);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist) {\n            len = target->d.obj->arrCnt;\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n            Jsi_Func *fo = target->d.obj->d.fobj->func;\n            if (fo->type == FC_NORMAL)\n                len = fo->argnames->count;\n            else\n                len = fo->cmdSpec->maxArgs, len = (len>=0?len:fo->cmdSpec->minArgs);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->tree) {\n            len = target->d.obj->tree->numEntries;\n        } else {\n            return NULL;\n        }\n        (*ret)->vt = JSI_VT_NUMBER;\n        (*ret)->d.num = (Jsi_Number)len;\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && (interp->subOpts.noproto==0 && Jsi_Strcmp(keyStr,\"constructor\")==0)) {\n        const char *cp;\n        Jsi_Obj *o = target->d.obj->constructor;\n        if (o) {\n            if (o->ot == JSI_OT_FUNCTION) {\n                Jsi_Value *proto = Jsi_TreeObjGetValue(o, \"prototype\", 0);\n                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {\n                    o = proto->d.obj->constructor;\n                }\n            }\n        } else {\n            switch(target->d.obj->ot) {\n                case JSI_OT_NUMBER:\n                    cp = \"Number\";\n                    break;\n                case JSI_OT_BOOL:\n                    cp = \"Boolean\";\n                    break;\n                case JSI_OT_STRING:\n                    cp = \"String\";\n                    break;\n                case JSI_OT_REGEXP:\n                    cp = \"RegExp\";\n                    break;\n                case JSI_OT_OBJECT:\n                    if (target->d.obj->isarrlist) {\n                        cp = \"Array\";\n                        break;\n                    }\n                    cp = \"Object\";\n                    break;\n                default:\n                    Jsi_ValueMakeUndef(interp, ret);\n                    return *ret;\n            }\n            v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);\n            if (v==NULL || v->vt != JSI_VT_OBJECT)\n                return NULL;\n            o = target->d.obj->constructor = v->d.obj;\n        }\n        Jsi_ValueMakeObject(interp, ret, o);\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n        /* Looking up something like \"String.substr\" */\n        Jsi_Func* func = target->d.obj->d.fobj->func;\n        if (func->type == FC_BUILDIN) {\n            if (func->f.bits.iscons && func->name) {\n                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);\n                if (!v) {\n                } else {\n                    bool ooo = interp->subOpts.noproto;\n                    interp->subOpts.noproto = 0;\n                    v = Jsi_ValueObjLookup(interp, v, \"prototype\", 0);\n                    interp->subOpts.noproto = ooo;\n                    \n                    if (v && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {\n                        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && Jsi_Strcmp(func->name,\"Interp\")) {\n                            Jsi_Func* sfunc = v->d.obj->d.fobj->func;\n                            /* Handle \"Math.pow(2,3)\", \"String.fromCharCode(0x21)\", ... */\n                            sfunc->callflags.bits.addargs = 1;\n                        }\n                        return v;\n                    }\n                }\n            }\n            if (Jsi_ValueIsString(interp, key)) {\n                char *kstr = Jsi_ValueString(interp, key, NULL);\n                if (!Jsi_Strcmp(kstr,\"call\") || !Jsi_Strcmp(kstr,\"apply\") || !Jsi_Strcmp(kstr,\"bind\")) {\n                    char fbuf[100];\n                    snprintf(fbuf, sizeof(fbuf), \"Function.%s\", kstr);\n                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);\n                    if (vv)\n                        return vv;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 615,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n  OpData* op_data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kInputLayerNormCoefficientsTensor);\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kForgetLayerNormCoefficientsTensor);\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kCellLayerNormCoefficientsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, kForgetGateBiasTensor);\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, kCellGateBiasTensor);\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, kOutputGateBiasTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(context, node, kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      // Index the scratch buffers pointers to the global scratch buffer.\n      TfLiteTensor* scratch_buffer = GetTemporary(context, node, 0);\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n          cell_to_input_weights, cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*aux_input_to_forget_weights=*/nullptr,\n          /*aux_input_to_cell_weights=*/nullptr,\n          /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n          forget_gate_bias, cell_gate_bias, output_gate_bias,\n          projection_weights, projection_bias, params,\n          /*forward_sequence=*/true,\n          /*time_major=*/true,\n          /*output_offset=*/0, scratch_buffer, output_state, cell_state,\n          output);\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      const bool is_hybrid = (input->type == kTfLiteFloat32);\n      const bool is_sparse = input_to_output_weights->sparsity != nullptr;\n      if (is_hybrid) {\n        TfLiteTensor* row_sums = GetTemporary(context, node, kRowSums);\n        const int row_sums_size = row_sums->dims->data[0];\n        if (is_sparse) {\n          TfLiteTensor* input_to_input_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToInputWeightsLedgerOffset];\n          TfLiteTensor* input_to_forget_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToForgetWeightsLedgerOffset];\n          TfLiteTensor* input_to_cell_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToCellWeightsLedgerOffset];\n          TfLiteTensor* input_to_output_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToOutputWeightsLedgerOffset];\n          TfLiteTensor* recurrent_to_input_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kRecurrentToInputWeightsLedgerOffset];\n          TfLiteTensor* recurrent_to_forget_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kRecurrentToForgetWeightsLedgerOffset];\n          TfLiteTensor* recurrent_to_cell_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kRecurrentToCellWeightsLedgerOffset];\n          TfLiteTensor* recurrent_to_output_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kRecurrentToOutputWeightsLedgerOffset];\n          TfLiteTensor* projection_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kProjectionWeightsLedgerOffset];\n          if (!op_data->ledger_initialized) {\n            copy_ledger(input_to_input_weights == nullptr\n                            ? nullptr\n                            : input_to_input_weights->sparsity,\n                        input_to_input_weights_ledger);\n            copy_ledger(input_to_forget_weights->sparsity,\n                        input_to_forget_weights_ledger);\n            copy_ledger(input_to_cell_weights->sparsity,\n                        input_to_cell_weights_ledger);\n            copy_ledger(input_to_output_weights->sparsity,\n                        input_to_output_weights_ledger);\n            copy_ledger(recurrent_to_input_weights == nullptr\n                            ? nullptr\n                            : recurrent_to_input_weights->sparsity,\n                        recurrent_to_input_weights_ledger);\n            copy_ledger(recurrent_to_forget_weights->sparsity,\n                        recurrent_to_forget_weights_ledger);\n            copy_ledger(recurrent_to_cell_weights->sparsity,\n                        recurrent_to_cell_weights_ledger);\n            copy_ledger(recurrent_to_output_weights->sparsity,\n                        recurrent_to_output_weights_ledger);\n            copy_ledger(projection_weights->sparsity,\n                        projection_weights_ledger);\n            op_data->ledger_initialized = true;\n          }\n          return lstm_eval::EvalHybrid(\n              input, input_to_input_weights, input_to_input_weights_ledger,\n              input_to_forget_weights, input_to_forget_weights_ledger,\n              input_to_cell_weights, input_to_cell_weights_ledger,\n              input_to_output_weights, input_to_output_weights_ledger,\n              recurrent_to_input_weights, recurrent_to_input_weights_ledger,\n              recurrent_to_forget_weights, recurrent_to_forget_weights_ledger,\n              recurrent_to_cell_weights, recurrent_to_cell_weights_ledger,\n              recurrent_to_output_weights, recurrent_to_output_weights_ledger,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients,\n              /*aux_input=*/nullptr,\n              /*aux_input_to_input_weights=*/nullptr,\n              /*aux_input_to_forget_weights=*/nullptr,\n              /*aux_input_to_cell_weights=*/nullptr,\n              /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n              forget_gate_bias, cell_gate_bias, output_gate_bias,\n              projection_weights, projection_weights_ledger, projection_bias,\n              params,\n              /*forward_sequence=*/true, /*time_major=*/true,\n              /*output_offset=*/0, GetTemporary(context, node, kScratchBuffer),\n              GetTemporary(context, node, kInputScalingFactors),\n              /*aux_input_sf=*/nullptr,\n              GetTemporary(context, node, kOutputStateScalingFactors),\n              GetTemporary(context, node, kProductScalingFactors),\n              GetTemporary(context, node, kRecoveredCellWeights),\n              GetTemporary(context, node, kInputQuantized),\n              /*aux_input_quantized=*/nullptr,\n              GetTemporary(context, node, kOutputStateQuantized),\n              GetTemporary(context, node, kCellStateQuantized), output_state,\n              cell_state, GetTemporary(context, node, kAccumScratch), output,\n              GetTemporary(context, node, kInputZeroPoints),\n              /*aux_input_zp=*/nullptr,\n              GetTemporary(context, node, kOutputStateZeroPoints), row_sums,\n              row_sums_size, &op_data->compute_row_sums,\n              CpuBackendContext::GetFromContext(context));\n        }\n        return lstm_eval::EvalHybrid(\n            input, input_to_input_weights,\n            /*input_to_input_weights_ledger*/ nullptr, input_to_forget_weights,\n            /*input_to_forget_weights_ledger*/ nullptr, input_to_cell_weights,\n            /*input_to_cell_weights_ledger*/ nullptr, input_to_output_weights,\n            /*input_to_output_weights_ledger*/ nullptr,\n            recurrent_to_input_weights,\n            /*recurrent_to_input_weights_ledger*/ nullptr,\n            recurrent_to_forget_weights,\n            /*recurrent_to_forget_weights_ledger*/ nullptr,\n            recurrent_to_cell_weights,\n            /*recurrent_to_cell_weights_ledger*/ nullptr,\n            recurrent_to_output_weights,\n            /*recurrent_to_output_weights_ledger*/ nullptr,\n            cell_to_input_weights, cell_to_forget_weights,\n            cell_to_output_weights, input_layer_norm_coefficients,\n            forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n            output_layer_norm_coefficients, /*aux_input=*/nullptr,\n            /*aux_input_to_input_weights=*/nullptr,\n            /*aux_input_to_forget_weights=*/nullptr,\n            /*aux_input_to_cell_weights=*/nullptr,\n            /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n            forget_gate_bias, cell_gate_bias, output_gate_bias,\n            projection_weights, /*projection_weights_ledger*/ nullptr,\n            projection_bias, params,\n            /*forward_sequence=*/true, /*time_major=*/true, /*output_offset=*/0,\n            GetTemporary(context, node, kScratchBuffer),\n            GetTemporary(context, node, kInputScalingFactors),\n            /*aux_input_sf=*/nullptr,\n            GetTemporary(context, node, kOutputStateScalingFactors),\n            GetTemporary(context, node, kProductScalingFactors),\n            GetTemporary(context, node, kRecoveredCellWeights),\n            GetTemporary(context, node, kInputQuantized),\n            /*aux_input_quantized=*/nullptr,\n            GetTemporary(context, node, kOutputStateQuantized),\n            GetTemporary(context, node, kCellStateQuantized), output_state,\n            cell_state, GetTemporary(context, node, kAccumScratch), output,\n            GetTemporary(context, node, kInputZeroPoints),\n            /*aux_input_zp=*/nullptr,\n            GetTemporary(context, node, kOutputStateZeroPoints), row_sums,\n            row_sums_size, &op_data->compute_row_sums,\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        const int num_intermediate_tensors = node->intermediates->size;\n        if (num_intermediate_tensors == 5) {\n          TfLiteTensor* scratch0 = GetTemporary(context, node, 0);\n          TfLiteTensor* scratch1 = GetTemporary(context, node, 1);\n          TfLiteTensor* scratch2 = GetTemporary(context, node, 2);\n          TfLiteTensor* scratch3 = GetTemporary(context, node, 3);\n          TfLiteTensor* scratch4 = GetTemporary(context, node, 4);\n          TfLiteTensor* scratch5 = GetTemporary(context, node, 5);\n          return lstm_eval::EvalInteger8x8_16(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients, input_gate_bias, forget_gate_bias,\n              cell_gate_bias, output_gate_bias, projection_weights,\n              projection_bias, params, &op_data->integer_lstm_param,\n              output_state, cell_state, output, scratch0, scratch1, scratch2,\n              scratch3, scratch4, scratch5,\n              CpuBackendContext::GetFromContext(context));\n        } else {\n          TfLiteTensor* scratch0 = GetTemporary(context, node, 0);\n          TfLiteTensor* scratch1 = GetTemporary(context, node, 1);\n          TfLiteTensor* scratch2 = GetTemporary(context, node, 2);\n          TfLiteTensor* scratch3 = GetTemporary(context, node, 3);\n          TfLiteTensor* scratch4 = GetTemporary(context, node, 4);\n          TfLiteTensor* scratch5 = GetTemporary(context, node, 5);\n          TfLiteTensor* scratch6 = GetTemporary(context, node, 6);\n          TfLiteTensor* scratch7 = GetTemporary(context, node, 7);\n          return lstm_eval::EvalInteger8x8_8(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients, input_gate_bias, forget_gate_bias,\n              cell_gate_bias, output_gate_bias, projection_weights,\n              projection_bias, params, output_state, cell_state, output,\n              &op_data->integer_lstm_param, scratch0, scratch1, scratch2,\n              scratch3, scratch4, scratch5, scratch6, scratch7);\n          return kTfLiteOk;\n        }\n      }\n    }\n    default:\n      context->ReportError(context, \"Type %d is not currently supported.\",\n                           input_to_output_weights->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 616,
        "code": "define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_no_bang_allowed));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname(e_invalid_argument_str, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,\n\t\t    NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(e_cannot_use_g_here));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(e_closure_function_should_not_be_at_top_level,\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_characters_str), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_dictionary_entry_already_exists));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(e_function_name_conflicts_with_variable_str, name);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_dictionary_entry_already_exists));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(e_function_name_does_not_match_script_file_name_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 617,
        "code": "void luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15888"
    },
    {
        "index": 618,
        "code": "mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2022-0240"
    },
    {
        "index": 619,
        "code": "TfLiteStatus PrepareHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, default_value_tensor->type, output_tensor->type);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           output_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               output_tensor->type == kTfLiteInt64));\n  return context->ResizeTensor(context, output_tensor,\n                               TfLiteIntArrayCopy(key_tensor->dims));\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 620,
        "code": "static void __Pyx_AddTraceback(const char *funcname, int c_line,\n                               int py_line, const char *filename) {\n    PyCodeObject *py_code = 0;\n    PyFrameObject *py_frame = 0;\n    PyThreadState *tstate = __Pyx_PyThreadState_Current;\n    if (c_line) {\n        c_line = __Pyx_CLineForTraceback(tstate, c_line);\n    }\n    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);\n    if (!py_code) {\n        py_code = __Pyx_CreateCodeObjectForTraceback(\n            funcname, c_line, py_line, filename);\n        if (!py_code) goto bad;\n        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);\n    }\n    py_frame = PyFrame_New(\n        tstate,            /*PyThreadState *tstate,*/\n        py_code,           /*PyCodeObject *code,*/\n        __pyx_d,    /*PyObject *globals,*/\n        0                  /*PyObject *locals*/\n    );\n    if (!py_frame) goto bad;\n    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);\n    PyTraceBack_Here(py_frame);\nbad:\n    Py_XDECREF(py_code);\n    Py_XDECREF(py_frame);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 621,
        "code": "static Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n   /* Single object containing result members. */\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[200];\n    //Jsi_ObjIncrRefCount(interp, ores);\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    //Jsi_IncrRefCount(interp, vres);\n    \n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 622,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_6varint_write_varint(CYTHON_UNUSED PyObject *__pyx_self, Py_ssize_t __pyx_v_number, PyObject *__pyx_v_buf) {\n  Py_ssize_t __pyx_v_i;\n  unsigned char __pyx_v_towrite;\n  unsigned char __pyx_v_num_buf[32];\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  __Pyx_RefNannySetupContext(\"write_varint\", 0);\n\n  /* \"clickhouse_driver/varint.pyx\":8\n *     Writes integer of variable length using LEB128.\n *     \"\"\"\n *     cdef Py_ssize_t i = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned char towrite\n *     # Py_ssize_t checks integer on function call and\n */\n  __pyx_v_i = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":15\n *     cdef unsigned char num_buf[32]\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         towrite = number & 0x7f\n *         number >>= 7\n */\n  while (1) {\n\n    /* \"clickhouse_driver/varint.pyx\":16\n * \n *     while True:\n *         towrite = number & 0x7f             # <<<<<<<<<<<<<<\n *         number >>= 7\n *         if number:\n */\n    __pyx_v_towrite = (__pyx_v_number & 0x7f);\n\n    /* \"clickhouse_driver/varint.pyx\":17\n *     while True:\n *         towrite = number & 0x7f\n *         number >>= 7             # <<<<<<<<<<<<<<\n *         if number:\n *             num_buf[i] = towrite | 0x80\n */\n    __pyx_v_number = (__pyx_v_number >> 7);\n\n    /* \"clickhouse_driver/varint.pyx\":18\n *         towrite = number & 0x7f\n *         number >>= 7\n *         if number:             # <<<<<<<<<<<<<<\n *             num_buf[i] = towrite | 0x80\n *             i += 1\n */\n    __pyx_t_1 = (__pyx_v_number != 0);\n    if (__pyx_t_1) {\n\n      /* \"clickhouse_driver/varint.pyx\":19\n *         number >>= 7\n *         if number:\n *             num_buf[i] = towrite | 0x80             # <<<<<<<<<<<<<<\n *             i += 1\n *         else:\n */\n      (__pyx_v_num_buf[__pyx_v_i]) = (__pyx_v_towrite | 0x80);\n\n      /* \"clickhouse_driver/varint.pyx\":20\n *         if number:\n *             num_buf[i] = towrite | 0x80\n *             i += 1             # <<<<<<<<<<<<<<\n *         else:\n *             num_buf[i] = towrite\n */\n      __pyx_v_i = (__pyx_v_i + 1);\n\n      /* \"clickhouse_driver/varint.pyx\":18\n *         towrite = number & 0x7f\n *         number >>= 7\n *         if number:             # <<<<<<<<<<<<<<\n *             num_buf[i] = towrite | 0x80\n *             i += 1\n */\n      goto __pyx_L5;\n    }\n\n    /* \"clickhouse_driver/varint.pyx\":22\n *             i += 1\n *         else:\n *             num_buf[i] = towrite             # <<<<<<<<<<<<<<\n *             i += 1\n *             break\n */\n    /*else*/ {\n      (__pyx_v_num_buf[__pyx_v_i]) = __pyx_v_towrite;\n\n      /* \"clickhouse_driver/varint.pyx\":23\n *         else:\n *             num_buf[i] = towrite\n *             i += 1             # <<<<<<<<<<<<<<\n *             break\n * \n */\n      __pyx_v_i = (__pyx_v_i + 1);\n\n      /* \"clickhouse_driver/varint.pyx\":24\n *             num_buf[i] = towrite\n *             i += 1\n *             break             # <<<<<<<<<<<<<<\n * \n *     buf.write(PyBytes_FromStringAndSize(<char *>num_buf, i))\n */\n      goto __pyx_L4_break;\n    }\n    __pyx_L5:;\n  }\n  __pyx_L4_break:;\n\n  /* \"clickhouse_driver/varint.pyx\":26\n *             break\n * \n *     buf.write(PyBytes_FromStringAndSize(<char *>num_buf, i))             # <<<<<<<<<<<<<<\n * \n * \n */\n  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 26, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyBytes_FromStringAndSize(((char *)__pyx_v_num_buf), __pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 26, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_t_5 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);\n    if (likely(__pyx_t_5)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n      __Pyx_INCREF(__pyx_t_5);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_3, function);\n    }\n  }\n  __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 26, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":4\n * \n * \n * def write_varint(Py_ssize_t number, buf):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Writes integer of variable length using LEB128.\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.varint.write_varint\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 623,
        "code": "bool MemFile::seek(int64_t offset, int whence /* = SEEK_SET */) {\n  assertx(m_len != -1);\n  if (whence == SEEK_CUR) {\n    if (offset > 0 && offset < bufferedLen()) {\n      setReadPosition(getReadPosition() + offset);\n      setPosition(getPosition() + offset);\n      return true;\n    }\n    offset += getPosition();\n    whence = SEEK_SET;\n  }\n\n  // invalidate the current buffer\n  setWritePosition(0);\n  setReadPosition(0);\n  if (whence == SEEK_SET) {\n    m_cursor = offset;\n  } else {\n    assertx(whence == SEEK_END);\n    m_cursor = m_len + offset;\n  }\n  setPosition(m_cursor);\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1918"
    },
    {
        "index": 624,
        "code": "void ieee80211_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tint headroom;\n\tenum ieee80211_encrypt encrypt;\n\n\tif (info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)\n\t\tencrypt = ENCRYPT_NO;\n\telse if (ieee80211_is_mgmt(hdr->frame_control))\n\t\tencrypt = ENCRYPT_MGMT;\n\telse\n\t\tencrypt = ENCRYPT_DATA;\n\n\theadroom = local->tx_headroom;\n\tif (encrypt != ENCRYPT_NO)\n\t\theadroom += sdata->encrypt_headroom;\n\theadroom -= skb_headroom(skb);\n\theadroom = max_t(int, 0, headroom);\n\n\tif (ieee80211_skb_resize(sdata, skb, headroom, encrypt)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\t/* reload after potential resize */\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    is_unicast_ether_addr(hdr->addr1)) {\n\t\t\tif (mesh_nexthop_resolve(sdata, skb))\n\t\t\t\treturn; /* skb queued: don't free */\n\t\t} else {\n\t\t\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n\t\t}\n\t}\n\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_tx(sdata, sta, skb, false);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-38206"
    },
    {
        "index": 625,
        "code": "R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tif (!a) {\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0559"
    },
    {
        "index": 626,
        "code": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);\n    char *crypt_res = crypt(key,salt);\n\n    if (crypt_res) {\n      return strdup(crypt_res);\n    }\n#endif\n  }\n\n  return ((salt[0] == '*') && (salt[1] == '0'))\n                  ? strdup(\"*1\") : strdup(\"*0\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1917"
    },
    {
        "index": 627,
        "code": "TfLiteStatus InitializeTemporaries(TfLiteContext* context, TfLiteNode* node,\n                                   OpContext* op_context) {\n  // Creates a temp index to iterate through input data.\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  TfLiteIntArrayFree(node->temporaries);\n  node->temporaries = TfLiteIntArrayCreate(3);\n  node->temporaries->data[0] = op_data->scratch_tensor_index;\n  TfLiteTensor* scratch_tensor = GetTemporary(context, node, /*index=*/0);\n  scratch_tensor->type = kTfLiteInt32;\n  scratch_tensor->allocation_type = kTfLiteArenaRw;\n  TfLiteIntArray* index_size = TfLiteIntArrayCreate(1);\n  index_size->data[0] = NumDimensions(op_context->input);\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, scratch_tensor, index_size));\n\n  // Creates a temp tensor to store resolved axis given input data.\n  node->temporaries->data[1] = op_data->scratch_tensor_index + 1;\n  TfLiteTensor* resolved_axis = GetTemporary(context, node, /*index=*/1);\n  resolved_axis->type = kTfLiteInt32;\n  // Creates a temp tensor to store temp sums when calculating mean.\n  node->temporaries->data[2] = op_data->scratch_tensor_index + 2;\n  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);\n  switch (op_context->input->type) {\n    case kTfLiteFloat32:\n      temp_sum->type = kTfLiteFloat32;\n      break;\n    case kTfLiteInt32:\n      temp_sum->type = kTfLiteInt64;\n      break;\n    case kTfLiteInt64:\n      temp_sum->type = kTfLiteInt64;\n      break;\n    case kTfLiteUInt8:\n    case kTfLiteInt8:\n    case kTfLiteInt16:\n      temp_sum->type = kTfLiteInt32;\n      break;\n    case kTfLiteBool:\n      temp_sum->type = kTfLiteBool;\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 628,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_STATUS(CalculateOpData(context, params, input, output, data));\n\n  if (input->type == kTfLiteFloat32) {\n    CalculateActivationRange(params->activation, &data->activation_min_f32,\n                             &data->activation_max_f32);\n  } else if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8) {\n    CalculateActivationRangeQuantized(context, params->activation, output,\n                                      &data->activation_min,\n                                      &data->activation_max);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 629,
        "code": "void FillDiagHelper(const TfLiteTensor* input, TfLiteTensor* output) {\n  const int num_output_dims = output->dims->size;\n  int batch_size = 1;\n  for (int i = 0; i < num_output_dims - 2; ++i) {\n    batch_size *= output->dims->data[i];\n  }\n\n  const int row_size = output->dims->data[num_output_dims - 2];\n  const int col_size = output->dims->data[num_output_dims - 1];\n  switch (output->type) {\n    case kTfLiteInt64: {\n      return FillDiag<int64_t>(input, output, batch_size, row_size, col_size);\n    }\n    case kTfLiteInt32: {\n      return FillDiag<int32_t>(input, output, batch_size, row_size, col_size);\n    }\n    case kTfLiteInt16: {\n      return FillDiag<int16_t>(input, output, batch_size, row_size, col_size);\n    }\n    case kTfLiteInt8: {\n      return FillDiag<int8_t>(input, output, batch_size, row_size, col_size);\n    }\n    case kTfLiteUInt8: {\n      return FillDiag<uint8_t>(input, output, batch_size, row_size, col_size);\n    }\n    default:\n      return FillDiag<float>(input, output, batch_size, row_size, col_size);\n  }\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 630,
        "code": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26267"
    },
    {
        "index": 631,
        "code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 632,
        "code": "static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)\n{\n    int i, j, ret;\n    int64_t off;\n    int val_1;\n    int num_video;\n    AVIOContext pb0, *pb = &pb0;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_header_len\n    avio_r8(pb); // '1'\n\n    val_1 = ffio_read_varlen(pb);\n\n    for (i=0;i<val_1;i++) {\n        int c = avio_r8(pb);\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        for (j=0;j<c;j++) {\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n            avio_r8(pb); // val_3\n            avio_r8(pb); // val_4\n        }\n    }\n\n    avio_r8(pb); // num_streams\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_5\n\n    avio_r8(pb); // '2'\n    num_video = avio_r8(pb);\n\n    avio_seek(pb, off, SEEK_SET);\n    if (num_video != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    for (i = 0; i < num_video; i++) {\n        AVStream *st = avformat_new_stream(s, NULL);\n        int num, den;\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_VP6;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb);\n        avio_r8(pb); // '3'\n        avio_r8(pb); // val_7\n        num = avio_rl32(pb); // frame_time\n        den = avio_rl32(pb); // time_base\n        avpriv_set_pts_info(st, 64, num, den);\n        st->nb_frames = avio_rl32(pb); // n frames\n        st->codecpar->width = avio_rl16(pb); // width\n        st->codecpar->height = avio_rl16(pb); // height\n        avio_r8(pb); // val_8\n        avio_rl32(pb); // val_9\n\n        avio_seek(pb, off, SEEK_SET);\n    }\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_10\n    avio_r8(pb); // '4'\n    viv->num_audio = avio_r8(pb);\n    avio_seek(pb, off, SEEK_SET);\n\n    if (viv->num_audio != 1)\n        av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);\n\n    for(i=0;i<viv->num_audio;i++) {\n        int q;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = num_video + i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_VORBIS;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb); // length\n        avio_r8(pb); // '5'\n        avio_r8(pb); //codec_id\n        avio_rl16(pb); //codec_subid\n        st->codecpar->channels = avio_rl16(pb); // channels\n        st->codecpar->sample_rate = avio_rl32(pb); // sample_rate\n        avio_seek(pb, 10, SEEK_CUR); // data_1\n        q = avio_r8(pb);\n        avio_seek(pb, q, SEEK_CUR); // data_2\n        avio_r8(pb); // zeropad\n\n        if (avio_tell(pb) < off) {\n            int num_data;\n            int xd_size = 0;\n            int data_len[256];\n            int offset = 1;\n            uint8_t *p;\n            ffio_read_varlen(pb); // val_13\n            avio_r8(pb); // '19'\n            ffio_read_varlen(pb); // len_3\n            num_data = avio_r8(pb);\n            for (j = 0; j < num_data; j++) {\n                uint64_t len = ffio_read_varlen(pb);\n                if (len > INT_MAX/2 - xd_size) {\n                    return AVERROR_INVALIDDATA;\n                }\n                data_len[j] = len;\n                xd_size += len;\n            }\n\n            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);\n            if (ret < 0)\n                return ret;\n\n            p = st->codecpar->extradata;\n            p[0] = 2;\n\n            for (j = 0; j < num_data - 1; j++) {\n                unsigned delta = av_xiphlacing(&p[offset], data_len[j]);\n                if (delta > data_len[j]) {\n                    return AVERROR_INVALIDDATA;\n                }\n                offset += delta;\n            }\n\n            for (j = 0; j < num_data; j++) {\n                int ret = avio_read(pb, &p[offset], data_len[j]);\n                if (ret < data_len[j]) {\n                    st->codecpar->extradata_size = 0;\n                    av_freep(&st->codecpar->extradata);\n                    break;\n                }\n                offset += data_len[j];\n            }\n\n            if (offset < st->codecpar->extradata_size)\n                st->codecpar->extradata_size = offset;\n        }\n    }\n\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-35964"
    },
    {
        "index": 633,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_2__pyx_unpickle_BufferedSocketReader(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_v___pyx_PickleError = 0;\n  PyObject *__pyx_v___pyx_result = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedSocketReader\", 0);\n\n  /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0xef9caf0:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)\n */\n  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xef9caf0) != 0);\n  if (__pyx_t_1) {\n\n    /* \"(tree fragment)\":5\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0xef9caf0:\n *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketReader.__new__(__pyx_type)\n */\n    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_n_s_PickleError);\n    __Pyx_GIVEREF(__pyx_n_s_PickleError);\n    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);\n    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __Pyx_INCREF(__pyx_t_2);\n    __pyx_v___pyx_PickleError = __pyx_t_2;\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":6\n *     if __pyx_checksum != 0xef9caf0:\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)             # <<<<<<<<<<<<<<\n *     __pyx_result = BufferedSocketReader.__new__(__pyx_type)\n *     if __pyx_state is not None:\n */\n    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xef, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_INCREF(__pyx_v___pyx_PickleError);\n    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_5)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_5);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);\n    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_Raise(__pyx_t_3, 0, 0, 0);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __PYX_ERR(1, 6, __pyx_L1_error)\n\n    /* \"(tree fragment)\":4\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n *     if __pyx_checksum != 0xef9caf0:             # <<<<<<<<<<<<<<\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)\n */\n  }\n\n  /* \"(tree fragment)\":7\n *         from pickle import PickleError as __pyx_PickleError\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketReader.__new__(__pyx_type)             # <<<<<<<<<<<<<<\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedSocketReader__set_state(<BufferedSocketReader> __pyx_result, __pyx_state)\n */\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedSocketReader), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_4 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_4)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_4);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);\n  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_v___pyx_result = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketReader.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedSocketReader__set_state(<BufferedSocketReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);\n  __pyx_t_6 = (__pyx_t_1 != 0);\n  if (__pyx_t_6) {\n\n    /* \"(tree fragment)\":9\n *     __pyx_result = BufferedSocketReader.__new__(__pyx_type)\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedSocketReader__set_state(<BufferedSocketReader> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedSocketReader__set_state(BufferedSocketReader __pyx_result, tuple __pyx_state):\n */\n    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected %.16s, got %.200s\", \"tuple\", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)\n    __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedSocketReader__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedSocketReader *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n    /* \"(tree fragment)\":8\n *         raise __pyx_PickleError(\"Incompatible checksums (%s vs 0xef9caf0 = (buffer, current_buffer_size, position, sock))\" % __pyx_checksum)\n *     __pyx_result = BufferedSocketReader.__new__(__pyx_type)\n *     if __pyx_state is not None:             # <<<<<<<<<<<<<<\n *         __pyx_unpickle_BufferedSocketReader__set_state(<BufferedSocketReader> __pyx_result, __pyx_state)\n *     return __pyx_result\n */\n  }\n\n  /* \"(tree fragment)\":10\n *     if __pyx_state is not None:\n *         __pyx_unpickle_BufferedSocketReader__set_state(<BufferedSocketReader> __pyx_result, __pyx_state)\n *     return __pyx_result             # <<<<<<<<<<<<<<\n * cdef __pyx_unpickle_BufferedSocketReader__set_state(BufferedSocketReader __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.current_buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v___pyx_result);\n  __pyx_r = __pyx_v___pyx_result;\n  goto __pyx_L0;\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedSocketReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError\n *     cdef object __pyx_result\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedSocketReader\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v___pyx_PickleError);\n  __Pyx_XDECREF(__pyx_v___pyx_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 634,
        "code": "ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-36222"
    },
    {
        "index": 635,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_10ByteString_2read_items(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_n_items, PyObject *__pyx_v_buf) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"read_items\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":41\n * \n *     def read_items(self, n_items, buf):\n *         return buf.read_strings(n_items)             # <<<<<<<<<<<<<<\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_buf, __pyx_n_s_read_strings); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 41, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_n_items) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_n_items);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 41, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":40\n *         buf.write_strings(items)\n * \n *     def read_items(self, n_items, buf):             # <<<<<<<<<<<<<<\n *         return buf.read_strings(n_items)\n * \n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.ByteString.read_items\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 636,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_7columns_12stringcolumn_6String___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_encoding, PyObject *__pyx_v_kwargs) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":23\n * \n *     def __init__(self, encoding=default_encoding, **kwargs):\n *         self.encoding = encoding             # <<<<<<<<<<<<<<\n *         super(String, self).__init__(**kwargs)\n * \n */\n  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_encoding, __pyx_v_encoding) < 0) __PYX_ERR(0, 23, __pyx_L1_error)\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":24\n *     def __init__(self, encoding=default_encoding, **kwargs):\n *         self.encoding = encoding\n *         super(String, self).__init__(**kwargs)             # <<<<<<<<<<<<<<\n * \n *     def write_items(self, items, buf):\n */\n  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_String); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 24, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);\n  __Pyx_INCREF(__pyx_v_self);\n  __Pyx_GIVEREF(__pyx_v_self);\n  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);\n  __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 24, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_v_kwargs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/columns/stringcolumn.pyx\":22\n *     default_encoding = defines.STRINGS_ENCODING\n * \n *     def __init__(self, encoding=default_encoding, **kwargs):             # <<<<<<<<<<<<<<\n *         self.encoding = encoding\n *         super(String, self).__init__(**kwargs)\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_AddTraceback(\"clickhouse_driver.columns.stringcolumn.String.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 637,
        "code": "static bool set_sockaddr(sockaddr_storage &sa_storage, req::ptr<Socket> sock,\n                         const String& addr, int port,\n                         struct sockaddr *&sa_ptr, size_t &sa_size) {\n  // Always zero it out:\n  // - fields are added over time; zeroing it out is future-proofing; for\n  //   example, sockaddr_in6 did not originally include sin6_scope_id or\n  //   sin6_flowinfo.\n  // - required for all on MacOS for correct behavior\n  // - on Linux, required for sockaddr_un to deal with buggy sun_path readers\n  //   (they should look at the length)\n  memset(&sa_storage, 0, sizeof(struct sockaddr_storage));\n  struct sockaddr *sock_type = (struct sockaddr*) &sa_storage;\n  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {\n        // Linux supports 3 kinds of unix sockets; behavior of this struct\n        // is in `man 7 unix`; relevant parts:\n        // - unnamed: 0-length path. As paths are not required to be\n        //   null-terminated, this needs to be undicated by the size.\n        //   These might be created by `socketpair()`, for eaxmple.\n        // - pathname (common): nothing strange. struct size technically\n        //   indicates length, but null terminators are usually set. This\n        //   does matter if addr.length() == size of the char array though\n        // - abstract: these have a meaningful name, but start with `\\0`\n        //\n        // Setting sa_size to indicate a 0-length path is required to\n        // distinguish between unnamed and abstract.\n        sa_size = offsetof(struct sockaddr_un, sun_path);\n      }\n#endif\n\n#endif // ifdef _MSC_VER\n    }\n    break;\n  case AF_INET:\n    {\n      struct sockaddr_in *sa = (struct sockaddr_in *)sock_type;\n      sa->sin_family = AF_INET;\n      sa->sin_port = htons((unsigned short) port);\n      if (!php_set_inet_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in);\n    }\n    break;\n  case AF_INET6:\n    {\n      struct sockaddr_in6 *sa = (struct sockaddr_in6 *)sock_type;\n      sa->sin6_family = AF_INET6;\n      sa->sin6_port = htons((unsigned short) port);\n      if (!php_set_inet6_addr(sa, addr.c_str(), sock)) {\n        return false;\n      }\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = sizeof(struct sockaddr_in6);\n    }\n    break;\n  default:\n    raise_warning(\"unsupported socket type '%d', must be \"\n                    \"AF_UNIX, AF_INET, or AF_INET6\", sock->getType());\n    return false;\n  }\n#ifdef __APPLE__\n  // This field is not in the relevant standards, not defined on Linux, but is\n  // technically required on MacOS (and other BSDs) according to the man pages:\n  // - `man 4 netintro` covers the base sa_len\n  // - `man 4 unix` and `man 4 inet6` cover AF_UNIX sun_len and AF_INET6\n  //    sin6_len\n  // - ... At least MacOS Catalina includes the wrong `man 4 inet`. Look at the\n  //   (Net|Free|Open)BSD `man 4 inet` instead.\n  //   The MacOS man page says it starts with `sin_family`, which would conflict\n  //   with the base sockaddr definition. `sin_len` is actually the first field\n  //   in the header file, matching `sa_len`.\n  sa_ptr->sa_len = sa_size;\n#endif\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 638,
        "code": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tint pred = is_branch_taken(dst_reg, insn->imm, opcode);\n\n\t\tif (pred == 1) {\n\t\t\t /* only follow the goto, ignore fall-through */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else if (pred == 0) {\n\t\t\t/* only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    regs[insn->src_reg].type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(regs[insn->src_reg].var_off))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg, regs[insn->src_reg].var_off.value,\n\t\t\t\t\t\topcode);\n\t\t\telse if (tnum_is_const(dst_reg->var_off))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &regs[insn->src_reg],\n\t\t\t\t\t\t    dst_reg->var_off.value, opcode);\n\t\t\telse if (opcode == BPF_JEQ || opcode == BPF_JNE)\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    &regs[insn->src_reg],\n\t\t\t\t\t\t    &regs[insn->dst_reg], opcode);\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, opcode);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level)\n\t\tprint_verifier_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-7308"
    },
    {
        "index": 639,
        "code": " void MediaStreamManager::StopStreamDevice(int render_process_id,\n                                           int render_frame_id,\n                                           const std::string& device_id,\n                                           int session_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DVLOG(1) << \"StopStreamDevice({render_frame_id = \" << render_frame_id << \"} \"\n           << \", {device_id = \" << device_id << \"}, session_id = \" << session_id\n           << \"})\";\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5755"
    },
    {
        "index": 640,
        "code": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader___init__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v_bufsize) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"__init__\", 0);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":15\n * \n *     def __init__(self, bufsize):\n *         self.buffer = bytearray(bufsize)             # <<<<<<<<<<<<<<\n * \n *         self.position = 0\n */\n  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyByteArray_Type)), __pyx_v_bufsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v_self->buffer);\n  __Pyx_DECREF(__pyx_v_self->buffer);\n  __pyx_v_self->buffer = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":17\n *         self.buffer = bytearray(bufsize)\n * \n *         self.position = 0             # <<<<<<<<<<<<<<\n *         self.current_buffer_size = 0\n * \n */\n  __pyx_v_self->position = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":18\n * \n *         self.position = 0\n *         self.current_buffer_size = 0             # <<<<<<<<<<<<<<\n * \n *         super(BufferedReader, self).__init__()\n */\n  __pyx_v_self->current_buffer_size = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":20\n *         self.current_buffer_size = 0\n * \n *         super(BufferedReader, self).__init__()             # <<<<<<<<<<<<<<\n * \n *     def read_into_buffer(self):\n */\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedReader));\n  __Pyx_GIVEREF(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedReader));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedReader));\n  __Pyx_INCREF(((PyObject *)__pyx_v_self));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_self));\n  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __pyx_t_3 = NULL;\n  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n    if (likely(__pyx_t_3)) {\n      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n      __Pyx_INCREF(__pyx_t_3);\n      __Pyx_INCREF(function);\n      __Pyx_DECREF_SET(__pyx_t_2, function);\n    }\n  }\n  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 20, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":14\n *     cdef public bytearray buffer\n * \n *     def __init__(self, bufsize):             # <<<<<<<<<<<<<<\n *         self.buffer = bytearray(bufsize)\n * \n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.__init__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 641,
        "code": "static int __Pyx_modinit_type_import_code(void) {\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__Pyx_modinit_type_import_code\", 0);\n  /*--- Type import code ---*/\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"type\", \n  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000\n  sizeof(PyTypeObject),\n  #else\n  sizeof(PyHeapTypeObject),\n  #endif\n  __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 8, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"bool\", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(3, 8, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 15, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, \"complex\", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);\n   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(4, 15, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_RefNannyFinishContext();\n  return 0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_RefNannyFinishContext();\n  return -1;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 642,
        "code": "Jsi_RC jsi_PkgDumpInfo(Jsi_Interp *interp, const char *name, Jsi_Value **ret) {\n    jsi_PkgInfo *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n    if (hPtr && ((ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr)))) {\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringDup(interp, name), 0);\n        Jsi_ObjInsert(interp, nobj, \"version\", Jsi_ValueNewNumber(interp, ptr->version), 0);\n        Jsi_ObjInsert(interp, nobj, \"lastReq\", Jsi_ValueNewNumber(interp, ptr->lastReq), 0);\n        char buf[200];\n        jsi_VersionNormalize(ptr->version, buf, sizeof(buf));\n        Jsi_ObjInsert(interp, nobj, \"verStr\", Jsi_ValueNewStringDup(interp, buf), 0);\n        const char *cp = (ptr->loadFile?ptr->loadFile:\"\");\n        Jsi_ObjInsert(interp, nobj, \"loadFile\", Jsi_ValueNewStringDup(interp, cp), 0);\n        Jsi_Value *fval2, *fval = Jsi_NameLookup(interp, name);\n        if (!fval || !Jsi_ValueIsFunction(interp, fval))\n            fval = Jsi_ValueNewNull(interp);\n        Jsi_ObjInsert(interp, nobj, \"func\", fval, 0);\n        fval = ptr->popts.info;\n        if (!fval) fval = interp->NullValue;\n        if (!Jsi_ValueIsObjType(interp, fval, JSI_OT_FUNCTION))\n            Jsi_ObjInsert(interp, nobj, \"info\", fval, 0);\n        else {\n            fval2 = Jsi_ValueNew1(interp);\n            Jsi_RC rc = Jsi_FunctionInvoke(interp, fval, NULL, &fval2, NULL);\n            if (rc != JSI_OK)\n                Jsi_LogWarn(\"status call failed\");\n            Jsi_ObjInsert(interp, nobj, \"info\", fval2, 0);\n            Jsi_DecrRefCount(interp, fval2);\n        }\n        fval = interp->NullValue;\n        if (ptr->popts.spec && ptr->popts.data) {\n            fval = Jsi_ValueNew1(interp);\n            Jsi_OptionsConf(interp, ptr->popts.spec, ptr->popts.data, NULL, &fval, 0);\n        }\n        Jsi_ObjInsert(interp, nobj, \"status\", fval, 0);\n        if (fval != interp->NullValue)\n            Jsi_DecrRefCount(interp, fval);\n\n        fval = Jsi_ValueNew1(interp);\n        Jsi_OptionsConf(interp, jsiModuleOptions, &ptr->popts.modConf, NULL, &fval, 0);\n        Jsi_ObjInsert(interp, nobj, \"moduleOpts\", fval, 0);\n        Jsi_DecrRefCount(interp, fval);\n\n        return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 643,
        "code": "Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g->num_node_ids();\n  cf_info->frame_names.resize(num_nodes);\n  std::vector<Node*> parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector<bool> visited;\n  visited.resize(num_nodes);\n\n  string frame_name;\n  std::deque<Node*> ready;\n\n  // Initialize with the root nodes.\n  for (Node* n : g->nodes()) {\n    if (n->in_edges().empty()) {\n      visited[n->id()] = true;\n      cf_info->unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node->id();\n    ready.pop_front();\n\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      // Enter a child frame.\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node->attrs(), \"frame_name\", &frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      // Exit to the parent frame.\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[parent->id()];\n      parent = parent_nodes[parent->id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[curr_id];\n    }\n\n    for (const Edge* out_edge : curr_node->out_edges()) {\n      Node* out = out_edge->dst();\n      if (IsSink(out)) continue;\n      const int out_id = out->id();\n\n      // Add to ready queue if not visited.\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n\n        // Process the node 'out'.\n        cf_info->frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info->unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n\n  return Status::OK();\n}\n",
        "cwe_id": "CWE-476",
        "cve_id": "CVE-2021-41217"
    },
    {
        "index": 644,
        "code": "static int jsi_wsHttp(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, void *user,\n    struct lws_context *context, const char* inPtr, Jsi_DString *tStr, jsi_wsPss *pss)\n{\n    const char *ext = NULL;\n    unsigned char buffer[JSI_BUFSIZ];\n    const char *mime = NULL;\n    time_t now = time(NULL);\n    char buf[JSI_BUFSIZ];\n    int rc = 0;\n    buf[0] = 0;\n    uchar *p = buffer, *end = &buffer[sizeof(buffer)-1];\n    int n;\n    Jsi_Value* fname = NULL;\n    bool isJsiWeb = 0, isSSI = 0;\n    cmdPtr->stats.httpLast = now;\n    \n    /* if a legal POST URL, let it continue and accept data */\n    if (lws_hdr_total_length(wsi, WSI_TOKEN_POST_URI))\n        return 0;\n    if (!pss)\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n\n    int uplen=(cmdPtr->urlPrefix?Jsi_Strlen(cmdPtr->urlPrefix):0);\n\n    if (inPtr && cmdPtr->urlPrefix && !Jsi_Strncmp(inPtr, cmdPtr->urlPrefix, uplen))\n        inPtr += uplen;\n\n    if (cmdPtr->redirDisable) {// Try to defray redirect loops.\n        if (difftime(now, cmdPtr->stats.redirLast)>=600)\n            cmdPtr->redirDisable = 0;\n        else\n            cmdPtr->redirDisable--;\n    }\n\n    if ((cmdPtr->urlRedirect && (inPtr == 0 || *inPtr == 0 || !Jsi_Strcmp(inPtr, \"/\")) && !cmdPtr->redirDisable)\n        && (inPtr = cmdPtr->urlRedirect) && inPtr[0]) {\n        cmdPtr->stats.redirCnt++;\n        // TODO: system time change can disrupt the following.\n        if (cmdPtr->redirMax>0 && !cmdPtr->redirDisable && cmdPtr->redirMax>0 && cmdPtr->stats.redirLast\n            && difftime(now, cmdPtr->stats.redirLast)<600 && ++cmdPtr->redirAllCnt>cmdPtr->redirMax)\n            cmdPtr->redirDisable = 100;\n        cmdPtr->stats.redirLast = now;\n        rc = lws_http_redirect(wsi, 301, (uchar*)inPtr, Jsi_Strlen(inPtr), &p, end);\n        return (rc == 100 ? 0 : 1);\n    }\n    if (!inPtr || !*inPtr)\n        inPtr = \"/\";\n\n    if (cmdPtr->useridPass || cmdPtr->onAuth) {\n        int ok = 0;\n        int alen;\n        const char *auth = jsi_wsHeader(pss, \"authorization\", &alen);\n        if (auth && !Jsi_Strncasecmp(auth, \"basic \", 6) && !cmdPtr->deleted) {\n            auth += 6;\n            Jsi_DString eStr = {}, bStr = {};\n            Jsi_DSAppendLen(&eStr, auth, alen - 6);\n            Jsi_Base64(Jsi_DSValue(&eStr), -1, &bStr, 1);\n            const char *bp = Jsi_DSValue(&bStr);\n            if (bp && bp[0]) {\n                if (!cmdPtr->onAuth)\n                    ok = (!Jsi_Strcmp(cmdPtr->useridPass, bp));\n                else {\n                    /* Pass 4 args: ws, id, url and userid:pass . */\n                    Jsi_Obj *oarg1;\n                    Jsi_Value *vpargs, *vargs[10];\n                    int n = 0;\n                    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n                    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n                    vargs[n++] = Jsi_ValueNewStringDup(interp, inPtr);\n                    vargs[n++] = Jsi_ValueNewStringDup(interp, bp);\n                    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n                    Jsi_IncrRefCount(interp, vpargs);\n                    Jsi_Value *ret = Jsi_ValueNew1(interp);\n                    bool rb = 0;\n                    rc = Jsi_FunctionInvoke(interp, cmdPtr->onAuth, vpargs, &ret, NULL);\n                    if (rc == JSI_OK)\n                        rb = !Jsi_ValueIsFalse(interp, ret);\n\n                    Jsi_DecrRefCount(interp, vpargs);\n                    Jsi_DecrRefCount(interp, ret);\n\n                    if (rc != JSI_OK) {\n                        Jsi_LogError(\"websock bad rcv eval\");\n                        return -1;\n                    }\n                    ok = rb;\n                }\n            }\n            Jsi_DSFree(&eStr);\n            Jsi_DSFree(&bStr);\n        }\n        if (!ok) {\n            const char *realm = (cmdPtr->realm?cmdPtr->realm:\"jsish\");\n            int n = snprintf(buf, sizeof(buf), \"Basic realm=\\\"%s\\\"\", realm);\n            if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_WWW_AUTHENTICATE,\n                    (unsigned char *)buf, n, &p, end))\n                return -1;\n            if (jsi_wsServeString(pss, wsi, \"Password is required to access this page\", 401, (char*)buffer, NULL)<0)\n                return -1;\n            return lws_http_transaction_completed(wsi);\n        }\n    }\n\n    if (cmdPtr->onGet || pss->onGet) {\n        Jsi_RC jrc;\n        int rrv = 1;\n        if (cmdPtr->getRegexp) {\n            rrv = 0;\n            jrc = Jsi_RegExpMatch(interp, cmdPtr->getRegexp, inPtr, &rrv, NULL);\n            if (jrc != JSI_OK)\n                return -1; // Error in regexp.\n        }\n        if (rrv) {\n            jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, pss->onGet?pss->onGet:cmdPtr->onGet, tStr);\n            switch (jrc) {\n                case JSI_ERROR: return -1;\n                case JSI_OK: return 0;\n                case JSI_SIGNAL:\n                    return jsi_ws_http_redirect(wsi, 302, tStr, &p, end);\n                case JSI_CONTINUE:\n                    inPtr = Jsi_DSValue(tStr); break;\n                case JSI_BREAK: break;\n                default: break;\n            }\n        }\n    }\n    ext = Jsi_Strrchr(inPtr, '.');\n\n    Jsi_Value *rdir = (pss->rootdir?pss->rootdir:cmdPtr->rootdir);\n    cmdPtr->curRoot = (rdir?Jsi_ValueString(cmdPtr->interp, rdir, NULL):\"./\");\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    jsi_wsPathAlias(interp, cmdPtr, &inPtr, &sStr);\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", cmdPtr->curRoot, inPtr);\n    Jsi_DSFree(&sStr);\n    if (cmdPtr->debug>1)\n        fprintf(stderr, \"FILE: %s in %s | %s\\n\", buf, cmdPtr->curRoot, Jsi_ValueString(interp, cmdPtr->rootdir, NULL));\n    char extBuf[100], *cpde = Jsi_Strrchr(buf, '/');\n    isJsiWeb = (cpde && cmdPtr->jsiFnPattern && Jsi_GlobMatch(cmdPtr->jsiFnPattern, cpde+1, 0));\n    bool isgzip = 0;\n    if (!ext || !ext[1])\n        mime = \"text/html\";\n    else {\n        const char *eext = ext+1;\n        uint elen = Jsi_Strlen(ext);\n        if (elen>3 && elen<(sizeof(extBuf)-10) && !Jsi_Strcmp(ext+elen-3,\".gz\")) {\n            Jsi_Strcpy(extBuf, ext);\n            extBuf[elen-3] = 0;\n            char *ext2 = Jsi_Strrchr(extBuf, '.');\n            if (ext2) {\n                isgzip = 1;\n                ext = ext2;\n            }\n        }\n        Jsi_HashEntry *hPtr;\n\n        if (cmdPtr->mimeTypes) {\n            /* Lookup mime type in mimeTypes object. */\n            Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->mimeTypes, ext+1, 1);\n            if (mVal)\n                mime = Jsi_ValueString(interp, mVal, NULL);\n        }\n        if (!mime) {\n            static const char* mtypes[] = {\n                \"html\", \"text/html\", \"js\", \"application/x-javascript\",\n                \"css\", \"text/css\", \"png\", \"image/png\", \"ico\", \"image/icon\",\n                \"gif\", \"image/gif\", \"jpeg\", \"image/jpeg\",\n                \"jpg\", \"image/jpeg\", \"svg\", \"image/svg+xml\",\n                \"json\", \"application/json\", \"txt\", \"text/plain\",\n                \"jsi\", \"application/x-javascript\", \"cssi\", \"text/css\",\n                \"shtml\", \"text/html\",  \"scss\", \"text/css\",\n                \"sjs\", \"application/x-javascript\",\n                0, 0\n            };\n            mime = \"text/html\";\n            int i;\n            for (i=0; mtypes[i]; i+=2)\n                if (tolower(*eext) == mtypes[i][0] && !Jsi_Strncasecmp(eext, mtypes[i], -1)) {\n                    mime = mtypes[i+1];\n                    break;\n                }\n        }\n\n        isSSI = jsi_wsIsSSIExt(interp, cmdPtr, pss, eext);\n\n        if ((hPtr = Jsi_HashEntryFind(cmdPtr->handlers, ext)) && !cmdPtr->deleted) {\n            /* Use interprete html eg. using jsi_wpp preprocessor */\n            Jsi_DString jStr = {};\n            Jsi_Value *vrc = NULL;\n            int hrc = 0, strLen, evrc, isalloc=0;\n            char *vStr, *hstr = NULL;\n            jsi_wsHander *hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n            Jsi_Value *hv = hdlPtr->val;\n\n            if (Jsi_Strchr(buf, '\\'') || Jsi_Strchr(buf, '\\\"')) {\n                jsi_wsServeString(pss, wsi, \"Can not handle quotes in url\", 404, NULL, NULL);\n                return -1;\n            }\n            cmdPtr->handlersPkg=1;\n\n            // Attempt to load package and get function.\n            if ((hdlPtr->flags&1) && cmdPtr->handlersPkg && Jsi_ValueIsString(interp, hv)\n                && ((hstr = Jsi_ValueString(interp, hv, NULL)))) {\n                vrc = Jsi_NameLookup(interp, hstr);\n                if (!vrc) {\n                    Jsi_Number pver = Jsi_PkgRequire(interp, hstr, 0);\n                    if (pver >= 0)\n                        vrc = Jsi_NameLookup(interp, hstr);\n                }\n                if (!vrc || !Jsi_ValueIsFunction(interp, vrc)) {\n                    if (vrc)\n                        Jsi_DecrRefCount(interp, vrc);\n                    Jsi_LogError(\"Failed to autoload handle: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to autoload handler\", 404, NULL, NULL);\n                    return -1;\n                }\n                if (hdlPtr->val)\n                    Jsi_DecrRefCount(interp, hdlPtr->val);\n                hdlPtr->val = vrc;\n                Jsi_IncrRefCount(interp, vrc);\n                hv = vrc;\n            }\n\n            if ((hdlPtr->flags&2) && !hdlPtr->triedLoad && !hdlPtr->objVar && Jsi_ValueIsFunction(interp, hv)) {\n                // Run command and from returned object get the parse function.\n                hdlPtr->triedLoad = 1;\n                Jsi_DSAppend(&jStr, \"[null]\", NULL);\n                Jsi_DSAppend(&jStr, \"]\", NULL);\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);\n                if (Jsi_InterpGone(interp))\n                    return -1;\n                if (evrc != JSI_OK || !vrc || !Jsi_ValueIsObjType(interp, vrc, JSI_OT_OBJECT)) {\n                    Jsi_LogError(\"Failed to load obj: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to load obj\", 404, NULL, NULL);\n                    return -1;\n                }\n                Jsi_Value *fvrc = Jsi_ValueObjLookup(interp, vrc, \"parse\", 0);\n                if (!fvrc || !Jsi_ValueIsFunction(interp, fvrc)) {\n                    Jsi_LogError(\"Failed to find parse: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to find parse\", 404, NULL, NULL);\n                    return -1;\n                }\n                hdlPtr->objVar = fvrc;\n                Jsi_IncrRefCount(interp, fvrc);\n                hv = vrc;\n\n            }\n\n            if (hdlPtr->objVar) {  // Call the obj.parse function.\n                Jsi_DSAppend(&jStr, \"[\\\"\", buf, \"\\\"]\", NULL); // TODO: JSON encode.\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hdlPtr->objVar, Jsi_DSValue(&jStr), &vrc);\n                isalloc = 1;\n            }\n            else if (Jsi_ValueIsFunction(interp, hv)) {\n                //printf(\"CNCNN: %s\\n\", Jsi_DSValue(&cmdPtr->cName));\n                Jsi_DSAppend(&jStr, \"[\\\"\", buf, \"\\\", {wsName:\\\"\", Jsi_DSValue(&cmdPtr->cName), \"\\\"\", \"}]\", NULL); // TODO: JSON encode.\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);\n                isalloc = 1;\n            } else {\n                // One shot invoke of string command.\n                hstr = Jsi_ValueString(interp, hv, NULL);\n                Jsi_DSAppend(&jStr, hstr, \"('\", buf, \"');\", NULL);\n                evrc = Jsi_EvalString(interp, Jsi_DSValue(&jStr), JSI_EVAL_RETURN);\n                if (evrc == JSI_OK)\n                    vrc = Jsi_InterpResult(interp);\n            }\n            // Take result from vrc and return it.\n            if (evrc != JSI_OK) {\n                Jsi_LogError(\"failure in websocket handler\");\n            } else if ((!vrc) ||\n                (!(vStr = Jsi_ValueString(interp, vrc, &strLen)))) {\n                Jsi_LogError(\"failed to get result\");\n            } else {\n                hrc = jsi_wsServeString(pss, wsi, vStr, 0, NULL, mime);\n            }\n            Jsi_DSFree(&jStr);\n            if (isalloc)\n                Jsi_DecrRefCount(interp, vrc);\n            if (hrc<=0)\n                return -1;\n            return 1;\n        }\n    }\n    if (!buf[0]) {\n        if (cmdPtr->debug)\n            fprintf(stderr, \"empty file: %s\\n\", inPtr);\n        return -1;\n    }\n    fname = Jsi_ValueNewStringDup(interp, buf);\n    Jsi_IncrRefCount(interp, fname);\n\n    Jsi_DString hStr = {};\n    Jsi_StatBuf jsb;\n    bool native = Jsi_FSNative(interp, fname);\n    if ((native && Jsi_InterpSafe(interp) && Jsi_InterpAccess(interp, fname, JSI_INTACCESS_READ) != JSI_OK) ||\n        (Jsi_Stat(interp, fname, &jsb) || jsb.st_size<=0)) {\nnofile:\n        if (cmdPtr->onUnknown || pss->onUnknown) {\n            Jsi_Value *uk = (pss->onUnknown?pss->onUnknown:cmdPtr->onUnknown);\n            Jsi_RC jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, uk, NULL);\n            if (jrc == JSI_ERROR)\n                goto bail;\n            if (jrc == JSI_OK)\n                goto done;\n        }\n\n        if (0 && Jsi_Strstr(buf, \"favicon.ico\"))\n            rc = jsi_wsServeString(pss, wsi, \"data:;base64,iVBORw0KGgo=\", 200, NULL, \"image/icon\");\n        else {\n            const char *cp = Jsi_Strrchr(buf,'/');\n            if (cp && cp[1]) {\n                char statPath[PATH_MAX];\n                snprintf(statPath, sizeof(statPath), \"/zvfs/lib/web%s\", cp);\n                Jsi_DecrRefCount(interp, fname);\n                fname = Jsi_ValueNewStringDup(interp, statPath);\n                Jsi_IncrRefCount(interp, fname);\n                if (!Jsi_Stat(interp, fname, &jsb) && jsb.st_size>0) {\n                    native = 0;\n                    goto serve;\n                }\n            }\n            if (cmdPtr->noWarn==0 && !Jsi_Strstr(buf, \"favicon.ico\"))\n                fprintf(stderr, \"failed open file for read: %s\\n\", buf);\n            rc = jsi_wsServeString(pss, wsi, \"<b style='color:red'>ERROR: can not serve file!</b>\", 404, NULL, NULL);\n        }\n        Jsi_DecrRefCount(interp, fname);\n        goto done;\n    }\n    if (!ext || isSSI)\n        goto serve;\n    if (S_ISDIR(jsb.st_mode)) {\n        if (cmdPtr->noWarn==0)\n            fprintf(stderr, \"can not serve directory: %s\\n\", buf);\n        rc = jsi_wsServeString(pss, wsi, \"<b style='color:red'>ERROR: can not serve directory!</b>\", 404, NULL, NULL);\n        Jsi_DecrRefCount(interp, fname);\n        goto done;\n    }\n\nserve:\n    n = 0;\n    // TODO: add automatic cookie mgmt?\n/*\n    if (!strcmp((const char *)in, \"/\") &&\n       !lws_hdr_total_length(wsi, WSI_TOKEN_HTTP_COOKIE)) {\n        gettimeofday(&tv, NULL);\n        n = sprintf(b64, \"test=LWS_%u_%u_COOKIE;Max-Age=360000\",\n            (unsigned int)tv.tv_sec,\n            (unsigned int)tv.tv_usec);\n\n        if (lws_add_http_header_by_name(wsi,\n            (unsigned char *)\"set-cookie:\",\n            (unsigned char *)b64, n, &p,\n            (unsigned char *)buffer + sizeof(buffer)))\n            return 1;\n    }*/\n    static const char stsStr[] = \"max-age=15768000 ; includeSubDomains\";\n    if (lws_is_ssl(wsi) && lws_add_http_header_by_name(wsi,\n                    (uchar *) \"Strict-Transport-Security:\",\n                    (uchar *) stsStr,\n                    sizeof(stsStr)-1, &p, (uchar *)buffer + sizeof(buffer)))\n        goto bail;\n    n = p - buffer;\n    if (n>0)\n        Jsi_DSAppendLen(&hStr, (char*)buffer, n);\n    p = buffer;\n\n    if (isgzip) {\n        if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_ENCODING,\n                    (unsigned char *)\"gzip\", n, &p, end))\n            goto bail;\n    }\n    if (cmdPtr->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, cmdPtr->headers, &hStr))\n        goto bail;\n\n    if (pss->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, pss->headers, &hStr))\n        goto bail;\n\n    n = Jsi_DSLength(&hStr);\n\n    if (native && !isSSI && !isJsiWeb) {\n\n        if (!jsi_wsAddStdHeader(interp, cmdPtr, wsi, &hStr)) {\n            Jsi_DecrRefCount(interp, fname);\n            goto bail;\n        }\n        int hrc = lws_serve_http_file(wsi, buf, mime, Jsi_DSValue(&hStr), Jsi_DSLength(&hStr));\n        if (hrc >= 0 && cmdPtr->onModify)\n            jsi_wsFileAdd(interp, cmdPtr, fname);\n        Jsi_DecrRefCount(interp, fname);\n        if (hrc<0) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"can not serve file (%d): %s\\n\", hrc, buf);\n            goto bail;\n        } else if (hrc > 0 && lws_http_transaction_completed(wsi))\n            goto bail;\n    } else {\n        // Need to read data for non-native files.\n        Jsi_DString dStr = {}, fStr = {};\n        if (isSSI)\n            rc = jsi_wsEvalSSI(interp, cmdPtr, fname, &fStr, 1, pss);\n        else {\n            rc = jsi_wsFileRead(interp, fname, &fStr, cmdPtr, pss);\n            if (isJsiWeb)\n                Jsi_DSAppend(&fStr, \"\\nwindow.jsiWebSocket=true;\", NULL);\n        }\n        if (rc != JSI_OK) {\n            Jsi_DSFree(&fStr);\n            goto nofile;\n        }\n        int hrc = jsi_wsServeHeader(pss, wsi, (int)Jsi_DSLength(&fStr), 200, Jsi_DSValue(&hStr), mime, &dStr);\n        if (hrc>=0) {\n            Jsi_DSAppendLen(&dStr, Jsi_DSValue(&fStr), Jsi_DSLength(&fStr));\n            char *strVal = Jsi_DSValue(&dStr);\n            int strLen = Jsi_DSLength(&dStr);\n            hrc = jsi_wswrite(pss, wsi, (unsigned char*)strVal, strLen, LWS_WRITE_HTTP);\n        }\n        Jsi_DecrRefCount(interp, fname);\n        Jsi_DSFree(&dStr);\n        Jsi_DSFree(&fStr);\n        if (hrc<0) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"can not serve data (%d): %s\\n\", hrc, buf);\n            goto bail;\n        } else if (hrc > 0 && lws_http_transaction_completed(wsi))\n            goto bail;\n\n    }\ndone:\n    Jsi_DSFree(&hStr);\n    return rc;\n\nbail:\n    rc = 1;\n    goto done;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-22873"
    },
    {
        "index": 645,
        "code": "static void printFlow(u_int16_t id, struct ndpi_flow_info *flow, u_int16_t thread_id) {\n  FILE *out = results_file ? results_file : stdout;\n  u_int8_t known_tls;\n  char buf[32], buf1[64];\n  u_int i;\n\n  double dos_ge_score;\n  double dos_slow_score;\n  double dos_hulk_score;\n  double ddos_score;\n\n  double hearthbleed_score;\n\n  double ftp_patator_score;\n  double ssh_patator_score;\n\n  double inf_score;\n\n  if(csv_fp != NULL) {\n    float data_ratio = ndpi_data_ratio(flow->src2dst_bytes, flow->dst2src_bytes);\n    double f = (double)flow->first_seen, l = (double)flow->last_seen;\n\n    /* PLEASE KEEP IN SYNC WITH printCSVHeader() */\n    dos_ge_score = Dos_goldeneye_score(flow);\n    \n    dos_slow_score = Dos_slow_score(flow);\n    dos_hulk_score = Dos_hulk_score(flow);\n    ddos_score = Ddos_score(flow);\n\n    hearthbleed_score = Hearthbleed_score(flow);\n\n    ftp_patator_score = Ftp_patator_score(flow);\n    ssh_patator_score = Ssh_patator_score(flow);\n\n    inf_score = Infiltration_score(flow);\n   \n    double benign_score = dos_ge_score < 1 && dos_slow_score < 1 && \\\n    dos_hulk_score < 1 && ddos_score < 1 && hearthbleed_score < 1 && \\\n    ftp_patator_score < 1 && ssh_patator_score < 1 && inf_score < 1 ? 1.1 : 0;\n\n    fprintf(csv_fp, \"%u,%u,%.3f,%.3f,%.3f,%s,%u,%s,%u,\",\n\t    flow->flow_id,\n\t    flow->protocol,\n\t    f/1000.0, l/1000.0,\n\t    (l-f)/1000.0,\n\t    flow->src_name, ntohs(flow->src_port),\n\t    flow->dst_name, ntohs(flow->dst_port)\n\t    );\n\n    fprintf(csv_fp, \"%s,\",\n\t    ndpi_protocol2id(ndpi_thread_info[thread_id].workflow->ndpi_struct,\n\t\t\t     flow->detected_protocol, buf, sizeof(buf)));\n\n    fprintf(csv_fp, \"%s,%s,\",\n\t    ndpi_protocol2name(ndpi_thread_info[thread_id].workflow->ndpi_struct,\n\t\t\t       flow->detected_protocol, buf, sizeof(buf)),\n\t    flow->host_server_name);\n    \n    fprintf(csv_fp, \"%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,\", \\\n\t    benign_score, dos_slow_score, dos_ge_score, dos_hulk_score, \\\n\t    ddos_score, hearthbleed_score, ftp_patator_score,\t\t\\\n\t    ssh_patator_score, inf_score);\n    \n    fprintf(csv_fp, \"%u,%llu,%llu,\", flow->src2dst_packets,\n\t    (long long unsigned int) flow->src2dst_bytes, (long long unsigned int) flow->src2dst_goodput_bytes);\n    fprintf(csv_fp, \"%u,%llu,%llu,\", flow->dst2src_packets,\n\t    (long long unsigned int) flow->dst2src_bytes, (long long unsigned int) flow->dst2src_goodput_bytes);\n    fprintf(csv_fp, \"%.3f,%s,\", data_ratio, ndpi_data_ratio2str(data_ratio));\n    fprintf(csv_fp, \"%.1f,%.1f,\", 100.0*((float)flow->src2dst_goodput_bytes / (float)(flow->src2dst_bytes+1)),\n\t    100.0*((float)flow->dst2src_goodput_bytes / (float)(flow->dst2src_bytes+1)));\n    \n    /* IAT (Inter Arrival Time) */\n    fprintf(csv_fp, \"%u,%.1f,%u,%.1f,\",\n\t    ndpi_data_min(flow->iat_flow), ndpi_data_average(flow->iat_flow), ndpi_data_max(flow->iat_flow), ndpi_data_stddev(flow->iat_flow));\n\n    fprintf(csv_fp, \"%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,\",\n\t    ndpi_data_min(flow->iat_c_to_s), ndpi_data_average(flow->iat_c_to_s), ndpi_data_max(flow->iat_c_to_s), ndpi_data_stddev(flow->iat_c_to_s),\n\t    ndpi_data_min(flow->iat_s_to_c), ndpi_data_average(flow->iat_s_to_c), ndpi_data_max(flow->iat_s_to_c), ndpi_data_stddev(flow->iat_s_to_c));\n\n    /* Packet Length */\n    fprintf(csv_fp, \"%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,\",\n\t    ndpi_data_min(flow->pktlen_c_to_s), ndpi_data_average(flow->pktlen_c_to_s), ndpi_data_max(flow->pktlen_c_to_s), ndpi_data_stddev(flow->pktlen_c_to_s),\n\t    ndpi_data_min(flow->pktlen_s_to_c), ndpi_data_average(flow->pktlen_s_to_c), ndpi_data_max(flow->pktlen_s_to_c), ndpi_data_stddev(flow->pktlen_s_to_c));\n\n    /* TCP flags */\n   fprintf(csv_fp, \"%d,%d,%d,%d,%d,%d,%d,%d,\", flow->cwr_count, flow->ece_count, flow->urg_count, flow->ack_count, flow->psh_count, flow->rst_count, flow->syn_count, flow->fin_count);\n\n   fprintf(csv_fp, \"%d,%d,%d,%d,%d,%d,%d,%d,\", flow->src2dst_cwr_count, flow->src2dst_ece_count, flow->src2dst_urg_count, flow->src2dst_ack_count, flow->src2dst_psh_count, flow->src2dst_rst_count, flow->src2dst_syn_count, flow->src2dst_fin_count);\n\n   fprintf(csv_fp, \"%d,%d,%d,%d,%d,%d,%d,%d,\", flow->dst2src_cwr_count, flow->ece_count, flow->urg_count, flow->ack_count, flow->psh_count, flow->rst_count, flow->syn_count, flow->fin_count);\n\n   /* TCP window */\n   fprintf(csv_fp, \"%u,%u,\", flow->c_to_s_init_win, flow->s_to_c_init_win);\n\n    fprintf(csv_fp, \"%s,%s,\",\n\t    (flow->ssh_tls.client_requested_server_name[0] != '\\0')  ? flow->ssh_tls.client_requested_server_name : \"\",\n\t    (flow->ssh_tls.server_info[0] != '\\0')  ? flow->ssh_tls.server_info : \"\");\n\n    fprintf(csv_fp, \"%s,%s,%s,%s,%s,\",\n\t    (flow->ssh_tls.ssl_version != 0)        ? ndpi_ssl_version2str(flow->ssh_tls.ssl_version, &known_tls) : \"0\",\n\t    (flow->ssh_tls.ja3_client[0] != '\\0')   ? flow->ssh_tls.ja3_client : \"\",\n\t    (flow->ssh_tls.ja3_client[0] != '\\0')   ? is_unsafe_cipher(flow->ssh_tls.client_unsafe_cipher) : \"0\",\n\t    (flow->ssh_tls.ja3_server[0] != '\\0')   ? flow->ssh_tls.ja3_server : \"\",\n\t    (flow->ssh_tls.ja3_server[0] != '\\0')   ? is_unsafe_cipher(flow->ssh_tls.server_unsafe_cipher) : \"0\");\n    \n    fprintf(csv_fp, \"%s,%s,\",\n\t    flow->ssh_tls.tls_alpn                  ? flow->ssh_tls.tls_alpn : \"\",\n\t    flow->ssh_tls.tls_supported_versions    ? flow->ssh_tls.tls_supported_versions : \"\" \n\t    );\n    fprintf(csv_fp, \"%s,%s,\",\n\t    flow->ssh_tls.tls_issuerDN              ? flow->ssh_tls.tls_issuerDN : \"\",\n\t    flow->ssh_tls.tls_subjectDN             ? flow->ssh_tls.tls_subjectDN : \"\" \n\t    );\n    fprintf(csv_fp, \"%s,%s\",\n\t    (flow->ssh_tls.client_hassh[0] != '\\0') ? flow->ssh_tls.client_hassh : \"\",\n\t    (flow->ssh_tls.server_hassh[0] != '\\0') ? flow->ssh_tls.server_hassh : \"\"\n\t    );\n\n    fprintf(csv_fp, \",%s\", flow->info);\n  }\n\n  if((verbose != 1) && (verbose != 2)) {\n    if(csv_fp && enable_joy_stats) {\n      flowGetBDMeanandVariance(flow);\n    }\n\n    if(csv_fp)\n      fprintf(csv_fp, \"\\n\");\n    return;\n  }\n\n  if(csv_fp || (verbose > 1)) {\n#if 1\n  fprintf(out, \"\\t%u\", id);\n#else\n  fprintf(out, \"\\t%u(%u)\", id, flow->flow_id);\n#endif\n\n  fprintf(out, \"\\t%s \", ipProto2Name(flow->protocol));\n\n  fprintf(out, \"%s%s%s:%u %s %s%s%s:%u \",\n\t  (flow->ip_version == 6) ? \"[\" : \"\",\n\t  flow->src_name, (flow->ip_version == 6) ? \"]\" : \"\", ntohs(flow->src_port),\n\t  flow->bidirectional ? \"<->\" : \"->\",\n\t  (flow->ip_version == 6) ? \"[\" : \"\",\n\t  flow->dst_name, (flow->ip_version == 6) ? \"]\" : \"\", ntohs(flow->dst_port)\n\t  );\n\n  if(flow->vlan_id > 0) fprintf(out, \"[VLAN: %u]\", flow->vlan_id);\n  if(enable_payload_analyzer) fprintf(out, \"[flowId: %u]\", flow->flow_id);\n  }\n  \n  if(enable_joy_stats) {\n    /* Print entropy values for monitored flows. */\n    flowGetBDMeanandVariance(flow);\n    fflush(out);\n    fprintf(out, \"[score: %.4f]\", flow->entropy.score);\n  }\n\t\n  if(csv_fp) fprintf(csv_fp, \"\\n\");\n    \n  fprintf(out, \"[proto: \");\n  if(flow->tunnel_type != ndpi_no_tunnel)\n    fprintf(out, \"%s:\", ndpi_tunnel2str(flow->tunnel_type));\n\n  fprintf(out, \"%s/%s]\",\n\t  ndpi_protocol2id(ndpi_thread_info[thread_id].workflow->ndpi_struct,\n\t\t\t   flow->detected_protocol, buf, sizeof(buf)),\n\t  ndpi_protocol2name(ndpi_thread_info[thread_id].workflow->ndpi_struct,\n\t\t\t     flow->detected_protocol, buf1, sizeof(buf1)));\n\n  if(flow->detected_protocol.category != 0)\n    fprintf(out, \"[cat: %s/%u]\",\n\t    ndpi_category_get_name(ndpi_thread_info[thread_id].workflow->ndpi_struct,\n\t\t\t\t   flow->detected_protocol.category),\n\t    (unsigned int)flow->detected_protocol.category);\n\n  fprintf(out, \"[%u pkts/%llu bytes \", flow->src2dst_packets, (long long unsigned int) flow->src2dst_bytes);\n  fprintf(out, \"%s %u pkts/%llu bytes]\",\n\t  (flow->dst2src_packets > 0) ? \"<->\" : \"->\",\n\t  flow->dst2src_packets, (long long unsigned int) flow->dst2src_bytes);\n\n  fprintf(out, \"[Goodput ratio: %.0f/%.0f]\",\n\t  100.0*((float)flow->src2dst_goodput_bytes / (float)(flow->src2dst_bytes+1)),\n\t  100.0*((float)flow->dst2src_goodput_bytes / (float)(flow->dst2src_bytes+1)));\n\n  if(flow->last_seen > flow->first_seen)\n    fprintf(out, \"[%.2f sec]\", ((float)(flow->last_seen - flow->first_seen))/(float)1000);\n  else\n    fprintf(out, \"[< 1 sec]\");\n\n  if(flow->telnet.username[0] != '\\0')  fprintf(out, \"[Username: %s]\", flow->telnet.username);\n  if(flow->telnet.password[0] != '\\0')  fprintf(out, \"[Password: %s]\", flow->telnet.password);\n  if(flow->host_server_name[0] != '\\0') fprintf(out, \"[Host: %s]\", flow->host_server_name);\n\n  if(flow->info[0] != '\\0') fprintf(out, \"[%s]\", flow->info);\n  if(flow->flow_extra_info[0] != '\\0') fprintf(out, \"[%s]\", flow->flow_extra_info);\n\n  if((flow->src2dst_packets+flow->dst2src_packets) > 5) {\n    if(flow->iat_c_to_s && flow->iat_s_to_c) {\n      float data_ratio = ndpi_data_ratio(flow->src2dst_bytes, flow->dst2src_bytes);\n\n      fprintf(out, \"[bytes ratio: %.3f (%s)]\", data_ratio, ndpi_data_ratio2str(data_ratio));\n\n      /* IAT (Inter Arrival Time) */\n      fprintf(out, \"[IAT c2s/s2c min/avg/max/stddev: %u/%u %.0f/%.0f %u/%u %.0f/%.0f]\",\n\t      ndpi_data_min(flow->iat_c_to_s),     ndpi_data_min(flow->iat_s_to_c),\n\t      (float)ndpi_data_average(flow->iat_c_to_s), (float)ndpi_data_average(flow->iat_s_to_c),\n\t      ndpi_data_max(flow->iat_c_to_s),     ndpi_data_max(flow->iat_s_to_c),\n\t      (float)ndpi_data_stddev(flow->iat_c_to_s),  (float)ndpi_data_stddev(flow->iat_s_to_c));\n\n      /* Packet Length */\n      fprintf(out, \"[Pkt Len c2s/s2c min/avg/max/stddev: %u/%u %.0f/%.0f %u/%u %.0f/%.0f]\",\n\t      ndpi_data_min(flow->pktlen_c_to_s), ndpi_data_min(flow->pktlen_s_to_c),\n\t      ndpi_data_average(flow->pktlen_c_to_s), ndpi_data_average(flow->pktlen_s_to_c),\n\t      ndpi_data_max(flow->pktlen_c_to_s), ndpi_data_max(flow->pktlen_s_to_c),\n\t      ndpi_data_stddev(flow->pktlen_c_to_s),  ndpi_data_stddev(flow->pktlen_s_to_c));\n    }\n  }\n\n  if(flow->http.url[0] != '\\0') {\n    ndpi_risk_enum risk = ndpi_validate_url(flow->http.url);\n\n    if(risk != NDPI_NO_RISK)\n      NDPI_SET_BIT(flow->risk, risk);\n    \n    fprintf(out, \"[URL: %s[StatusCode: %u]\",\n\t    flow->http.url, flow->http.response_status_code);\n\n    if(flow->http.content_type[0] != '\\0')\n      fprintf(out, \"[ContentType: %s]\", flow->http.content_type);\n\n    if(flow->http.user_agent[0] != '\\0')\n      fprintf(out, \"[UserAgent: %s]\", flow->http.user_agent);\n  }\n\n  if(flow->risk) {\n    u_int i;\n    \n    fprintf(out, \"[Risk: \");\n\n    for(i=0; i<NDPI_MAX_RISK; i++)\n      if(NDPI_ISSET_BIT(flow->risk, i))\n\tfprintf(out, \"** %s **\", ndpi_risk2str(i));\n    \n    fprintf(out, \"]\");\n  }\n  \n  if(flow->ssh_tls.ssl_version != 0) fprintf(out, \"[%s]\", ndpi_ssl_version2str(flow->ssh_tls.ssl_version, &known_tls));\n  if(flow->ssh_tls.client_requested_server_name[0] != '\\0') fprintf(out, \"[Client: %s]\", flow->ssh_tls.client_requested_server_name);\n  if(flow->ssh_tls.client_hassh[0] != '\\0') fprintf(out, \"[HASSH-C: %s]\", flow->ssh_tls.client_hassh);\n\n  if(flow->ssh_tls.ja3_client[0] != '\\0') fprintf(out, \"[JA3C: %s%s]\", flow->ssh_tls.ja3_client,\n\t\t\t\t\t\t  print_cipher(flow->ssh_tls.client_unsafe_cipher));\n\n  if(flow->ssh_tls.server_info[0] != '\\0') fprintf(out, \"[Server: %s]\", flow->ssh_tls.server_info);\n\n  if(flow->ssh_tls.server_names) fprintf(out, \"[ServerNames: %s]\", flow->ssh_tls.server_names);\n  if(flow->ssh_tls.server_hassh[0] != '\\0') fprintf(out, \"[HASSH-S: %s]\", flow->ssh_tls.server_hassh);\n\n  if(flow->ssh_tls.ja3_server[0] != '\\0') fprintf(out, \"[JA3S: %s%s]\", flow->ssh_tls.ja3_server,\n\t\t\t\t\t\t  print_cipher(flow->ssh_tls.server_unsafe_cipher));\n\n  if(flow->ssh_tls.tls_issuerDN)  fprintf(out, \"[Issuer: %s]\", flow->ssh_tls.tls_issuerDN);\n  if(flow->ssh_tls.tls_subjectDN) fprintf(out, \"[Subject: %s]\", flow->ssh_tls.tls_subjectDN);\n\n  if((flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)\n     || (flow->detected_protocol.app_protocol == NDPI_PROTOCOL_TLS)) {\n    if(flow->ssh_tls.sha1_cert_fingerprint_set) {\n      fprintf(out, \"[Certificate SHA-1: \");\n      for(i=0; i<20; i++)\n\tfprintf(out, \"%s%02X\", (i > 0) ? \":\" : \"\",\n\t\tflow->ssh_tls.sha1_cert_fingerprint[i] & 0xFF);\n      fprintf(out, \"]\");\n    }\n  }\n\n  if(flow->ssh_tls.notBefore && flow->ssh_tls.notAfter) {\n    char notBefore[32], notAfter[32];\n    struct tm a, b;\n    struct tm *before = gmtime_r(&flow->ssh_tls.notBefore, &a);\n    struct tm *after  = gmtime_r(&flow->ssh_tls.notAfter, &b);\n\n    strftime(notBefore, sizeof(notBefore), \"%F %T\", before);\n    strftime(notAfter, sizeof(notAfter), \"%F %T\", after);\n\n    fprintf(out, \"[Validity: %s - %s]\", notBefore, notAfter);\n  }\n\n  if(flow->ssh_tls.server_cipher != '\\0') fprintf(out, \"[Cipher: %s]\", ndpi_cipher2str(flow->ssh_tls.server_cipher));\n  if(flow->bittorent_hash[0] != '\\0') fprintf(out, \"[BT Hash: %s]\", flow->bittorent_hash);\n  if(flow->dhcp_fingerprint[0] != '\\0') fprintf(out, \"[DHCP Fingerprint: %s]\", flow->dhcp_fingerprint);\n\n  if(flow->has_human_readeable_strings) fprintf(out, \"[PLAIN TEXT (%s)]\", flow->human_readeable_string_buffer);\n\n  fprintf(out, \"\\n\");\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15472"
    },
    {
        "index": 646,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* begin = GetInput(context, node, kBeginTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Ensure validity of input tensor and its dimension.\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE(context,\n                 begin->type == kTfLiteInt32 || begin->type == kTfLiteInt64);\n  TF_LITE_ENSURE(context,\n                 size->type == kTfLiteInt32 || size->type == kTfLiteInt64);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(begin), 1);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(begin), NumElements(size));\n  TF_LITE_ENSURE_MSG(context, NumDimensions(input) <= kMaxDim,\n                     \"Slice op only supports 1D-4D input arrays.\");\n\n  // Postpone allocation of output if any of the indexing tensors is not\n  // constant\n  if (!(IsConstantTensor(begin) && IsConstantTensor(size))) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  return ResizeOutputShape(context, input, begin, size, output);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 647,
        "code": "void RemoteFrame::Navigate(const FrameLoadRequest& passed_request) {\n  FrameLoadRequest frame_request(passed_request);\n\n  FrameLoader::SetReferrerForFrameRequest(frame_request);\n   FrameLoader::UpgradeInsecureRequest(frame_request.GetResourceRequest(),\n                                       frame_request.OriginDocument());\n \n  frame_request.GetResourceRequest().SetHasUserGesture(\n      Frame::HasTransientUserActivation(this));\n   Client()->Navigate(frame_request.GetResourceRequest(),\n                      frame_request.ReplacesCurrentItem());\n }\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-5790"
    },
    {
        "index": 648,
        "code": "TfLiteStatus HardSwishPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    HardSwishParams* params = static_cast<HardSwishParams*>(node->user_data);\n\n    params->input_zero_point = input->params.zero_point;\n    params->output_zero_point = output->params.zero_point;\n\n    const float input_scale = input->params.scale;\n    const float hires_input_scale = (1.0f / 128.0f) * input_scale;\n    const float reluish_scale = 3.0f / 32768.0f;\n    const float output_scale = output->params.scale;\n\n    const double output_multiplier =\n        static_cast<double>(hires_input_scale / output_scale);\n    int32_t output_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(output_multiplier, &output_multiplier_fixedpoint_int32,\n                       &params->output_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        output_multiplier_fixedpoint_int32,\n        &params->output_multiplier_fixedpoint_int16);\n\n    TF_LITE_ENSURE(context, params->output_multiplier_exponent <= 0);\n\n    const double reluish_multiplier =\n        static_cast<double>(hires_input_scale / reluish_scale);\n    int32_t reluish_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(reluish_multiplier, &reluish_multiplier_fixedpoint_int32,\n                       &params->reluish_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        reluish_multiplier_fixedpoint_int32,\n        &params->reluish_multiplier_fixedpoint_int16);\n  }\n\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 649,
        "code": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; // TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n      \n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n        /*if (*ret)\n            Jsi_DecrRefCount(interp, *ret);\n        *ret = _this;\n        Jsi_IncrRefCount(interp, *ret);*/\n    }\n    return rc;\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2020-22875"
    },
    {
        "index": 650,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  if (type != kTfLiteBool) {\n    context->ReportError(context, \"Logical ops only support bool type.\");\n    return kTfLiteError;\n  }\n  output->type = type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 651,
        "code": "bool logToUSDT(const Array& bt) {\n  std::lock_guard<std::mutex> lock(usdt_mutex);\n\n  memset(&bt_slab, 0, sizeof(bt_slab));\n\n  int i = 0;\n  IterateVNoInc(\n    bt.get(),\n    [&](TypedValue tv) -> bool {\n\n      if (i >= strobelight::kMaxStackframes) {\n        return true;\n      }\n\n      assertx(isArrayLikeType(type(tv)));\n      ArrayData* bt_frame = val(tv).parr;\n      strobelight::backtrace_frame_t* frame = &bt_slab.frames[i];\n\n      auto const line = bt_frame->get(s_line.get());\n      if (line.is_init()) {\n        assertx(isIntType(type(line)));\n        frame->line = val(line).num;\n      }\n\n      auto const file_name = bt_frame->get(s_file.get());\n      if (file_name.is_init()) {\n        assertx(isStringType(type(file_name)));\n        strncpy(frame->file_name,\n                val(file_name).pstr->data(),\n                std::min(val(file_name).pstr->size(), strobelight::kFileNameMax));\n        frame->file_name[strobelight::kFileNameMax - 1] = '\\0';\n      }\n\n      auto const class_name = bt_frame->get(s_class.get());\n      if (class_name.is_init()) {\n        assertx(isStringType(type(class_name)));\n        strncpy(frame->class_name,\n                val(class_name).pstr->data(),\n                std::min(val(class_name).pstr->size(), strobelight::kClassNameMax));\n        frame->class_name[strobelight::kClassNameMax - 1] = '\\0';\n      }\n\n      auto const function_name = bt_frame->get(s_function.get());\n      if (function_name.is_init()) {\n        assertx(isStringType(type(function_name)));\n        strncpy(frame->function,\n                val(function_name).pstr->data(),\n                std::min(val(function_name).pstr->size(),\n                         strobelight::kFunctionMax));\n        frame->function[strobelight::kFunctionMax - 1] = '\\0';\n      }\n\n      i++;\n      return false;\n    }\n  );\n  bt_slab.len = i;\n\n  // Allow BPF to read the now-formatted stacktrace\n  FOLLY_SDT_WITH_SEMAPHORE(hhvm, hhvm_stack, &bt_slab);\n\n  return true;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 652,
        "code": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedwriter_14BufferedWriter_10write_strings(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_items, PyObject *__pyx_v_encoding) {\n  int __pyx_v_do_encode;\n  PyObject *__pyx_v_value = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  Py_ssize_t __pyx_t_3;\n  PyObject *(*__pyx_t_4)(PyObject *);\n  PyObject *__pyx_t_5 = NULL;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  Py_ssize_t __pyx_t_8;\n  PyObject *__pyx_t_9 = NULL;\n  int __pyx_t_10;\n  PyObject *__pyx_t_11 = NULL;\n  __Pyx_RefNannySetupContext(\"write_strings\", 0);\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":50\n * \n *     def write_strings(self, items, encoding=None):\n *         cdef int do_encode = encoding is not None             # <<<<<<<<<<<<<<\n * \n *         for value in items:\n */\n  __pyx_t_1 = (__pyx_v_encoding != Py_None);\n  __pyx_v_do_encode = __pyx_t_1;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":52\n *         cdef int do_encode = encoding is not None\n * \n *         for value in items:             # <<<<<<<<<<<<<<\n *             if not PyBytes_Check(value):\n *                 if do_encode:\n */\n  if (likely(PyList_CheckExact(__pyx_v_items)) || PyTuple_CheckExact(__pyx_v_items)) {\n    __pyx_t_2 = __pyx_v_items; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;\n    __pyx_t_4 = NULL;\n  } else {\n    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 52, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 52, __pyx_L1_error)\n  }\n  for (;;) {\n    if (likely(!__pyx_t_4)) {\n      if (likely(PyList_CheckExact(__pyx_t_2))) {\n        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;\n        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS\n        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 52, __pyx_L1_error)\n        #else\n        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 52, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        #endif\n      } else {\n        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;\n        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS\n        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 52, __pyx_L1_error)\n        #else\n        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 52, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        #endif\n      }\n    } else {\n      __pyx_t_5 = __pyx_t_4(__pyx_t_2);\n      if (unlikely(!__pyx_t_5)) {\n        PyObject* exc_type = PyErr_Occurred();\n        if (exc_type) {\n          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();\n          else __PYX_ERR(0, 52, __pyx_L1_error)\n        }\n        break;\n      }\n      __Pyx_GOTREF(__pyx_t_5);\n    }\n    __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_5);\n    __pyx_t_5 = 0;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":53\n * \n *         for value in items:\n *             if not PyBytes_Check(value):             # <<<<<<<<<<<<<<\n *                 if do_encode:\n *                     value = value.encode(encoding)\n */\n    __pyx_t_1 = ((!(PyBytes_Check(__pyx_v_value) != 0)) != 0);\n    if (__pyx_t_1) {\n\n      /* \"clickhouse_driver/bufferedwriter.pyx\":54\n *         for value in items:\n *             if not PyBytes_Check(value):\n *                 if do_encode:             # <<<<<<<<<<<<<<\n *                     value = value.encode(encoding)\n *                 else:\n */\n      __pyx_t_1 = (__pyx_v_do_encode != 0);\n      if (likely(__pyx_t_1)) {\n\n        /* \"clickhouse_driver/bufferedwriter.pyx\":55\n *             if not PyBytes_Check(value):\n *                 if do_encode:\n *                     value = value.encode(encoding)             # <<<<<<<<<<<<<<\n *                 else:\n *                     raise ValueError('bytes object expected')\n */\n        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_encode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 55, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_6);\n        __pyx_t_7 = NULL;\n        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {\n          __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);\n          if (likely(__pyx_t_7)) {\n            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);\n            __Pyx_INCREF(__pyx_t_7);\n            __Pyx_INCREF(function);\n            __Pyx_DECREF_SET(__pyx_t_6, function);\n          }\n        }\n        __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_encoding) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_encoding);\n        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;\n        if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 55, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n        __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_5);\n        __pyx_t_5 = 0;\n\n        /* \"clickhouse_driver/bufferedwriter.pyx\":54\n *         for value in items:\n *             if not PyBytes_Check(value):\n *                 if do_encode:             # <<<<<<<<<<<<<<\n *                     value = value.encode(encoding)\n *                 else:\n */\n        goto __pyx_L6;\n      }\n\n      /* \"clickhouse_driver/bufferedwriter.pyx\":57\n *                     value = value.encode(encoding)\n *                 else:\n *                     raise ValueError('bytes object expected')             # <<<<<<<<<<<<<<\n * \n *             write_varint(len(value), self)\n */\n      /*else*/ {\n        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 57, __pyx_L1_error)\n        __Pyx_GOTREF(__pyx_t_5);\n        __Pyx_Raise(__pyx_t_5, 0, 0, 0);\n        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n        __PYX_ERR(0, 57, __pyx_L1_error)\n      }\n      __pyx_L6:;\n\n      /* \"clickhouse_driver/bufferedwriter.pyx\":53\n * \n *         for value in items:\n *             if not PyBytes_Check(value):             # <<<<<<<<<<<<<<\n *                 if do_encode:\n *                     value = value.encode(encoding)\n */\n    }\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":59\n *                     raise ValueError('bytes object expected')\n * \n *             write_varint(len(value), self)             # <<<<<<<<<<<<<<\n *             self.write(value)\n * \n */\n    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_write_varint); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 59, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_6);\n    __pyx_t_8 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 59, __pyx_L1_error)\n    __pyx_t_7 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 59, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_9 = NULL;\n    __pyx_t_10 = 0;\n    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {\n      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_6);\n      if (likely(__pyx_t_9)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);\n        __Pyx_INCREF(__pyx_t_9);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_6, function);\n        __pyx_t_10 = 1;\n      }\n    }\n    #if CYTHON_FAST_PYCALL\n    if (PyFunction_Check(__pyx_t_6)) {\n      PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_t_7, ((PyObject *)__pyx_v_self)};\n      __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 59, __pyx_L1_error)\n      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    } else\n    #endif\n    #if CYTHON_FAST_PYCCALL\n    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {\n      PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_t_7, ((PyObject *)__pyx_v_self)};\n      __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 59, __pyx_L1_error)\n      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    } else\n    #endif\n    {\n      __pyx_t_11 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 59, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_11);\n      if (__pyx_t_9) {\n        __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_9); __pyx_t_9 = NULL;\n      }\n      __Pyx_GIVEREF(__pyx_t_7);\n      PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_10, __pyx_t_7);\n      __Pyx_INCREF(((PyObject *)__pyx_v_self));\n      __Pyx_GIVEREF(((PyObject *)__pyx_v_self));\n      PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_10, ((PyObject *)__pyx_v_self));\n      __pyx_t_7 = 0;\n      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_11, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 59, __pyx_L1_error)\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;\n    }\n    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":60\n * \n *             write_varint(len(value), self)\n *             self.write(value)             # <<<<<<<<<<<<<<\n * \n * \n */\n    __pyx_t_5 = ((struct __pyx_vtabstruct_17clickhouse_driver_14bufferedwriter_BufferedWriter *)__pyx_v_self->__pyx_vtab)->write(__pyx_v_self, __pyx_v_value, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 60, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_5);\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":52\n *         cdef int do_encode = encoding is not None\n * \n *         for value in items:             # <<<<<<<<<<<<<<\n *             if not PyBytes_Check(value):\n *                 if do_encode:\n */\n  }\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":49\n *         self.write_into_stream()\n * \n *     def write_strings(self, items, encoding=None):             # <<<<<<<<<<<<<<\n *         cdef int do_encode = encoding is not None\n * \n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_9);\n  __Pyx_XDECREF(__pyx_t_11);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.BufferedWriter.write_strings\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_value);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 654,
        "code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; // includes check for end of string\n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1888"
    },
    {
        "index": 655,
        "code": "int64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n  }\n  m_cursor += length;\n  return length;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1919"
    },
    {
        "index": 656,
        "code": "static void processCertificateElements(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t       struct ndpi_flow_struct *flow,\n\t\t\t\t       u_int16_t p_offset, u_int16_t certificate_len) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int num_found = 0, i;\n  char buffer[64] = { '\\0' }, rdnSeqBuf[1024] = { '\\0' };\n  u_int rdn_len = 0;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s() [offset: %u][certificate_len: %u]\\n\", __FUNCTION__, p_offset, certificate_len);\n#endif\n\n  /* Check after handshake protocol header (5 bytes) and message header (4 bytes) */\n  for(i = p_offset; i < certificate_len; i++) {\n    /*\n       See https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.5.0/com.ibm.mq.sec.doc/q009860_.htm\n       for X.509 certificate labels\n    */\n    if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03)) {\n      /* Common Name */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"CN\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Common Name\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x06)) {\n      /* Country */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"C\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Country\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x07)) {\n      /* Locality */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"L\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Locality\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x08)) {\n      /* State or Province */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"ST\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"State or Province\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0a)) {\n      /* Organization Name */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"O\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Organization Name\", buffer);\n#endif\n\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0b)) {\n      /* Organization Unit */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"OU\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Organization Unit\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x30) && (packet->payload[i+1] == 0x1e) && (packet->payload[i+2] == 0x17)) {\n      /* Certificate Validity */\n      u_int8_t len = packet->payload[i+3];\n      u_int offset = i+4;\n\n      if(num_found == 0) {\n\tnum_found++;\n\n#ifdef DEBUG_TLS\n\tprintf(\"[TLS] %s() IssuerDN [%s]\\n\", __FUNCTION__, rdnSeqBuf);\n#endif\n\n\tif(rdn_len) flow->protos.stun_ssl.ssl.issuerDN = ndpi_strdup(rdnSeqBuf);\n\trdn_len = 0; /* Reset buffer */\n      }\n\n      if((offset+len) < packet->payload_packet_len) {\n\tchar utcDate[32];\n\n#ifdef DEBUG_TLS\n\tu_int j;\n\n\tprintf(\"[CERTIFICATE] notBefore [len: %u][\", len);\n\tfor(j=0; j<len; j++) printf(\"%c\", packet->payload[i+4+j]);\n\tprintf(\"]\\n\");\n#endif\n\n\tif(len < (sizeof(utcDate)-1)) {\n\t  struct tm utc;\n\t  utc.tm_isdst = -1; /* Not set by strptime */\n\n\t  strncpy(utcDate, (const char*)&packet->payload[i+4], len);\n\t  utcDate[len] = '\\0';\n\n\t  /* 141021000000Z */\n\t  if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {\n\t    flow->protos.stun_ssl.ssl.notBefore = timegm(&utc);\n#ifdef DEBUG_TLS\n\t    printf(\"[CERTIFICATE] notBefore %u [%s]\\n\",\n\t\t   flow->protos.stun_ssl.ssl.notBefore, utcDate);\n#endif\n\t  }\n\t}\n\n\toffset += len;\n\n\tif((offset+1) < packet->payload_packet_len) {\n\t  len = packet->payload[offset+1];\n\n\t  offset += 2;\n\n\t  if((offset+len) < packet->payload_packet_len) {\n\t    u_int32_t time_sec = flow->packet.current_time_ms / 1000;\n#ifdef DEBUG_TLS\n\t    u_int j;\n\n\t    printf(\"[CERTIFICATE] notAfter [len: %u][\", len);\n\t    for(j=0; j<len; j++) printf(\"%c\", packet->payload[offset+j]);\n\t    printf(\"]\\n\");\n#endif\n\n\t    if(len < (sizeof(utcDate)-1)) {\n\t      struct tm utc;\n\t      utc.tm_isdst = -1; /* Not set by strptime */\n\n\t      strncpy(utcDate, (const char*)&packet->payload[offset], len);\n\t      utcDate[len] = '\\0';\n\n\t      /* 141021000000Z */\n\t      if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {\n\t\tflow->protos.stun_ssl.ssl.notAfter = timegm(&utc);\n#ifdef DEBUG_TLS\n\t\tprintf(\"[CERTIFICATE] notAfter %u [%s]\\n\",\n\t\t       flow->protos.stun_ssl.ssl.notAfter, utcDate);\n#endif\n\t      }\n\t    }\n\n\n\t    if((time_sec < flow->protos.stun_ssl.ssl.notBefore)\n\t       || (time_sec > flow->protos.stun_ssl.ssl.notAfter))\n\t    NDPI_SET_BIT(flow->risk, NDPI_TLS_CERTIFICATE_EXPIRED); /* Certificate expired */\n\t  }\n\t}\n      }\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x1d) && (packet->payload[i+2] == 0x11)) {\n      /* Organization OID: 2.5.29.17 (subjectAltName) */\n      u_int8_t matched_name = 0;\n\n#ifdef DEBUG_TLS\n      printf(\"******* [TLS] Found subjectAltName\\n\");\n#endif\n\n      i += 3 /* skip the initial patten 55 1D 11 */;\n      i++; /* skip the first type, 0x04 == BIT STRING, and jump to it's length */\n      if(i < packet->payload_packet_len) {\n\ti += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip BIT STRING length */\n\tif(i < packet->payload_packet_len) {\n\t  i += 2; /* skip the second type, 0x30 == SEQUENCE, and jump to it's length */\n\t  if(i < packet->payload_packet_len) {\n\t    i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip SEQUENCE length */\n\t    i++;\n\n\t    while(i < packet->payload_packet_len) {\n\t      if(packet->payload[i] == 0x82) {\n\t\tif((i < (packet->payload_packet_len - 1))\n\t\t   && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {\n\t\t  u_int8_t len = packet->payload[i + 1];\n\t\t  char dNSName[256];\n\n\t\t  i += 2;\n\n\t\t  /* The check \"len > sizeof(dNSName) - 1\" will be always false. If we add it,\n\t\t     the compiler is smart enough to detect it and throws a warning */\n\t\t  if(len == 0 /* Looks something went wrong */)\n\t\t    break;\n\n\t\t  strncpy(dNSName, (const char*)&packet->payload[i], len);\n\t\t  dNSName[len] = '\\0';\n\n\t\t  cleanupServerName(dNSName, len);\n\n#if DEBUG_TLS\n\t\t  printf(\"[TLS] dNSName %s [%s]\\n\", dNSName, flow->protos.stun_ssl.ssl.client_requested_server_name);\n#endif\n\t\t  if(matched_name == 0) {\n\t\t    if((dNSName[0] == '*') && strstr(flow->protos.stun_ssl.ssl.client_requested_server_name, &dNSName[1]))\n\t\t      matched_name = 1;\n\t\t    else if(strcmp(flow->protos.stun_ssl.ssl.client_requested_server_name, dNSName) == 0)\n\t\t      matched_name = 1;\n\t\t  }\n\n\t\t  if(flow->protos.stun_ssl.ssl.server_names == NULL)\n\t\t    flow->protos.stun_ssl.ssl.server_names = ndpi_strdup(dNSName),\n\t\t      flow->protos.stun_ssl.ssl.server_names_len = strlen(dNSName);\n\t\t  else {\n\t\t    u_int16_t dNSName_len = strlen(dNSName);\n\t\t    u_int16_t newstr_len = flow->protos.stun_ssl.ssl.server_names_len + dNSName_len + 1;\n\t\t    char *newstr = (char*)ndpi_realloc(flow->protos.stun_ssl.ssl.server_names,\n\t\t\t\t\t\t       flow->protos.stun_ssl.ssl.server_names_len+1, newstr_len+1);\n\n\t\t    if(newstr) {\n\t\t      flow->protos.stun_ssl.ssl.server_names = newstr;\n\t\t      flow->protos.stun_ssl.ssl.server_names[flow->protos.stun_ssl.ssl.server_names_len] = ',';\n\t\t      strncpy(&flow->protos.stun_ssl.ssl.server_names[flow->protos.stun_ssl.ssl.server_names_len+1],\n\t\t\t      dNSName, dNSName_len+1);\n\t\t      flow->protos.stun_ssl.ssl.server_names[newstr_len] = '\\0';\n\t\t      flow->protos.stun_ssl.ssl.server_names_len = newstr_len;\n\t\t    }\n\t\t  }\n\n\t\t  if(!flow->l4.tcp.tls.subprotocol_detected)\n\t\t    if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))\n\t\t      flow->l4.tcp.tls.subprotocol_detected = 1;\n\n\t\t  i += len;\n\t\t} else {\n#if DEBUG_TLS\n\t\t  printf(\"[TLS] Leftover %u bytes\", packet->payload_packet_len - i);\n#endif\n\t\t  break;\n\t\t}\n\t      } else {\n\t\tbreak;\n\t      }\n\t    } /* while */\n\n\t    if(!matched_name)\n\t      NDPI_SET_BIT(flow->risk, NDPI_TLS_CERTIFICATE_MISMATCH); /* Certificate mismatch */\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(rdn_len) flow->protos.stun_ssl.ssl.subjectDN = ndpi_strdup(rdnSeqBuf);\n\n  if(flow->protos.stun_ssl.ssl.subjectDN && flow->protos.stun_ssl.ssl.issuerDN\n     && (!strcmp(flow->protos.stun_ssl.ssl.subjectDN, flow->protos.stun_ssl.ssl.issuerDN)))\n    NDPI_SET_BIT(flow->risk, NDPI_TLS_SELFSIGNED_CERTIFICATE);\n\n#if DEBUG_TLS\n  printf(\"[TLS] %s() SubjectDN [%s]\\n\", __FUNCTION__, rdnSeqBuf);\n#endif\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15474"
    },
    {
        "index": 657,
        "code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       /*runtime_inputs=*/1, /*outputs=*/1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 658,
        "code": "static int exif_scan_thumbnail(image_info_type *ImageInfo) {\n  unsigned char c, *data = (unsigned char*)ImageInfo->Thumbnail.data;\n  int n, marker;\n  size_t length=2, pos=0;\n  jpeg_sof_info sof_info;\n\n  if (!data || ImageInfo->Thumbnail.size < 4) {\n    return 0; /* nothing to do here */\n  }\n  if (memcmp(data, \"\\xFF\\xD8\\xFF\", 3)) {\n    if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {\n      raise_warning(\"Thumbnail is not a JPEG image\");\n    }\n    return 0;\n  }\n  for (;;) {\n    pos += length;\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    c = data[pos++];\n    if (pos>=ImageInfo->Thumbnail.size)\n      return 0;\n    if (c != 0xFF) {\n      return 0;\n    }\n    n = 8;\n    while ((c = data[pos++]) == 0xFF && n--) {\n      if (pos+3>=ImageInfo->Thumbnail.size)\n        return 0;\n      /* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n    }\n    if (c == 0xFF)\n      return 0;\n    marker = c;\n    length = php_jpg_get16(data+pos);\n    if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {\n      return 0;\n    }\n    switch (marker) {\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        /* handle SOFn block */\n        if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {\n          /* exif_process_SOFn needs 8 bytes */\n          return 0;\n        }\n        exif_process_SOFn(data+pos, marker, &sof_info);\n        ImageInfo->Thumbnail.height   = sof_info.height;\n        ImageInfo->Thumbnail.width    = sof_info.width;\n        return 1;\n\n      case M_SOS:\n      case M_EOI:\n        raise_warning(\"Could not compute size of thumbnail\");\n        return 0;\n        break;\n\n      default:\n        /* just skip */\n        break;\n    }\n  }\n\n  raise_warning(\"Could not compute size of thumbnail\");\n  return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-1921"
    },
    {
        "index": 659,
        "code": "gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    ((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n",
        "cwe_id": "CWE-189",
        "cve_id": "CVE-2019-17546"
    },
    {
        "index": 661,
        "code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* cond = GetInput(context, node, 0);\n  bool cond_value = cond->data.b[0];\n\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n\n  // Currently we copy the input / output between the subgraphs. This isn't\n  // optimized yet.\n  // TODO(b/120234921): Optimize and avoid copying tensors between subgraphs.\n  int active_branch_subgraph_index =\n      cond_value ? op_data->then_subgraph_index : op_data->else_subgraph_index;\n  Subgraph& active_branch_subgraph =\n      *(*subgraphs)[active_branch_subgraph_index];\n  for (int i = 0; i < active_branch_subgraph.inputs().size(); ++i) {\n    const TfLiteTensor* input = GetInput(context, node, i + 1);\n    TfLiteTensor* subgraph_input =\n        active_branch_subgraph.tensor(active_branch_subgraph.inputs()[i]);\n    TF_LITE_ENSURE_EQ(context, input->bytes, subgraph_input->bytes);\n    memcpy(subgraph_input->data.raw, input->data.raw, input->bytes);\n  }\n\n  // Note: It's guaranteed that the subgraphs' `AllocateTensors` are called\n  // in `Prepare`, so we don't need to do it here again.\n  TF_LITE_ENSURE_OK(context, active_branch_subgraph.Invoke());\n\n  for (int tensor_index : active_branch_subgraph.outputs()) {\n    active_branch_subgraph.EnsureTensorDataIsReadable(tensor_index);\n  }\n\n  bool has_dynamic_output_tensors = false;\n  for (int i = 0; i < node->outputs->size; ++i) {\n    TfLiteTensor* output = GetOutput(context, node, i);\n    if (IsDynamicTensor(output)) {\n      has_dynamic_output_tensors = true;\n      break;\n    }\n  }\n\n  if (has_dynamic_output_tensors) {\n    for (int i = 0; i < node->outputs->size; ++i) {\n      TfLiteTensor* output = GetOutput(context, node, i);\n      TfLiteTensor* subgraph_output =\n          active_branch_subgraph.tensor(active_branch_subgraph.outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(subgraph_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n\n  for (int i = 0; i < active_branch_subgraph.outputs().size(); ++i) {\n    const TfLiteTensor* subgraph_output =\n        active_branch_subgraph.tensor(active_branch_subgraph.outputs()[i]);\n    TfLiteTensor* output = GetOutput(context, node, i);\n    TF_LITE_ENSURE_EQ(context, output->bytes, subgraph_output->bytes);\n    memcpy(output->data.raw, subgraph_output->data.raw, output->bytes);\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 662,
        "code": "read_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)\n{\n    char_u\t*p = virp->vir_line + 1;\n    int\t\tbartype;\n    garray_T\tvalues;\n    bval_T\t*vp;\n    int\t\ti;\n    int\t\tread_next = TRUE;\n\n    // The format is: |{bartype},{value},...\n    // For a very long string:\n    //     |{bartype},>{length of \"{text}{text2}\"}\n    //     |<{text1}\n    //     |<{text2},{value}\n    // For a long line not using a string\n    //     |{bartype},{lots of values},>\n    //     |<{value},{value}\n    if (*p == '<')\n    {\n\t// Continuation line of an unrecognized item.\n\tif (writing)\n\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n    }\n    else\n    {\n\tga_init2(&values, sizeof(bval_T), 20);\n\tbartype = getdigits(&p);\n\tswitch (bartype)\n\t{\n\t    case BARTYPE_VERSION:\n\t\t// Only use the version when it comes before the encoding.\n\t\t// If it comes later it was copied by a Vim version that\n\t\t// doesn't understand the version.\n\t\tif (!got_encoding)\n\t\t{\n\t\t    read_next = barline_parse(virp, p, &values);\n\t\t    vp = (bval_T *)values.ga_data;\n\t\t    if (values.ga_len > 0 && vp->bv_type == BVAL_NR)\n\t\t\tvirp->vir_version = vp->bv_nr;\n\t\t}\n\t\tbreak;\n\n\t    case BARTYPE_HISTORY:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_history(&values, writing);\n\t\tbreak;\n\n\t    case BARTYPE_REGISTER:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_register(&values, force);\n\t\tbreak;\n\n\t    case BARTYPE_MARK:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_mark(&values, force);\n\t\tbreak;\n\n\t    default:\n\t\t// copy unrecognized line (for future use)\n\t\tif (writing)\n\t\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n\t}\n\tfor (i = 0; i < values.ga_len; ++i)\n\t{\n\t    vp = (bval_T *)values.ga_data + i;\n\t    if (vp->bv_type == BVAL_STRING && vp->bv_allocated)\n\t\tvim_free(vp->bv_string);\n\t    vim_free(vp->bv_tofree);\n\t}\n\tga_clear(&values);\n    }\n\n    if (read_next)\n\treturn viminfo_readline(virp);\n    return FALSE;\n}\n",
        "cwe_id": "CWE-416",
        "cve_id": "CVE-2022-0156"
    },
    {
        "index": 663,
        "code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15900"
    },
    {
        "index": 664,
        "code": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter___pyx_unpickle_BufferedSocketWriter__set_state(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedSocketWriter *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  char *__pyx_t_2;\n  Py_ssize_t __pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  PyObject *__pyx_t_9 = NULL;\n  __Pyx_RefNannySetupContext(\"__pyx_unpickle_BufferedSocketWriter__set_state\", 0);\n\n  /* \"(tree fragment)\":12\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedSocketWriter__set_state(BufferedSocketWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]             # <<<<<<<<<<<<<<\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyObject_AsWritableString(__pyx_t_1); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __pyx_v___pyx_result->__pyx_base.buffer = __pyx_t_2;\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_3 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.buffer_size = __pyx_t_3;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_3 = __Pyx_PyIndex_AsSsize_t(__pyx_t_1); if (unlikely((__pyx_t_3 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __pyx_v___pyx_result->__pyx_base.position = __pyx_t_3;\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n    __PYX_ERR(1, 12, __pyx_L1_error)\n  }\n  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 12, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_1);\n  __Pyx_GOTREF(__pyx_v___pyx_result->sock);\n  __Pyx_DECREF(__pyx_v___pyx_result->sock);\n  __pyx_v___pyx_result->sock = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedSocketWriter__set_state(BufferedSocketWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  if (unlikely(__pyx_v___pyx_state == Py_None)) {\n    PyErr_SetString(PyExc_TypeError, \"object of type 'NoneType' has no len()\");\n    __PYX_ERR(1, 13, __pyx_L1_error)\n  }\n  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_5 = ((__pyx_t_3 > 4) != 0);\n  if (__pyx_t_5) {\n  } else {\n    __pyx_t_4 = __pyx_t_5;\n    goto __pyx_L4_bool_binop_done;\n  }\n  __pyx_t_5 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(1, 13, __pyx_L1_error)\n  __pyx_t_6 = (__pyx_t_5 != 0);\n  __pyx_t_4 = __pyx_t_6;\n  __pyx_L4_bool_binop_done:;\n  if (__pyx_t_4) {\n\n    /* \"(tree fragment)\":14\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n *         __pyx_result.__dict__.update(__pyx_state[4])             # <<<<<<<<<<<<<<\n */\n    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_update); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_8);\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    if (unlikely(__pyx_v___pyx_state == Py_None)) {\n      PyErr_SetString(PyExc_TypeError, \"'NoneType' object is not subscriptable\");\n      __PYX_ERR(1, 14, __pyx_L1_error)\n    }\n    __pyx_t_7 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_7);\n    __pyx_t_9 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {\n      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);\n      if (likely(__pyx_t_9)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);\n        __Pyx_INCREF(__pyx_t_9);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_8, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_9, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_7);\n    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;\n    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n    /* \"(tree fragment)\":13\n * cdef __pyx_unpickle_BufferedSocketWriter__set_state(BufferedSocketWriter __pyx_result, tuple __pyx_state):\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<\n *         __pyx_result.__dict__.update(__pyx_state[4])\n */\n  }\n\n  /* \"(tree fragment)\":11\n *         __pyx_unpickle_BufferedSocketWriter__set_state(<BufferedSocketWriter> __pyx_result, __pyx_state)\n *     return __pyx_result\n * cdef __pyx_unpickle_BufferedSocketWriter__set_state(BufferedSocketWriter __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<\n *     __pyx_result.buffer = __pyx_state[0]; __pyx_result.buffer_size = __pyx_state[1]; __pyx_result.position = __pyx_state[2]; __pyx_result.sock = __pyx_state[3]\n *     if len(__pyx_state) > 4 and hasattr(__pyx_result, '__dict__'):\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_XDECREF(__pyx_t_9);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedwriter.__pyx_unpickle_BufferedSocketWriter__set_state\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-26759"
    },
    {
        "index": 665,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = input->dims->data[1];\n  output_size->data[2] = input->dims->data[2];\n  output_size->data[3] = input->dims->data[3];\n\n  return context->ResizeTensor(context, output, output_size);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 666,
        "code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* input_weights = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* recurrent_weights =\n      GetInput(context, node, kRecurrentWeightsTensor);\n  const TfLiteTensor* bias = GetInput(context, node, kBiasTensor);\n  const TfLiteTensor* hidden_state =\n      GetInput(context, node, kHiddenStateTensor);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  auto* params = reinterpret_cast<TfLiteSequenceRNNParams*>(node->builtin_data);\n  const bool time_major = params->time_major;\n  const int batch_size =\n      (time_major) ? input->dims->data[1] : input->dims->data[0];\n  const int max_time =\n      (time_major) ? input->dims->data[0] : input->dims->data[1];\n  const int num_units = input_weights->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[2],\n                    input_weights->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, input_weights->dims->data[0], bias->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, recurrent_weights->dims->data[0],\n                    bias->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, recurrent_weights->dims->data[1],\n                    bias->dims->data[0]);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_weights->type,\n                          recurrent_weights->type);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hidden_state), 2);\n  TF_LITE_ENSURE_EQ(context, hidden_state->dims->data[0], batch_size);\n  TF_LITE_ENSURE_EQ(context, hidden_state->dims->data[1], num_units);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(3);\n  output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  output_size_array->data[2] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  const bool is_hybrid = IsHybridOp(input, input_weights);\n\n  // Allocate temporary tensors to store quantized values of input and\n  // hidden_state tensors.\n  if (is_hybrid) {\n    auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n    op_data->compute_row_sums = true;\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(6);\n    node->temporaries->data[0] = op_data->scratch_tensor_index;\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    input_quantized->type = input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n    node->temporaries->data[1] = op_data->scratch_tensor_index + 1;\n    TfLiteTensor* hidden_state_quantized =\n        GetTemporary(context, node, /*index=*/1);\n    hidden_state_quantized->type = input_weights->type;\n    hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(hidden_state_quantized->dims,\n                             hidden_state->dims)) {\n      TfLiteIntArray* hidden_state_quantized_size =\n          TfLiteIntArrayCopy(hidden_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, hidden_state_quantized,\n                                              hidden_state_quantized_size));\n    }\n    node->temporaries->data[2] = op_data->scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/2);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[3] = op_data->scratch_tensor_index + 3;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/3);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {num_units, batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[4] = op_data->scratch_tensor_index + 4;\n    TfLiteTensor* zero_points = GetTemporary(context, node, /*index=*/4);\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    node->temporaries->data[5] = op_data->scratch_tensor_index + 5;\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/5);\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[2] = {2, num_units};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 2, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(2);\n      row_sums_size->data[0] = row_sums_dims[0];\n      row_sums_size->data[1] = row_sums_dims[1];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  return kTfLiteOk;\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 667,
        "code": "TfLiteStatus PreluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  PreluParams* params = static_cast<PreluParams*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  const TfLiteTensor* alpha = GetInput(context, node, 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n\n  return CalculatePreluParams(input, alpha, output, params);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-15211"
    },
    {
        "index": 668,
        "code": "sixel_allocator_malloc(\n    sixel_allocator_t   /* in */ *allocator,  /* allocator object */\n    size_t              /* in */ n)           /* allocation size */\n{\n    /* precondition */\n    assert(allocator);\n    assert(allocator->fn_malloc);\n\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    return allocator->fn_malloc(n);\n}\n",
        "cwe_id": "CWE-119",
        "cve_id": "CVE-2020-21049"
    },
    {
        "index": 21790,
        "code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\n\treturn hash;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-41168"
    },
    {
        "index": 779,
        "code": "xscale1pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\t/*\n\t * NOTE: there's an A stepping erratum that states if an overflow\n\t *       bit already exists and another occurs, the previous\n\t *       Overflow bit gets cleared. There's no workaround.\n\t *\t Fixed in B stepping or later.\n\t */\n\tpmnc = xscale1pmu_read_pmnc();\n\n\t/*\n\t * Write the value back to clear the overflow flags. Overflow\n\t * flags remain in pmnc for use below. We also disable the PMU\n\t * while we process the interrupt.\n\t */\n\txscale1pmu_write_pmnc(pmnc & ~XSCALE_PMU_ENABLE);\n\n\tif (!(pmnc & XSCALE1_OVERFLOWED_MASK))\n\t\treturn IRQ_NONE;\n\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!xscale1_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n\t\tif (!armpmu_event_set_period(event, hwc, idx))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 0, &data, regs))\n\t\t\tarmpmu->disable(hwc, idx);\n\t}\n\n\tirq_work_run();\n\n\t/*\n\t * Re-enable the PMU.\n\t */\n\tpmnc = xscale1pmu_read_pmnc() | XSCALE_PMU_ENABLE;\n\txscale1pmu_write_pmnc(pmnc);\n\n\treturn IRQ_HANDLED;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 4613,
        "code": "static int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19055"
    },
    {
        "index": 865,
        "code": "static int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 17517,
        "code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-11924"
    },
    {
        "index": 4647,
        "code": "int i2400m_op_rfkill_sw_toggle(struct wimax_dev *wimax_dev,\n\t\t\t       enum wimax_rf_state state)\n{\n\tint result;\n\tstruct i2400m *i2400m = wimax_dev_to_i2400m(wimax_dev);\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct sk_buff *ack_skb;\n\tstruct {\n\t\tstruct i2400m_l3l4_hdr hdr;\n\t\tstruct i2400m_tlv_rf_operation sw_rf;\n\t} __packed *cmd;\n\tchar strerr[32];\n\n\td_fnstart(4, dev, \"(wimax_dev %p state %d)\\n\", wimax_dev, state);\n\n\tresult = -ENOMEM;\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\tgoto error_alloc;\n\tcmd->hdr.type = cpu_to_le16(I2400M_MT_CMD_RF_CONTROL);\n\tcmd->hdr.length = sizeof(cmd->sw_rf);\n\tcmd->hdr.version = cpu_to_le16(I2400M_L3L4_VERSION);\n\tcmd->sw_rf.hdr.type = cpu_to_le16(I2400M_TLV_RF_OPERATION);\n\tcmd->sw_rf.hdr.length = cpu_to_le16(sizeof(cmd->sw_rf.status));\n\tswitch (state) {\n\tcase WIMAX_RF_OFF:\t/* RFKILL ON, radio OFF */\n\t\tcmd->sw_rf.status = cpu_to_le32(2);\n\t\tbreak;\n\tcase WIMAX_RF_ON:\t/* RFKILL OFF, radio ON */\n\t\tcmd->sw_rf.status = cpu_to_le32(1);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tack_skb = i2400m_msg_to_dev(i2400m, cmd, sizeof(*cmd));\n\tresult = PTR_ERR(ack_skb);\n\tif (IS_ERR(ack_skb)) {\n\t\tdev_err(dev, \"Failed to issue 'RF Control' command: %d\\n\",\n\t\t\tresult);\n\t\tgoto error_msg_to_dev;\n\t}\n\tresult = i2400m_msg_check_status(wimax_msg_data(ack_skb),\n\t\t\t\t\t strerr, sizeof(strerr));\n\tif (result < 0) {\n\t\tdev_err(dev, \"'RF Control' (0x%04x) command failed: %d - %s\\n\",\n\t\t\tI2400M_MT_CMD_RF_CONTROL, result, strerr);\n\t\tgoto error_cmd;\n\t}\n\n\t/* Now we wait for the state to change to RADIO_OFF or RADIO_ON */\n\tresult = wait_event_timeout(\n\t\ti2400m->state_wq, i2400m_radio_is(i2400m, state),\n\t\t5 * HZ);\n\tif (result == 0)\n\t\tresult = -ETIMEDOUT;\n\tif (result < 0)\n\t\tdev_err(dev, \"Error waiting for device to toggle RF state: \"\n\t\t\t\"%d\\n\", result);\n\tresult = 0;\nerror_cmd:\n\tkfree(cmd);\n\tkfree_skb(ack_skb);\nerror_msg_to_dev:\nerror_alloc:\n\td_fnend(4, dev, \"(wimax_dev %p state %d) = %d\\n\",\n\t\twimax_dev, state, result);\n\treturn result;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19051"
    },
    {
        "index": 877,
        "code": "static void ptrace_triggered(struct perf_event *bp, int nmi,\n\t\t\t     struct perf_sample_data *data,\n\t\t\t     struct pt_regs *regs)\n{\n\tint i;\n\tstruct thread_struct *thread = &(current->thread);\n\n\t/*\n\t * Store in the virtual DR6 register the fact that the breakpoint\n\t * was hit so the thread's debugger will see it.\n\t */\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (thread->ptrace_bps[i] == bp)\n\t\t\tbreak;\n\t}\n\n\tthread->debugreg6 |= (DR_TRAP0 << i);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 6310,
        "code": "int crxFreeImageData(CrxImage *img)\r\n{\r\n  CrxTile *tile = img->tiles;\r\n  int nTiles = img->tileRows * img->tileCols;\r\n\r\n  if (img->tiles)\r\n  {\r\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\r\n      if (tile[curTile].comps)\r\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\r\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\r\n    free(img->tiles);\r\n    img->tiles = 0;\r\n  }\r\n\r\n  if (img->planeBuf)\r\n  {\r\n    free(img->planeBuf);\r\n    img->planeBuf = 0;\r\n  }\r\n\r\n  return 0;\r\n}\r",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2020-35534"
    },
    {
        "index": 8866,
        "code": "static Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info); \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    more_frames;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  void\n    *sans[4] = { NULL, NULL, NULL, NULL };\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse); */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n    if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n    status=TIFFGetProfiles(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetEXIFProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      (void) TIFFGetGPSProperties(tiff,image,exception);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n          image->resolution.x-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n          image->resolution.y-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n             &vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n#if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression; break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace,exception);\n    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                    exception);\n                }\n          }\n      }\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    if (samples_per_pixel > MaxPixelChannels)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n      }\n    method=ReadGenericMethod;\n    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          buffer[MagickPathExtent];\n\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n        method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV) ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    if (TIFFScanlineSize(tiff) <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((1.0*TIFFScanlineSize(tiff)) > (2.53*GetBlobSize(image)))\n      ThrowTIFFException(CorruptImageError,\"InsufficientImageDataInFile\");\n    number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)\n      image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/\n      log(2.0))),image->columns*rows_per_strip));\n    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n          pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n            else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=RGBAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n              }\n            if (image->colorspace == CMYKColorspace)\n              {\n                quantum_type=CMYKQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  {\n                    quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n                  }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>\n              3));\n            if (status == MagickFalse)\n              ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n      {\n        /*\n          Convert YCC TIFF image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          Quantum\n            *magick_restrict q;\n\n          ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n          if (tiff_status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=2*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;\n\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          rows_remaining=0;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n                  break;\n                rows_remaining=rows_per_strip;\n                if ((y+rows_per_strip) > (ssize_t) image->rows)\n                  rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n                p=strip_pixels;\n                strip_id++;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n              quantum_info,quantum_type,p,exception);\n            p+=stride;\n            rows_remaining--;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        extent=TIFFTileSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=columns*sizeof(uint64);\n#else\n        extent+=columns*sizeof(uint32);\n#endif\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n            {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n              break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t) image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n            for (x=0; x < (ssize_t) image->columns; x+=columns)\n            {\n              size_t\n                columns_remaining,\n                row;\n\n              columns_remaining=image->columns-x;\n              if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n              if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining; row++)\n              {\n                Quantum\n                  *magick_restrict q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                  exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,quantum_type,p,exception);\n                p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            }\n          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *generic_info = (MemoryInfo * ) NULL;\n\n        uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert generic TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n#if defined(TIFF_VERSION_BIG)\n        number_pixels+=image->columns*sizeof(uint64);\n#else\n        number_pixels+=image->columns*sizeof(uint32);\n#endif\n        generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n        if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        p=pixels+(image->columns*image->rows)-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            x;\n\n          Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n  TIFFClose(tiff);\n  if (status != MagickFalse)\n    TIFFReadPhotoshopLayers(image_info,image,exception);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-3574"
    },
    {
        "index": 200,
        "code": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2015-8631"
    },
    {
        "index": 21787,
        "code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-41168"
    },
    {
        "index": 180,
        "code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2015-8631"
    },
    {
        "index": 184,
        "code": "get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)\n{\n    static gpol_ret             ret;\n    kadm5_ret_t         ret2;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_principal_ent_rec     caller_ent;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_gpol_ret,  &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_policy\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    ret.code = KADM5_AUTH_GET;\n    if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_INQUIRE, NULL, NULL))\n        ret.code = KADM5_OK;\n    else {\n        ret.code = kadm5_get_principal(handle->lhandle,\n                                       handle->current_caller,\n                                       &caller_ent,\n                                       KADM5_PRINCIPAL_NORMAL_MASK);\n        if (ret.code == KADM5_OK) {\n            if (caller_ent.aux_attributes & KADM5_POLICY &&\n                strcmp(caller_ent.policy, arg->name) == 0) {\n                ret.code = KADM5_OK;\n            } else ret.code = KADM5_AUTH_GET;\n            ret2 = kadm5_free_principal_ent(handle->lhandle,\n                                            &caller_ent);\n            ret.code = ret.code ? ret.code : ret2;\n        }\n    }\n\n    if (ret.code == KADM5_OK) {\n        ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname,\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2015-8631"
    },
    {
        "index": 22979,
        "code": "build_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,\n                                        struct hmap *lflows,\n                                        struct ds *actions,\n                                        const struct shash *meter_groups)\n{\n    if (od->nbs) {\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,\n                      \"eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)\",\n                      \"handle_svc_check(inport);\");\n\n        struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n        if (mcast_sw_info->enabled) {\n            ds_clear(actions);\n            ds_put_cstr(actions, \"igmp;\");\n            /* Punt IGMP traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"igmp\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Punt MLD traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"mldv1 || mldv2\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Flood all IP multicast traffic destined to 224.0.0.X to all\n             * ports - RFC 4541, section 2.1.2, item 2.\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip4.mcast && ip4.dst == 224.0.0.0/24\",\n                          \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n            /* Flood all IPv6 multicast traffic destined to reserved\n             * multicast IPs (RFC 4291, 2.7.1).\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip6.mcast_flood\",\n                          \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n\n            /* Forward uregistered IP multicast to routers with relay enabled\n             * and to any ports configured to flood IP multicast traffic.\n             * If configured to flood unregistered traffic this will be\n             * handled by the L2 multicast flow.\n             */\n            if (!mcast_sw_info->flood_unregistered) {\n                ds_clear(actions);\n\n                if (mcast_sw_info->flood_relay) {\n                    ds_put_cstr(actions,\n                                \"clone { \"\n                                    \"outport = \\\"\"MC_MROUTER_FLOOD\"\\\"; \"\n                                    \"output; \"\n                                \"}; \");\n                }\n\n                if (mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, \"outport =\\\"\"MC_STATIC\"\\\"; output;\");\n                }\n\n                /* Explicitly drop the traffic if relay or static flooding\n                 * is not configured.\n                 */\n                if (!mcast_sw_info->flood_relay &&\n                        !mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, debug_drop_action());\n                }\n\n                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,\n                              \"ip4.mcast || ip6.mcast\",\n                              ds_cstr(actions));\n            }\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, \"eth.mcast\",\n                      \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n    }\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2023-3153"
    },
    {
        "index": 826,
        "code": "static int misaligned_load(struct pt_regs *regs,\n\t\t\t   __u32 opcode,\n\t\t\t   int displacement_not_indexed,\n\t\t\t   int width_shift,\n\t\t\t   int do_sign_extend)\n{\n\t/* Return -1 for a fault, 0 for OK */\n\tint error;\n\tint destreg;\n\t__u64 address;\n\n\terror = generate_and_check_address(regs, opcode,\n\t\t\tdisplacement_not_indexed, width_shift, &address);\n\tif (error < 0) {\n\t\treturn error;\n\t}\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n\n\tdestreg = (opcode >> 4) & 0x3f;\n\tif (user_mode(regs)) {\n\t\t__u64 buffer;\n\n\t\tif (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) {\n\t\t\treturn -1; /* fault */\n\t\t}\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\tif (do_sign_extend) {\n\t\t\t\tregs->regs[destreg] = (__u64)(__s64) *(__s16 *) &buffer;\n\t\t\t} else {\n\t\t\t\tregs->regs[destreg] = (__u64) *(__u16 *) &buffer;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tregs->regs[destreg] = (__u64)(__s64) *(__s32 *) &buffer;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tregs->regs[destreg] = buffer;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_load, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* kernel mode - we can take short cuts since if we fault, it's a genuine bug */\n\t\t__u64 lo, hi;\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\tmisaligned_kernel_word_load(address, do_sign_extend, &regs->regs[destreg]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tasm (\"ldlo.l %1, 0, %0\" : \"=r\" (lo) : \"r\" (address));\n\t\t\tasm (\"ldhi.l %1, 3, %0\" : \"=r\" (hi) : \"r\" (address));\n\t\t\tregs->regs[destreg] = lo | hi;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tasm (\"ldlo.q %1, 0, %0\" : \"=r\" (lo) : \"r\" (address));\n\t\t\tasm (\"ldhi.q %1, 7, %0\" : \"=r\" (hi) : \"r\" (address));\n\t\t\tregs->regs[destreg] = lo | hi;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_load, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 3729,
        "code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\t/* ttm_bo_init failure will call the destroy */\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2017-10810"
    },
    {
        "index": 4608,
        "code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-19053"
    },
    {
        "index": 6888,
        "code": "static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-17177"
    },
    {
        "index": 12772,
        "code": "static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 i, nb_rare, field_rare;\n\ts32 field_tag;\n\n\tGF_LSR_READ_INT(lsr, nb_rare, 1, \"has_rare\");\n\tif (!nb_rare) return;\n\tGF_LSR_READ_INT(lsr, nb_rare, 6, \"nbOfAttributes\");\n\n\tfor (i=0; i<nb_rare; i++) {\n\t\tGF_LSR_READ_INT(lsr, field_rare, 6, \"attributeRARE\");\n\n\t\t/*lsr extend*/\n\t\tif (field_rare==49) {\n\t\t\tu32 extID, len, j;\n\t\t\twhile (1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tif (extID==2) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, len, 2, \"nbOfAttributes\");\n\t\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, extID, 3, \"attributeRARE\");\n\t\t\t\t\t\tswitch (extID) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"syncMaster\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, \"focusHighlight\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, \"initialVisibility\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, \"requiredFonts\", GF_FALSE, GF_TRUE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_read_int(lsr->bs, len);\n\t\t\t\t}\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, 1, \"hasNextExtension\");\n\t\t\t\tif (!extID) break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfield_tag = gf_lsr_rare_type_to_attribute(field_rare);\n\t\tif (field_tag==-1) {\n\t\t\treturn;\n\t\t}\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;\n\t\tif (lsr->last_error) return;\n\n\t\tswitch (field_tag) {\n\t\tcase TAG_SVG_ATT__class:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"class\");\n\t\t\tbreak;\n\t\t/*properties*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"audio-level\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color:\n\t\t\tlsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, \"color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"color-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, \"display\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display_align:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, \"display-align\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, \"fill-rule\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"image-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\t\tlsr_read_line_increment_type(lsr, info.far_ptr, \"line-increment\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, \"pointer-events\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"shape-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"solid-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"solid-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"stop-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stop-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\t{\n\t\t\tu32 j, flag;\n\t\t\tSVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"dashArray\");\n\t\t\tif (flag) {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tda->array.vals[j] = lsr_read_fixed_16_8(lsr, \"dash\");\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tif (lsr->last_error) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"dashOffset\");\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, \"stroke-linecap\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, \"stroke-linejoin\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"miterLimit\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stroke-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"strokeWidth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, \"text-achor\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"text-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"viewport-fill\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"viewport-fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, \"vector-effect\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, \"visibility\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredExtensions:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredExtensions\", GF_TRUE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFormats:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredFormats\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFeatures:\n\t\t{\n\t\t\tu32 j, fcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (j=0; j<fcount; j++) {\n\t\t\t\tu32 fval;\n\t\t\t\tGF_LSR_READ_INT(lsr, fval, 6, \"feature\");\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_systemLanguage:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"systemLanguage\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_base:\n\t\t\tlsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, \"xml:base\");\n\t\t\t((XMLRI*)info.far_ptr)->type = XMLRI_STRING;\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_lang:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xml:lang\");\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_space:\n\t\t\tGF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, \"xml:space\");\n\t\t\tbreak;\n\t\t/*focusable*/\n\t\tcase TAG_SVG_ATT_nav_next:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNext\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_prev:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusPrev\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_focusable:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, \"focusable\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tlsr_read_matrix(lsr, info.far_ptr);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_decoration:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"textDecoration\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, \"font-variant\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_family:\n\t\t{\n\t\t\tu32 flag;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isInherit\");\n\t\t\tif (flag) {\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;\n\t\t\t} else {\n\t\t\t\tchar *ft;\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, \"fontIndex\");\n\t\t\t\tft = (char*)gf_list_get(lsr->font_table, flag);\n\t\t\t\tif (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_size:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"fontSize\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_style:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, \"fontStyle\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, \"fontWeight\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_title:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xlink:title\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_type:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:type\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_role:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:role\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_arcrole:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:arcrole\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_actuate:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 2, \"xlink:actuate\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_show:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:show\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_end:\n\t\t\tlsr_read_smil_times(lsr, NULL, 0, info.far_ptr, \"end\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_max:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_min:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) return;\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2023-23145"
    },
    {
        "index": 921,
        "code": "static void watchdog_overflow_callback(struct perf_event *event, int nmi,\n\t\t struct perf_sample_data *data,\n\t\t struct pt_regs *regs)\n{\n\t/* Ensure the watchdog never gets throttled */\n\tevent->hw.interrupts = 0;\n\n\tif (__this_cpu_read(watchdog_nmi_touch) == true) {\n\t\t__this_cpu_write(watchdog_nmi_touch, false);\n\t\treturn;\n\t}\n\n\t/* check for a hardlockup\n\t * This is done by making sure our timer interrupt\n\t * is incrementing.  The timer interrupt should have\n\t * fired multiple times before we overflow'd.  If it hasn't\n\t * then this is a good indication the cpu is stuck\n\t */\n\tif (is_hardlockup()) {\n\t\tint this_cpu = smp_processor_id();\n\n\t\t/* only print hardlockups once */\n\t\tif (__this_cpu_read(hard_watchdog_warn) == true)\n\t\t\treturn;\n\n\t\tif (hardlockup_panic)\n\t\t\tpanic(\"Watchdog detected hard LOCKUP on cpu %d\", this_cpu);\n\t\telse\n\t\t\tWARN(1, \"Watchdog detected hard LOCKUP on cpu %d\", this_cpu);\n\n\t\t__this_cpu_write(hard_watchdog_warn, true);\n\t\treturn;\n\t}\n\n\t__this_cpu_write(hard_watchdog_warn, false);\n\treturn;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 862,
        "code": "asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned int insn = 0;\n\tint si_code, fault_code, fault;\n\tunsigned long address, mm_rss;\n\n\tfault_code = get_thread_fault_code();\n\n\tif (notify_page_fault(regs))\n\t\treturn;\n\n\tsi_code = SEGV_MAPERR;\n\taddress = current_thread_info()->fault_address;\n\n\tif ((fault_code & FAULT_CODE_ITLB) &&\n\t    (fault_code & FAULT_CODE_DTLB))\n\t\tBUG();\n\n\tif (test_thread_flag(TIF_32BIT)) {\n\t\tif (!(regs->tstate & TSTATE_PRIV)) {\n\t\t\tif (unlikely((regs->tpc >> 32) != 0)) {\n\t\t\t\tbogus_32bit_fault_tpc(regs);\n\t\t\t\tgoto intr_or_no_mm;\n\t\t\t}\n\t\t}\n\t\tif (unlikely((address >> 32) != 0)) {\n\t\t\tbogus_32bit_fault_address(regs, address);\n\t\t\tgoto intr_or_no_mm;\n\t\t}\n\t}\n\n\tif (regs->tstate & TSTATE_PRIV) {\n\t\tunsigned long tpc = regs->tpc;\n\n\t\t/* Sanity check the PC. */\n\t\tif ((tpc >= KERNBASE && tpc < (unsigned long) __init_end) ||\n\t\t    (tpc >= MODULES_VADDR && tpc < MODULES_END)) {\n\t\t\t/* Valid, no problems... */\n\t\t} else {\n\t\t\tbad_kernel_pc(regs, address);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto intr_or_no_mm;\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif ((regs->tstate & TSTATE_PRIV) &&\n\t\t    !search_exception_tables(regs->tpc)) {\n\t\t\tinsn = get_fault_insn(regs, insn);\n\t\t\tgoto handle_kernel_fault;\n\t\t}\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto bad_area;\n\n\t/* Pure DTLB misses do not tell us whether the fault causing\n\t * load/store/atomic was a write or not, it only says that there\n\t * was no match.  So in such a case we (carefully) read the\n\t * instruction to try and figure this out.  It's an optimization\n\t * so it's ok if we can't do this.\n\t *\n\t * Special hack, window spill/fill knows the exact fault type.\n\t */\n\tif (((fault_code &\n\t      (FAULT_CODE_DTLB | FAULT_CODE_WRITE | FAULT_CODE_WINFIXUP)) == FAULT_CODE_DTLB) &&\n\t    (vma->vm_flags & VM_WRITE) != 0) {\n\t\tinsn = get_fault_insn(regs, 0);\n\t\tif (!insn)\n\t\t\tgoto continue_fault;\n\t\t/* All loads, stores and atomics have bits 30 and 31 both set\n\t\t * in the instruction.  Bit 21 is set in all stores, but we\n\t\t * have to avoid prefetches which also have bit 21 set.\n\t\t */\n\t\tif ((insn & 0xc0200000) == 0xc0200000 &&\n\t\t    (insn & 0x01780000) != 0x01680000) {\n\t\t\t/* Don't bother updating thread struct value,\n\t\t\t * because update_mmu_cache only cares which tlb\n\t\t\t * the access came from.\n\t\t\t */\n\t\t\tfault_code |= FAULT_CODE_WRITE;\n\t\t}\n\t}\ncontinue_fault:\n\n\tif (vma->vm_start <= address)\n\t\tgoto good_area;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif (!(fault_code & FAULT_CODE_WRITE)) {\n\t\t/* Non-faulting loads shouldn't expand stack. */\n\t\tinsn = get_fault_insn(regs, insn);\n\t\tif ((insn & 0xc0800000) == 0xc0800000) {\n\t\t\tunsigned char asi;\n\n\t\t\tif (insn & 0x2000)\n\t\t\t\tasi = (regs->tstate >> 24);\n\t\t\telse\n\t\t\t\tasi = (insn >> 5);\n\t\t\tif ((asi & 0xf2) == 0x82)\n\t\t\t\tgoto bad_area;\n\t\t}\n\t}\n\tif (expand_stack(vma, address))\n\t\tgoto bad_area;\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\ngood_area:\n\tsi_code = SEGV_ACCERR;\n\n\t/* If we took a ITLB miss on a non-executable page, catch\n\t * that here.\n\t */\n\tif ((fault_code & FAULT_CODE_ITLB) && !(vma->vm_flags & VM_EXEC)) {\n\t\tBUG_ON(address != regs->tpc);\n\t\tBUG_ON(regs->tstate & TSTATE_PRIV);\n\t\tgoto bad_area;\n\t}\n\n\tif (fault_code & FAULT_CODE_WRITE) {\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\n\t\t/* Spitfire has an icache which does not snoop\n\t\t * processor stores.  Later processors do...\n\t\t */\n\t\tif (tlb_type == spitfire &&\n\t\t    (vma->vm_flags & VM_EXEC) != 0 &&\n\t\t    vma->vm_file != NULL)\n\t\t\tset_thread_fault_code(fault_code |\n\t\t\t\t\t      FAULT_CODE_BLKCOMMIT);\n\t} else {\n\t\t/* Allow reads even for write-only mappings */\n\t\tif (!(vma->vm_flags & (VM_READ | VM_EXEC)))\n\t\t\tgoto bad_area;\n\t}\n\n\tfault = handle_mm_fault(mm, vma, address, (fault_code & FAULT_CODE_WRITE) ? FAULT_FLAG_WRITE : 0);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\tcurrent->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t      regs, address);\n\t} else {\n\t\tcurrent->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t      regs, address);\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tmm_rss = get_mm_rss(mm);\n#ifdef CONFIG_HUGETLB_PAGE\n\tmm_rss -= (mm->context.huge_pte_count * (HPAGE_SIZE / PAGE_SIZE));\n#endif\n\tif (unlikely(mm_rss >\n\t\t     mm->context.tsb_block[MM_TSB_BASE].tsb_rss_limit))\n\t\ttsb_grow(mm, MM_TSB_BASE, mm_rss);\n#ifdef CONFIG_HUGETLB_PAGE\n\tmm_rss = mm->context.huge_pte_count;\n\tif (unlikely(mm_rss >\n\t\t     mm->context.tsb_block[MM_TSB_HUGE].tsb_rss_limit))\n\t\ttsb_grow(mm, MM_TSB_HUGE, mm_rss);\n#endif\n\treturn;\n\n\t/*\n\t * Something tried to access memory that isn't in our memory map..\n\t * Fix it, but check if it's kernel or user first..\n\t */\nbad_area:\n\tinsn = get_fault_insn(regs, insn);\n\tup_read(&mm->mmap_sem);\n\nhandle_kernel_fault:\n\tdo_kernel_fault(regs, si_code, fault_code, insn, address);\n\treturn;\n\n/*\n * We ran out of memory, or some other thing happened to us that made\n * us unable to handle the page fault gracefully.\n */\nout_of_memory:\n\tinsn = get_fault_insn(regs, insn);\n\tup_read(&mm->mmap_sem);\n\tif (!(regs->tstate & TSTATE_PRIV)) {\n\t\tpagefault_out_of_memory();\n\t\treturn;\n\t}\n\tgoto handle_kernel_fault;\n\nintr_or_no_mm:\n\tinsn = get_fault_insn(regs, 0);\n\tgoto handle_kernel_fault;\n\ndo_sigbus:\n\tinsn = get_fault_insn(regs, insn);\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n\tdo_fault_siginfo(BUS_ADRERR, SIGBUS, regs, insn, fault_code);\n\n\t/* Kernel mode? Handle exceptions or die */\n\tif (regs->tstate & TSTATE_PRIV)\n\t\tgoto handle_kernel_fault;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 11333,
        "code": "main(int argc, char* argv[])\n{\n\tuint16 bitspersample, shortv;\n\tuint32 imagewidth, imagelength;\n\tuint16 config = PLANARCONFIG_CONTIG;\n\tuint32 rowsperstrip = (uint32) -1;\n\tuint16 photometric = PHOTOMETRIC_RGB;\n\tuint16 *rmap, *gmap, *bmap;\n\tuint32 row;\n\tint cmap = -1;\n\tTIFF *in, *out;\n\tint c;\n\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"C:c:p:r:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'C':\t\t/* force colormap interpretation */\n\t\t\tcmap = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tif (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &shortv) ||\n\t    shortv != PHOTOMETRIC_PALETTE) {\n\t\tfprintf(stderr, \"%s: Expecting a palette image.\\n\",\n\t\t    argv[optind]);\n\t\treturn (-1);\n\t}\n\tif (!TIFFGetField(in, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {\n\t\tfprintf(stderr,\n\t\t    \"%s: No colormap (not a valid palette image).\\n\",\n\t\t    argv[optind]);\n\t\treturn (-1);\n\t}\n\tbitspersample = 0;\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr, \"%s: Sorry, can only handle 8-bit images.\\n\",\n\t\t    argv[optind]);\n\t\treturn (-1);\n\t}\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\tcpTags(in, out);\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\n\tif (compression != (uint16)-1)\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\telse\n\t\tTIFFGetField(in, TIFFTAG_COMPRESSION, &compression);\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\telse\n\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip));\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (cmap == -1)\n\t\tcmap = checkcmap(1<<bitspersample, rmap, gmap, bmap);\n\tif (cmap == 16) {\n\t\t/*\n\t\t * Convert 16-bit colormap to 8-bit.\n\t\t */\n\t\tint i;\n\n\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n#define\tCVT(x)\t\t(((x) * 255) / ((1L<<16)-1))\n\t\t\trmap[i] = CVT(rmap[i]);\n\t\t\tgmap[i] = CVT(gmap[i]);\n\t\t\tbmap[i] = CVT(bmap[i]);\n\t\t}\n\t}\n\t{ unsigned char *ibuf, *obuf;\n\t  register unsigned char* pp;\n\t  register uint32 x;\n\t  tmsize_t tss_in = TIFFScanlineSize(in);\n\t  tmsize_t tss_out = TIFFScanlineSize(out);\n\t  if (tss_out / tss_in < 3) {\n\t\t/*\n\t\t * BUG 2750: The following code does not know about chroma\n\t\t * subsampling of JPEG data. It assumes that the output buffer is 3x\n\t\t * the length of the input buffer due to exploding the palette into\n\t\t * RGB tuples. If this assumption is incorrect, it could lead to a\n\t\t * buffer overflow. Go ahead and fail now to prevent that.\n\t\t */\n\t\tfprintf(stderr, \"Could not determine correct image size for output. Exiting.\\n\");\n\t\treturn -1;\n      }\n\t  ibuf = (unsigned char*)_TIFFmalloc(tss_in);\n\t  obuf = (unsigned char*)_TIFFmalloc(tss_out);\n\t  switch (config) {\n\t  case PLANARCONFIG_CONTIG:\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (!TIFFReadScanline(in, ibuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tpp = obuf;\n\t\t\tfor (x = 0; x < imagewidth; x++) {\n\t\t\t\t*pp++ = (unsigned char) rmap[ibuf[x]];\n\t\t\t\t*pp++ = (unsigned char) gmap[ibuf[x]];\n\t\t\t\t*pp++ = (unsigned char) bmap[ibuf[x]];\n\t\t\t}\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t  case PLANARCONFIG_SEPARATE:\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (!TIFFReadScanline(in, ibuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\n\t\t\t\t*pp++ = (unsigned char) rmap[ibuf[x]];\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\n\t\t\t\t*pp++ = (unsigned char) gmap[ibuf[x]];\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\n\t\t\t\t*pp++ = (unsigned char) bmap[ibuf[x]];\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t  }\n\t  _TIFFfree(ibuf);\n\t  _TIFFfree(obuf);\n\t}\ndone:\n\t(void) TIFFClose(in);\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-6128"
    },
    {
        "index": 4915,
        "code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-3736"
    },
    {
        "index": 3410,
        "code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = disconnect_mount(p, how);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2016-6213"
    },
    {
        "index": 858,
        "code": "int do_mathemu(struct pt_regs *regs, struct fpustate *f)\n{\n\tunsigned long pc = regs->tpc;\n\tunsigned long tstate = regs->tstate;\n\tu32 insn = 0;\n\tint type = 0;\n\t/* ftt tells which ftt it may happen in, r is rd, b is rs2 and a is rs1. The *u arg tells\n\t   whether the argument should be packed/unpacked (0 - do not unpack/pack, 1 - unpack/pack)\n\t   non-u args tells the size of the argument (0 - no argument, 1 - single, 2 - double, 3 - quad */\n#define TYPE(ftt, r, ru, b, bu, a, au) type = (au << 2) | (a << 0) | (bu << 5) | (b << 3) | (ru << 8) | (r << 6) | (ftt << 9)\n\tint freg;\n\tstatic u64 zero[2] = { 0L, 0L };\n\tint flags;\n\tFP_DECL_EX;\n\tFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\n\tFP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);\n\tFP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);\n\tint IR;\n\tlong XR, xfsr;\n\n\tif (tstate & TSTATE_PRIV)\n\t\tdie_if_kernel(\"unfinished/unimplemented FPop from kernel\", regs);\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n\tif (test_thread_flag(TIF_32BIT))\n\t\tpc = (u32)pc;\n\tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n\t\tif ((insn & 0xc1f80000) == 0x81a00000) /* FPOP1 */ {\n\t\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t\t/* QUAD - ftt == 3 */\n\t\t\tcase FMOVQ:\n\t\t\tcase FNEGQ:\n\t\t\tcase FABSQ: TYPE(3,3,0,3,0,0,0); break;\n\t\t\tcase FSQRTQ: TYPE(3,3,1,3,1,0,0); break;\n\t\t\tcase FADDQ:\n\t\t\tcase FSUBQ:\n\t\t\tcase FMULQ:\n\t\t\tcase FDIVQ: TYPE(3,3,1,3,1,3,1); break;\n\t\t\tcase FDMULQ: TYPE(3,3,1,2,1,2,1); break;\n\t\t\tcase FQTOX: TYPE(3,2,0,3,1,0,0); break;\n\t\t\tcase FXTOQ: TYPE(3,3,1,2,0,0,0); break;\n\t\t\tcase FQTOS: TYPE(3,1,1,3,1,0,0); break;\n\t\t\tcase FQTOD: TYPE(3,2,1,3,1,0,0); break;\n\t\t\tcase FITOQ: TYPE(3,3,1,1,0,0,0); break;\n\t\t\tcase FSTOQ: TYPE(3,3,1,1,1,0,0); break;\n\t\t\tcase FDTOQ: TYPE(3,3,1,2,1,0,0); break;\n\t\t\tcase FQTOI: TYPE(3,1,0,3,1,0,0); break;\n\n\t\t\t/* We can get either unimplemented or unfinished\n\t\t\t * for these cases.  Pre-Niagara systems generate\n\t\t\t * unfinished fpop for SUBNORMAL cases, and Niagara\n\t\t\t * always gives unimplemented fpop for fsqrt{s,d}.\n\t\t\t */\n\t\t\tcase FSQRTS: {\n\t\t\t\tunsigned long x = current_thread_info()->xfsr[0];\n\n\t\t\t\tx = (x >> 14) & 0xf;\n\t\t\t\tTYPE(x,1,1,1,1,0,0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase FSQRTD: {\n\t\t\t\tunsigned long x = current_thread_info()->xfsr[0];\n\n\t\t\t\tx = (x >> 14) & 0xf;\n\t\t\t\tTYPE(x,2,1,2,1,0,0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* SUBNORMAL - ftt == 2 */\n\t\t\tcase FADDD:\n\t\t\tcase FSUBD:\n\t\t\tcase FMULD:\n\t\t\tcase FDIVD: TYPE(2,2,1,2,1,2,1); break;\n\t\t\tcase FADDS:\n\t\t\tcase FSUBS:\n\t\t\tcase FMULS:\n\t\t\tcase FDIVS: TYPE(2,1,1,1,1,1,1); break;\n\t\t\tcase FSMULD: TYPE(2,2,1,1,1,1,1); break;\n\t\t\tcase FSTOX: TYPE(2,2,0,1,1,0,0); break;\n\t\t\tcase FDTOX: TYPE(2,2,0,2,1,0,0); break;\n\t\t\tcase FDTOS: TYPE(2,1,1,2,1,0,0); break;\n\t\t\tcase FSTOD: TYPE(2,2,1,1,1,0,0); break;\n\t\t\tcase FSTOI: TYPE(2,1,0,1,1,0,0); break;\n\t\t\tcase FDTOI: TYPE(2,1,0,2,1,0,0); break;\n\n\t\t\t/* Only Ultra-III generates these */\n\t\t\tcase FXTOS: TYPE(2,1,1,2,0,0,0); break;\n\t\t\tcase FXTOD: TYPE(2,2,1,2,0,0,0); break;\n#if 0\t\t\t/* Optimized inline in sparc64/kernel/entry.S */\n\t\t\tcase FITOS: TYPE(2,1,1,1,0,0,0); break;\n#endif\n\t\t\tcase FITOD: TYPE(2,2,1,1,0,0,0); break;\n\t\t\t}\n\t\t}\n\t\telse if ((insn & 0xc1f80000) == 0x81a80000) /* FPOP2 */ {\n\t\t\tIR = 2;\n\t\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t\tcase FCMPQ: TYPE(3,0,0,3,1,3,1); break;\n\t\t\tcase FCMPEQ: TYPE(3,0,0,3,1,3,1); break;\n\t\t\t/* Now the conditional fmovq support */\n\t\t\tcase FMOVQ0:\n\t\t\tcase FMOVQ1:\n\t\t\tcase FMOVQ2:\n\t\t\tcase FMOVQ3:\n\t\t\t\t/* fmovq %fccX, %fY, %fZ */\n\t\t\t\tif (!((insn >> 11) & 3))\n\t\t\t\t\tXR = current_thread_info()->xfsr[0] >> 10;\n\t\t\t\telse\n\t\t\t\t\tXR = current_thread_info()->xfsr[0] >> (30 + ((insn >> 10) & 0x6));\n\t\t\t\tXR &= 3;\n\t\t\t\tIR = 0;\n\t\t\t\tswitch ((insn >> 14) & 0x7) {\n\t\t\t\t/* case 0: IR = 0; break; */\t\t\t/* Never */\n\t\t\t\tcase 1: if (XR) IR = 1; break;\t\t\t/* Not Equal */\n\t\t\t\tcase 2: if (XR == 1 || XR == 2) IR = 1; break;\t/* Less or Greater */\n\t\t\t\tcase 3: if (XR & 1) IR = 1; break;\t\t/* Unordered or Less */\n\t\t\t\tcase 4: if (XR == 1) IR = 1; break;\t\t/* Less */\n\t\t\t\tcase 5: if (XR & 2) IR = 1; break;\t\t/* Unordered or Greater */\n\t\t\t\tcase 6: if (XR == 2) IR = 1; break;\t\t/* Greater */\n\t\t\t\tcase 7: if (XR == 3) IR = 1; break;\t\t/* Unordered */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 14) & 8)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\tcase FMOVQI:\n\t\t\tcase FMOVQX:\n\t\t\t\t/* fmovq %[ix]cc, %fY, %fZ */\n\t\t\t\tXR = regs->tstate >> 32;\n\t\t\t\tif ((insn >> 5) & 0x80)\n\t\t\t\t\tXR >>= 4;\n\t\t\t\tXR &= 0xf;\n\t\t\t\tIR = 0;\n\t\t\t\tfreg = ((XR >> 2) ^ XR) & 2;\n\t\t\t\tswitch ((insn >> 14) & 0x7) {\n\t\t\t\t/* case 0: IR = 0; break; */\t\t\t/* Never */\n\t\t\t\tcase 1: if (XR & 4) IR = 1; break;\t\t/* Equal */\n\t\t\t\tcase 2: if ((XR & 4) || freg) IR = 1; break;\t/* Less or Equal */\n\t\t\t\tcase 3: if (freg) IR = 1; break;\t\t/* Less */\n\t\t\t\tcase 4: if (XR & 5) IR = 1; break;\t\t/* Less or Equal Unsigned */\n\t\t\t\tcase 5: if (XR & 1) IR = 1; break;\t\t/* Carry Set */\n\t\t\t\tcase 6: if (XR & 8) IR = 1; break;\t\t/* Negative */\n\t\t\t\tcase 7: if (XR & 2) IR = 1; break;\t\t/* Overflow Set */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 14) & 8)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\tcase FMOVQZ:\n\t\t\tcase FMOVQLE:\n\t\t\tcase FMOVQLZ:\n\t\t\tcase FMOVQNZ:\n\t\t\tcase FMOVQGZ:\n\t\t\tcase FMOVQGE:\n\t\t\t\tfreg = (insn >> 14) & 0x1f;\n\t\t\t\tif (!freg)\n\t\t\t\t\tXR = 0;\n\t\t\t\telse if (freg < 16)\n\t\t\t\t\tXR = regs->u_regs[freg];\n\t\t\t\telse if (test_thread_flag(TIF_32BIT)) {\n\t\t\t\t\tstruct reg_window32 __user *win32;\n\t\t\t\t\tflushw_user ();\n\t\t\t\t\twin32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP]));\n\t\t\t\t\tget_user(XR, &win32->locals[freg - 16]);\n\t\t\t\t} else {\n\t\t\t\t\tstruct reg_window __user *win;\n\t\t\t\t\tflushw_user ();\n\t\t\t\t\twin = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS);\n\t\t\t\t\tget_user(XR, &win->locals[freg - 16]);\n\t\t\t\t}\n\t\t\t\tIR = 0;\n\t\t\t\tswitch ((insn >> 10) & 3) {\n\t\t\t\tcase 1: if (!XR) IR = 1; break;\t\t\t/* Register Zero */\n\t\t\t\tcase 2: if (XR <= 0) IR = 1; break;\t\t/* Register Less Than or Equal to Zero */\n\t\t\t\tcase 3: if (XR < 0) IR = 1; break;\t\t/* Register Less Than Zero */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 10) & 4)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IR == 0) {\n\t\t\t\t/* The fmov test was false. Do a nop instead */\n\t\t\t\tcurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\n\t\t\t\tregs->tpc = regs->tnpc;\n\t\t\t\tregs->tnpc += 4;\n\t\t\t\treturn 1;\n\t\t\t} else if (IR == 1) {\n\t\t\t\t/* Change the instruction into plain fmovq */\n\t\t\t\tinsn = (insn & 0x3e00001f) | 0x81a00060;\n\t\t\t\tTYPE(3,3,0,3,0,0,0); \n\t\t\t}\n\t\t}\n\t}\n\tif (type) {\n\t\targp rs1 = NULL, rs2 = NULL, rd = NULL;\n\t\t\n\t\tfreg = (current_thread_info()->xfsr[0] >> 14) & 0xf;\n\t\tif (freg != (type >> 9))\n\t\t\tgoto err;\n\t\tcurrent_thread_info()->xfsr[0] &= ~0x1c000;\n\t\tfreg = ((insn >> 14) & 0x1f);\n\t\tswitch (type & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rs1 = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags))\n\t\t\t\trs1 = (argp)&zero;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (type & 0x7) {\n\t\tcase 7: FP_UNPACK_QP (QA, rs1); break;\n\t\tcase 6: FP_UNPACK_DP (DA, rs1); break;\n\t\tcase 5: FP_UNPACK_SP (SA, rs1); break;\n\t\t}\n\t\tfreg = (insn & 0x1f);\n\t\tswitch ((type >> 3) & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rs2 = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags))\n\t\t\t\trs2 = (argp)&zero;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((type >> 3) & 0x7) {\n\t\tcase 7: FP_UNPACK_QP (QB, rs2); break;\n\t\tcase 6: FP_UNPACK_DP (DB, rs2); break;\n\t\tcase 5: FP_UNPACK_SP (SB, rs2); break;\n\t\t}\n\t\tfreg = ((insn >> 25) & 0x1f);\n\t\tswitch ((type >> 6) & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rd = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & FPRS_FEF)) {\n\t\t\t\tcurrent_thread_info()->fpsaved[0] = FPRS_FEF;\n\t\t\t\tcurrent_thread_info()->gsr[0] = 0;\n\t\t\t}\n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags)) {\n\t\t\t\tif (freg < 32)\n\t\t\t\t\tmemset(f->regs, 0, 32*sizeof(u32));\n\t\t\t\telse\n\t\t\t\t\tmemset(f->regs+32, 0, 32*sizeof(u32));\n\t\t\t}\n\t\t\tcurrent_thread_info()->fpsaved[0] |= flags;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t/* + */\n\t\tcase FADDS: FP_ADD_S (SR, SA, SB); break;\n\t\tcase FADDD: FP_ADD_D (DR, DA, DB); break;\n\t\tcase FADDQ: FP_ADD_Q (QR, QA, QB); break;\n\t\t/* - */\n\t\tcase FSUBS: FP_SUB_S (SR, SA, SB); break;\n\t\tcase FSUBD: FP_SUB_D (DR, DA, DB); break;\n\t\tcase FSUBQ: FP_SUB_Q (QR, QA, QB); break;\n\t\t/* * */\n\t\tcase FMULS: FP_MUL_S (SR, SA, SB); break;\n\t\tcase FSMULD: FP_CONV (D, S, 1, 1, DA, SA);\n\t\t\t     FP_CONV (D, S, 1, 1, DB, SB);\n\t\tcase FMULD: FP_MUL_D (DR, DA, DB); break;\n\t\tcase FDMULQ: FP_CONV (Q, D, 2, 1, QA, DA);\n\t\t\t     FP_CONV (Q, D, 2, 1, QB, DB);\n\t\tcase FMULQ: FP_MUL_Q (QR, QA, QB); break;\n\t\t/* / */\n\t\tcase FDIVS: FP_DIV_S (SR, SA, SB); break;\n\t\tcase FDIVD: FP_DIV_D (DR, DA, DB); break;\n\t\tcase FDIVQ: FP_DIV_Q (QR, QA, QB); break;\n\t\t/* sqrt */\n\t\tcase FSQRTS: FP_SQRT_S (SR, SB); break;\n\t\tcase FSQRTD: FP_SQRT_D (DR, DB); break;\n\t\tcase FSQRTQ: FP_SQRT_Q (QR, QB); break;\n\t\t/* mov */\n\t\tcase FMOVQ: rd->q[0] = rs2->q[0]; rd->q[1] = rs2->q[1]; break;\n\t\tcase FABSQ: rd->q[0] = rs2->q[0] & 0x7fffffffffffffffUL; rd->q[1] = rs2->q[1]; break;\n\t\tcase FNEGQ: rd->q[0] = rs2->q[0] ^ 0x8000000000000000UL; rd->q[1] = rs2->q[1]; break;\n\t\t/* float to int */\n\t\tcase FSTOI: FP_TO_INT_S (IR, SB, 32, 1); break;\n\t\tcase FDTOI: FP_TO_INT_D (IR, DB, 32, 1); break;\n\t\tcase FQTOI: FP_TO_INT_Q (IR, QB, 32, 1); break;\n\t\tcase FSTOX: FP_TO_INT_S (XR, SB, 64, 1); break;\n\t\tcase FDTOX: FP_TO_INT_D (XR, DB, 64, 1); break;\n\t\tcase FQTOX: FP_TO_INT_Q (XR, QB, 64, 1); break;\n\t\t/* int to float */\n\t\tcase FITOQ: IR = rs2->s; FP_FROM_INT_Q (QR, IR, 32, int); break;\n\t\tcase FXTOQ: XR = rs2->d; FP_FROM_INT_Q (QR, XR, 64, long); break;\n\t\t/* Only Ultra-III generates these */\n\t\tcase FXTOS: XR = rs2->d; FP_FROM_INT_S (SR, XR, 64, long); break;\n\t\tcase FXTOD: XR = rs2->d; FP_FROM_INT_D (DR, XR, 64, long); break;\n#if 0\t\t/* Optimized inline in sparc64/kernel/entry.S */\n\t\tcase FITOS: IR = rs2->s; FP_FROM_INT_S (SR, IR, 32, int); break;\n#endif\n\t\tcase FITOD: IR = rs2->s; FP_FROM_INT_D (DR, IR, 32, int); break;\n\t\t/* float to float */\n\t\tcase FSTOD: FP_CONV (D, S, 1, 1, DR, SB); break;\n\t\tcase FSTOQ: FP_CONV (Q, S, 2, 1, QR, SB); break;\n\t\tcase FDTOQ: FP_CONV (Q, D, 2, 1, QR, DB); break;\n\t\tcase FDTOS: FP_CONV (S, D, 1, 1, SR, DB); break;\n\t\tcase FQTOS: FP_CONV (S, Q, 1, 2, SR, QB); break;\n\t\tcase FQTOD: FP_CONV (D, Q, 1, 2, DR, QB); break;\n\t\t/* comparison */\n\t\tcase FCMPQ:\n\t\tcase FCMPEQ:\n\t\t\tFP_CMP_Q(XR, QB, QA, 3);\n\t\t\tif (XR == 3 &&\n\t\t\t    (((insn >> 5) & 0x1ff) == FCMPEQ ||\n\t\t\t     FP_ISSIGNAN_Q(QA) ||\n\t\t\t     FP_ISSIGNAN_Q(QB)))\n\t\t\t\tFP_SET_EXCEPTION (FP_EX_INVALID);\n\t\t}\n\t\tif (!FP_INHIBIT_RESULTS) {\n\t\t\tswitch ((type >> 6) & 0x7) {\n\t\t\tcase 0: xfsr = current_thread_info()->xfsr[0];\n\t\t\t\tif (XR == -1) XR = 2;\n\t\t\t\tswitch (freg & 3) {\n\t\t\t\t/* fcc0, 1, 2, 3 */\n\t\t\t\tcase 0: xfsr &= ~0xc00; xfsr |= (XR << 10); break;\n\t\t\t\tcase 1: xfsr &= ~0x300000000UL; xfsr |= (XR << 32); break;\n\t\t\t\tcase 2: xfsr &= ~0xc00000000UL; xfsr |= (XR << 34); break;\n\t\t\t\tcase 3: xfsr &= ~0x3000000000UL; xfsr |= (XR << 36); break;\n\t\t\t\t}\n\t\t\t\tcurrent_thread_info()->xfsr[0] = xfsr;\n\t\t\t\tbreak;\n\t\t\tcase 1: rd->s = IR; break;\n\t\t\tcase 2: rd->d = XR; break;\n\t\t\tcase 5: FP_PACK_SP (rd, SR); break;\n\t\t\tcase 6: FP_PACK_DP (rd, DR); break;\n\t\t\tcase 7: FP_PACK_QP (rd, QR); break;\n\t\t\t}\n\t\t}\n\n\t\tif(_fex != 0)\n\t\t\treturn record_exception(regs, _fex);\n\n\t\t/* Success and no exceptions detected. */\n\t\tcurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\n\t\tregs->tpc = regs->tnpc;\n\t\tregs->tnpc += 4;\n\t\treturn 1;\n\t}\nerr:\treturn 0;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2011-2918"
    },
    {
        "index": 6317,
        "code": "int crxSetupImageData(crx_data_header_t *hdr, CrxImage *img, int16_t *outBuf,\r\n                      uint64_t mdatOffset, uint32_t mdatSize,\r\n                      uint8_t *mdatHdrPtr)\r\n{\r\n  int IncrBitTable[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0,\r\n                          0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0};\r\n\r\n  img->planeWidth = hdr->f_width;\r\n  img->planeHeight = hdr->f_height;\r\n\r\n  if (hdr->tileWidth < 0x16 || hdr->tileHeight < 0x16 ||\r\n      img->planeWidth > 0x7FFF || img->planeHeight > 0x7FFF)\r\n    return -1;\r\n\r\n  img->tileCols = (img->planeWidth + hdr->tileWidth - 1) / hdr->tileWidth;\r\n  img->tileRows = (img->planeHeight + hdr->tileHeight - 1) / hdr->tileHeight;\r\n\r\n  if (img->tileCols > 0xFF || img->tileRows > 0xFF ||\r\n      img->planeWidth - hdr->tileWidth * (img->tileCols - 1) < 0x16 ||\r\n      img->planeHeight - hdr->tileHeight * (img->tileRows - 1) < 0x16)\r\n    return -1;\r\n\r\n  img->tiles = 0;\r\n  img->levels = hdr->imageLevels;\r\n  img->subbandCount = 3 * img->levels + 1; // 3 bands per level + one last LL\r\n  img->nPlanes = hdr->nPlanes;\r\n  img->nBits = hdr->nBits;\r\n  img->encType = hdr->encType;\r\n  img->samplePrecision = hdr->nBits + IncrBitTable[4 * hdr->encType + 2] + 1;\r\n  img->mdatOffset = mdatOffset + hdr->mdatHdrSize;\r\n  img->mdatSize = mdatSize;\r\n  img->planeBuf = 0;\r\n  img->outBufs[0] = img->outBufs[1] = img->outBufs[2] = img->outBufs[3] = 0;\r\n\r\n  // The encoding type 3 needs all 4 planes to be decoded to generate row of\r\n  // RGGB values. It seems to be using some other colour space for raw encoding\r\n  // It is a massive buffer so ideallly it will need a different approach:\r\n  // decode planes line by line and convert single line then without\r\n  // intermediate plane buffer. At the moment though it's too many changes so\r\n  // left as is.\r\n  if (img->encType == 3 && img->nPlanes == 4 && img->nBits > 8)\r\n  {\r\n    img->planeBuf =\r\n        (int16_t *)malloc(img->planeHeight * img->planeWidth * img->nPlanes *\r\n                          ((img->samplePrecision + 7) >> 3));\r\n    if (!img->planeBuf)\r\n      return -1;\r\n  }\r\n\r\n  int32_t rowSize = 2 * img->planeWidth;\r\n\r\n  if (img->nPlanes == 1)\r\n    img->outBufs[0] = outBuf;\r\n  else\r\n    switch (hdr->cfaLayout)\r\n    {\r\n    case 0:\r\n      // R G\r\n      // G B\r\n      img->outBufs[0] = outBuf;\r\n      img->outBufs[1] = outBuf + 1;\r\n      img->outBufs[2] = outBuf + rowSize;\r\n      img->outBufs[3] = img->outBufs[2] + 1;\r\n      break;\r\n    case 1:\r\n      // G R\r\n      // B G\r\n      img->outBufs[1] = outBuf;\r\n      img->outBufs[0] = outBuf + 1;\r\n      img->outBufs[3] = outBuf + rowSize;\r\n      img->outBufs[2] = img->outBufs[3] + 1;\r\n      break;\r\n    case 2:\r\n      // G B\r\n      // R G\r\n      img->outBufs[2] = outBuf;\r\n      img->outBufs[3] = outBuf + 1;\r\n      img->outBufs[0] = outBuf + rowSize;\r\n      img->outBufs[1] = img->outBufs[0] + 1;\r\n      break;\r\n    case 3:\r\n      // B G\r\n      // G R\r\n      img->outBufs[3] = outBuf;\r\n      img->outBufs[2] = outBuf + 1;\r\n      img->outBufs[1] = outBuf + rowSize;\r\n      img->outBufs[0] = img->outBufs[1] + 1;\r\n      break;\r\n    }\r\n\r\n  // read header\r\n  return crxReadImageHeaders(hdr, img, mdatHdrPtr, mdatSize);\r\n}\r",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2020-35534"
    },
    {
        "index": 5613,
        "code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    /* defensive in the extreme... */\n                if (chdir(wd) || chdir(name)) {    /* someone rmdir()'d it? */\n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-20176"
    },
    {
        "index": 5529,
        "code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n\n    assert(c != NULL);\n    // if response was original filled with something, but we're now writing\n    // out an error or similar, have to reset the object first.\n    // TODO: since this is often redundant with allocation, how many callers\n    // are actually requiring it be reset? Can we fast test by just looking at\n    // tosend and reset if nonzero?\n    resp_reset(resp);\n\n    if (c->noreply) {\n        // TODO: just invalidate the response since nothing's been attempted\n        // to send yet?\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n\n    // Fill response object with static string.\n\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n\n    conn_set_state(c, conn_new_cmd);\n    return;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2022-48571"
    },
    {
        "index": 17797,
        "code": "TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {\n  setup(false, \"\");\n\n  std::string response_code;\n  std::string response_body;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {\n          response_code = std::string(headers.Status()->value().getStringView());\n        }));\n    decoder->decodeHeaders(std::move(headers), true);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(\"431\", response_code);\n  EXPECT_EQ(\"\", response_body);\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2019-15226"
    },
    {
        "index": 12679,
        "code": "GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tif (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2021-33366"
    },
    {
        "index": 5525,
        "code": "static void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */\n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.inline_ascii_response = false;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; /* disabled */\n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = true;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}",
        "cwe_id": "CWE-399",
        "cve_id": "CVE-2018-1000115"
    },
    {
        "index": 12433,
        "code": "void RemoteFsDevice::load()\n{\n    if (RemoteFsDevice::constSambaAvahiProtocol==details.url.scheme()) {\n        // Start Avahi listener...\n        Avahi::self();\n        QUrlQuery q(details.url);\n        if (q.hasQueryItem(constServiceNameQuery)) {\n            details.serviceName=q.queryItemValue(constServiceNameQuery);\n        }\n\n        if (!details.serviceName.isEmpty()) {\n            AvahiService *srv=Avahi::self()->getService(details.serviceName);\n            if (!srv || srv->getHost().isEmpty()) {\n                sub=tr(\"Not Available\");\n            } else {\n                sub=tr(\"Available\");\n            }\n        }\n        connect(Avahi::self(), SIGNAL(serviceAdded(QString)), SLOT(serviceAdded(QString)));\n        connect(Avahi::self(), SIGNAL(serviceRemoved(QString)), SLOT(serviceRemoved(QString)));\n    }\n\n    if (isConnected()) {\n        setAudioFolder();\n        readOpts(settingsFileName(), opts, true);\n        rescan(false); // Read from cache if we have it!\n    }\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-12559"
    },
    {
        "index": 23019,
        "code": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2023-49294"
    },
    {
        "index": 4848,
        "code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2020-28374"
    },
    {
        "index": 12431,
        "code": "RemoteFsDevice::RemoteFsDevice(MusicLibraryModel *m, const Details &d)\n    : FsDevice(m, d.name, createUdi(d.name))\n    , mountToken(0)\n    , currentMountStatus(false)\n    , details(d)\n    , proc(0)\n    , mounterIface(0)\n    , messageSent(false)\n{\n//    details.path=Utils::fixPath(details.path);\n    setup();\n    icn=MonoIcon::icon(details.isLocalFile()\n                       ? FontAwesome::foldero\n                       : constSshfsProtocol==details.url.scheme()\n                         ? FontAwesome::linux_os\n                         : FontAwesome::windows, Utils::monoIconColor());\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-12559"
    },
    {
        "index": 13029,
        "code": "static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-14363"
    },
    {
        "index": 23733,
        "code": "check_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n\n        /* fallback for malformed epub files */\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n\n                /*We didn't find a match*/\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n\n                return FALSE;\n            }\n        }\n    }\n\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n\n    return FALSE;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2023-52076"
    },
    {
        "index": 23817,
        "code": "ssize_t fio_flush(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  errno = 0;\n  ssize_t flushed = 0;\n  int tmp;\n  /* start critical section */\n  if (fio_trylock(&uuid_data(uuid).sock_lock))\n    goto would_block;\n\n  if (!uuid_data(uuid).packet)\n    goto flush_rw_hook;\n\n  const fio_packet_s *old_packet = uuid_data(uuid).packet;\n  const size_t old_sent = uuid_data(uuid).sent;\n\n  tmp = uuid_data(uuid).packet->write_func(fio_uuid2fd(uuid),\n                                           uuid_data(uuid).packet);\n  if (tmp <= 0) {\n    goto test_errno;\n  }\n\n  if (uuid_data(uuid).packet_count >= 1024 &&\n      uuid_data(uuid).packet == old_packet &&\n      uuid_data(uuid).sent >= old_sent &&\n      (uuid_data(uuid).sent - old_sent) < 32768) {\n    /* Slowloris attack assumed */\n    goto attacked;\n  }\n\n  /* end critical section */\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  /* test for fio_close marker */\n  if (!uuid_data(uuid).packet && uuid_data(uuid).close)\n    goto closed;\n\n  /* return state */\n  return uuid_data(uuid).open && uuid_data(uuid).packet != NULL;\n\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n\nclosed:\n  fio_force_close(uuid);\n  return -1;\n\nflush_rw_hook:\n  flushed = uuid_data(uuid).rw_hooks->flush(uuid, uuid_data(uuid).rw_udata);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  if (!flushed)\n    return 0;\n  if (flushed < 0) {\n    goto test_errno;\n  }\n  touchfd(fio_uuid2fd(uuid));\n  return 1;\n\ntest_errno:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  switch (errno) {\n  case EWOULDBLOCK: /* fallthrough */\n#if EWOULDBLOCK != EAGAIN\n  case EAGAIN: /* fallthrough */\n#endif\n  case ENOTCONN:      /* fallthrough */\n  case EINPROGRESS:   /* fallthrough */\n  case ENOSPC:        /* fallthrough */\n  case EADDRNOTAVAIL: /* fallthrough */\n  case EINTR:\n    return 1;\n  case EFAULT:\n    FIO_LOG_ERROR(\"fio_flush EFAULT - possible memory address error sent to \"\n                  \"Unix socket.\");\n    /* fallthrough */\n  case EPIPE:  /* fallthrough */\n  case EIO:    /* fallthrough */\n  case EINVAL: /* fallthrough */\n  case EBADF:\n    uuid_data(uuid).close = 1;\n    fio_force_close(uuid);\n    return -1;\n  }\n  fprintf(stderr, \"UUID error: %p (%d)\\n\", (void *)uuid, errno);\n  perror(\"No errno handler\");\n  return 0;\n\ninvalid:\n  /* bad UUID */\n  errno = EBADF;\n  return -1;\n\nattacked:\n  /* don't close, just detach from facil.io and mark uuid as invalid */\n  FIO_LOG_WARNING(\"(facil.io) possible Slowloris attack from %.*s\",\n                  (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  return -1;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2024-22050"
    },
    {
        "index": 7825,
        "code": "void do_change_user(int afdt_fd) {\n  std::string uname;\n  lwp_read(afdt_fd, uname);\n  if (!uname.length()) return;\n\n  auto buf = PasswdBuffer{};\n  struct passwd *pw;\n  if (getpwnam_r(uname.c_str(), &buf.ent, buf.data.get(), buf.size, &pw)) {\n    // TODO(alexeyt) should we log something and/or fail to start?\n    return;\n  }\n  if (!pw) {\n    // TODO(alexeyt) should we log something and/or fail to start?\n    return;\n  }\n\n  if (pw->pw_gid) {\n    initgroups(pw->pw_name, pw->pw_gid);\n    setgid(pw->pw_gid);\n  }\n  if (pw->pw_uid) {\n    setuid(pw->pw_uid);\n  }\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2019-3556"
    },
    {
        "index": 23838,
        "code": "static void fio_cli_set_arg(cstr_s arg, char const *value, char const *line,\n                            fio_cli_parser_data_s *parser) {\n  /* handle unnamed argument */\n  if (!line || !arg.len) {\n    if (!value) {\n      goto print_help;\n    }\n    if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||\n        !strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {\n      goto print_help;\n    }\n    cstr_s n = {.len = ++parser->unnamed_count};\n    fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);\n    if (parser->unnamed_max >= 0 &&\n        parser->unnamed_count > parser->unnamed_max) {\n      arg.len = 0;\n      goto error;\n    }\n    return;\n  }\n\n  /* validate data types */\n  char const *type = fio_cli_get_line_type(parser, line);\n  switch ((size_t)type) {\n  case FIO_CLI_BOOL__TYPE_I:\n    if (value && value != parser->argv[parser->pos + 1]) {\n      goto error;\n    }\n    value = \"1\";\n    break;\n  case FIO_CLI_INT__TYPE_I:\n    if (value) {\n      char const *tmp = value;\n      fio_atol((char **)&tmp);\n      if (*tmp) {\n        goto error;\n      }\n    }\n    /* fallthrough */\n  case FIO_CLI_STRING__TYPE_I:\n    if (!value)\n      goto error;\n    if (!value[0])\n      goto finish;\n    break;\n  }\n\n  /* add values using all aliases possible */\n  {\n    cstr_s n = {.data = line};\n    while (n.data[0] == '-') {\n      while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n        ++n.len;\n      }\n      fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n      while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n        ++n.len;\n      }\n      n.data += n.len;\n      n.len = 0;\n    }\n  }\n\nfinish:\n\n  /* handle additional argv progress (if value is on separate argv) */\n  if (value && parser->pos < parser->argc &&\n      value == parser->argv[parser->pos + 1])\n    ++parser->pos;\n  return;\n\nerror: /* handle errors*/\n  /* TODO! */\n  fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\",\n          (int)arg.len, arg.data, arg.len ? \"with value\" : \"\",\n          value ? (value[0] ? value : \"(empty)\") : \"(null)\");\nprint_help:\n  fprintf(stderr, \"\\n%s\\n\",\n          parser->description ? parser->description\n                              : \"This application accepts any of the following \"\n                                \"possible arguments:\");\n  /* print out each line's arguments */\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:  /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      ++pos;\n      continue;\n    }\n    type = (char *)FIO_CLI_STRING__TYPE_I;\n    switch ((intptr_t)pos[1]) {\n    case FIO_CLI_PRINT__TYPE_I:\n      fprintf(stderr, \"%s\\n\", pos[0]);\n      pos += 2;\n      continue;\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);\n      pos += 2;\n      continue;\n\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n      type = pos[1];\n    }\n    /* print line @ pos, starting with main argument name */\n    int alias_count = 0;\n    int first_len = 0;\n    size_t tmp = 0;\n    char const *const p = *pos;\n    while (p[tmp] == '-') {\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        if (!alias_count)\n          ++first_len;\n        ++tmp;\n      }\n      ++alias_count;\n      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n        ++tmp;\n      }\n    }\n    switch ((size_t)type) {\n    case FIO_CLI_STRING__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    case FIO_CLI_BOOL__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);\n      break;\n    case FIO_CLI_INT__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    }\n    /* print aliase information */\n    tmp = first_len;\n    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n      ++tmp;\n    }\n    while (p[tmp] == '-') {\n      const size_t start = tmp;\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        ++tmp;\n      }\n      int padding = first_len - (tmp - start);\n      if (padding < 0)\n        padding = 0;\n      switch ((size_t)type) {\n      case FIO_CLI_STRING__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t\\x1B[2msame as \"\n                \"%.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_BOOL__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t\\x1B[2msame as %.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_INT__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t\\x1B[2msame as \"\n                \"%.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      }\n    }\n\n    ++pos;\n  }\n  fprintf(stderr, \"\\nUse any of the following input formats:\\n\"\n                  \"\\t-arg <value>\\t-arg=<value>\\t-arg<value>\\n\"\n                  \"\\n\"\n                  \"Use the -h, -help or -? to get this information again.\\n\"\n                  \"\\n\");\n  fio_cli_end();\n  exit(0);\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2024-22050"
    },
    {
        "index": 9197,
        "code": "int main(int argc, char *argv[]) {\n  struct mschm_decompressor *chmd;\n  struct mschmd_header *chm;\n  struct mschmd_file *file, **f;\n  unsigned int numf, i;\n\n  setbuf(stdout, NULL);\n  setbuf(stderr, NULL);\n  user_umask = umask(0); umask(user_umask);\n\n  MSPACK_SYS_SELFTEST(i);\n  if (i) return 0;\n\n  if ((chmd = mspack_create_chm_decompressor(NULL))) {\n    for (argv++; *argv; argv++) {\n      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\n\t/* build an ordered list of files for maximum extraction speed */\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}\n\tchmd->close(chmd, chm);\n      }\n      else {\n\tprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n      }\n    }\n    mspack_destroy_chm_decompressor(chmd);\n  }\n  return 0;\n}",
        "cwe_id": "CWE-22",
        "cve_id": "CVE-2018-18586"
    },
    {
        "index": 9592,
        "code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-25136"
    },
    {
        "index": 9595,
        "code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-25136"
    },
    {
        "index": 17402,
        "code": "TEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t\t  size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 17416,
        "code": "TEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t uint32_t key_type,\n\t\t\t\t\t size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\ts->ops = &ecc_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_keypair_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\ts->d = crypto_bignum_allocate(key_size_bits);\n\tif (!s->d)\n\t\tgoto err;\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 6684,
        "code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2016-5768"
    },
    {
        "index": 5024,
        "code": "static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tdev_kfree_skb(skb);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2022-28390"
    },
    {
        "index": 13319,
        "code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-16423"
    },
    {
        "index": 21716,
        "code": "void my_output_message( j_common_ptr ) {} // Don't do anything with messages!",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2021-39432"
    },
    {
        "index": 5042,
        "code": "static int rpmsg_probe(struct virtio_device *vdev)\n{\n\tvq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done };\n\tstatic const char * const names[] = { \"input\", \"output\" };\n\tstruct virtqueue *vqs[2];\n\tstruct virtproc_info *vrp;\n\tstruct virtio_rpmsg_channel *vch = NULL;\n\tstruct rpmsg_device *rpdev_ns, *rpdev_ctrl;\n\tvoid *bufs_va;\n\tint err = 0, i;\n\tsize_t total_buf_space;\n\tbool notify;\n\n\tvrp = kzalloc(sizeof(*vrp), GFP_KERNEL);\n\tif (!vrp)\n\t\treturn -ENOMEM;\n\n\tvrp->vdev = vdev;\n\n\tidr_init(&vrp->endpoints);\n\tmutex_init(&vrp->endpoints_lock);\n\tmutex_init(&vrp->tx_lock);\n\tinit_waitqueue_head(&vrp->sendq);\n\n\t/* We expect two virtqueues, rx and tx (and in this order) */\n\terr = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL);\n\tif (err)\n\t\tgoto free_vrp;\n\n\tvrp->rvq = vqs[0];\n\tvrp->svq = vqs[1];\n\n\t/* we expect symmetric tx/rx vrings */\n\tWARN_ON(virtqueue_get_vring_size(vrp->rvq) !=\n\t\tvirtqueue_get_vring_size(vrp->svq));\n\n\t/* we need less buffers if vrings are small */\n\tif (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2)\n\t\tvrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2;\n\telse\n\t\tvrp->num_bufs = MAX_RPMSG_NUM_BUFS;\n\n\tvrp->buf_size = MAX_RPMSG_BUF_SIZE;\n\n\ttotal_buf_space = vrp->num_bufs * vrp->buf_size;\n\n\t/* allocate coherent memory for the buffers */\n\tbufs_va = dma_alloc_coherent(vdev->dev.parent,\n\t\t\t\t     total_buf_space, &vrp->bufs_dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!bufs_va) {\n\t\terr = -ENOMEM;\n\t\tgoto vqs_del;\n\t}\n\n\tdev_dbg(&vdev->dev, \"buffers: va %pK, dma %pad\\n\",\n\t\tbufs_va, &vrp->bufs_dma);\n\n\t/* half of the buffers is dedicated for RX */\n\tvrp->rbufs = bufs_va;\n\n\t/* and half is dedicated for TX */\n\tvrp->sbufs = bufs_va + total_buf_space / 2;\n\n\t/* set up the receive buffers */\n\tfor (i = 0; i < vrp->num_bufs / 2; i++) {\n\t\tstruct scatterlist sg;\n\t\tvoid *cpu_addr = vrp->rbufs + i * vrp->buf_size;\n\n\t\trpmsg_sg_init(&sg, cpu_addr, vrp->buf_size);\n\n\t\terr = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tWARN_ON(err); /* sanity check; this can't really happen */\n\t}\n\n\t/* suppress \"tx-complete\" interrupts */\n\tvirtqueue_disable_cb(vrp->svq);\n\n\tvdev->priv = vrp;\n\n\trpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev);\n\tif (IS_ERR(rpdev_ctrl)) {\n\t\terr = PTR_ERR(rpdev_ctrl);\n\t\tgoto free_coherent;\n\t}\n\n\t/* if supported by the remote processor, enable the name service */\n\tif (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) {\n\t\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\t\tif (!vch) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_ctrldev;\n\t\t}\n\n\t\t/* Link the channel to our vrp */\n\t\tvch->vrp = vrp;\n\n\t\t/* Assign public information to the rpmsg_device */\n\t\trpdev_ns = &vch->rpdev;\n\t\trpdev_ns->ops = &virtio_rpmsg_ops;\n\t\trpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\t\trpdev_ns->dev.parent = &vrp->vdev->dev;\n\t\trpdev_ns->dev.release = virtio_rpmsg_release_device;\n\n\t\terr = rpmsg_ns_register_device(rpdev_ns);\n\t\tif (err)\n\t\t\tgoto free_vch;\n\t}\n\n\t/*\n\t * Prepare to kick but don't notify yet - we can't do this before\n\t * device is ready.\n\t */\n\tnotify = virtqueue_kick_prepare(vrp->rvq);\n\n\t/* From this point on, we can notify and get callbacks. */\n\tvirtio_device_ready(vdev);\n\n\t/* tell the remote processor it can start sending messages */\n\t/*\n\t * this might be concurrent with callbacks, but we are only\n\t * doing notify, not a full kick here, so that's ok.\n\t */\n\tif (notify)\n\t\tvirtqueue_notify(vrp->rvq);\n\n\tdev_info(&vdev->dev, \"rpmsg host is online\\n\");\n\n\treturn 0;\n\nfree_vch:\n\tkfree(vch);\nfree_ctrldev:\n\trpmsg_virtio_del_ctrl_dev(rpdev_ctrl);\nfree_coherent:\n\tdma_free_coherent(vdev->dev.parent, total_buf_space,\n\t\t\t  bufs_va, vrp->bufs_dma);\nvqs_del:\n\tvdev->config->del_vqs(vrp->vdev);\nfree_vrp:\n\tkfree(vrp);\n\treturn err;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2022-34495"
    },
    {
        "index": 17418,
        "code": "TEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\ts->ops = &ecc_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_public_key_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 5027,
        "code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2022-28389"
    },
    {
        "index": 17407,
        "code": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 11588,
        "code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2020-27794"
    },
    {
        "index": 17372,
        "code": "static TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2023-41325"
    },
    {
        "index": 13410,
        "code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2018-16425"
    },
    {
        "index": 7558,
        "code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2019-6978"
    },
    {
        "index": 3579,
        "code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}",
        "cwe_id": "CWE-415",
        "cve_id": "CVE-2017-18174"
    },
    {
        "index": 17634,
        "code": "bool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2019-13226"
    },
    {
        "index": 8261,
        "code": "create_watching_parent (void)\n{\n  pid_t child;\n  sigset_t ourset;\n  struct sigaction oldact[3];\n  int status = 0;\n  int retval;\n\n  retval = pam_open_session (pamh, 0);\n  if (is_pam_failure(retval))\n    {\n      cleanup_pam (retval);\n      errx (EXIT_FAILURE, _(\"cannot open session: %s\"),\n\t     pam_strerror (pamh, retval));\n    }\n  else\n    _pam_session_opened = 1;\n\n  memset(oldact, 0, sizeof(oldact));\n\n  child = fork ();\n  if (child == (pid_t) -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _(\"cannot create child process\"));\n    }\n\n  /* the child proceeds to run the shell */\n  if (child == 0)\n    return;\n\n  /* In the parent watch the child.  */\n\n  /* su without pam support does not have a helper that keeps\n     sitting on any directory so let's go to /.  */\n  if (chdir (\"/\") != 0)\n    warn (_(\"cannot change directory to %s\"), \"/\");\n\n  sigfillset (&ourset);\n  if (sigprocmask (SIG_BLOCK, &ourset, NULL))\n    {\n      warn (_(\"cannot block signals\"));\n      caught_signal = true;\n    }\n  if (!caught_signal)\n    {\n      struct sigaction action;\n      action.sa_handler = su_catch_sig;\n      sigemptyset (&action.sa_mask);\n      action.sa_flags = 0;\n      sigemptyset (&ourset);\n    if (!same_session)\n      {\n        if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))\n          {\n            warn (_(\"cannot set signal handler\"));\n            caught_signal = true;\n          }\n      }\n    if (!caught_signal && (sigaddset(&ourset, SIGTERM)\n                    || sigaddset(&ourset, SIGALRM)\n                    || sigaction(SIGTERM, &action, &oldact[0])\n                    || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {\n\t  warn (_(\"cannot set signal handler\"));\n\t  caught_signal = true;\n\t}\n    if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])\n                                     || sigaction(SIGQUIT, &action, &oldact[2])))\n      {\n        warn (_(\"cannot set signal handler\"));\n        caught_signal = true;\n      }\n    }\n  if (!caught_signal)\n    {\n      pid_t pid;\n      for (;;)\n\t{\n\t  pid = waitpid (child, &status, WUNTRACED);\n\n\t  if (pid != (pid_t)-1 && WIFSTOPPED (status))\n\t    {\n\t      kill (getpid (), SIGSTOP);\n\t      /* once we get here, we must have resumed */\n\t      kill (pid, SIGCONT);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(\" ...killed.\\n\"));\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);\n          break;\n        case SIGINT:\n          sigaction(SIGINT, &oldact[1], NULL);\n          break;\n        case SIGQUIT:\n          sigaction(SIGQUIT, &oldact[2], NULL);\n          break;\n        default:\n\t  /* just in case that signal stuff initialization failed and\n\t   * caught_signal = true */\n          caught_signal = SIGKILL;\n          break;\n      }\n      kill(getpid(), caught_signal);\n    }\n  exit (status);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-2616"
    },
    {
        "index": 2745,
        "code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\n\t/* ipc_addid() locks msq upon success. */\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\n\treturn msq->q_perm.id;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2015-7613"
    },
    {
        "index": 9119,
        "code": "int ha_myisam::repair(THD *thd, MI_CHECK &param, bool do_optimize)\n{\n  int error=0;\n  uint local_testflag=param.testflag;\n  bool optimize_done= !do_optimize, statistics_done=0;\n  const char *old_proc_info=thd->proc_info;\n  char fixed_name[FN_REFLEN];\n  MYISAM_SHARE* share = file->s;\n  ha_rows rows= file->state->records;\n  DBUG_ENTER(\"ha_myisam::repair\");\n\n  param.db_name=    table->s->db.str;\n  param.table_name= table->alias;\n  param.using_global_keycache = 1;\n  param.thd= thd;\n  param.tmpdir= &mysql_tmpdir_list;\n  param.out_flag= 0;\n  strmov(fixed_name,file->filename);\n\n  // Release latches since this can take a long time\n  ha_release_temporary_latches(thd);\n\n  // Don't lock tables if we have used LOCK TABLE\n  if (! thd->locked_tables_mode &&\n      mi_lock_database(file, table->s->tmp_table ? F_EXTRA_LCK : F_WRLCK))\n  {\n    mi_check_print_error(&param,ER(ER_CANT_LOCK),my_errno);\n    DBUG_RETURN(HA_ADMIN_FAILED);\n  }\n\n  if (!do_optimize ||\n      ((file->state->del || share->state.split != file->state->records) &&\n       (!(param.testflag & T_QUICK) ||\n\t!(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))))\n  {\n    ulonglong key_map= ((local_testflag & T_CREATE_MISSING_KEYS) ?\n\t\t\tmi_get_mask_all_keys_active(share->base.keys) :\n\t\t\tshare->state.key_map);\n    uint testflag=param.testflag;\n#ifdef HAVE_MMAP\n    bool remap= test(share->file_map);\n    /*\n      mi_repair*() functions family use file I/O even if memory\n      mapping is available.\n\n      Since mixing mmap I/O and file I/O may cause various artifacts,\n      memory mapping must be disabled.\n    */\n    if (remap)\n      mi_munmap_file(file);\n#endif\n    if (mi_test_if_sort_rep(file,file->state->records,key_map,0) &&\n\t(local_testflag & T_REP_BY_SORT))\n    {\n      local_testflag|= T_STATISTICS;\n      param.testflag|= T_STATISTICS;\t\t// We get this for free\n      statistics_done=1;\n      if (THDVAR(thd, repair_threads)>1)\n      {\n        char buf[40];\n        /* TODO: respect myisam_repair_threads variable */\n        my_snprintf(buf, 40, \"Repair with %d threads\", my_count_bits(key_map));\n        thd_proc_info(thd, buf);\n        error = mi_repair_parallel(&param, file, fixed_name,\n            param.testflag & T_QUICK);\n        thd_proc_info(thd, \"Repair done\"); // to reset proc_info, as\n                                      // it was pointing to local buffer\n      }\n      else\n      {\n        thd_proc_info(thd, \"Repair by sorting\");\n        error = mi_repair_by_sort(&param, file, fixed_name,\n            param.testflag & T_QUICK);\n      }\n    }\n    else\n    {\n      thd_proc_info(thd, \"Repair with keycache\");\n      param.testflag &= ~T_REP_BY_SORT;\n      error=  mi_repair(&param, file, fixed_name,\n\t\t\tparam.testflag & T_QUICK);\n    }\n#ifdef HAVE_MMAP\n    if (remap)\n      mi_dynmap_file(file, file->state->data_file_length);\n#endif\n    param.testflag=testflag;\n    optimize_done=1;\n  }\n  if (!error)\n  {\n    if ((local_testflag & T_SORT_INDEX) &&\n\t(share->state.changed & STATE_NOT_SORTED_PAGES))\n    {\n      optimize_done=1;\n      thd_proc_info(thd, \"Sorting index\");\n      error=mi_sort_index(&param,file,fixed_name);\n    }\n    if (!statistics_done && (local_testflag & T_STATISTICS))\n    {\n      if (share->state.changed & STATE_NOT_ANALYZED)\n      {\n\toptimize_done=1;\n\tthd_proc_info(thd, \"Analyzing\");\n\terror = chk_key(&param, file);\n      }\n      else\n\tlocal_testflag&= ~T_STATISTICS;\t\t// Don't update statistics\n    }\n  }\n  thd_proc_info(thd, \"Saving state\");\n  if (!error)\n  {\n    if ((share->state.changed & STATE_CHANGED) || mi_is_crashed(file))\n    {\n      share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t       STATE_CRASHED_ON_REPAIR);\n      file->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;\n    }\n    /*\n      the following 'if', thought conceptually wrong,\n      is a useful optimization nevertheless.\n    */\n    if (file->state != &file->s->state.state)\n      file->s->state.state = *file->state;\n    if (file->s->base.auto_key)\n      update_auto_increment_key(&param, file, 1);\n    if (optimize_done)\n      error = update_state_info(&param, file,\n\t\t\t\tUPDATE_TIME | UPDATE_OPEN_COUNT |\n\t\t\t\t(local_testflag &\n\t\t\t\t T_STATISTICS ? UPDATE_STAT : 0));\n    info(HA_STATUS_NO_LOCK | HA_STATUS_TIME | HA_STATUS_VARIABLE |\n\t HA_STATUS_CONST);\n    if (rows != file->state->records && ! (param.testflag & T_VERY_SILENT))\n    {\n      char llbuff[22],llbuff2[22];\n      mi_check_print_warning(&param,\"Number of rows changed from %s to %s\",\n\t\t\t     llstr(rows,llbuff),\n\t\t\t     llstr(file->state->records,llbuff2));\n    }\n  }\n  else\n  {\n    mi_mark_crashed_on_repair(file);\n    file->update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;\n    update_state_info(&param, file, 0);\n  }\n  thd_proc_info(thd, old_proc_info);\n  if (! thd->locked_tables_mode)\n    mi_lock_database(file,F_UNLCK);\n  DBUG_RETURN(error ? HA_ADMIN_FAILED :\n\t      !optimize_done ? HA_ADMIN_ALREADY_DONE : HA_ADMIN_OK);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-6663"
    },
    {
        "index": 651,
        "code": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\n\t/* In the case of sock_create_lite(), the sock->sk field is not\n\t * defined yet but it is not a problem as the only users of these\n\t * \"lite\" PF_INET sockets are functions which do an accept() call\n\t * afterwards so we will label the socket as part of the accept(). */\n\tif (sk == NULL)\n\t\treturn 0;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\n\treturn 0;\n\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 1003,
        "code": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2011-1833"
    },
    {
        "index": 2432,
        "code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2014-9710"
    },
    {
        "index": 2907,
        "code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2015-8839"
    },
    {
        "index": 4667,
        "code": "__mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tmpt_ioctl_header __user *uhdr = (void __user *) arg;\n\tmpt_ioctl_header\t khdr;\n\tint iocnum;\n\tunsigned iocnumX;\n\tint nonblock = (file->f_flags & O_NONBLOCK);\n\tint ret;\n\tMPT_ADAPTER *iocp = NULL;\n\n\tif (copy_from_user(&khdr, uhdr, sizeof(khdr))) {\n\t\tprintk(KERN_ERR MYNAM \"%s::mptctl_ioctl() @%d - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_header data @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uhdr);\n\t\treturn -EFAULT;\n\t}\n\tret = -ENXIO;\t\t\t\t/* (-6) No such device or address */\n\n\t/* Verify intended MPT adapter - set iocnum and the adapter\n\t * pointer (iocp)\n\t */\n\tiocnumX = khdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL))\n\t\treturn -ENODEV;\n\n\tif (!iocp->active) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_ioctl() @%d - Controller disabled.\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Handle those commands that are just returning\n\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t */\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(arg);\n\t}\n\n\t/* All of these commands require an interrupt or\n\t * are unknown/illegal.\n\t */\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2020-12652"
    },
    {
        "index": 632,
        "code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 645,
        "code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\n\treturn 0;\n\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2012-3552"
    },
    {
        "index": 4783,
        "code": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2020-27675"
    },
    {
        "index": 4493,
        "code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\n\t/*\n\t * If the granularity bit is set, the limit is given in multiples\n\t * of 4096. This also means that the 12 least significant bits are\n\t * not tested when checking the segment limits. In practice,\n\t * this means that the segment ends in (limit << 12) + 0xfff.\n\t */\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2019-13233"
    },
    {
        "index": 17598,
        "code": "bool DDeviceDiskInfoPrivate::openDataStream(int index)\n{\n    if (process) {\n        process->deleteLater();\n    }\n\n    process = new QProcess();\n\n    QObject::connect(process, static_cast<void (QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n                     process, [this] (int code, QProcess::ExitStatus status) {\n        if (isClosing())\n            return;\n\n        if (status == QProcess::CrashExit) {\n            setErrorString(QObject::tr(\"process \\\"%1 %2\\\" crashed\").arg(process->program()).arg(process->arguments().join(\" \")));\n        } else if (code != 0) {\n            setErrorString(QObject::tr(\"Failed to perform process \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(QString::fromUtf8(process->readAllStandardError())));\n        }\n    });\n\n    switch (currentScope) {\n    case DDiskInfo::Headgear: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            process->start(QStringLiteral(\"dd if=%1 bs=512 count=2048 status=none\").arg(filePath()), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"dd of=%1 bs=512 status=none conv=fsync\").arg(filePath()));\n        }\n\n        break;\n    }\n    case DDiskInfo::PartitionTable: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read)\n            process->start(QStringLiteral(\"sfdisk -d %1\").arg(filePath()), QIODevice::ReadOnly);\n        else\n            process->start(QStringLiteral(\"sfdisk %1 --no-reread\").arg(filePath()));\n\n        break;\n    }\n    case DDiskInfo::Partition: {\n        const DPartInfo &part = (index == 0 && currentMode == DDiskInfo::Write) ? DDevicePartInfo(filePath()) : q->getPartByNumber(index);\n\n        if (!part) {\n            dCDebug(\"Part is null(index: %d)\", index);\n\n            return false;\n        }\n\n        dCDebug(\"Try open device: %s, mode: %s\", qPrintable(part.filePath()), currentMode == DDiskInfo::Read ? \"Read\" : \"Write\");\n\n        if (Helper::isMounted(part.filePath())) {\n            if (Helper::umountDevice(part.filePath())) {\n                part.d->mountPoint.clear();\n            } else {\n                setErrorString(QObject::tr(\"\\\"%1\\\" is busy\").arg(part.filePath()));\n\n                return false;\n            }\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            const QString &executer = Helper::getPartcloneExecuter(part);\n            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /tmp/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /tmp/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n        }\n\n        break;\n    }\n    case DDiskInfo::JsonInfo: {\n        process->deleteLater();\n        process = 0;\n        buffer.setData(q->toJson());\n        break;\n    }\n    default:\n        return false;\n    }\n\n    if (process) {\n        if (!process->waitForStarted()) {\n            setErrorString(QObject::tr(\"Failed to start \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(process->errorString()));\n\n            return false;\n        }\n\n        dCDebug(\"The \\\"%s %s\\\" command start finished\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")));\n    }\n\n    bool ok = process ? process->isOpen() : buffer.open(QIODevice::ReadOnly);\n\n    if (!ok) {\n        setErrorString(QObject::tr(\"Failed to open process, error: %1\").arg(process ? process->errorString(): buffer.errorString()));\n    }\n\n    return ok;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2019-13226"
    },
    {
        "index": 9129,
        "code": "static int myisamchk(MI_CHECK *param, char * filename)\n{\n  int error,lock_type,recreate;\n  int rep_quick= param->testflag & (T_QUICK | T_FORCE_UNIQUENESS);\n  MI_INFO *info;\n  File datafile;\n  char llbuff[22],llbuff2[22];\n  my_bool state_updated=0;\n  MYISAM_SHARE *share;\n  DBUG_ENTER(\"myisamchk\");\n\n  param->out_flag=error=param->warning_printed=param->error_printed=\n    recreate=0;\n  datafile=0;\n  param->isam_file_name=filename;\t\t/* For error messages */\n  if (!(info=mi_open(filename,\n\t\t     (param->testflag & (T_DESCRIPT | T_READONLY)) ?\n\t\t     O_RDONLY : O_RDWR,\n\t\t     HA_OPEN_FOR_REPAIR |\n\t\t     ((param->testflag & T_WAIT_FOREVER) ?\n\t\t      HA_OPEN_WAIT_IF_LOCKED :\n\t\t      (param->testflag & T_DESCRIPT) ?\n\t\t      HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED))))\n  {\n    /* Avoid twice printing of isam file name */\n    param->error_printed=1;\n    switch (my_errno) {\n    case HA_ERR_CRASHED:\n      mi_check_print_error(param,\"'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair\",filename);\n      break;\n    case HA_ERR_NOT_A_TABLE:\n      mi_check_print_error(param,\"'%s' is not a MyISAM-table\",filename);\n      break;\n    case HA_ERR_CRASHED_ON_USAGE:\n      mi_check_print_error(param,\"'%s' is marked as crashed\",filename);\n      break;\n    case HA_ERR_CRASHED_ON_REPAIR:\n      mi_check_print_error(param,\"'%s' is marked as crashed after last repair\",filename);\n      break;\n    case HA_ERR_OLD_FILE:\n      mi_check_print_error(param,\"'%s' is an old type of MyISAM-table\", filename);\n      break;\n    case HA_ERR_END_OF_FILE:\n      mi_check_print_error(param,\"Couldn't read complete header from '%s'\", filename);\n      break;\n    case EAGAIN:\n      mi_check_print_error(param,\"'%s' is locked. Use -w to wait until unlocked\",filename);\n      break;\n    case ENOENT:\n      mi_check_print_error(param,\"File '%s' doesn't exist\",filename);\n      break;\n    case EACCES:\n      mi_check_print_error(param,\"You don't have permission to use '%s'\",filename);\n      break;\n    default:\n      mi_check_print_error(param,\"%d when opening MyISAM-table '%s'\",\n\t\t  my_errno,filename);\n      break;\n    }\n    DBUG_RETURN(1);\n  }\n  share=info->s;\n  share->options&= ~HA_OPTION_READ_ONLY_DATA; /* We are modifing it */\n  share->tot_locks-= share->r_locks;\n  share->r_locks=0;\n\n  /*\n    Skip the checking of the file if:\n    We are using --fast and the table is closed properly\n    We are using --check-only-changed-tables and the table hasn't changed\n  */\n  if (param->testflag & (T_FAST | T_CHECK_ONLY_CHANGED))\n  {\n    my_bool need_to_check= mi_is_crashed(info) || share->state.open_count != 0;\n\n    if ((param->testflag & (T_REP_ANY | T_SORT_RECORDS)) &&\n\t((share->state.changed & (STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t  STATE_CRASHED_ON_REPAIR) ||\n\t  !(param->testflag & T_CHECK_ONLY_CHANGED))))\n      need_to_check=1;\n\n    if (info->s->base.keys && info->state->records)\n    {\n      if ((param->testflag & T_STATISTICS) &&\n          (share->state.changed & STATE_NOT_ANALYZED))\n        need_to_check=1;\n      if ((param->testflag & T_SORT_INDEX) &&\n          (share->state.changed & STATE_NOT_SORTED_PAGES))\n        need_to_check=1;\n      if ((param->testflag & T_REP_BY_SORT) &&\n          (share->state.changed & STATE_NOT_OPTIMIZED_KEYS))\n        need_to_check=1;\n    }\n    if ((param->testflag & T_CHECK_ONLY_CHANGED) &&\n\t(share->state.changed & (STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR)))\n      need_to_check=1;\n    if (!need_to_check)\n    {\n      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)\n\tprintf(\"MyISAM file: %s is already checked\\n\",filename);\n      if (mi_close(info))\n      {\n\tmi_check_print_error(param,\"%d when closing MyISAM-table '%s'\",\n\t\t\t     my_errno,filename);\n\tDBUG_RETURN(1);\n      }\n      DBUG_RETURN(0);\n    }\n  }\n  if ((param->testflag & (T_REP_ANY | T_STATISTICS |\n\t\t\t  T_SORT_RECORDS | T_SORT_INDEX)) &&\n      (((param->testflag & T_UNPACK) &&\n\tshare->data_file_type == COMPRESSED_RECORD) ||\n       mi_uint2korr(share->state.header.state_info_length) !=\n       MI_STATE_INFO_SIZE ||\n       mi_uint2korr(share->state.header.base_info_length) !=\n       MI_BASE_INFO_SIZE ||\n       mi_is_any_intersect_keys_active(param->keys_in_use, share->base.keys,\n                                       ~share->state.key_map) ||\n       test_if_almost_full(info) ||\n       info->s->state.header.file_version[3] != myisam_file_magic[3] ||\n       (set_collation &&\n        set_collation->number != share->state.header.language) ||\n       myisam_block_size != MI_KEY_BLOCK_LENGTH))\n  {\n    if (set_collation)\n      param->language= set_collation->number;\n    if (recreate_table(param, &info,filename))\n    {\n      (void) fprintf(stderr,\n\t\t   \"MyISAM-table '%s' is not fixed because of errors\\n\",\n\t      filename);\n      return(-1);\n    }\n    recreate=1;\n    if (!(param->testflag & T_REP_ANY))\n    {\n      param->testflag|=T_REP_BY_SORT;\t\t/* if only STATISTICS */\n      if (!(param->testflag & T_SILENT))\n\tprintf(\"- '%s' has old table-format. Recreating index\\n\",filename);\n      rep_quick|=T_QUICK;\n    }\n    share=info->s;\n    share->tot_locks-= share->r_locks;\n    share->r_locks=0;\n  }\n\n  if (param->testflag & T_DESCRIPT)\n  {\n    param->total_files++;\n    param->total_records+=info->state->records;\n    param->total_deleted+=info->state->del;\n    descript(param, info, filename);\n  }\n  else\n  {\n    if (!stopwords_inited++)\n      ft_init_stopwords();\n\n    if (!(param->testflag & T_READONLY))\n      lock_type = F_WRLCK;\t\t\t/* table is changed */\n    else\n      lock_type= F_RDLCK;\n    if (info->lock_type == F_RDLCK)\n      info->lock_type=F_UNLCK;\t\t\t/* Read only table */\n    if (_mi_readinfo(info,lock_type,0))\n    {\n      mi_check_print_error(param,\"Can't lock indexfile of '%s', error: %d\",\n\t\t  filename,my_errno);\n      param->error_printed=0;\n      goto end2;\n    }\n    /*\n      _mi_readinfo() has locked the table.\n      We mark the table as locked (without doing file locks) to be able to\n      use functions that only works on locked tables (like row caching).\n    */\n    mi_lock_database(info, F_EXTRA_LCK);\n    datafile=info->dfile;\n\n    if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))\n    {\n      if (param->testflag & T_REP_ANY)\n      {\n\tulonglong tmp=share->state.key_map;\n\tmi_copy_keys_active(share->state.key_map, share->base.keys,\n                            param->keys_in_use);\n\tif (tmp != share->state.key_map)\n\t  info->update|=HA_STATE_CHANGED;\n      }\n      if (rep_quick && chk_del(param, info, param->testflag & ~T_VERBOSE))\n      {\n\tif (param->testflag & T_FORCE_CREATE)\n\t{\n\t  rep_quick=0;\n\t  mi_check_print_info(param,\"Creating new data file\\n\");\n\t}\n\telse\n\t{\n\t  error=1;\n\t  mi_check_print_error(param,\n\t\t\t       \"Quick-recover aborted; Run recovery without switch 'q'\");\n\t}\n      }\n      if (!error)\n      {\n\tif ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&\n\t    (mi_is_any_key_active(share->state.key_map) ||\n\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          if (param->testflag & T_REP_BY_SORT)\n            error=mi_repair_by_sort(param,info,filename,rep_quick);\n          else\n            error=mi_repair_parallel(param,info,filename,rep_quick);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error=mi_repair(param, info,filename,rep_quick);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  soon remove the following reopen-code\n\t*/\n#ifndef TO_BE_REMOVED\n\tif (param->out_flag & O_NEW_DATA)\n\t{\t\t\t/* Change temp file to org file */\n\t  (void) my_close(info->dfile,MYF(MY_WME)); /* Close new file */\n\t  error|=change_to_newfile(filename, MI_NAME_DEXT, DATA_TMP_EXT, MYF(0));\n\t  if (mi_open_datafile(info,info->s, NULL, -1))\n\t    error=1;\n\t  param->out_flag&= ~O_NEW_DATA; /* We are using new datafile */\n\t  param->read_cache.file=info->dfile;\n\t}\n#endif\n\tif (! error)\n\t{\n\t  uint key;\n\t  /*\n\t    We can't update the index in mi_sort_records if we have a\n\t    prefix compressed or fulltext index\n\t  */\n\t  my_bool update_index=1;\n\t  for (key=0 ; key < share->base.keys; key++)\n\t    if (share->keyinfo[key].flag & (HA_BINARY_PACK_KEY|HA_FULLTEXT))\n\t      update_index=0;\n\n\t  error=mi_sort_records(param,info,filename,param->opt_sort_key,\n                             /* what is the following parameter for ? */\n\t\t\t\t(my_bool) !(param->testflag & T_REP),\n\t\t\t\tupdate_index);\n\t  datafile=info->dfile;\t/* This is now locked */\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error=mi_repair_by_sort(param,info,filename,1);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror=mi_sort_index(param,info,filename);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);\n    }\n    else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))\n    {\n      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)\n\tprintf(\"Checking MyISAM file: %s\\n\",filename);\n      if (!(param->testflag & T_SILENT))\n\tprintf(\"Data records: %7s   Deleted blocks: %7s\\n\",\n\t       llstr(info->state->records,llbuff),\n\t       llstr(info->state->del,llbuff2));\n      error =chk_status(param,info);\n      mi_intersect_keys_active(share->state.key_map, param->keys_in_use);\n      error =chk_size(param,info);\n      if (!error || !(param->testflag & (T_FAST | T_FORCE_CREATE)))\n\terror|=chk_del(param, info,param->testflag);\n      if ((!error || (!(param->testflag & (T_FAST | T_FORCE_CREATE)) &&\n\t\t      !param->start_check_pos)))\n      {\n\terror|=chk_key(param, info);\n\tif (!error && (param->testflag & (T_STATISTICS | T_AUTO_INC)))\n\t  error=update_state_info(param, info,\n\t\t\t\t  ((param->testflag & T_STATISTICS) ?\n\t\t\t\t   UPDATE_STAT : 0) |\n\t\t\t\t  ((param->testflag & T_AUTO_INC) ?\n\t\t\t\t   UPDATE_AUTO_INC : 0));\n      }\n      if ((!rep_quick && !error) ||\n\t  !(param->testflag & (T_FAST | T_FORCE_CREATE)))\n      {\n\tif (param->testflag & (T_EXTEND | T_MEDIUM))\n\t  (void) init_key_cache(dflt_key_cache,opt_key_cache_block_size,\n                              param->use_buffers, 0, 0);\n\t(void) init_io_cache(&param->read_cache,datafile,\n\t\t\t   (uint) param->read_buffer_length,\n\t\t\t   READ_CACHE,\n\t\t\t   (param->start_check_pos ?\n\t\t\t    param->start_check_pos :\n\t\t\t    share->pack.header_length),\n\t\t\t   1,\n\t\t\t   MYF(MY_WME));\n\tlock_memory(param);\n\tif ((info->s->options & (HA_OPTION_PACK_RECORD |\n\t\t\t\t HA_OPTION_COMPRESS_RECORD)) ||\n\t    (param->testflag & (T_EXTEND | T_MEDIUM)))\n\t  error|=chk_data_link(param, info, param->testflag & T_EXTEND);\n\terror|=flush_blocks(param, share->key_cache, share->kfile);\n\t(void) end_io_cache(&param->read_cache);\n      }\n      if (!error)\n      {\n\tif ((share->state.changed & STATE_CHANGED) &&\n\t    (param->testflag & T_UPDATE_STATE))\n\t  info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      }\n      else if (!mi_is_crashed(info) &&\n\t       (param->testflag & T_UPDATE_STATE))\n      {\t\t\t\t\t\t/* Mark crashed */\n\tmi_mark_crashed(info);\n\tinfo->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;\n      }\n    }\n  }\n  if ((param->testflag & T_AUTO_INC) ||\n      ((param->testflag & T_REP_ANY) && info->s->base.auto_key))\n    update_auto_increment_key(param, info,\n\t\t\t      (my_bool) !test(param->testflag & T_AUTO_INC));\n\n  if (!(param->testflag & T_DESCRIPT))\n  {\n    if (info->update & HA_STATE_CHANGED && ! (param->testflag & T_READONLY))\n      error|=update_state_info(param, info,\n\t\t\t       UPDATE_OPEN_COUNT |\n\t\t\t       (((param->testflag & T_REP_ANY) ?\n\t\t\t\t UPDATE_TIME : 0) |\n\t\t\t\t(state_updated ? UPDATE_STAT : 0) |\n\t\t\t\t((param->testflag & T_SORT_RECORDS) ?\n\t\t\t\t UPDATE_SORT : 0)));\n    (void) lock_file(param, share->kfile,0L,F_UNLCK,\"indexfile\",filename);\n    info->update&= ~HA_STATE_CHANGED;\n  }\n  mi_lock_database(info, F_UNLCK);\nend2:\n  if (mi_close(info))\n  {\n    mi_check_print_error(param,\"%d when closing MyISAM-table '%s'\",my_errno,filename);\n    DBUG_RETURN(1);\n  }\n  if (error == 0)\n  {\n    if (param->out_flag & O_NEW_DATA)\n      error|=change_to_newfile(filename,MI_NAME_DEXT,DATA_TMP_EXT,\n\t\t\t       ((param->testflag & T_BACKUP_DATA) ?\n\t\t\t\tMYF(MY_REDEL_MAKE_BACKUP) : MYF(0)));\n    if (param->out_flag & O_NEW_INDEX)\n      error|=change_to_newfile(filename, MI_NAME_IEXT, INDEX_TMP_EXT, MYF(0));\n  }\n  (void) fflush(stdout); (void) fflush(stderr);\n  if (param->error_printed)\n  {\n    if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))\n    {\n      (void) fprintf(stderr,\n\t\t   \"MyISAM-table '%s' is not fixed because of errors\\n\",\n\t\t   filename);\n      if (param->testflag & T_REP_ANY)\n\t(void) fprintf(stderr,\n\t\t     \"Try fixing it by using the --safe-recover (-o), the --force (-f) option or by not using the --quick (-q) flag\\n\");\n    }\n    else if (!(param->error_printed & 2) &&\n\t     !(param->testflag & T_FORCE_CREATE))\n      (void) fprintf(stderr,\n      \"MyISAM-table '%s' is corrupted\\nFix it using switch \\\"-r\\\" or \\\"-o\\\"\\n\",\n\t      filename);\n  }\n  else if (param->warning_printed &&\n\t   ! (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX |\n\t\t\t  T_FORCE_CREATE)))\n    (void) fprintf(stderr, \"MyISAM-table '%s' is usable but should be fixed\\n\",\n\t\t filename);\n  (void) fflush(stderr);\n  DBUG_RETURN(error);\n} /* myisamchk */",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-6663"
    },
    {
        "index": 21514,
        "code": "static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    /* remove potentially scheduled timers for this datagram */\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            /* remove frames of this datagram from frame queue */\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                /* unset packet just to be safe */\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        /* reset frame queue with remaining frames */\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2023-33974"
    },
    {
        "index": 3267,
        "code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-6130"
    },
    {
        "index": 2987,
        "code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n\t\t    timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* remove slave links */\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t\tmutex_unlock(&register_mutex);\n\t}\n out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-2547"
    },
    {
        "index": 5288,
        "code": "static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\n\t/* Finish outstanding timers, making sure they are done */\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\n\t/* Finish writing to ldisc */\n\tflush_work(&gsm->tx_work);\n\n\t/* Free up any link layer users and finally the control channel */\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\t/* Now wipe the queues */\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2023-6546"
    },
    {
        "index": 4024,
        "code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\n\tdm_get(md);\n\treturn md;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2017-18203"
    },
    {
        "index": 19475,
        "code": "static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock;\n    SSL *ossl_ssl;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    pj_assert(ossl_ssl);\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    pj_assert(ssock);\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n\n    case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\n    case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\n    case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\n    case X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\n\tssock->verify_status |= PJ_SSL_CERT_EINVALID_FORMAT;\n\tbreak;\n\n    case X509_V_ERR_CERT_NOT_YET_VALID:\n    case X509_V_ERR_CERT_HAS_EXPIRED:\n\tssock->verify_status |= PJ_SSL_CERT_EVALIDITY_PERIOD;\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_CRL:\n    case X509_V_ERR_CRL_NOT_YET_VALID:\n    case X509_V_ERR_CRL_HAS_EXPIRED:\n    case X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\n    case X509_V_ERR_CRL_SIGNATURE_FAILURE:\n    case X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\n    case X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\n\tssock->verify_status |= PJ_SSL_CERT_ECRL_FAILURE;\n\tbreak;\t\n\n    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n    case X509_V_ERR_CERT_UNTRUSTED:\n    case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n\tssock->verify_status |= PJ_SSL_CERT_EUNTRUSTED;\n\tbreak;\t\n\n    case X509_V_ERR_CERT_SIGNATURE_FAILURE:\n    case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n    case X509_V_ERR_SUBJECT_ISSUER_MISMATCH:\n    case X509_V_ERR_AKID_SKID_MISMATCH:\n    case X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH:\n    case X509_V_ERR_KEYUSAGE_NO_CERTSIGN:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_MISMATCH;\n\tbreak;\n\n    case X509_V_ERR_CERT_REVOKED:\n\tssock->verify_status |= PJ_SSL_CERT_EREVOKED;\n\tbreak;\t\n\n    case X509_V_ERR_INVALID_PURPOSE:\n    case X509_V_ERR_CERT_REJECTED:\n    case X509_V_ERR_INVALID_CA:\n\tssock->verify_status |= PJ_SSL_CERT_EINVALID_PURPOSE;\n\tbreak;\n\n    case X509_V_ERR_CERT_CHAIN_TOO_LONG: /* not really used */\n    case X509_V_ERR_PATH_LENGTH_EXCEEDED:\n\tssock->verify_status |= PJ_SSL_CERT_ECHAIN_TOO_LONG;\n\tbreak;\n\n    /* Unknown errors */\n    case X509_V_ERR_OUT_OF_MEM:\n    default:\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    /* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\n    return preverify_ok;\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2021-32686"
    },
    {
        "index": 2976,
        "code": "void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution, ticks;\n\tstruct list_head *p, *ack_list_head;\n\tunsigned long flags;\n\tint use_tasklet = 0;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t/* remember the current resolution */\n\tif (timer->hw.c_resolution)\n\t\tresolution = timer->hw.c_resolution(timer);\n\telse\n\t\tresolution = timer->hw.resolution;\n\n\t/* loop for all active instances\n\t * Here we cannot use list_for_each_entry because the active_list of a\n\t * processed instance is relinked to done_list_head before the callback\n\t * is called.\n\t */\n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks) /* not expired */\n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n\t\t} else {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tif (--timer->running)\n\t\t\t\tlist_del(&ti->active_list);\n\t\t}\n\t\tif ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||\n\t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t/* restart timer */\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t/* now process all fast callbacks */\n\twhile (!list_empty(&timer->ack_list_head)) {\n\t\tp = timer->ack_list_head.next;\t\t/* get first item */\n\t\tti = list_entry(p, struct snd_timer_instance, ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(p);\n\n\t\tticks = ti->pticks;\n\t\tti->pticks = 0;\n\n\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\tspin_unlock(&timer->lock);\n\t\tif (ti->callback)\n\t\t\tti->callback(ti, resolution, ticks);\n\t\tspin_lock(&timer->lock);\n\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t}\n\n\t/* do we have any slow callbacks? */\n\tuse_tasklet = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_tasklet)\n\t\ttasklet_schedule(&timer->task_queue);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2016-2545"
    },
    {
        "index": 2741,
        "code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\t/* Check whether a task is in the sock.  */\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this transport really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}",
        "cwe_id": "CWE-362",
        "cve_id": "CVE-2015-8767"
    }
]